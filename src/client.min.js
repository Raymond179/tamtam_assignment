/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 48);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(49);
} else {
  module.exports = __webpack_require__(50);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(60)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(61)();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(43);
var isBuffer = __webpack_require__(115);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return stripLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return hasBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return stripBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return stripTrailingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return parsePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createPath; });
var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(6);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__BrowserRouter__ = __webpack_require__(59);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "BrowserRouter", function() { return __WEBPACK_IMPORTED_MODULE_0__BrowserRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__HashRouter__ = __webpack_require__(63);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "HashRouter", function() { return __WEBPACK_IMPORTED_MODULE_1__HashRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Link__ = __webpack_require__(34);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Link", function() { return __WEBPACK_IMPORTED_MODULE_2__Link__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__MemoryRouter__ = __webpack_require__(65);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "MemoryRouter", function() { return __WEBPACK_IMPORTED_MODULE_3__MemoryRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__NavLink__ = __webpack_require__(68);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "NavLink", function() { return __WEBPACK_IMPORTED_MODULE_4__NavLink__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Prompt__ = __webpack_require__(71);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Prompt", function() { return __WEBPACK_IMPORTED_MODULE_5__Prompt__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__Redirect__ = __webpack_require__(73);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Redirect", function() { return __WEBPACK_IMPORTED_MODULE_6__Redirect__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__Route__ = __webpack_require__(35);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Route", function() { return __WEBPACK_IMPORTED_MODULE_7__Route__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__Router__ = __webpack_require__(20);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Router", function() { return __WEBPACK_IMPORTED_MODULE_8__Router__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__StaticRouter__ = __webpack_require__(79);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "StaticRouter", function() { return __WEBPACK_IMPORTED_MODULE_9__StaticRouter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__Switch__ = __webpack_require__(81);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return __WEBPACK_IMPORTED_MODULE_10__Switch__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__matchPath__ = __webpack_require__(83);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "matchPath", function() { return __WEBPACK_IMPORTED_MODULE_11__matchPath__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__withRouter__ = __webpack_require__(84);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "withRouter", function() { return __WEBPACK_IMPORTED_MODULE_12__withRouter__["a"]; });



























/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return locationsAreEqual; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_resolve_pathname__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_value_equal__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__PathUtils__ = __webpack_require__(10);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = Object(__WEBPACK_IMPORTED_MODULE_2__PathUtils__["d" /* parsePath */])(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(__WEBPACK_IMPORTED_MODULE_0_resolve_pathname__["default"])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(__WEBPACK_IMPORTED_MODULE_1_value_equal__["default"])(a.state, b.state);
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(8);
  var warning = __webpack_require__(12);
  var ReactPropTypesSecret = __webpack_require__(16);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(51);
} else {
  module.exports = __webpack_require__(54);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.locationsAreEqual = exports.createLocation = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _resolvePathname = __webpack_require__(31);

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__(32);

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__(9);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Router__ = __webpack_require__(21);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Router__["a" /* default */]);

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






/**
 * The public API for putting history on context.
 */

var Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: '/',
      url: '/',
      params: {},
      isExact: pathname === '/'
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;


    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(children == null || __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.count(children) === 1, 'A <Router> may have only one child element');

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(this.props.history === nextProps.history, 'You cannot change <Router history>');
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.only(children) : null;
  };

  return Router;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

Router.propTypes = {
  history: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
  children: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.node
};
Router.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
};
Router.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Router);

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_path_to_regexp__);


var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compilePath = function compilePath(pattern, options) {
  var cacheKey = '' + options.end + options.strict + options.sensitive;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = __WEBPACK_IMPORTED_MODULE_0_path_to_regexp___default()(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof options === 'string') options = { path: options };

  var _options = options,
      _options$path = _options.path,
      path = _options$path === undefined ? '/' : _options$path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict,
      _options$sensitive = _options.sensitive,
      sensitive = _options$sensitive === undefined ? false : _options$sensitive;

  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

/* harmony default export */ __webpack_exports__["a"] = (matchPath);

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);


var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          __WEBPACK_IMPORTED_MODULE_0_warning___default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

/* harmony default export */ __webpack_exports__["a"] = (createTransitionManager);

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(4);
var normalizeHeaderName = __webpack_require__(117);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(44);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(44);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(6);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */
function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(52);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (resolvePathname);

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (valueEqual);

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link = function (_React$Component) {
  _inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    _classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore right clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;


          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        innerRef = _props.innerRef,
        props = _objectWithoutProperties(_props, ['replace', 'to', 'innerRef']); // eslint-disable-line no-unused-vars

    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(this.context.router, 'You should not use <Link> outside a <Router>');

    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement('a', _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));
  };

  return Link;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Link.propTypes = {
  onClick: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  target: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  to: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object]).isRequired,
  innerRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func])
};
Link.defaultProps = {
  replace: false
};
Link.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      createHref: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Link);

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Route__ = __webpack_require__(36);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Route__["a" /* default */]);

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__matchPath__ = __webpack_require__(22);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var isEmptyChildren = function isEmptyChildren(children) {
  return __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.count(children) === 0;
};

/**
 * The public API for matching a single path and rendering.
 */

var Route = function (_React$Component) {
  _inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    _classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, router) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact,
        sensitive = _ref.sensitive;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(router, 'You should not use <Route> or withRouter() outside a <Router>');

    var route = router.route;

    var pathname = (location || route.location).pathname;

    return path ? Object(__WEBPACK_IMPORTED_MODULE_4__matchPath__["a" /* default */])(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }) : route.match;
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.component && this.props.render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props = this.props,
        children = _props.children,
        component = _props.component,
        render = _props.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    return component ? // component prop gets first priority, only called if there's a match
    match ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(component, props) : null : render ? // render prop is next, only called if there's a match
    match ? render(props) : null : children ? // children come last, always called
    typeof children === 'function' ? children(props) : !isEmptyChildren(children) ? __WEBPACK_IMPORTED_MODULE_2_react___default.a.Children.only(children) : null : null;
  };

  return Route;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

Route.propTypes = {
  computedMatch: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object, // private, from <Switch>
  path: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,
  exact: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  strict: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  sensitive: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.bool,
  component: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func,
  render: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func,
  children: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.node]),
  location: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
};
Route.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
    route: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
    staticContext: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object
  })
};
Route.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Route);

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return canUseDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return removeEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getConfirmation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return supportsHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return supportsPopStateOnHashChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return supportsGoWithoutReloadUsingHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isExtraneousPopstateEvent; });
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,/9j/4QAkRXhpZgAASUkqAAgAAAABAJiCAgAAAAAAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAA8AAD/4QOXaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjMtYzAxMSA2Ni4xNDU2NjEsIDIwMTIvMDIvMDYtMTQ6NTY6MjcgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTc3QjI0ODFGNzc3MTFFNzk1RThDOTVDRTNCRUJDQjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTc3QjI0ODBGNzc3MTFFNzk1RThDOTVDRTNCRUJDQjEiIHhtcDpDcmVhdG9yVG9vbD0iRHhPIE9wdGljcyBQcm8gOCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSI5ODhEMTAxMUU1M0U2RUY2NjhFRDcwOUZCMTEyODBFQSIgc3RSZWY6ZG9jdW1lbnRJRD0iOTg4RDEwMTFFNTNFNkVGNjY4RUQ3MDlGQjExMjgwRUEiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij5Tbm93Zmxha2VzPC9yZGY6bGk+IDwvcmRm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Gbg97DQVAhqLm2vXtVDPw7UDJW2224/yqBC253GwAoA72N9egqhj9BQHTpUEj4fgKA66/I0C330I7UDsbdqoLnla3xqKYB+P6UQuu2nbpQMbbnegORv+t6AItagdzb89KAF/h3NA+ht0opa7WsfzoiQF+gufleimSF+HWgCba/j4UQBrgigd+5vRSJGv+BQMG97H4igetrdKAA0A/SgB8KB3t1oGSSfGgiRrpegYsAb7f1oHppf8aCR2NAhpuaAt460DNr/qKB6Ed6BW6UDAt/rQAB670D07XvQBOnegAP8AMigNaA/PxoGLdevegALUD1HWgDtttvQHT9KAufw2oGfy/M0AaBA3oHQBNjp11oGPhpQI9DQBN6B3AXXrQH9aA8Tv3oHvbW9A7fLx8KBHW9AeHagDofj+lAfCgCfHSgADqRa9AaX8KB3HwoDpp31oGRoPzoDptr3oENtdbHaii9hroPCiHcdPlQBvtvQIX0N6B37WuP0qAGtUKwt0oqXTTQUC/p2ohX6fjQPa1FLS9EMG58OlANa3XwFAX1HU96ACnS52oFqBegY0OoHegevX8aAG4/SgDptQIAix+dAfpf8AWgDfX40BptsKB3oFbU9KA6XoA6adKAvfpQAFj26UAR/lQLcUCI370BY9flQHG5GunegmALXOhoF1007UAb96BG1vCgfx2NAib7796BG9t/nQO/agNdT1oA6Hv4mgOlu/WgDe5oD49d6CN9dTp+poHfS35+FAhppf50ADrpQF9RagdtO9FK+mn40B22v2ohC9u/6UB4UBfTSgVx8aKYGl7UCtpYjpRAO96BWIPjQBFtfwoosABtRASD1qBEA/OqA3sL/hQF9u5NAEEDfbWgQ7a0Ua/PwohagjbWgat0AGu1FBOthtRAdBfW21Aht+F6Bf50AALaW126UDN7UAPh4XNAb96BaWufxoDU7D4mgWt/C340AAW+HWgFaxv3oDXegD17dKA/K3egd7696DG1raURC51108aod9b9T1oCxIt0oHb4fh1oDUjuaAIPe/WgCRse+lQPp/WqD87fjQS2Oh1qA6aDTYUC/rQSF++v4UDvvpr4UCJHj4UBfSwoAb2vvuTQSNrD8iKAsR431tRRyN/HwoDXbuaINzc/lRTB10ogJ2trfc0B5T/rRR10OtAwdOxoh/0NFAB26UAd9NqB2/LagA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EwDsRa/Wil0PgKICQL3FBE3vqKBqbfjQMG977b0CHYfKoGQR018aqlcfgNx/WiDQeO9BIWtr8zUAWJqiIN2Itv8AlQTv2vvUEDYAm9UO3TX51Ar2I2v0qgJs1vwoHYbj/rUCvfXX40B3vqKAsQLiqoJHTUeNEBW1r3sdqgfJen41QrfM0AfhQIa9KB30vaoHcX01PagjoW1NtKAtrftVUeZha97UQhpqdiNLUANh2oJeXjtr4VBHb4VQDY23OoopHTW21EA0B6eFAdjv2tQA3PbtQMLa3gaKjbW99R+FEIaNpt1oJLqdNuh60UrkH4G+lArak99b0QrbA7d6B679KBLfci1vyoFqb22oDS2g17UBa9up8KBEtbU6b1FFvH4Wqoewv+veoAi2vUVREkaCgx+64MeZhvFIOQ+scdCCOxolcjB9skghMZyGLwxizjcMSSN97DTWmGufg4vua+839T043KlnA/7oGrXv170qxH3FscGXGjszGZnkVm1PIeXTc2bpRIsh91TGwcYMnGUMGlDDe4ueNqka16jEmEsSuAQrAML6Gx11qouBGlA2OlgD+goA69LDtQR15aHTagfS/wCdBLQ9KCLeG51oFYDQdrfOgLdR2oEp0O+1A9+9vCgzHQfGqiIGl+9AE/LwoJXufhQHQn8TQFxY9upoI308b6UDv+PUUDGlu1BJtdTpbegRAA026CgBcb/lQAvfc/Cgdha350U7C3cdKgLgW1sLUElW7anTpQOwF76k7/CgixP4daB9NvgaIBe53J7UDN76aEfKinreiC/fY0UA696B20JtQHT4a3oGCRrfXewoDlv49el6BXPwHW1BMFrWvbrQR/Xw2oJeW1xfxoET4/50Er9LfDwoEBrr1oJWudN+9Aa2+G1BEtYH9aB6XvrbwoJXFtqBgclNzt1oFde9Ajpbv1oHcjwHTrQAPm7+AoC4Pw7UDJIAB/CgYtbXQ7EeFAagdTp10oGq3W3agLfK3WgVzr49aB30ta5oF18KB7Ea3vQGhve/woHcctdtqBHcEf4/GgBaxJ/DwoGTfYanoKB/nagXIgj86KL999qIY033oC9z28KBdR470ALi96B3vewv4UAQALUDI4gHvqBQL4aGgNfD4UDPE/SSKAAvsNaABOvS/SigaC426X01ohkm+p160CblcCgd7jUbUC662Ou9Awbtr86A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"

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _classnames = __webpack_require__(105);

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    CAROUSEL: function CAROUSEL(isSlider) {
        return (0, _classnames2.default)({
            "carousel": true,
            "carousel-slider": isSlider
        });
    },

    WRAPPER: function WRAPPER(isSlider, axis) {
        return (0, _classnames2.default)({
            "thumbs-wrapper": !isSlider,
            "slider-wrapper": isSlider,
            "axis-horizontal": axis === "horizontal",
            "axis-vertical": axis !== "horizontal"
        });
    },

    SLIDER: function SLIDER(isSlider, isSwiping) {
        return (0, _classnames2.default)({
            "thumbs": !isSlider,
            "slider": isSlider,
            "animated": !isSwiping
        });
    },

    ITEM: function ITEM(isSlider, selected) {
        return (0, _classnames2.default)({
            "thumb": !isSlider,
            "slide": isSlider,
            "selected": selected
        });
    },

    ARROW_PREV: function ARROW_PREV(disabled) {
        return (0, _classnames2.default)({
            "control-arrow control-prev": true,
            "control-disabled": disabled
        });
    },

    ARROW_NEXT: function ARROW_NEXT(disabled) {
        return (0, _classnames2.default)({
            "control-arrow control-next": true,
            "control-disabled": disabled
        });
    },

    DOT: function DOT(selected) {
        return (0, _classnames2.default)({
            "dot": true,
            'selected': selected
        });
    }
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (position, axis) {
    var positionCss = axis === 'horizontal' ? [position, 0, 0] : [0, position, 0];
    var transitionProp = 'translate3d';

    var translatedPosition = '(' + positionCss.join(',') + ')';

    return transitionProp + translatedPosition;
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(106)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(exports, require('./react-swipe'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.reactSwipe);
    global.index = mod.exports;
  }
})(this, function (exports, _reactSwipe) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _reactSwipe2 = _interopRequireDefault(_reactSwipe);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  exports.default = _reactSwipe2.default;
});

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(17);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _cssClasses = __webpack_require__(39);

var _cssClasses2 = _interopRequireDefault(_cssClasses);

var _dimensions = __webpack_require__(107);

var _CSSTranslate = __webpack_require__(40);

var _CSSTranslate2 = _interopRequireDefault(_CSSTranslate);

var _reactEasySwipe = __webpack_require__(41);

var _reactEasySwipe2 = _interopRequireDefault(_reactEasySwipe);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Thumbs = function (_Component) {
    _inherits(Thumbs, _Component);

    function Thumbs(props) {
        _classCallCheck(this, Thumbs);

        var _this = _possibleConstructorReturn(this, (Thumbs.__proto__ || Object.getPrototypeOf(Thumbs)).call(this, props));

        _this.updateSizes = function () {
            if (!_this.state.initialized) {
                return;
            }

            var total = _this.props.children.length;
            _this.wrapperSize = _this.itemsWrapper.clientWidth;
            _this.itemSize = _this.props.thumbWidth ? _this.props.thumbWidth : (0, _dimensions.outerWidth)(_this.refs.thumb0);
            _this.visibleItems = Math.floor(_this.wrapperSize / _this.itemSize);
            _this.lastPosition = total - _this.visibleItems;
            _this.showArrows = _this.visibleItems < total;
        };

        _this.setMountState = function () {
            _this.setState({ hasMount: true });
            _this.updateSizes();
        };

        _this.handleClickItem = function (index, item) {
            var handler = _this.props.onSelectItem;

            if (typeof handler === 'function') {
                handler(index, item);
            }
        };

        _this.onSwipeStart = function () {
            _this.setState({
                swiping: true
            });
        };

        _this.onSwipeEnd = function () {
            _this.setState({
                swiping: false
            });
        };

        _this.onSwipeMove = function (deltaX) {
            var leftBoundry = 0;
            var list = _reactDom2.default.findDOMNode(_this.itemList);
            var wrapperSize = list.clientWidth;
            var visibleItems = Math.floor(wrapperSize / _this.itemSize);

            var currentPosition = -_this.state.firstItem * _this.itemSize;
            var lastLeftBoundry = -_this.visibleItems * _this.itemSize;

            // prevent user from swiping left out of boundaries
            if (currentPosition === leftBoundry && deltaX > 0) {
                deltaX = 0;
            }

            // prevent user from swiping right out of boundaries
            if (currentPosition === lastLeftBoundry && deltaX < 0) {
                deltaX = 0;
            }

            var position = currentPosition + 100 / (wrapperSize / deltaX) + '%';

            // if 3d isn't available we will use left to move
            ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {
                list.style[prop] = (0, _CSSTranslate2.default)(position, _this.props.axis);
            });
        };

        _this.slideRight = function (positions) {
            _this.moveTo(_this.state.firstItem - (typeof positions === 'Number' ? positions : 1));
        };

        _this.slideLeft = function (positions) {
            _this.moveTo(_this.state.firstItem + (typeof positions === 'Number' ? positions : 1));
        };

        _this.moveTo = function (position) {
            // position can't be lower than 0
            position = position < 0 ? 0 : position;
            // position can't be higher than last postion
            position = position >= _this.lastPosition ? _this.lastPosition : position;

            _this.setState({
                firstItem: position,
                // if it's not a slider, we don't need to set position here
                selectedItem: _this.state.selectedItem
            });
        };

        _this.state = {
            initialized: false,
            selectedItem: props.selectedItem,
            hasMount: false,
            firstItem: _this.getFirstItem(props.selectedItem),
            images: []
        };
        return _this;
    }

    _createClass(Thumbs, [{
        key: 'componentDidMount',
        value: function componentDidMount(nextProps) {
            if (!this.props.children) {
                return;
            }

            this.setupThumbs();
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(props, state) {
            if (props.selectedItem !== this.state.selectedItem) {
                this.setState({
                    selectedItem: props.selectedItem,
                    firstItem: this.getFirstItem(props.selectedItem)
                });
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps) {
            if (!prevProps.children && this.props.children && !this.state.initialized) {
                this.setupThumbs();
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            this.destroyThumbs();
        }
    }, {
        key: 'setupThumbs',
        value: function setupThumbs() {
            // as the widths are calculated, we need to resize
            // the carousel when the window is resized
            window.addEventListener("resize", this.updateSizes);
            // issue #2 - image loading smaller
            window.addEventListener("DOMContentLoaded", this.updateSizes);

            var images = this.getImages();

            if (!images) {
                return;
            }

            this.setState({
                initialized: true,
                images: images
            });

            // when the component is rendered we need to calculate
            // the container size to adjust the responsive behaviour
            this.updateSizes();
        }
    }, {
        key: 'destroyThumbs',
        value: function destroyThumbs() {
            // removing listeners
            window.removeEventListener("resize", this.updateSizes);
            window.removeEventListener("DOMContentLoaded", this.updateSizes);
        }
    }, {
        key: 'getImages',
        value: function getImages() {
            var images = _react2.default.Children.map(this.props.children, function (item, index) {
                var img = item;

                // if the item is not an image, try to find the first image in the item's children.
                if (item.type !== "img") {
                    img = _react2.default.Children.toArray(item.props.children).filter(function (children) {
                        return children.type === "img";
                    })[0];
                }

                if (!img || img.length === 0) {
                    return null;
                }

                return img;
            });

            if (images.filter(function (image) {
                return image !== null;
            }).length === 0) {
                console.warn('No images found! Can\'t build the thumb list without images. If you don\'t need thumbs, set showThumbs={false} in the Carousel. Note that it\'s not possible to get images rendered inside custom components. More info at https://github.com/leandrowd/react-responsive-carousel/blob/master/TROUBLESHOOTING.md');

                return null;
            }

            return images;
        }
    }, {
        key: 'getFirstItem',
        value: function getFirstItem(selectedItem) {
            if (!this.showArrows) {
                return 0;
            }

            var firstItem = selectedItem;

            if (selectedItem >= this.lastPosition) {
                firstItem = this.lastPosition;
            }

            if (selectedItem < this.state.firstItem + this.visibleItems) {
                firstItem = this.state.firstItem;
            }

            if (selectedItem < this.state.firstItem) {
                firstItem = selectedItem;
            }

            return firstItem;
        }
    }, {
        key: 'renderItems',
        value: function renderItems() {
            var _this2 = this;

            return this.state.images.map(function (img, index) {
                var itemClass = _cssClasses2.default.ITEM(false, index === _this2.state.selectedItem && _this2.state.hasMount);

                var thumbProps = {
                    key: index,
                    ref: 'thumb' + index,
                    className: itemClass,
                    onClick: _this2.handleClickItem.bind(_this2, index, _this2.props.children[index])
                };

                if (index === 0) {
                    img = _react2.default.cloneElement(img, {
                        onLoad: _this2.setMountState
                    });
                }

                return _react2.default.createElement(
                    'li',
                    thumbProps,
                    img
                );
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _this3 = this;

            if (!this.props.children || this.state.images.length === 0) {
                return null;
            }

            // show left arrow?
            var hasPrev = this.showArrows && this.state.firstItem > 0;
            // show right arrow
            var hasNext = this.showArrows && this.state.firstItem < this.lastPosition;
            // obj to hold the transformations and styles
            var itemListStyles = {};

            var currentPosition = -this.state.firstItem * this.itemSize + 'px';

            var transformProp = (0, _CSSTranslate2.default)(currentPosition, this.props.axis);

            var transitionTime = this.props.transitionTime + 'ms';

            itemListStyles = {
                'WebkitTransform': transformProp,
                'MozTransform': transformProp,
                'MsTransform': transformProp,
                'OTransform': transformProp,
                'transform': transformProp,
                'msTransform': transformProp,
                'WebkitTransitionDuration': transitionTime,
                'MozTransitionDuration': transitionTime,
                'MsTransitionDuration': transitionTime,
                'OTransitionDuration': transitionTime,
                'transitionDuration': transitionTime,
                'msTransitionDuration': transitionTime
            };

            return _react2.default.createElement(
                'div',
                { className: _cssClasses2.default.CAROUSEL(false) },
                _react2.default.createElement(
                    'div',
                    { className: _cssClasses2.default.WRAPPER(false), ref: function ref(node) {
                            return _this3.itemsWrapper = node;
                        } },
                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_PREV(!hasPrev), onClick: this.slideRight }),
                    _react2.default.createElement(
                        _reactEasySwipe2.default,
                        { tagName: 'ul',
                            selectedItem: this.state.selectedItem,
                            className: _cssClasses2.default.SLIDER(false, this.state.swiping),
                            onSwipeLeft: this.slideLeft,
                            onSwipeRight: this.slideRight,
                            onSwipeMove: this.onSwipeMove,
                            onSwipeStart: this.onSwipeStart,
                            onSwipeEnd: this.onSwipeEnd,
                            style: itemListStyles,
                            ref: function ref(node) {
                                return _this3.itemList = node;
                            } },
                        this.renderItems()
                    ),
                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_NEXT(!hasNext), onClick: this.slideLeft })
                )
            );
        }
    }]);

    return Thumbs;
}(_react.Component);

Thumbs.displayName = 'Thumbs';
Thumbs.propsTypes = {
    children: _propTypes2.default.element.isRequired,
    transitionTime: _propTypes2.default.number,
    selectedItem: _propTypes2.default.number,
    thumbWidth: _propTypes2.default.number
};
Thumbs.defaultProps = {
    selectedItem: 0,
    transitionTime: 350,
    axis: 'horizontal'
};
exports.default = Thumbs;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(4);
var settle = __webpack_require__(118);
var buildURL = __webpack_require__(120);
var parseHeaders = __webpack_require__(121);
var isURLSameOrigin = __webpack_require__(122);
var createError = __webpack_require__(45);
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(123);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(124);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(119);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(17);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactRouterDom = __webpack_require__(13);

var _main = __webpack_require__(87);

var _main2 = _interopRequireDefault(_main);

var _Layout = __webpack_require__(97);

var _Layout2 = _interopRequireDefault(_Layout);

var _Home = __webpack_require__(101);

var _Home2 = _interopRequireDefault(_Home);

var _Contact = __webpack_require__(133);

var _Contact2 = _interopRequireDefault(_Contact);

var _People = __webpack_require__(135);

var _People2 = _interopRequireDefault(_People);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_reactDom2.default.render(_react2.default.createElement(
	_reactRouterDom.HashRouter,
	null,
	_react2.default.createElement(
		_Layout2.default,
		null,
		_react2.default.createElement(
			_reactRouterDom.Route,
			{ exact: true, path: '/', component: _Home2.default },
			' '
		),
		_react2.default.createElement(
			_reactRouterDom.Route,
			{ path: '/contact', component: _Contact2.default },
			' '
		),
		_react2.default.createElement(
			_reactRouterDom.Route,
			{ path: '/people', component: _People2.default },
			' '
		)
	)
), document.getElementById('app'));

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var m=__webpack_require__(7),n=__webpack_require__(11),p=__webpack_require__(6),q="function"===typeof Symbol&&Symbol["for"],r=q?Symbol["for"]("react.element"):60103,t=q?Symbol["for"]("react.call"):60104,u=q?Symbol["for"]("react.return"):60105,v=q?Symbol["for"]("react.portal"):60106,w=q?Symbol["for"]("react.fragment"):60107,x="function"===typeof Symbol&&Symbol.iterator;
function y(a){for(var b=arguments.length-1,e="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,c=0;c<b;c++)e+="\x26args[]\x3d"+encodeURIComponent(arguments[c+1]);b=Error(e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}
var z={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function A(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}A.prototype.isReactComponent={};A.prototype.setState=function(a,b){"object"!==typeof a&&"function"!==typeof a&&null!=a?y("85"):void 0;this.updater.enqueueSetState(this,a,b,"setState")};A.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
function B(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}function C(){}C.prototype=A.prototype;var D=B.prototype=new C;D.constructor=B;m(D,A.prototype);D.isPureReactComponent=!0;function E(a,b,e){this.props=a;this.context=b;this.refs=n;this.updater=e||z}var F=E.prototype=new C;F.constructor=E;m(F,A.prototype);F.unstable_isAsyncReactComponent=!0;F.render=function(){return this.props.children};var G={current:null},H=Object.prototype.hasOwnProperty,I={key:!0,ref:!0,__self:!0,__source:!0};
function J(a,b,e){var c,d={},g=null,k=null;if(null!=b)for(c in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)H.call(b,c)&&!I.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var h=Array(f),l=0;l<f;l++)h[l]=arguments[l+2];d.children=h}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:r,type:a,key:g,ref:k,props:d,_owner:G.current}}function K(a){return"object"===typeof a&&null!==a&&a.$$typeof===r}
function escape(a){var b={"\x3d":"\x3d0",":":"\x3d2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var L=/\/+/g,M=[];function N(a,b,e,c){if(M.length){var d=M.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}function O(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>M.length&&M.push(a)}
function P(a,b,e,c){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case r:case t:case u:case v:g=!0}}if(g)return e(c,a,""===b?"."+Q(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+Q(d,k);g+=P(d,f,e,c)}else if(null===a||"undefined"===typeof a?f=null:(f=x&&a[x]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=
f.call(a),k=0;!(d=a.next()).done;)d=d.value,f=b+Q(d,k++),g+=P(d,f,e,c);else"object"===d&&(e=""+a,y("31","[object Object]"===e?"object with keys {"+Object.keys(a).join(", ")+"}":e,""));return g}function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function R(a,b){a.func.call(a.context,b,a.count++)}
function S(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?T(a,c,e,p.thatReturnsArgument):null!=a&&(K(a)&&(b=d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(L,"$\x26/")+"/")+e,a={$$typeof:r,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}),c.push(a))}function T(a,b,e,c,d){var g="";null!=e&&(g=(""+e).replace(L,"$\x26/")+"/");b=N(b,g,c,d);null==a||P(a,"",S,b);O(b)}
var U={Children:{map:function(a,b,e){if(null==a)return a;var c=[];T(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=N(null,null,b,e);null==a||P(a,"",R,b);O(b)},count:function(a){return null==a?0:P(a,"",p.thatReturnsNull,null)},toArray:function(a){var b=[];T(a,b,null,p.thatReturnsArgument);return b},only:function(a){K(a)?void 0:y("143");return a}},Component:A,PureComponent:B,unstable_AsyncComponent:E,Fragment:w,createElement:J,cloneElement:function(a,b,e){var c=m({},a.props),
d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=G.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)H.call(b,h)&&!I.hasOwnProperty(h)&&(c[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)c.children=e;else if(1<h){f=Array(h);for(var l=0;l<h;l++)f[l]=arguments[l+2];c.children=f}return{$$typeof:r,type:a.type,key:d,ref:g,props:c,_owner:k}},createFactory:function(a){var b=J.bind(null,a);b.type=a;return b},
isValidElement:K,version:"16.2.0",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:G,assign:m}},V=Object.freeze({default:U}),W=V&&U||V;module.exports=W["default"]?W["default"]:W;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var _assign = __webpack_require__(7);
var emptyObject = __webpack_require__(11);
var invariant = __webpack_require__(8);
var warning = __webpack_require__(12);
var emptyFunction = __webpack_require__(6);
var checkPropTypes = __webpack_require__(15);

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var constructor = publicInstance.constructor;
    var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
    var warningKey = componentName + '.' + callerName;
    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }
    warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
Component.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
        return undefined;
      }
    });
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function PureComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
// Avoid an extra prototype jump for these methods.
_assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

function AsyncComponent(props, context, updater) {
  // Duplicated from Component.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
asyncComponentPrototype.constructor = AsyncComponent;
// Avoid an extra prototype jump for these methods.
_assign(asyncComponentPrototype, Component.prototype);
asyncComponentPrototype.unstable_isAsyncReactComponent = true;
asyncComponentPrototype.render = function () {
  return this.props.children;
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown;
var specialPropRefWarningShown;

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    });
    // self and source are DEV only properties.
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    });
    // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */
function createElement(type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}

/**
 * Return a function that produces ReactElements of a given type.
 * See https://reactjs.org/docs/react-api.html#createfactory
 */


function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
}

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */
function cloneElement(element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}

/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var ReactDebugCurrentFrame = {};

{
  // Component that is being worked on
  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var impl = ReactDebugCurrentFrame.getCurrentStack;
    if (impl) {
      return impl();
    }
    return null;
  };
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */
function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

var POOL_SIZE = 10;
var traverseContextPool = [];
function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
  if (traverseContextPool.length) {
    var traverseContext = traverseContextPool.pop();
    traverseContext.result = mapResult;
    traverseContext.keyPrefix = keyPrefix;
    traverseContext.func = mapFunction;
    traverseContext.context = mapContext;
    traverseContext.count = 0;
    return traverseContext;
  } else {
    return {
      result: mapResult,
      keyPrefix: keyPrefix,
      func: mapFunction,
      context: mapContext,
      count: 0
    };
  }
}

function releaseTraverseContext(traverseContext) {
  traverseContext.result = null;
  traverseContext.keyPrefix = null;
  traverseContext.func = null;
  traverseContext.context = null;
  traverseContext.count = 0;
  if (traverseContextPool.length < POOL_SIZE) {
    traverseContextPool.push(traverseContext);
  }
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;
      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_CALL_TYPE:
          case REACT_RETURN_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }
    }
  }

  if (invokeCallback) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (typeof iteratorFn === 'function') {
      {
        // Warn about using Maps as children
        if (iteratorFn === children.entries) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(children);
      var step;
      var ii = 0;
      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getComponentKey(child, ii++);
        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
      }
    } else if (type === 'object') {
      var addendum = '';
      {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
      }
      var childrenString = '' + children;
      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof component === 'object' && component !== null && component.key != null) {
    // Explicit key
    return escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  releaseTraverseContext(traverseContext);
}

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (isValidElement(mappedChild)) {
      mappedChild = cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  releaseTraverseContext(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
  return children;
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

{
  var currentlyValidatingElement = null;

  var propTypesMisspellWarningShown = false;

  var getDisplayName = function (element) {
    if (element == null) {
      return '#empty';
    } else if (typeof element === 'string' || typeof element === 'number') {
      return '#text';
    } else if (typeof element.type === 'string') {
      return element.type;
    } else if (element.type === REACT_FRAGMENT_TYPE) {
      return 'React.Fragment';
    } else {
      return element.type.displayName || element.type.name || 'Unknown';
    }
  };

  var getStackAddendum = function () {
    var stack = '';
    if (currentlyValidatingElement) {
      var name = getDisplayName(currentlyValidatingElement);
      var owner = currentlyValidatingElement._owner;
      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
    }
    stack += ReactDebugCurrentFrame.getStackAddendum() || '';
    return stack;
  };

  var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current);
    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = '\n\nCheck the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
  }

  currentlyValidatingElement = element;
  {
    warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
  }
  currentlyValidatingElement = null;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  var propTypes = componentClass.propTypes;
  if (propTypes) {
    currentlyValidatingElement = element;
    checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
    currentlyValidatingElement = null;
  } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
    propTypesMisspellWarningShown = true;
    warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
  }
}

/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */
function validateFragmentProps(fragment) {
  currentlyValidatingElement = fragment;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;

      if (!VALID_FRAGMENT_PROPS.has(key)) {
        warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator['return']) {
        _iterator['return']();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (fragment.ref !== null) {
    warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
  }

  currentlyValidatingElement = null;
}

function createElementWithValidation(type, props, children) {
  var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number';
  // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.
  if (!validType) {
    var info = '';
    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendum(props);
    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    info += getStackAddendum() || '';

    warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  var element = createElement.apply(this, arguments);

  // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.
  if (element == null) {
    return element;
  }

  // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)
  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}

function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  // Legacy hook TODO: Warn if this is accessed
  validatedFactory.type = type;

  {
    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}

function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);
  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }
  validatePropTypes(newElement);
  return newElement;
}

var React = {
  Children: {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  },

  Component: Component,
  PureComponent: PureComponent,
  unstable_AsyncComponent: AsyncComponent,

  Fragment: REACT_FRAGMENT_TYPE,

  createElement: createElementWithValidation,
  cloneElement: cloneElementWithValidation,
  createFactory: createFactoryWithValidation,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: ReactCurrentOwner,
    // Used by renderers to avoid bundling object-assign twice in UMD bundles:
    assign: _assign
  }
};

{
  _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
    // These should not be included in production.
    ReactDebugCurrentFrame: ReactDebugCurrentFrame,
    // Shim for React DOM 16.0.0 which still destructured (but not used) this.
    // TODO: remove in React 17.0.
    ReactComponentTreeHook: {}
  });
}



var React$2 = Object.freeze({
	default: React
});

var React$3 = ( React$2 && React ) || React$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var react = React$3['default'] ? React$3['default'] : React$3;

module.exports = react;
  })();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
var aa=__webpack_require__(0),l=__webpack_require__(25),B=__webpack_require__(7),C=__webpack_require__(6),ba=__webpack_require__(26),da=__webpack_require__(27),ea=__webpack_require__(28),fa=__webpack_require__(29),ia=__webpack_require__(30),D=__webpack_require__(11);
function E(a){for(var b=arguments.length-1,c="Minified React error #"+a+"; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d"+a,d=0;d<b;d++)c+="\x26args[]\x3d"+encodeURIComponent(arguments[d+1]);b=Error(c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name="Invariant Violation";b.framesToPop=1;throw b;}aa?void 0:E("227");
var oa={children:!0,dangerouslySetInnerHTML:!0,defaultValue:!0,defaultChecked:!0,innerHTML:!0,suppressContentEditableWarning:!0,suppressHydrationWarning:!0,style:!0};function pa(a,b){return(a&b)===b}
var ta={MUST_USE_PROPERTY:1,HAS_BOOLEAN_VALUE:4,HAS_NUMERIC_VALUE:8,HAS_POSITIVE_NUMERIC_VALUE:24,HAS_OVERLOADED_BOOLEAN_VALUE:32,HAS_STRING_BOOLEAN_VALUE:64,injectDOMPropertyConfig:function(a){var b=ta,c=a.Properties||{},d=a.DOMAttributeNamespaces||{},e=a.DOMAttributeNames||{};a=a.DOMMutationMethods||{};for(var f in c){ua.hasOwnProperty(f)?E("48",f):void 0;var g=f.toLowerCase(),h=c[f];g={attributeName:g,attributeNamespace:null,propertyName:f,mutationMethod:null,mustUseProperty:pa(h,b.MUST_USE_PROPERTY),
hasBooleanValue:pa(h,b.HAS_BOOLEAN_VALUE),hasNumericValue:pa(h,b.HAS_NUMERIC_VALUE),hasPositiveNumericValue:pa(h,b.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:pa(h,b.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:pa(h,b.HAS_STRING_BOOLEAN_VALUE)};1>=g.hasBooleanValue+g.hasNumericValue+g.hasOverloadedBooleanValue?void 0:E("50",f);e.hasOwnProperty(f)&&(g.attributeName=e[f]);d.hasOwnProperty(f)&&(g.attributeNamespace=d[f]);a.hasOwnProperty(f)&&(g.mutationMethod=a[f]);ua[f]=g}}},ua={};
function va(a,b){if(oa.hasOwnProperty(a)||2<a.length&&("o"===a[0]||"O"===a[0])&&("n"===a[1]||"N"===a[1]))return!1;if(null===b)return!0;switch(typeof b){case "boolean":return oa.hasOwnProperty(a)?a=!0:(b=wa(a))?a=b.hasBooleanValue||b.hasStringBooleanValue||b.hasOverloadedBooleanValue:(a=a.toLowerCase().slice(0,5),a="data-"===a||"aria-"===a),a;case "undefined":case "number":case "string":case "object":return!0;default:return!1}}function wa(a){return ua.hasOwnProperty(a)?ua[a]:null}
var xa=ta,ya=xa.MUST_USE_PROPERTY,K=xa.HAS_BOOLEAN_VALUE,za=xa.HAS_NUMERIC_VALUE,Aa=xa.HAS_POSITIVE_NUMERIC_VALUE,Ba=xa.HAS_OVERLOADED_BOOLEAN_VALUE,Ca=xa.HAS_STRING_BOOLEAN_VALUE,Da={Properties:{allowFullScreen:K,async:K,autoFocus:K,autoPlay:K,capture:Ba,checked:ya|K,cols:Aa,contentEditable:Ca,controls:K,"default":K,defer:K,disabled:K,download:Ba,draggable:Ca,formNoValidate:K,hidden:K,loop:K,multiple:ya|K,muted:ya|K,noValidate:K,open:K,playsInline:K,readOnly:K,required:K,reversed:K,rows:Aa,rowSpan:za,
scoped:K,seamless:K,selected:ya|K,size:Aa,start:za,span:Aa,spellCheck:Ca,style:0,tabIndex:0,itemScope:K,acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,value:Ca},DOMAttributeNames:{acceptCharset:"accept-charset",className:"class",htmlFor:"for",httpEquiv:"http-equiv"},DOMMutationMethods:{value:function(a,b){if(null==b)return a.removeAttribute("value");"number"!==a.type||!1===a.hasAttribute("value")?a.setAttribute("value",""+b):a.validity&&!a.validity.badInput&&a.ownerDocument.activeElement!==a&&
a.setAttribute("value",""+b)}}},Ea=xa.HAS_STRING_BOOLEAN_VALUE,M={xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace"},Ga={Properties:{autoReverse:Ea,externalResourcesRequired:Ea,preserveAlpha:Ea},DOMAttributeNames:{autoReverse:"autoReverse",externalResourcesRequired:"externalResourcesRequired",preserveAlpha:"preserveAlpha"},DOMAttributeNamespaces:{xlinkActuate:M.xlink,xlinkArcrole:M.xlink,xlinkHref:M.xlink,xlinkRole:M.xlink,xlinkShow:M.xlink,xlinkTitle:M.xlink,xlinkType:M.xlink,
xmlBase:M.xml,xmlLang:M.xml,xmlSpace:M.xml}},Ha=/[\-\:]([a-z])/g;function Ia(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function(a){var b=a.replace(Ha,
Ia);Ga.Properties[b]=0;Ga.DOMAttributeNames[b]=a});xa.injectDOMPropertyConfig(Da);xa.injectDOMPropertyConfig(Ga);
var P={_caughtError:null,_hasCaughtError:!1,_rethrowError:null,_hasRethrowError:!1,injection:{injectErrorUtils:function(a){"function"!==typeof a.invokeGuardedCallback?E("197"):void 0;Ja=a.invokeGuardedCallback}},invokeGuardedCallback:function(a,b,c,d,e,f,g,h,k){Ja.apply(P,arguments)},invokeGuardedCallbackAndCatchFirstError:function(a,b,c,d,e,f,g,h,k){P.invokeGuardedCallback.apply(this,arguments);if(P.hasCaughtError()){var q=P.clearCaughtError();P._hasRethrowError||(P._hasRethrowError=!0,P._rethrowError=
q)}},rethrowCaughtError:function(){return Ka.apply(P,arguments)},hasCaughtError:function(){return P._hasCaughtError},clearCaughtError:function(){if(P._hasCaughtError){var a=P._caughtError;P._caughtError=null;P._hasCaughtError=!1;return a}E("198")}};function Ja(a,b,c,d,e,f,g,h,k){P._hasCaughtError=!1;P._caughtError=null;var q=Array.prototype.slice.call(arguments,3);try{b.apply(c,q)}catch(v){P._caughtError=v,P._hasCaughtError=!0}}
function Ka(){if(P._hasRethrowError){var a=P._rethrowError;P._rethrowError=null;P._hasRethrowError=!1;throw a;}}var La=null,Ma={};
function Na(){if(La)for(var a in Ma){var b=Ma[a],c=La.indexOf(a);-1<c?void 0:E("96",a);if(!Oa[c]){b.extractEvents?void 0:E("97",a);Oa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;Pa.hasOwnProperty(h)?E("99",h):void 0;Pa[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&Qa(k[e],g,h);e=!0}else f.registrationName?(Qa(f.registrationName,g,h),e=!0):e=!1;e?void 0:E("98",d,a)}}}}
function Qa(a,b,c){Ra[a]?E("100",a):void 0;Ra[a]=b;Sa[a]=b.eventTypes[c].dependencies}var Oa=[],Pa={},Ra={},Sa={};function Ta(a){La?E("101"):void 0;La=Array.prototype.slice.call(a);Na()}function Ua(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];Ma.hasOwnProperty(c)&&Ma[c]===d||(Ma[c]?E("102",c):void 0,Ma[c]=d,b=!0)}b&&Na()}
var Va=Object.freeze({plugins:Oa,eventNameDispatchConfigs:Pa,registrationNameModules:Ra,registrationNameDependencies:Sa,possibleRegistrationNames:null,injectEventPluginOrder:Ta,injectEventPluginsByName:Ua}),Wa=null,Xa=null,Ya=null;function Za(a,b,c,d){b=a.type||"unknown-event";a.currentTarget=Ya(d);P.invokeGuardedCallbackAndCatchFirstError(b,c,void 0,a);a.currentTarget=null}
function $a(a,b){null==b?E("30"):void 0;if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function ab(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var bb=null;
function cb(a,b){if(a){var c=a._dispatchListeners,d=a._dispatchInstances;if(Array.isArray(c))for(var e=0;e<c.length&&!a.isPropagationStopped();e++)Za(a,b,c[e],d[e]);else c&&Za(a,b,c,d);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function db(a){return cb(a,!0)}function gb(a){return cb(a,!1)}var hb={injectEventPluginOrder:Ta,injectEventPluginsByName:Ua};
function ib(a,b){var c=a.stateNode;if(!c)return null;var d=Wa(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;c&&"function"!==typeof c?E("231",b,typeof c):void 0;
return c}function jb(a,b,c,d){for(var e,f=0;f<Oa.length;f++){var g=Oa[f];g&&(g=g.extractEvents(a,b,c,d))&&(e=$a(e,g))}return e}function kb(a){a&&(bb=$a(bb,a))}function lb(a){var b=bb;bb=null;b&&(a?ab(b,db):ab(b,gb),bb?E("95"):void 0,P.rethrowCaughtError())}var mb=Object.freeze({injection:hb,getListener:ib,extractEvents:jb,enqueueEvents:kb,processEventQueue:lb}),nb=Math.random().toString(36).slice(2),Q="__reactInternalInstance$"+nb,ob="__reactEventHandlers$"+nb;
function pb(a){if(a[Q])return a[Q];for(var b=[];!a[Q];)if(b.push(a),a.parentNode)a=a.parentNode;else return null;var c=void 0,d=a[Q];if(5===d.tag||6===d.tag)return d;for(;a&&(d=a[Q]);a=b.pop())c=d;return c}function qb(a){if(5===a.tag||6===a.tag)return a.stateNode;E("33")}function rb(a){return a[ob]||null}
var sb=Object.freeze({precacheFiberNode:function(a,b){b[Q]=a},getClosestInstanceFromNode:pb,getInstanceFromNode:function(a){a=a[Q];return!a||5!==a.tag&&6!==a.tag?null:a},getNodeFromInstance:qb,getFiberCurrentPropsFromNode:rb,updateFiberProps:function(a,b){a[ob]=b}});function tb(a){do a=a["return"];while(a&&5!==a.tag);return a?a:null}function ub(a,b,c){for(var d=[];a;)d.push(a),a=tb(a);for(a=d.length;0<a--;)b(d[a],"captured",c);for(a=0;a<d.length;a++)b(d[a],"bubbled",c)}
function vb(a,b,c){if(b=ib(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a)}function wb(a){a&&a.dispatchConfig.phasedRegistrationNames&&ub(a._targetInst,vb,a)}function xb(a){if(a&&a.dispatchConfig.phasedRegistrationNames){var b=a._targetInst;b=b?tb(b):null;ub(b,vb,a)}}
function yb(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=ib(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=$a(c._dispatchListeners,b),c._dispatchInstances=$a(c._dispatchInstances,a))}function zb(a){a&&a.dispatchConfig.registrationName&&yb(a._targetInst,null,a)}function Ab(a){ab(a,wb)}
function Bb(a,b,c,d){if(c&&d)a:{var e=c;for(var f=d,g=0,h=e;h;h=tb(h))g++;h=0;for(var k=f;k;k=tb(k))h++;for(;0<g-h;)e=tb(e),g--;for(;0<h-g;)f=tb(f),h--;for(;g--;){if(e===f||e===f.alternate)break a;e=tb(e);f=tb(f)}e=null}else e=null;f=e;for(e=[];c&&c!==f;){g=c.alternate;if(null!==g&&g===f)break;e.push(c);c=tb(c)}for(c=[];d&&d!==f;){g=d.alternate;if(null!==g&&g===f)break;c.push(d);d=tb(d)}for(d=0;d<e.length;d++)yb(e[d],"bubbled",a);for(a=c.length;0<a--;)yb(c[a],"captured",b)}
var Cb=Object.freeze({accumulateTwoPhaseDispatches:Ab,accumulateTwoPhaseDispatchesSkipTarget:function(a){ab(a,xb)},accumulateEnterLeaveDispatches:Bb,accumulateDirectDispatches:function(a){ab(a,zb)}}),Db=null;function Eb(){!Db&&l.canUseDOM&&(Db="textContent"in document.documentElement?"textContent":"innerText");return Db}var S={_root:null,_startText:null,_fallbackText:null};
function Fb(){if(S._fallbackText)return S._fallbackText;var a,b=S._startText,c=b.length,d,e=Gb(),f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);S._fallbackText=e.slice(a,1<d?1-d:void 0);return S._fallbackText}function Gb(){return"value"in S._root?S._root.value:S._root[Eb()]}
var Hb="dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),Ib={type:null,target:null,currentTarget:C.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
function T(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?C.thatReturnsTrue:C.thatReturnsFalse;this.isPropagationStopped=C.thatReturnsFalse;return this}
B(T.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=C.thatReturnsTrue)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=C.thatReturnsTrue)},persist:function(){this.isPersistent=C.thatReturnsTrue},isPersistent:C.thatReturnsFalse,
destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;for(a=0;a<Hb.length;a++)this[Hb[a]]=null}});T.Interface=Ib;T.augmentClass=function(a,b){function c(){}c.prototype=this.prototype;var d=new c;B(d,a.prototype);a.prototype=d;a.prototype.constructor=a;a.Interface=B({},this.Interface,b);a.augmentClass=this.augmentClass;Jb(a)};Jb(T);function Kb(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
function Lb(a){a instanceof this?void 0:E("223");a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function Jb(a){a.eventPool=[];a.getPooled=Kb;a.release=Lb}function Mb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Mb,{data:null});function Nb(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Nb,{data:null});var Pb=[9,13,27,32],Vb=l.canUseDOM&&"CompositionEvent"in window,Wb=null;l.canUseDOM&&"documentMode"in document&&(Wb=document.documentMode);var Xb;
if(Xb=l.canUseDOM&&"TextEvent"in window&&!Wb){var Yb=window.opera;Xb=!("object"===typeof Yb&&"function"===typeof Yb.version&&12>=parseInt(Yb.version(),10))}
var Zb=Xb,$b=l.canUseDOM&&(!Vb||Wb&&8<Wb&&11>=Wb),ac=String.fromCharCode(32),bc={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["topCompositionEnd","topKeyPress","topTextInput","topPaste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
captured:"onCompositionStartCapture"},dependencies:"topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")}},cc=!1;
function dc(a,b){switch(a){case "topKeyUp":return-1!==Pb.indexOf(b.keyCode);case "topKeyDown":return 229!==b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":return!0;default:return!1}}function ec(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var fc=!1;function gc(a,b){switch(a){case "topCompositionEnd":return ec(b);case "topKeyPress":if(32!==b.which)return null;cc=!0;return ac;case "topTextInput":return a=b.data,a===ac&&cc?null:a;default:return null}}
function hc(a,b){if(fc)return"topCompositionEnd"===a||!Vb&&dc(a,b)?(a=Fb(),S._root=null,S._startText=null,S._fallbackText=null,fc=!1,a):null;switch(a){case "topPaste":return null;case "topKeyPress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "topCompositionEnd":return $b?null:b.data;default:return null}}
var ic={eventTypes:bc,extractEvents:function(a,b,c,d){var e;if(Vb)b:{switch(a){case "topCompositionStart":var f=bc.compositionStart;break b;case "topCompositionEnd":f=bc.compositionEnd;break b;case "topCompositionUpdate":f=bc.compositionUpdate;break b}f=void 0}else fc?dc(a,c)&&(f=bc.compositionEnd):"topKeyDown"===a&&229===c.keyCode&&(f=bc.compositionStart);f?($b&&(fc||f!==bc.compositionStart?f===bc.compositionEnd&&fc&&(e=Fb()):(S._root=d,S._startText=Gb(),fc=!0)),f=Mb.getPooled(f,b,c,d),e?f.data=
e:(e=ec(c),null!==e&&(f.data=e)),Ab(f),e=f):e=null;(a=Zb?gc(a,c):hc(a,c))?(b=Nb.getPooled(bc.beforeInput,b,c,d),b.data=a,Ab(b)):b=null;return[e,b]}},jc=null,kc=null,lc=null;function mc(a){if(a=Xa(a)){jc&&"function"===typeof jc.restoreControlledState?void 0:E("194");var b=Wa(a.stateNode);jc.restoreControlledState(a.stateNode,a.type,b)}}var nc={injectFiberControlledHostComponent:function(a){jc=a}};function oc(a){kc?lc?lc.push(a):lc=[a]:kc=a}
function pc(){if(kc){var a=kc,b=lc;lc=kc=null;mc(a);if(b)for(a=0;a<b.length;a++)mc(b[a])}}var qc=Object.freeze({injection:nc,enqueueStateRestore:oc,restoreStateIfNeeded:pc});function rc(a,b){return a(b)}var sc=!1;function tc(a,b){if(sc)return rc(a,b);sc=!0;try{return rc(a,b)}finally{sc=!1,pc()}}var uc={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};
function vc(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!uc[a.type]:"textarea"===b?!0:!1}function wc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var xc;l.canUseDOM&&(xc=document.implementation&&document.implementation.hasFeature&&!0!==document.implementation.hasFeature("",""));
function yc(a,b){if(!l.canUseDOM||b&&!("addEventListener"in document))return!1;b="on"+a;var c=b in document;c||(c=document.createElement("div"),c.setAttribute(b,"return;"),c="function"===typeof c[b]);!c&&xc&&"wheel"===a&&(c=document.implementation.hasFeature("Events.wheel","3.0"));return c}function zc(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ac(a){var b=zc(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"function"===typeof c.get&&"function"===typeof c.set)return Object.defineProperty(a,b,{enumerable:c.enumerable,configurable:!0,get:function(){return c.get.call(this)},set:function(a){d=""+a;c.set.call(this,a)}}),{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}
function Bc(a){a._valueTracker||(a._valueTracker=Ac(a))}function Cc(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=zc(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}var Dc={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")}};
function Ec(a,b,c){a=T.getPooled(Dc.change,a,b,c);a.type="change";oc(c);Ab(a);return a}var Fc=null,Gc=null;function Hc(a){kb(a);lb(!1)}function Ic(a){var b=qb(a);if(Cc(b))return a}function Jc(a,b){if("topChange"===a)return b}var Kc=!1;l.canUseDOM&&(Kc=yc("input")&&(!document.documentMode||9<document.documentMode));function Lc(){Fc&&(Fc.detachEvent("onpropertychange",Mc),Gc=Fc=null)}function Mc(a){"value"===a.propertyName&&Ic(Gc)&&(a=Ec(Gc,a,wc(a)),tc(Hc,a))}
function Nc(a,b,c){"topFocus"===a?(Lc(),Fc=b,Gc=c,Fc.attachEvent("onpropertychange",Mc)):"topBlur"===a&&Lc()}function Oc(a){if("topSelectionChange"===a||"topKeyUp"===a||"topKeyDown"===a)return Ic(Gc)}function Pc(a,b){if("topClick"===a)return Ic(b)}function $c(a,b){if("topInput"===a||"topChange"===a)return Ic(b)}
var ad={eventTypes:Dc,_isInputEventSupported:Kc,extractEvents:function(a,b,c,d){var e=b?qb(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Jc;else if(vc(e))if(Kc)g=$c;else{g=Oc;var h=Nc}else f=e.nodeName,!f||"input"!==f.toLowerCase()||"checkbox"!==e.type&&"radio"!==e.type||(g=Pc);if(g&&(g=g(a,b)))return Ec(g,c,d);h&&h(a,e,b);"topBlur"===a&&null!=b&&(a=b._wrapperState||e._wrapperState)&&a.controlled&&"number"===e.type&&(a=""+e.value,e.getAttribute("value")!==
a&&e.setAttribute("value",a))}};function bd(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(bd,{view:null,detail:null});var cd={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function dd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=cd[a])?!!b[a]:!1}function ed(){return dd}function fd(a,b,c,d){return T.call(this,a,b,c,d)}
bd.augmentClass(fd,{screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:ed,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)}});
var gd={mouseEnter:{registrationName:"onMouseEnter",dependencies:["topMouseOut","topMouseOver"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["topMouseOut","topMouseOver"]}},hd={eventTypes:gd,extractEvents:function(a,b,c,d){if("topMouseOver"===a&&(c.relatedTarget||c.fromElement)||"topMouseOut"!==a&&"topMouseOver"!==a)return null;var e=d.window===d?d:(e=d.ownerDocument)?e.defaultView||e.parentWindow:window;"topMouseOut"===a?(a=b,b=(b=c.relatedTarget||c.toElement)?pb(b):null):a=null;if(a===
b)return null;var f=null==a?e:qb(a);e=null==b?e:qb(b);var g=fd.getPooled(gd.mouseLeave,a,c,d);g.type="mouseleave";g.target=f;g.relatedTarget=e;c=fd.getPooled(gd.mouseEnter,b,c,d);c.type="mouseenter";c.target=e;c.relatedTarget=f;Bb(g,c,a,b);return[g,c]}},id=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function jd(a){a=a.type;return"string"===typeof a?a:"function"===typeof a?a.displayName||a.name:null}
function kd(a){var b=a;if(a.alternate)for(;b["return"];)b=b["return"];else{if(0!==(b.effectTag&2))return 1;for(;b["return"];)if(b=b["return"],0!==(b.effectTag&2))return 1}return 3===b.tag?2:3}function ld(a){return(a=a._reactInternalFiber)?2===kd(a):!1}function md(a){2!==kd(a)?E("188"):void 0}
function nd(a){var b=a.alternate;if(!b)return b=kd(a),3===b?E("188"):void 0,1===b?null:a;for(var c=a,d=b;;){var e=c["return"],f=e?e.alternate:null;if(!e||!f)break;if(e.child===f.child){for(var g=e.child;g;){if(g===c)return md(e),a;if(g===d)return md(e),b;g=g.sibling}E("188")}if(c["return"]!==d["return"])c=e,d=f;else{g=!1;for(var h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}g?
void 0:E("189")}}c.alternate!==d?E("190"):void 0}3!==c.tag?E("188"):void 0;return c.stateNode.current===c?a:b}function od(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}
function pd(a){a=nd(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child&&4!==b.tag)b.child["return"]=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b["return"]||b["return"]===a)return null;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}}return null}var qd=[];
function rd(a){var b=a.targetInst;do{if(!b){a.ancestors.push(b);break}var c;for(c=b;c["return"];)c=c["return"];c=3!==c.tag?null:c.stateNode.containerInfo;if(!c)break;a.ancestors.push(b);b=pb(c)}while(b);for(c=0;c<a.ancestors.length;c++)b=a.ancestors[c],sd(a.topLevelType,b,a.nativeEvent,wc(a.nativeEvent))}var td=!0,sd=void 0;function ud(a){td=!!a}function U(a,b,c){return c?ba.listen(c,b,vd.bind(null,a)):null}function wd(a,b,c){return c?ba.capture(c,b,vd.bind(null,a)):null}
function vd(a,b){if(td){var c=wc(b);c=pb(c);null===c||"number"!==typeof c.tag||2===kd(c)||(c=null);if(qd.length){var d=qd.pop();d.topLevelType=a;d.nativeEvent=b;d.targetInst=c;a=d}else a={topLevelType:a,nativeEvent:b,targetInst:c,ancestors:[]};try{tc(rd,a)}finally{a.topLevelType=null,a.nativeEvent=null,a.targetInst=null,a.ancestors.length=0,10>qd.length&&qd.push(a)}}}
var xd=Object.freeze({get _enabled(){return td},get _handleTopLevel(){return sd},setHandleTopLevel:function(a){sd=a},setEnabled:ud,isEnabled:function(){return td},trapBubbledEvent:U,trapCapturedEvent:wd,dispatchEvent:vd});function yd(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;c["ms"+a]="MS"+b;c["O"+a]="o"+b.toLowerCase();return c}
var zd={animationend:yd("Animation","AnimationEnd"),animationiteration:yd("Animation","AnimationIteration"),animationstart:yd("Animation","AnimationStart"),transitionend:yd("Transition","TransitionEnd")},Ad={},Bd={};l.canUseDOM&&(Bd=document.createElement("div").style,"AnimationEvent"in window||(delete zd.animationend.animation,delete zd.animationiteration.animation,delete zd.animationstart.animation),"TransitionEvent"in window||delete zd.transitionend.transition);
function Cd(a){if(Ad[a])return Ad[a];if(!zd[a])return a;var b=zd[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Bd)return Ad[a]=b[c];return""}
var Dd={topAbort:"abort",topAnimationEnd:Cd("animationend")||"animationend",topAnimationIteration:Cd("animationiteration")||"animationiteration",topAnimationStart:Cd("animationstart")||"animationstart",topBlur:"blur",topCancel:"cancel",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topChange:"change",topClick:"click",topClose:"close",topCompositionEnd:"compositionend",topCompositionStart:"compositionstart",topCompositionUpdate:"compositionupdate",topContextMenu:"contextmenu",topCopy:"copy",
topCut:"cut",topDoubleClick:"dblclick",topDrag:"drag",topDragEnd:"dragend",topDragEnter:"dragenter",topDragExit:"dragexit",topDragLeave:"dragleave",topDragOver:"dragover",topDragStart:"dragstart",topDrop:"drop",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topFocus:"focus",topInput:"input",topKeyDown:"keydown",topKeyPress:"keypress",topKeyUp:"keyup",topLoadedData:"loadeddata",topLoad:"load",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",
topMouseDown:"mousedown",topMouseMove:"mousemove",topMouseOut:"mouseout",topMouseOver:"mouseover",topMouseUp:"mouseup",topPaste:"paste",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topScroll:"scroll",topSeeked:"seeked",topSeeking:"seeking",topSelectionChange:"selectionchange",topStalled:"stalled",topSuspend:"suspend",topTextInput:"textInput",topTimeUpdate:"timeupdate",topToggle:"toggle",topTouchCancel:"touchcancel",topTouchEnd:"touchend",topTouchMove:"touchmove",
topTouchStart:"touchstart",topTransitionEnd:Cd("transitionend")||"transitionend",topVolumeChange:"volumechange",topWaiting:"waiting",topWheel:"wheel"},Ed={},Fd=0,Gd="_reactListenersID"+(""+Math.random()).slice(2);function Hd(a){Object.prototype.hasOwnProperty.call(a,Gd)||(a[Gd]=Fd++,Ed[a[Gd]]={});return Ed[a[Gd]]}function Id(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Jd(a,b){var c=Id(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Id(c)}}function Kd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&"text"===a.type||"textarea"===b||"true"===a.contentEditable)}
var Ld=l.canUseDOM&&"documentMode"in document&&11>=document.documentMode,Md={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")}},Nd=null,Od=null,Pd=null,Qd=!1;
function Rd(a,b){if(Qd||null==Nd||Nd!==da())return null;var c=Nd;"selectionStart"in c&&Kd(c)?c={start:c.selectionStart,end:c.selectionEnd}:window.getSelection?(c=window.getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset}):c=void 0;return Pd&&ea(Pd,c)?null:(Pd=c,a=T.getPooled(Md.select,Od,a,b),a.type="select",a.target=Nd,Ab(a),a)}
var Sd={eventTypes:Md,extractEvents:function(a,b,c,d){var e=d.window===d?d.document:9===d.nodeType?d:d.ownerDocument,f;if(!(f=!e)){a:{e=Hd(e);f=Sa.onSelect;for(var g=0;g<f.length;g++){var h=f[g];if(!e.hasOwnProperty(h)||!e[h]){e=!1;break a}}e=!0}f=!e}if(f)return null;e=b?qb(b):window;switch(a){case "topFocus":if(vc(e)||"true"===e.contentEditable)Nd=e,Od=b,Pd=null;break;case "topBlur":Pd=Od=Nd=null;break;case "topMouseDown":Qd=!0;break;case "topContextMenu":case "topMouseUp":return Qd=!1,Rd(c,d);case "topSelectionChange":if(Ld)break;
case "topKeyDown":case "topKeyUp":return Rd(c,d)}return null}};function Td(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Td,{animationName:null,elapsedTime:null,pseudoElement:null});function Ud(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(Ud,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}});function Vd(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(Vd,{relatedTarget:null});
function Wd(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;return 32<=a||13===a?a:0}
var Xd={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Yd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"};function Zd(a,b,c,d){return T.call(this,a,b,c,d)}
bd.augmentClass(Zd,{key:function(a){if(a.key){var b=Xd[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Wd(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Yd[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:ed,charCode:function(a){return"keypress"===a.type?Wd(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Wd(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}});function $d(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass($d,{dataTransfer:null});function ae(a,b,c,d){return T.call(this,a,b,c,d)}bd.augmentClass(ae,{touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:ed});function be(a,b,c,d){return T.call(this,a,b,c,d)}T.augmentClass(be,{propertyName:null,elapsedTime:null,pseudoElement:null});
function ce(a,b,c,d){return T.call(this,a,b,c,d)}fd.augmentClass(ce,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null});var de={},ee={};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function(a){var b=a[0].toUpperCase()+
a.slice(1),c="on"+b;b="top"+b;c={phasedRegistrationNames:{bubbled:c,captured:c+"Capture"},dependencies:[b]};de[a]=c;ee[b]=c});
var fe={eventTypes:de,extractEvents:function(a,b,c,d){var e=ee[a];if(!e)return null;switch(a){case "topKeyPress":if(0===Wd(c))return null;case "topKeyDown":case "topKeyUp":a=Zd;break;case "topBlur":case "topFocus":a=Vd;break;case "topClick":if(2===c.button)return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":a=fd;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":a=
$d;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":a=ae;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":a=Td;break;case "topTransitionEnd":a=be;break;case "topScroll":a=bd;break;case "topWheel":a=ce;break;case "topCopy":case "topCut":case "topPaste":a=Ud;break;default:a=T}b=a.getPooled(e,b,c,d);Ab(b);return b}};sd=function(a,b,c,d){a=jb(a,b,c,d);kb(a);lb(!1)};hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Wa=sb.getFiberCurrentPropsFromNode;Xa=sb.getInstanceFromNode;Ya=sb.getNodeFromInstance;hb.injectEventPluginsByName({SimpleEventPlugin:fe,EnterLeaveEventPlugin:hd,ChangeEventPlugin:ad,SelectEventPlugin:Sd,BeforeInputEventPlugin:ic});var ge=[],he=-1;function V(a){0>he||(a.current=ge[he],ge[he]=null,he--)}function W(a,b){he++;ge[he]=a.current;a.current=b}new Set;var ie={current:D},X={current:!1},je=D;function ke(a){return le(a)?je:ie.current}
function me(a,b){var c=a.type.contextTypes;if(!c)return D;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function le(a){return 2===a.tag&&null!=a.type.childContextTypes}function ne(a){le(a)&&(V(X,a),V(ie,a))}
function oe(a,b,c){null!=ie.cursor?E("168"):void 0;W(ie,b,a);W(X,c,a)}function pe(a,b){var c=a.stateNode,d=a.type.childContextTypes;if("function"!==typeof c.getChildContext)return b;c=c.getChildContext();for(var e in c)e in d?void 0:E("108",jd(a)||"Unknown",e);return B({},b,c)}function qe(a){if(!le(a))return!1;var b=a.stateNode;b=b&&b.__reactInternalMemoizedMergedChildContext||D;je=ie.current;W(ie,b,a);W(X,X.current,a);return!0}
function re(a,b){var c=a.stateNode;c?void 0:E("169");if(b){var d=pe(a,je);c.__reactInternalMemoizedMergedChildContext=d;V(X,a);V(ie,a);W(ie,d,a)}else V(X,a);W(X,b,a)}
function Y(a,b,c){this.tag=a;this.key=b;this.stateNode=this.type=null;this.sibling=this.child=this["return"]=null;this.index=0;this.memoizedState=this.updateQueue=this.memoizedProps=this.pendingProps=this.ref=null;this.internalContextTag=c;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.expirationTime=0;this.alternate=null}
function se(a,b,c){var d=a.alternate;null===d?(d=new Y(a.tag,a.key,a.internalContextTag),d.type=a.type,d.stateNode=a.stateNode,d.alternate=a,a.alternate=d):(d.effectTag=0,d.nextEffect=null,d.firstEffect=null,d.lastEffect=null);d.expirationTime=c;d.pendingProps=b;d.child=a.child;d.memoizedProps=a.memoizedProps;d.memoizedState=a.memoizedState;d.updateQueue=a.updateQueue;d.sibling=a.sibling;d.index=a.index;d.ref=a.ref;return d}
function te(a,b,c){var d=void 0,e=a.type,f=a.key;"function"===typeof e?(d=e.prototype&&e.prototype.isReactComponent?new Y(2,f,b):new Y(0,f,b),d.type=e,d.pendingProps=a.props):"string"===typeof e?(d=new Y(5,f,b),d.type=e,d.pendingProps=a.props):"object"===typeof e&&null!==e&&"number"===typeof e.tag?(d=e,d.pendingProps=a.props):E("130",null==e?e:typeof e,"");d.expirationTime=c;return d}function ue(a,b,c,d){b=new Y(10,d,b);b.pendingProps=a;b.expirationTime=c;return b}
function ve(a,b,c){b=new Y(6,null,b);b.pendingProps=a;b.expirationTime=c;return b}function we(a,b,c){b=new Y(7,a.key,b);b.type=a.handler;b.pendingProps=a;b.expirationTime=c;return b}function xe(a,b,c){a=new Y(9,null,b);a.expirationTime=c;return a}function ye(a,b,c){b=new Y(4,a.key,b);b.pendingProps=a.children||[];b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}var ze=null,Ae=null;
function Be(a){return function(b){try{return a(b)}catch(c){}}}function Ce(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);ze=Be(function(a){return b.onCommitFiberRoot(c,a)});Ae=Be(function(a){return b.onCommitFiberUnmount(c,a)})}catch(d){}return!0}function De(a){"function"===typeof ze&&ze(a)}function Ee(a){"function"===typeof Ae&&Ae(a)}
function Fe(a){return{baseState:a,expirationTime:0,first:null,last:null,callbackList:null,hasForceUpdate:!1,isInitialized:!1}}function Ge(a,b){null===a.last?a.first=a.last=b:(a.last.next=b,a.last=b);if(0===a.expirationTime||a.expirationTime>b.expirationTime)a.expirationTime=b.expirationTime}
function He(a,b){var c=a.alternate,d=a.updateQueue;null===d&&(d=a.updateQueue=Fe(null));null!==c?(a=c.updateQueue,null===a&&(a=c.updateQueue=Fe(null))):a=null;a=a!==d?a:null;null===a?Ge(d,b):null===d.last||null===a.last?(Ge(d,b),Ge(a,b)):(Ge(d,b),a.last=b)}function Ie(a,b,c,d){a=a.partialState;return"function"===typeof a?a.call(b,c,d):a}
function Je(a,b,c,d,e,f){null!==a&&a.updateQueue===c&&(c=b.updateQueue={baseState:c.baseState,expirationTime:c.expirationTime,first:c.first,last:c.last,isInitialized:c.isInitialized,callbackList:null,hasForceUpdate:!1});c.expirationTime=0;c.isInitialized?a=c.baseState:(a=c.baseState=b.memoizedState,c.isInitialized=!0);for(var g=!0,h=c.first,k=!1;null!==h;){var q=h.expirationTime;if(q>f){var v=c.expirationTime;if(0===v||v>q)c.expirationTime=q;k||(k=!0,c.baseState=a)}else{k||(c.first=h.next,null===
c.first&&(c.last=null));if(h.isReplace)a=Ie(h,d,a,e),g=!0;else if(q=Ie(h,d,a,e))a=g?B({},a,q):B(a,q),g=!1;h.isForced&&(c.hasForceUpdate=!0);null!==h.callback&&(q=c.callbackList,null===q&&(q=c.callbackList=[]),q.push(h))}h=h.next}null!==c.callbackList?b.effectTag|=32:null!==c.first||c.hasForceUpdate||(b.updateQueue=null);k||(c.baseState=a);return a}
function Ke(a,b){var c=a.callbackList;if(null!==c)for(a.callbackList=null,a=0;a<c.length;a++){var d=c[a],e=d.callback;d.callback=null;"function"!==typeof e?E("191",e):void 0;e.call(b)}}
function Le(a,b,c,d){function e(a,b){b.updater=f;a.stateNode=b;b._reactInternalFiber=a}var f={isMounted:ld,enqueueSetState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!1,isForced:!1,nextCallback:null,next:null});a(c,g)},enqueueReplaceState:function(c,d,e){c=c._reactInternalFiber;e=void 0===e?null:e;var g=b(c);He(c,{expirationTime:g,partialState:d,callback:e,isReplace:!0,isForced:!1,nextCallback:null,next:null});
a(c,g)},enqueueForceUpdate:function(c,d){c=c._reactInternalFiber;d=void 0===d?null:d;var e=b(c);He(c,{expirationTime:e,partialState:null,callback:d,isReplace:!1,isForced:!0,nextCallback:null,next:null});a(c,e)}};return{adoptClassInstance:e,constructClassInstance:function(a,b){var c=a.type,d=ke(a),f=2===a.tag&&null!=a.type.contextTypes,g=f?me(a,d):D;b=new c(b,g);e(a,b);f&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=d,a.__reactInternalMemoizedMaskedChildContext=g);return b},mountClassInstance:function(a,
b){var c=a.alternate,d=a.stateNode,e=d.state||null,g=a.pendingProps;g?void 0:E("158");var h=ke(a);d.props=g;d.state=a.memoizedState=e;d.refs=D;d.context=me(a,h);null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent&&(a.internalContextTag|=1);"function"===typeof d.componentWillMount&&(e=d.state,d.componentWillMount(),e!==d.state&&f.enqueueReplaceState(d,d.state,null),e=a.updateQueue,null!==e&&(d.state=Je(c,a,e,d,g,b)));"function"===typeof d.componentDidMount&&(a.effectTag|=
4)},updateClassInstance:function(a,b,e){var g=b.stateNode;g.props=b.memoizedProps;g.state=b.memoizedState;var h=b.memoizedProps,k=b.pendingProps;k||(k=h,null==k?E("159"):void 0);var u=g.context,z=ke(b);z=me(b,z);"function"!==typeof g.componentWillReceiveProps||h===k&&u===z||(u=g.state,g.componentWillReceiveProps(k,z),g.state!==u&&f.enqueueReplaceState(g,g.state,null));u=b.memoizedState;e=null!==b.updateQueue?Je(a,b,b.updateQueue,g,k,e):u;if(!(h!==k||u!==e||X.current||null!==b.updateQueue&&b.updateQueue.hasForceUpdate))return"function"!==
typeof g.componentDidUpdate||h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),!1;var G=k;if(null===h||null!==b.updateQueue&&b.updateQueue.hasForceUpdate)G=!0;else{var I=b.stateNode,L=b.type;G="function"===typeof I.shouldComponentUpdate?I.shouldComponentUpdate(G,e,z):L.prototype&&L.prototype.isPureReactComponent?!ea(h,G)||!ea(u,e):!0}G?("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(k,e,z),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4)):("function"!==typeof g.componentDidUpdate||
h===a.memoizedProps&&u===a.memoizedState||(b.effectTag|=4),c(b,k),d(b,e));g.props=k;g.state=e;g.context=z;return G}}}var Qe="function"===typeof Symbol&&Symbol["for"],Re=Qe?Symbol["for"]("react.element"):60103,Se=Qe?Symbol["for"]("react.call"):60104,Te=Qe?Symbol["for"]("react.return"):60105,Ue=Qe?Symbol["for"]("react.portal"):60106,Ve=Qe?Symbol["for"]("react.fragment"):60107,We="function"===typeof Symbol&&Symbol.iterator;
function Xe(a){if(null===a||"undefined"===typeof a)return null;a=We&&a[We]||a["@@iterator"];return"function"===typeof a?a:null}var Ye=Array.isArray;
function Ze(a,b){var c=b.ref;if(null!==c&&"function"!==typeof c){if(b._owner){b=b._owner;var d=void 0;b&&(2!==b.tag?E("110"):void 0,d=b.stateNode);d?void 0:E("147",c);var e=""+c;if(null!==a&&null!==a.ref&&a.ref._stringRef===e)return a.ref;a=function(a){var b=d.refs===D?d.refs={}:d.refs;null===a?delete b[e]:b[e]=a};a._stringRef=e;return a}"string"!==typeof c?E("148"):void 0;b._owner?void 0:E("149",c)}return c}
function $e(a,b){"textarea"!==a.type&&E("31","[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,"")}
function af(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b,c){a=se(a,b,c);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=ve(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function k(a,b,c,d){if(null!==b&&b.type===c.type)return d=e(b,c.props,d),d.ref=Ze(b,c),d["return"]=a,d;d=te(c,a.internalContextTag,d);d.ref=Ze(b,c);d["return"]=a;return d}function q(a,b,c,d){if(null===b||7!==b.tag)return b=we(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c,d);
b["return"]=a;return b}function v(a,b,c,d){if(null===b||9!==b.tag)return b=xe(c,a.internalContextTag,d),b.type=c.value,b["return"]=a,b;b=e(b,null,d);b.type=c.value;b["return"]=a;return b}function y(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=ye(c,a.internalContextTag,d),b["return"]=a,b;b=e(b,c.children||[],d);b["return"]=a;return b}function u(a,b,c,d,f){if(null===b||10!==b.tag)return b=ue(c,a.internalContextTag,
d,f),b["return"]=a,b;b=e(b,c,d);b["return"]=a;return b}function z(a,b,c){if("string"===typeof b||"number"===typeof b)return b=ve(""+b,a.internalContextTag,c),b["return"]=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Re:if(b.type===Ve)return b=ue(b.props.children,a.internalContextTag,c,b.key),b["return"]=a,b;c=te(b,a.internalContextTag,c);c.ref=Ze(null,b);c["return"]=a;return c;case Se:return b=we(b,a.internalContextTag,c),b["return"]=a,b;case Te:return c=xe(b,a.internalContextTag,
c),c.type=b.value,c["return"]=a,c;case Ue:return b=ye(b,a.internalContextTag,c),b["return"]=a,b}if(Ye(b)||Xe(b))return b=ue(b,a.internalContextTag,c,null),b["return"]=a,b;$e(a,b)}return null}function G(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Re:return c.key===e?c.type===Ve?u(a,b,c.props.children,d,e):k(a,b,c,d):null;case Se:return c.key===e?q(a,b,c,d):null;case Te:return null===
e?v(a,b,c,d):null;case Ue:return c.key===e?y(a,b,c,d):null}if(Ye(c)||Xe(c))return null!==e?null:u(a,b,c,d,null);$e(a,c)}return null}function I(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Re:return a=a.get(null===d.key?c:d.key)||null,d.type===Ve?u(b,a,d.props.children,e,d.key):k(b,a,d,e);case Se:return a=a.get(null===d.key?c:d.key)||null,q(b,a,d,e);case Te:return a=a.get(c)||null,v(b,a,d,e);case Ue:return a=
a.get(null===d.key?c:d.key)||null,y(b,a,d,e)}if(Ye(d)||Xe(d))return a=a.get(c)||null,u(b,a,d,e,null);$e(b,d)}return null}function L(e,g,m,A){for(var h=null,r=null,n=g,w=g=0,k=null;null!==n&&w<m.length;w++){n.index>w?(k=n,n=null):k=n.sibling;var x=G(e,n,m[w],A);if(null===x){null===n&&(n=k);break}a&&n&&null===x.alternate&&b(e,n);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x;n=k}if(w===m.length)return c(e,n),h;if(null===n){for(;w<m.length;w++)if(n=z(e,m[w],A))g=f(n,g,w),null===r?h=n:r.sibling=n,r=n;return h}for(n=
d(e,n);w<m.length;w++)if(k=I(n,e,w,m[w],A)){if(a&&null!==k.alternate)n["delete"](null===k.key?w:k.key);g=f(k,g,w);null===r?h=k:r.sibling=k;r=k}a&&n.forEach(function(a){return b(e,a)});return h}function N(e,g,m,A){var h=Xe(m);"function"!==typeof h?E("150"):void 0;m=h.call(m);null==m?E("151"):void 0;for(var r=h=null,n=g,w=g=0,k=null,x=m.next();null!==n&&!x.done;w++,x=m.next()){n.index>w?(k=n,n=null):k=n.sibling;var J=G(e,n,x.value,A);if(null===J){n||(n=k);break}a&&n&&null===J.alternate&&b(e,n);g=f(J,
g,w);null===r?h=J:r.sibling=J;r=J;n=k}if(x.done)return c(e,n),h;if(null===n){for(;!x.done;w++,x=m.next())x=z(e,x.value,A),null!==x&&(g=f(x,g,w),null===r?h=x:r.sibling=x,r=x);return h}for(n=d(e,n);!x.done;w++,x=m.next())if(x=I(n,e,w,x.value,A),null!==x){if(a&&null!==x.alternate)n["delete"](null===x.key?w:x.key);g=f(x,g,w);null===r?h=x:r.sibling=x;r=x}a&&n.forEach(function(a){return b(e,a)});return h}return function(a,d,f,h){"object"===typeof f&&null!==f&&f.type===Ve&&null===f.key&&(f=f.props.children);
var m="object"===typeof f&&null!==f;if(m)switch(f.$$typeof){case Re:a:{var r=f.key;for(m=d;null!==m;){if(m.key===r)if(10===m.tag?f.type===Ve:m.type===f.type){c(a,m.sibling);d=e(m,f.type===Ve?f.props.children:f.props,h);d.ref=Ze(m,f);d["return"]=a;a=d;break a}else{c(a,m);break}else b(a,m);m=m.sibling}f.type===Ve?(d=ue(f.props.children,a.internalContextTag,h,f.key),d["return"]=a,a=d):(h=te(f,a.internalContextTag,h),h.ref=Ze(d,f),h["return"]=a,a=h)}return g(a);case Se:a:{for(m=f.key;null!==d;){if(d.key===
m)if(7===d.tag){c(a,d.sibling);d=e(d,f,h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=we(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a);case Te:a:{if(null!==d)if(9===d.tag){c(a,d.sibling);d=e(d,null,h);d.type=f.value;d["return"]=a;a=d;break a}else c(a,d);d=xe(f,a.internalContextTag,h);d.type=f.value;d["return"]=a;a=d}return g(a);case Ue:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===
f.implementation){c(a,d.sibling);d=e(d,f.children||[],h);d["return"]=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=ye(f,a.internalContextTag,h);d["return"]=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f,h)):(c(a,d),d=ve(f,a.internalContextTag,h)),d["return"]=a,a=d,g(a);if(Ye(f))return L(a,d,f,h);if(Xe(f))return N(a,d,f,h);m&&$e(a,f);if("undefined"===typeof f)switch(a.tag){case 2:case 1:h=a.type,E("152",h.displayName||
h.name||"Component")}return c(a,d)}}var bf=af(!0),cf=af(!1);
function df(a,b,c,d,e){function f(a,b,c){var d=b.expirationTime;b.child=null===a?cf(b,null,c,d):bf(b,a.child,c,d)}function g(a,b){var c=b.ref;null===c||a&&a.ref===c||(b.effectTag|=128)}function h(a,b,c,d){g(a,b);if(!c)return d&&re(b,!1),q(a,b);c=b.stateNode;id.current=b;var e=c.render();b.effectTag|=1;f(a,b,e);b.memoizedState=c.state;b.memoizedProps=c.props;d&&re(b,!0);return b.child}function k(a){var b=a.stateNode;b.pendingContext?oe(a,b.pendingContext,b.pendingContext!==b.context):b.context&&oe(a,
b.context,!1);I(a,b.containerInfo)}function q(a,b){null!==a&&b.child!==a.child?E("153"):void 0;if(null!==b.child){a=b.child;var c=se(a,a.pendingProps,a.expirationTime);b.child=c;for(c["return"]=b;null!==a.sibling;)a=a.sibling,c=c.sibling=se(a,a.pendingProps,a.expirationTime),c["return"]=b;c.sibling=null}return b.child}function v(a,b){switch(b.tag){case 3:k(b);break;case 2:qe(b);break;case 4:I(b,b.stateNode.containerInfo)}return null}var y=a.shouldSetTextContent,u=a.useSyncScheduling,z=a.shouldDeprioritizeSubtree,
G=b.pushHostContext,I=b.pushHostContainer,L=c.enterHydrationState,N=c.resetHydrationState,J=c.tryToClaimNextHydratableInstance;a=Le(d,e,function(a,b){a.memoizedProps=b},function(a,b){a.memoizedState=b});var w=a.adoptClassInstance,m=a.constructClassInstance,A=a.mountClassInstance,Ob=a.updateClassInstance;return{beginWork:function(a,b,c){if(0===b.expirationTime||b.expirationTime>c)return v(a,b);switch(b.tag){case 0:null!==a?E("155"):void 0;var d=b.type,e=b.pendingProps,r=ke(b);r=me(b,r);d=d(e,r);b.effectTag|=
1;"object"===typeof d&&null!==d&&"function"===typeof d.render?(b.tag=2,e=qe(b),w(b,d),A(b,c),b=h(a,b,!0,e)):(b.tag=1,f(a,b,d),b.memoizedProps=e,b=b.child);return b;case 1:a:{e=b.type;c=b.pendingProps;d=b.memoizedProps;if(X.current)null===c&&(c=d);else if(null===c||d===c){b=q(a,b);break a}d=ke(b);d=me(b,d);e=e(c,d);b.effectTag|=1;f(a,b,e);b.memoizedProps=c;b=b.child}return b;case 2:return e=qe(b),d=void 0,null===a?b.stateNode?E("153"):(m(b,b.pendingProps),A(b,c),d=!0):d=Ob(a,b,c),h(a,b,d,e);case 3:return k(b),
e=b.updateQueue,null!==e?(d=b.memoizedState,e=Je(a,b,e,null,null,c),d===e?(N(),b=q(a,b)):(d=e.element,r=b.stateNode,(null===a||null===a.child)&&r.hydrate&&L(b)?(b.effectTag|=2,b.child=cf(b,null,d,c)):(N(),f(a,b,d)),b.memoizedState=e,b=b.child)):(N(),b=q(a,b)),b;case 5:G(b);null===a&&J(b);e=b.type;var n=b.memoizedProps;d=b.pendingProps;null===d&&(d=n,null===d?E("154"):void 0);r=null!==a?a.memoizedProps:null;X.current||null!==d&&n!==d?(n=d.children,y(e,d)?n=null:r&&y(e,r)&&(b.effectTag|=16),g(a,b),
2147483647!==c&&!u&&z(e,d)?(b.expirationTime=2147483647,b=null):(f(a,b,n),b.memoizedProps=d,b=b.child)):b=q(a,b);return b;case 6:return null===a&&J(b),a=b.pendingProps,null===a&&(a=b.memoizedProps),b.memoizedProps=a,null;case 8:b.tag=7;case 7:e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null===e?E("154"):void 0);else if(null===e||b.memoizedProps===e)e=b.memoizedProps;d=e.children;b.stateNode=null===a?cf(b,b.stateNode,d,c):bf(b,b.stateNode,d,c);b.memoizedProps=e;return b.stateNode;
case 9:return null;case 4:a:{I(b,b.stateNode.containerInfo);e=b.pendingProps;if(X.current)null===e&&(e=a&&a.memoizedProps,null==e?E("154"):void 0);else if(null===e||b.memoizedProps===e){b=q(a,b);break a}null===a?b.child=bf(b,null,e,c):f(a,b,e);b.memoizedProps=e;b=b.child}return b;case 10:a:{c=b.pendingProps;if(X.current)null===c&&(c=b.memoizedProps);else if(null===c||b.memoizedProps===c){b=q(a,b);break a}f(a,b,c);b.memoizedProps=c;b=b.child}return b;default:E("156")}},beginFailedWork:function(a,b,
c){switch(b.tag){case 2:qe(b);break;case 3:k(b);break;default:E("157")}b.effectTag|=64;null===a?b.child=null:b.child!==a.child&&(b.child=a.child);if(0===b.expirationTime||b.expirationTime>c)return v(a,b);b.firstEffect=null;b.lastEffect=null;b.child=null===a?cf(b,null,null,c):bf(b,a.child,null,c);2===b.tag&&(a=b.stateNode,b.memoizedProps=a.props,b.memoizedState=a.state);return b.child}}}
function ef(a,b,c){function d(a){a.effectTag|=4}var e=a.createInstance,f=a.createTextInstance,g=a.appendInitialChild,h=a.finalizeInitialChildren,k=a.prepareUpdate,q=a.persistence,v=b.getRootHostContainer,y=b.popHostContext,u=b.getHostContext,z=b.popHostContainer,G=c.prepareToHydrateHostInstance,I=c.prepareToHydrateHostTextInstance,L=c.popHydrationState,N=void 0,J=void 0,w=void 0;a.mutation?(N=function(){},J=function(a,b,c){(b.updateQueue=c)&&d(b)},w=function(a,b,c,e){c!==e&&d(b)}):q?E("235"):E("236");
return{completeWork:function(a,b,c){var m=b.pendingProps;if(null===m)m=b.memoizedProps;else if(2147483647!==b.expirationTime||2147483647===c)b.pendingProps=null;switch(b.tag){case 1:return null;case 2:return ne(b),null;case 3:z(b);V(X,b);V(ie,b);m=b.stateNode;m.pendingContext&&(m.context=m.pendingContext,m.pendingContext=null);if(null===a||null===a.child)L(b),b.effectTag&=-3;N(b);return null;case 5:y(b);c=v();var A=b.type;if(null!==a&&null!=b.stateNode){var p=a.memoizedProps,q=b.stateNode,x=u();q=
k(q,A,p,m,c,x);J(a,b,q,A,p,m,c);a.ref!==b.ref&&(b.effectTag|=128)}else{if(!m)return null===b.stateNode?E("166"):void 0,null;a=u();if(L(b))G(b,c,a)&&d(b);else{a=e(A,m,c,a,b);a:for(p=b.child;null!==p;){if(5===p.tag||6===p.tag)g(a,p.stateNode);else if(4!==p.tag&&null!==p.child){p.child["return"]=p;p=p.child;continue}if(p===b)break;for(;null===p.sibling;){if(null===p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}h(a,A,m,c)&&d(b);b.stateNode=a}null!==b.ref&&
(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)w(a,b,a.memoizedProps,m);else{if("string"!==typeof m)return null===b.stateNode?E("166"):void 0,null;a=v();c=u();L(b)?I(b)&&d(b):b.stateNode=f(m,a,c,b)}return null;case 7:(m=b.memoizedProps)?void 0:E("165");b.tag=8;A=[];a:for((p=b.stateNode)&&(p["return"]=b);null!==p;){if(5===p.tag||6===p.tag||4===p.tag)E("247");else if(9===p.tag)A.push(p.type);else if(null!==p.child){p.child["return"]=p;p=p.child;continue}for(;null===p.sibling;){if(null===
p["return"]||p["return"]===b)break a;p=p["return"]}p.sibling["return"]=p["return"];p=p.sibling}p=m.handler;m=p(m.props,A);b.child=bf(b,null!==a?a.child:null,m,c);return b.child;case 8:return b.tag=7,null;case 9:return null;case 10:return null;case 4:return z(b),N(b),null;case 0:E("167");default:E("156")}}}}
function ff(a,b){function c(a){var c=a.ref;if(null!==c)try{c(null)}catch(A){b(a,A)}}function d(a){"function"===typeof Ee&&Ee(a);switch(a.tag){case 2:c(a);var d=a.stateNode;if("function"===typeof d.componentWillUnmount)try{d.props=a.memoizedProps,d.state=a.memoizedState,d.componentWillUnmount()}catch(A){b(a,A)}break;case 5:c(a);break;case 7:e(a.stateNode);break;case 4:k&&g(a)}}function e(a){for(var b=a;;)if(d(b),null===b.child||k&&4===b.tag){if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||
b["return"]===a)return;b=b["return"]}b.sibling["return"]=b["return"];b=b.sibling}else b.child["return"]=b,b=b.child}function f(a){return 5===a.tag||3===a.tag||4===a.tag}function g(a){for(var b=a,c=!1,f=void 0,g=void 0;;){if(!c){c=b["return"];a:for(;;){null===c?E("160"):void 0;switch(c.tag){case 5:f=c.stateNode;g=!1;break a;case 3:f=c.stateNode.containerInfo;g=!0;break a;case 4:f=c.stateNode.containerInfo;g=!0;break a}c=c["return"]}c=!0}if(5===b.tag||6===b.tag)e(b),g?J(f,b.stateNode):N(f,b.stateNode);
else if(4===b.tag?f=b.stateNode.containerInfo:d(b),null!==b.child){b.child["return"]=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b["return"]||b["return"]===a)return;b=b["return"];4===b.tag&&(c=!1)}b.sibling["return"]=b["return"];b=b.sibling}}var h=a.getPublicInstance,k=a.mutation;a=a.persistence;k||(a?E("235"):E("236"));var q=k.commitMount,v=k.commitUpdate,y=k.resetTextContent,u=k.commitTextUpdate,z=k.appendChild,G=k.appendChildToContainer,I=k.insertBefore,L=k.insertInContainerBefore,
N=k.removeChild,J=k.removeChildFromContainer;return{commitResetTextContent:function(a){y(a.stateNode)},commitPlacement:function(a){a:{for(var b=a["return"];null!==b;){if(f(b)){var c=b;break a}b=b["return"]}E("160");c=void 0}var d=b=void 0;switch(c.tag){case 5:b=c.stateNode;d=!1;break;case 3:b=c.stateNode.containerInfo;d=!0;break;case 4:b=c.stateNode.containerInfo;d=!0;break;default:E("161")}c.effectTag&16&&(y(b),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c["return"]||f(c["return"])){c=
null;break a}c=c["return"]}c.sibling["return"]=c["return"];for(c=c.sibling;5!==c.tag&&6!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;else c.child["return"]=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}for(var e=a;;){if(5===e.tag||6===e.tag)c?d?L(b,e.stateNode,c):I(b,e.stateNode,c):d?G(b,e.stateNode):z(b,e.stateNode);else if(4!==e.tag&&null!==e.child){e.child["return"]=e;e=e.child;continue}if(e===a)break;for(;null===e.sibling;){if(null===e["return"]||e["return"]===
a)return;e=e["return"]}e.sibling["return"]=e["return"];e=e.sibling}},commitDeletion:function(a){g(a);a["return"]=null;a.child=null;a.alternate&&(a.alternate.child=null,a.alternate["return"]=null)},commitWork:function(a,b){switch(b.tag){case 2:break;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps;a=null!==a?a.memoizedProps:d;var e=b.type,f=b.updateQueue;b.updateQueue=null;null!==f&&v(c,f,e,a,d,b)}break;case 6:null===b.stateNode?E("162"):void 0;c=b.memoizedProps;u(b.stateNode,null!==a?a.memoizedProps:
c,c);break;case 3:break;default:E("163")}},commitLifeCycles:function(a,b){switch(b.tag){case 2:var c=b.stateNode;if(b.effectTag&4)if(null===a)c.props=b.memoizedProps,c.state=b.memoizedState,c.componentDidMount();else{var d=a.memoizedProps;a=a.memoizedState;c.props=b.memoizedProps;c.state=b.memoizedState;c.componentDidUpdate(d,a)}b=b.updateQueue;null!==b&&Ke(b,c);break;case 3:c=b.updateQueue;null!==c&&Ke(c,null!==b.child?b.child.stateNode:null);break;case 5:c=b.stateNode;null===a&&b.effectTag&4&&q(c,
b.type,b.memoizedProps,b);break;case 6:break;case 4:break;default:E("163")}},commitAttachRef:function(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:b(h(c));break;default:b(c)}}},commitDetachRef:function(a){a=a.ref;null!==a&&a(null)}}}var gf={};
function hf(a){function b(a){a===gf?E("174"):void 0;return a}var c=a.getChildHostContext,d=a.getRootHostContext,e={current:gf},f={current:gf},g={current:gf};return{getHostContext:function(){return b(e.current)},getRootHostContainer:function(){return b(g.current)},popHostContainer:function(a){V(e,a);V(f,a);V(g,a)},popHostContext:function(a){f.current===a&&(V(e,a),V(f,a))},pushHostContainer:function(a,b){W(g,b,a);b=d(b);W(f,a,a);W(e,b,a)},pushHostContext:function(a){var d=b(g.current),h=b(e.current);
d=c(h,a.type,d);h!==d&&(W(f,a,a),W(e,d,a))},resetHostContainer:function(){e.current=gf;g.current=gf}}}
function jf(a){function b(a,b){var c=new Y(5,null,0);c.type="DELETED";c.stateNode=b;c["return"]=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function c(a,b){switch(a.tag){case 5:return b=f(b,a.type,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;case 6:return b=g(b,a.pendingProps),null!==b?(a.stateNode=b,!0):!1;default:return!1}}function d(a){for(a=a["return"];null!==a&&5!==a.tag&&3!==a.tag;)a=a["return"];y=a}var e=a.shouldSetTextContent;
a=a.hydration;if(!a)return{enterHydrationState:function(){return!1},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){E("175")},prepareToHydrateHostTextInstance:function(){E("176")},popHydrationState:function(){return!1}};var f=a.canHydrateInstance,g=a.canHydrateTextInstance,h=a.getNextHydratableSibling,k=a.getFirstHydratableChild,q=a.hydrateInstance,v=a.hydrateTextInstance,y=null,u=null,z=!1;return{enterHydrationState:function(a){u=
k(a.stateNode.containerInfo);y=a;return z=!0},resetHydrationState:function(){u=y=null;z=!1},tryToClaimNextHydratableInstance:function(a){if(z){var d=u;if(d){if(!c(a,d)){d=h(d);if(!d||!c(a,d)){a.effectTag|=2;z=!1;y=a;return}b(y,u)}y=a;u=k(d)}else a.effectTag|=2,z=!1,y=a}},prepareToHydrateHostInstance:function(a,b,c){b=q(a.stateNode,a.type,a.memoizedProps,b,c,a);a.updateQueue=b;return null!==b?!0:!1},prepareToHydrateHostTextInstance:function(a){return v(a.stateNode,a.memoizedProps,a)},popHydrationState:function(a){if(a!==
y)return!1;if(!z)return d(a),z=!0,!1;var c=a.type;if(5!==a.tag||"head"!==c&&"body"!==c&&!e(c,a.memoizedProps))for(c=u;c;)b(a,c),c=h(c);d(a);u=y?h(a.stateNode):null;return!0}}}
function kf(a){function b(a){Qb=ja=!0;var b=a.stateNode;b.current===a?E("177"):void 0;b.isReadyForCommit=!1;id.current=null;if(1<a.effectTag)if(null!==a.lastEffect){a.lastEffect.nextEffect=a;var c=a.firstEffect}else c=a;else c=a.firstEffect;yg();for(t=c;null!==t;){var d=!1,e=void 0;try{for(;null!==t;){var f=t.effectTag;f&16&&zg(t);if(f&128){var g=t.alternate;null!==g&&Ag(g)}switch(f&-242){case 2:Ne(t);t.effectTag&=-3;break;case 6:Ne(t);t.effectTag&=-3;Oe(t.alternate,t);break;case 4:Oe(t.alternate,
t);break;case 8:Sc=!0,Bg(t),Sc=!1}t=t.nextEffect}}catch(Tc){d=!0,e=Tc}d&&(null===t?E("178"):void 0,h(t,e),null!==t&&(t=t.nextEffect))}Cg();b.current=a;for(t=c;null!==t;){c=!1;d=void 0;try{for(;null!==t;){var k=t.effectTag;k&36&&Dg(t.alternate,t);k&128&&Eg(t);if(k&64)switch(e=t,f=void 0,null!==R&&(f=R.get(e),R["delete"](e),null==f&&null!==e.alternate&&(e=e.alternate,f=R.get(e),R["delete"](e))),null==f?E("184"):void 0,e.tag){case 2:e.stateNode.componentDidCatch(f.error,{componentStack:f.componentStack});
break;case 3:null===ca&&(ca=f.error);break;default:E("157")}var Qc=t.nextEffect;t.nextEffect=null;t=Qc}}catch(Tc){c=!0,d=Tc}c&&(null===t?E("178"):void 0,h(t,d),null!==t&&(t=t.nextEffect))}ja=Qb=!1;"function"===typeof De&&De(a.stateNode);ha&&(ha.forEach(G),ha=null);null!==ca&&(a=ca,ca=null,Ob(a));b=b.current.expirationTime;0===b&&(qa=R=null);return b}function c(a){for(;;){var b=Fg(a.alternate,a,H),c=a["return"],d=a.sibling;var e=a;if(2147483647===H||2147483647!==e.expirationTime){if(2!==e.tag&&3!==
e.tag)var f=0;else f=e.updateQueue,f=null===f?0:f.expirationTime;for(var g=e.child;null!==g;)0!==g.expirationTime&&(0===f||f>g.expirationTime)&&(f=g.expirationTime),g=g.sibling;e.expirationTime=f}if(null!==b)return b;null!==c&&(null===c.firstEffect&&(c.firstEffect=a.firstEffect),null!==a.lastEffect&&(null!==c.lastEffect&&(c.lastEffect.nextEffect=a.firstEffect),c.lastEffect=a.lastEffect),1<a.effectTag&&(null!==c.lastEffect?c.lastEffect.nextEffect=a:c.firstEffect=a,c.lastEffect=a));if(null!==d)return d;
if(null!==c)a=c;else{a.stateNode.isReadyForCommit=!0;break}}return null}function d(a){var b=rg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function e(a){var b=Gg(a.alternate,a,H);null===b&&(b=c(a));id.current=null;return b}function f(a){if(null!==R){if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=k(F)?e(F):d(F);else for(;null!==F&&!A();)F=k(F)?e(F):d(F)}else if(!(0===H||H>a))if(H<=Uc)for(;null!==F;)F=d(F);else for(;null!==F&&!A();)F=d(F)}function g(a,b){ja?E("243"):void 0;ja=!0;a.isReadyForCommit=
!1;if(a!==ra||b!==H||null===F){for(;-1<he;)ge[he]=null,he--;je=D;ie.current=D;X.current=!1;x();ra=a;H=b;F=se(ra.current,null,b)}var c=!1,d=null;try{f(b)}catch(Rc){c=!0,d=Rc}for(;c;){if(eb){ca=d;break}var g=F;if(null===g)eb=!0;else{var k=h(g,d);null===k?E("183"):void 0;if(!eb){try{c=k;d=b;for(k=c;null!==g;){switch(g.tag){case 2:ne(g);break;case 5:qg(g);break;case 3:p(g);break;case 4:p(g)}if(g===k||g.alternate===k)break;g=g["return"]}F=e(c);f(d)}catch(Rc){c=!0;d=Rc;continue}break}}}b=ca;eb=ja=!1;ca=
null;null!==b&&Ob(b);return a.isReadyForCommit?a.current.alternate:null}function h(a,b){var c=id.current=null,d=!1,e=!1,f=null;if(3===a.tag)c=a,q(a)&&(eb=!0);else for(var g=a["return"];null!==g&&null===c;){2===g.tag?"function"===typeof g.stateNode.componentDidCatch&&(d=!0,f=jd(g),c=g,e=!0):3===g.tag&&(c=g);if(q(g)){if(Sc||null!==ha&&(ha.has(g)||null!==g.alternate&&ha.has(g.alternate)))return null;c=null;e=!1}g=g["return"]}if(null!==c){null===qa&&(qa=new Set);qa.add(c);var h="";g=a;do{a:switch(g.tag){case 0:case 1:case 2:case 5:var k=
g._debugOwner,Qc=g._debugSource;var m=jd(g);var n=null;k&&(n=jd(k));k=Qc;m="\n    in "+(m||"Unknown")+(k?" (at "+k.fileName.replace(/^.*[\\\/]/,"")+":"+k.lineNumber+")":n?" (created by "+n+")":"");break a;default:m=""}h+=m;g=g["return"]}while(g);g=h;a=jd(a);null===R&&(R=new Map);b={componentName:a,componentStack:g,error:b,errorBoundary:d?c.stateNode:null,errorBoundaryFound:d,errorBoundaryName:f,willRetry:e};R.set(c,b);try{var p=b.error;p&&p.suppressReactErrorLogging||console.error(p)}catch(Vc){Vc&&
Vc.suppressReactErrorLogging||console.error(Vc)}Qb?(null===ha&&(ha=new Set),ha.add(c)):G(c);return c}null===ca&&(ca=b);return null}function k(a){return null!==R&&(R.has(a)||null!==a.alternate&&R.has(a.alternate))}function q(a){return null!==qa&&(qa.has(a)||null!==a.alternate&&qa.has(a.alternate))}function v(){return 20*(((I()+100)/20|0)+1)}function y(a){return 0!==ka?ka:ja?Qb?1:H:!Hg||a.internalContextTag&1?v():1}function u(a,b){return z(a,b,!1)}function z(a,b){for(;null!==a;){if(0===a.expirationTime||
a.expirationTime>b)a.expirationTime=b;null!==a.alternate&&(0===a.alternate.expirationTime||a.alternate.expirationTime>b)&&(a.alternate.expirationTime=b);if(null===a["return"])if(3===a.tag){var c=a.stateNode;!ja&&c===ra&&b<H&&(F=ra=null,H=0);var d=c,e=b;Rb>Ig&&E("185");if(null===d.nextScheduledRoot)d.remainingExpirationTime=e,null===O?(sa=O=d,d.nextScheduledRoot=d):(O=O.nextScheduledRoot=d,O.nextScheduledRoot=sa);else{var f=d.remainingExpirationTime;if(0===f||e<f)d.remainingExpirationTime=e}Fa||(la?
Sb&&(ma=d,na=1,m(ma,na)):1===e?w(1,null):L(e));!ja&&c===ra&&b<H&&(F=ra=null,H=0)}else break;a=a["return"]}}function G(a){z(a,1,!0)}function I(){return Uc=((Wc()-Pe)/10|0)+2}function L(a){if(0!==Tb){if(a>Tb)return;Jg(Xc)}var b=Wc()-Pe;Tb=a;Xc=Kg(J,{timeout:10*(a-2)-b})}function N(){var a=0,b=null;if(null!==O)for(var c=O,d=sa;null!==d;){var e=d.remainingExpirationTime;if(0===e){null===c||null===O?E("244"):void 0;if(d===d.nextScheduledRoot){sa=O=d.nextScheduledRoot=null;break}else if(d===sa)sa=e=d.nextScheduledRoot,
O.nextScheduledRoot=e,d.nextScheduledRoot=null;else if(d===O){O=c;O.nextScheduledRoot=sa;d.nextScheduledRoot=null;break}else c.nextScheduledRoot=d.nextScheduledRoot,d.nextScheduledRoot=null;d=c.nextScheduledRoot}else{if(0===a||e<a)a=e,b=d;if(d===O)break;c=d;d=d.nextScheduledRoot}}c=ma;null!==c&&c===b?Rb++:Rb=0;ma=b;na=a}function J(a){w(0,a)}function w(a,b){fb=b;for(N();null!==ma&&0!==na&&(0===a||na<=a)&&!Yc;)m(ma,na),N();null!==fb&&(Tb=0,Xc=-1);0!==na&&L(na);fb=null;Yc=!1;Rb=0;if(Ub)throw a=Zc,Zc=
null,Ub=!1,a;}function m(a,c){Fa?E("245"):void 0;Fa=!0;if(c<=I()){var d=a.finishedWork;null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(a.remainingExpirationTime=b(d)))}else d=a.finishedWork,null!==d?(a.finishedWork=null,a.remainingExpirationTime=b(d)):(a.finishedWork=null,d=g(a,c),null!==d&&(A()?a.finishedWork=d:a.remainingExpirationTime=b(d)));Fa=!1}function A(){return null===fb||fb.timeRemaining()>Lg?!1:Yc=!0}function Ob(a){null===ma?E("246"):
void 0;ma.remainingExpirationTime=0;Ub||(Ub=!0,Zc=a)}var r=hf(a),n=jf(a),p=r.popHostContainer,qg=r.popHostContext,x=r.resetHostContainer,Me=df(a,r,n,u,y),rg=Me.beginWork,Gg=Me.beginFailedWork,Fg=ef(a,r,n).completeWork;r=ff(a,h);var zg=r.commitResetTextContent,Ne=r.commitPlacement,Bg=r.commitDeletion,Oe=r.commitWork,Dg=r.commitLifeCycles,Eg=r.commitAttachRef,Ag=r.commitDetachRef,Wc=a.now,Kg=a.scheduleDeferredCallback,Jg=a.cancelDeferredCallback,Hg=a.useSyncScheduling,yg=a.prepareForCommit,Cg=a.resetAfterCommit,
Pe=Wc(),Uc=2,ka=0,ja=!1,F=null,ra=null,H=0,t=null,R=null,qa=null,ha=null,ca=null,eb=!1,Qb=!1,Sc=!1,sa=null,O=null,Tb=0,Xc=-1,Fa=!1,ma=null,na=0,Yc=!1,Ub=!1,Zc=null,fb=null,la=!1,Sb=!1,Ig=1E3,Rb=0,Lg=1;return{computeAsyncExpiration:v,computeExpirationForFiber:y,scheduleWork:u,batchedUpdates:function(a,b){var c=la;la=!0;try{return a(b)}finally{(la=c)||Fa||w(1,null)}},unbatchedUpdates:function(a){if(la&&!Sb){Sb=!0;try{return a()}finally{Sb=!1}}return a()},flushSync:function(a){var b=la;la=!0;try{a:{var c=
ka;ka=1;try{var d=a();break a}finally{ka=c}d=void 0}return d}finally{la=b,Fa?E("187"):void 0,w(1,null)}},deferredUpdates:function(a){var b=ka;ka=v();try{return a()}finally{ka=b}}}}
function lf(a){function b(a){a=od(a);return null===a?null:a.stateNode}var c=a.getPublicInstance;a=kf(a);var d=a.computeAsyncExpiration,e=a.computeExpirationForFiber,f=a.scheduleWork;return{createContainer:function(a,b){var c=new Y(3,null,0);a={current:c,containerInfo:a,pendingChildren:null,remainingExpirationTime:0,isReadyForCommit:!1,finishedWork:null,context:null,pendingContext:null,hydrate:b,nextScheduledRoot:null};return c.stateNode=a},updateContainer:function(a,b,c,q){var g=b.current;if(c){c=
c._reactInternalFiber;var h;b:{2===kd(c)&&2===c.tag?void 0:E("170");for(h=c;3!==h.tag;){if(le(h)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}(h=h["return"])?void 0:E("171")}h=h.stateNode.context}c=le(c)?pe(c,h):h}else c=D;null===b.context?b.context=c:b.pendingContext=c;b=q;b=void 0===b?null:b;q=null!=a&&null!=a.type&&null!=a.type.prototype&&!0===a.type.prototype.unstable_isAsyncReactComponent?d():e(g);He(g,{expirationTime:q,partialState:{element:a},callback:b,isReplace:!1,isForced:!1,
nextCallback:null,next:null});f(g,q)},batchedUpdates:a.batchedUpdates,unbatchedUpdates:a.unbatchedUpdates,deferredUpdates:a.deferredUpdates,flushSync:a.flushSync,getPublicRootInstance:function(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return c(a.child.stateNode);default:return a.child.stateNode}},findHostInstance:b,findHostInstanceWithNoPortals:function(a){a=pd(a);return null===a?null:a.stateNode},injectIntoDevTools:function(a){var c=a.findFiberByHostInstance;return Ce(B({},
a,{findHostInstanceByFiber:function(a){return b(a)},findFiberByHostInstance:function(a){return c?c(a):null}}))}}}var mf=Object.freeze({default:lf}),nf=mf&&lf||mf,of=nf["default"]?nf["default"]:nf;function pf(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:Ue,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}var qf="object"===typeof performance&&"function"===typeof performance.now,rf=void 0;rf=qf?function(){return performance.now()}:function(){return Date.now()};
var sf=void 0,tf=void 0;
if(l.canUseDOM)if("function"!==typeof requestIdleCallback||"function"!==typeof cancelIdleCallback){var uf=null,vf=!1,wf=-1,xf=!1,yf=0,zf=33,Af=33,Bf;Bf=qf?{didTimeout:!1,timeRemaining:function(){var a=yf-performance.now();return 0<a?a:0}}:{didTimeout:!1,timeRemaining:function(){var a=yf-Date.now();return 0<a?a:0}};var Cf="__reactIdleCallback$"+Math.random().toString(36).slice(2);window.addEventListener("message",function(a){if(a.source===window&&a.data===Cf){vf=!1;a=rf();if(0>=yf-a)if(-1!==wf&&wf<=
a)Bf.didTimeout=!0;else{xf||(xf=!0,requestAnimationFrame(Df));return}else Bf.didTimeout=!1;wf=-1;a=uf;uf=null;null!==a&&a(Bf)}},!1);var Df=function(a){xf=!1;var b=a-yf+Af;b<Af&&zf<Af?(8>b&&(b=8),Af=b<zf?zf:b):zf=b;yf=a+Af;vf||(vf=!0,window.postMessage(Cf,"*"))};sf=function(a,b){uf=a;null!=b&&"number"===typeof b.timeout&&(wf=rf()+b.timeout);xf||(xf=!0,requestAnimationFrame(Df));return 0};tf=function(){uf=null;vf=!1;wf=-1}}else sf=window.requestIdleCallback,tf=window.cancelIdleCallback;else sf=function(a){return setTimeout(function(){a({timeRemaining:function(){return Infinity}})})},
tf=function(a){clearTimeout(a)};var Ef=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Ff={},Gf={};
function Hf(a){if(Gf.hasOwnProperty(a))return!0;if(Ff.hasOwnProperty(a))return!1;if(Ef.test(a))return Gf[a]=!0;Ff[a]=!0;return!1}
function If(a,b,c){var d=wa(b);if(d&&va(b,c)){var e=d.mutationMethod;e?e(a,c):null==c||d.hasBooleanValue&&!c||d.hasNumericValue&&isNaN(c)||d.hasPositiveNumericValue&&1>c||d.hasOverloadedBooleanValue&&!1===c?Jf(a,b):d.mustUseProperty?a[d.propertyName]=c:(b=d.attributeName,(e=d.attributeNamespace)?a.setAttributeNS(e,b,""+c):d.hasBooleanValue||d.hasOverloadedBooleanValue&&!0===c?a.setAttribute(b,""):a.setAttribute(b,""+c))}else Kf(a,b,va(b,c)?c:null)}
function Kf(a,b,c){Hf(b)&&(null==c?a.removeAttribute(b):a.setAttribute(b,""+c))}function Jf(a,b){var c=wa(b);c?(b=c.mutationMethod)?b(a,void 0):c.mustUseProperty?a[c.propertyName]=c.hasBooleanValue?!1:"":a.removeAttribute(c.attributeName):a.removeAttribute(b)}
function Lf(a,b){var c=b.value,d=b.checked;return B({type:void 0,step:void 0,min:void 0,max:void 0},b,{defaultChecked:void 0,defaultValue:void 0,value:null!=c?c:a._wrapperState.initialValue,checked:null!=d?d:a._wrapperState.initialChecked})}function Mf(a,b){var c=b.defaultValue;a._wrapperState={initialChecked:null!=b.checked?b.checked:b.defaultChecked,initialValue:null!=b.value?b.value:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}
function Nf(a,b){b=b.checked;null!=b&&If(a,"checked",b)}function Of(a,b){Nf(a,b);var c=b.value;if(null!=c)if(0===c&&""===a.value)a.value="0";else if("number"===b.type){if(b=parseFloat(a.value)||0,c!=b||c==b&&a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else null==b.value&&null!=b.defaultValue&&a.defaultValue!==""+b.defaultValue&&(a.defaultValue=""+b.defaultValue),null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function Pf(a,b){switch(b.type){case "submit":case "reset":break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":a.value="";a.value=a.defaultValue;break;default:a.value=a.value}b=a.name;""!==b&&(a.name="");a.defaultChecked=!a.defaultChecked;a.defaultChecked=!a.defaultChecked;""!==b&&(a.name=b)}function Qf(a){var b="";aa.Children.forEach(a,function(a){null==a||"string"!==typeof a&&"number"!==typeof a||(b+=a)});return b}
function Rf(a,b){a=B({children:void 0},b);if(b=Qf(b.children))a.children=b;return a}function Sf(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+c;b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function Tf(a,b){var c=b.value;a._wrapperState={initialValue:null!=c?c:b.defaultValue,wasMultiple:!!b.multiple}}function Uf(a,b){null!=b.dangerouslySetInnerHTML?E("91"):void 0;return B({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Vf(a,b){var c=b.value;null==c&&(c=b.defaultValue,b=b.children,null!=b&&(null!=c?E("92"):void 0,Array.isArray(b)&&(1>=b.length?void 0:E("93"),b=b[0]),c=""+b),null==c&&(c=""));a._wrapperState={initialValue:""+c}}
function Wf(a,b){var c=b.value;null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&(a.defaultValue=c));null!=b.defaultValue&&(a.defaultValue=b.defaultValue)}function Xf(a){var b=a.textContent;b===a._wrapperState.initialValue&&(a.value=b)}var Yf={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function Zf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function $f(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Zf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var ag=void 0,bg=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Yf.svg||"innerHTML"in a)a.innerHTML=b;else{ag=ag||document.createElement("div");ag.innerHTML="\x3csvg\x3e"+b+"\x3c/svg\x3e";for(b=ag.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function cg(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var dg={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,
stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},eg=["Webkit","ms","Moz","O"];Object.keys(dg).forEach(function(a){eg.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);dg[b]=dg[a]})});
function fg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--");var e=c;var f=b[c];e=null==f||"boolean"===typeof f||""===f?"":d||"number"!==typeof f||0===f||dg.hasOwnProperty(e)&&dg[e]?(""+f).trim():f+"px";"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var gg=B({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function hg(a,b,c){b&&(gg[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML?E("137",a,c()):void 0),null!=b.dangerouslySetInnerHTML&&(null!=b.children?E("60"):void 0,"object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML?void 0:E("61")),null!=b.style&&"object"!==typeof b.style?E("62",c()):void 0)}
function ig(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var jg=Yf.html,kg=C.thatReturns("");
function lg(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Hd(a);b=Sa[b];for(var d=0;d<b.length;d++){var e=b[d];c.hasOwnProperty(e)&&c[e]||("topScroll"===e?wd("topScroll","scroll",a):"topFocus"===e||"topBlur"===e?(wd("topFocus","focus",a),wd("topBlur","blur",a),c.topBlur=!0,c.topFocus=!0):"topCancel"===e?(yc("cancel",!0)&&wd("topCancel","cancel",a),c.topCancel=!0):"topClose"===e?(yc("close",!0)&&wd("topClose","close",a),c.topClose=!0):Dd.hasOwnProperty(e)&&U(e,Dd[e],a),c[e]=!0)}}
var mg={topAbort:"abort",topCanPlay:"canplay",topCanPlayThrough:"canplaythrough",topDurationChange:"durationchange",topEmptied:"emptied",topEncrypted:"encrypted",topEnded:"ended",topError:"error",topLoadedData:"loadeddata",topLoadedMetadata:"loadedmetadata",topLoadStart:"loadstart",topPause:"pause",topPlay:"play",topPlaying:"playing",topProgress:"progress",topRateChange:"ratechange",topSeeked:"seeked",topSeeking:"seeking",topStalled:"stalled",topSuspend:"suspend",topTimeUpdate:"timeupdate",topVolumeChange:"volumechange",
topWaiting:"waiting"};function ng(a,b,c,d){c=9===c.nodeType?c:c.ownerDocument;d===jg&&(d=Zf(a));d===jg?"script"===a?(a=c.createElement("div"),a.innerHTML="\x3cscript\x3e\x3c/script\x3e",a=a.removeChild(a.firstChild)):a="string"===typeof b.is?c.createElement(a,{is:b.is}):c.createElement(a):a=c.createElementNS(d,a);return a}function og(a,b){return(9===b.nodeType?b:b.ownerDocument).createTextNode(a)}
function pg(a,b,c,d){var e=ig(b,c);switch(b){case "iframe":case "object":U("topLoad","load",a);var f=c;break;case "video":case "audio":for(f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);f=c;break;case "source":U("topError","error",a);f=c;break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);f=c;break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);f=c;break;case "details":U("topToggle","toggle",a);f=c;break;case "input":Mf(a,c);f=Lf(a,c);U("topInvalid","invalid",a);
lg(d,"onChange");break;case "option":f=Rf(a,c);break;case "select":Tf(a,c);f=B({},c,{value:void 0});U("topInvalid","invalid",a);lg(d,"onChange");break;case "textarea":Vf(a,c);f=Uf(a,c);U("topInvalid","invalid",a);lg(d,"onChange");break;default:f=c}hg(b,f,kg);var g=f,h;for(h in g)if(g.hasOwnProperty(h)){var k=g[h];"style"===h?fg(a,k,kg):"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,null!=k&&bg(a,k)):"children"===h?"string"===typeof k?("textarea"!==b||""!==k)&&cg(a,k):"number"===typeof k&&cg(a,
""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(Ra.hasOwnProperty(h)?null!=k&&lg(d,h):e?Kf(a,h,k):null!=k&&If(a,h,k))}switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "option":null!=c.value&&a.setAttribute("value",c.value);break;case "select":a.multiple=!!c.multiple;b=c.value;null!=b?Sf(a,!!c.multiple,b,!1):null!=c.defaultValue&&Sf(a,!!c.multiple,c.defaultValue,!0);break;default:"function"===typeof f.onClick&&(a.onclick=
C)}}
function sg(a,b,c,d,e){var f=null;switch(b){case "input":c=Lf(a,c);d=Lf(a,d);f=[];break;case "option":c=Rf(a,c);d=Rf(a,d);f=[];break;case "select":c=B({},c,{value:void 0});d=B({},d,{value:void 0});f=[];break;case "textarea":c=Uf(a,c);d=Uf(a,d);f=[];break;default:"function"!==typeof c.onClick&&"function"===typeof d.onClick&&(a.onclick=C)}hg(b,d,kg);var g,h;a=null;for(g in c)if(!d.hasOwnProperty(g)&&c.hasOwnProperty(g)&&null!=c[g])if("style"===g)for(h in b=c[g],b)b.hasOwnProperty(h)&&(a||(a={}),a[h]=
"");else"dangerouslySetInnerHTML"!==g&&"children"!==g&&"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&"autoFocus"!==g&&(Ra.hasOwnProperty(g)?f||(f=[]):(f=f||[]).push(g,null));for(g in d){var k=d[g];b=null!=c?c[g]:void 0;if(d.hasOwnProperty(g)&&k!==b&&(null!=k||null!=b))if("style"===g)if(b){for(h in b)!b.hasOwnProperty(h)||k&&k.hasOwnProperty(h)||(a||(a={}),a[h]="");for(h in k)k.hasOwnProperty(h)&&b[h]!==k[h]&&(a||(a={}),a[h]=k[h])}else a||(f||(f=[]),f.push(g,a)),a=k;else"dangerouslySetInnerHTML"===
g?(k=k?k.__html:void 0,b=b?b.__html:void 0,null!=k&&b!==k&&(f=f||[]).push(g,""+k)):"children"===g?b===k||"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(g,""+k):"suppressContentEditableWarning"!==g&&"suppressHydrationWarning"!==g&&(Ra.hasOwnProperty(g)?(null!=k&&lg(e,g),f||b===k||(f=[])):(f=f||[]).push(g,k))}a&&(f=f||[]).push("style",a);return f}
function tg(a,b,c,d,e){"input"===c&&"radio"===e.type&&null!=e.name&&Nf(a,e);ig(c,d);d=ig(c,e);for(var f=0;f<b.length;f+=2){var g=b[f],h=b[f+1];"style"===g?fg(a,h,kg):"dangerouslySetInnerHTML"===g?bg(a,h):"children"===g?cg(a,h):d?null!=h?Kf(a,g,h):a.removeAttribute(g):null!=h?If(a,g,h):Jf(a,g)}switch(c){case "input":Of(a,e);break;case "textarea":Wf(a,e);break;case "select":a._wrapperState.initialValue=void 0,b=a._wrapperState.wasMultiple,a._wrapperState.wasMultiple=!!e.multiple,c=e.value,null!=c?Sf(a,
!!e.multiple,c,!1):b!==!!e.multiple&&(null!=e.defaultValue?Sf(a,!!e.multiple,e.defaultValue,!0):Sf(a,!!e.multiple,e.multiple?[]:"",!1))}}
function ug(a,b,c,d,e){switch(b){case "iframe":case "object":U("topLoad","load",a);break;case "video":case "audio":for(var f in mg)mg.hasOwnProperty(f)&&U(f,mg[f],a);break;case "source":U("topError","error",a);break;case "img":case "image":U("topError","error",a);U("topLoad","load",a);break;case "form":U("topReset","reset",a);U("topSubmit","submit",a);break;case "details":U("topToggle","toggle",a);break;case "input":Mf(a,c);U("topInvalid","invalid",a);lg(e,"onChange");break;case "select":Tf(a,c);
U("topInvalid","invalid",a);lg(e,"onChange");break;case "textarea":Vf(a,c),U("topInvalid","invalid",a),lg(e,"onChange")}hg(b,c,kg);d=null;for(var g in c)c.hasOwnProperty(g)&&(f=c[g],"children"===g?"string"===typeof f?a.textContent!==f&&(d=["children",f]):"number"===typeof f&&a.textContent!==""+f&&(d=["children",""+f]):Ra.hasOwnProperty(g)&&null!=f&&lg(e,g));switch(b){case "input":Bc(a);Pf(a,c);break;case "textarea":Bc(a);Xf(a,c);break;case "select":case "option":break;default:"function"===typeof c.onClick&&
(a.onclick=C)}return d}function vg(a,b){return a.nodeValue!==b}
var wg=Object.freeze({createElement:ng,createTextNode:og,setInitialProperties:pg,diffProperties:sg,updateProperties:tg,diffHydratedProperties:ug,diffHydratedText:vg,warnForUnmatchedText:function(){},warnForDeletedHydratableElement:function(){},warnForDeletedHydratableText:function(){},warnForInsertedHydratedElement:function(){},warnForInsertedHydratedText:function(){},restoreControlledState:function(a,b,c){switch(b){case "input":Of(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=
c.parentNode;c=c.querySelectorAll("input[name\x3d"+JSON.stringify(""+b)+'][type\x3d"radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=rb(d);e?void 0:E("90");Cc(d);Of(d,e)}}}break;case "textarea":Wf(a,c);break;case "select":b=c.value,null!=b&&Sf(a,!!c.multiple,b,!1)}}});nc.injectFiberControlledHostComponent(wg);var xg=null,Mg=null;function Ng(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}
function Og(a){a=a?9===a.nodeType?a.documentElement:a.firstChild:null;return!(!a||1!==a.nodeType||!a.hasAttribute("data-reactroot"))}
var Z=of({getRootHostContext:function(a){var b=a.nodeType;switch(b){case 9:case 11:a=(a=a.documentElement)?a.namespaceURI:$f(null,"");break;default:b=8===b?a.parentNode:a,a=b.namespaceURI||null,b=b.tagName,a=$f(a,b)}return a},getChildHostContext:function(a,b){return $f(a,b)},getPublicInstance:function(a){return a},prepareForCommit:function(){xg=td;var a=da();if(Kd(a)){if("selectionStart"in a)var b={start:a.selectionStart,end:a.selectionEnd};else a:{var c=window.getSelection&&window.getSelection();
if(c&&0!==c.rangeCount){b=c.anchorNode;var d=c.anchorOffset,e=c.focusNode;c=c.focusOffset;try{b.nodeType,e.nodeType}catch(z){b=null;break a}var f=0,g=-1,h=-1,k=0,q=0,v=a,y=null;b:for(;;){for(var u;;){v!==b||0!==d&&3!==v.nodeType||(g=f+d);v!==e||0!==c&&3!==v.nodeType||(h=f+c);3===v.nodeType&&(f+=v.nodeValue.length);if(null===(u=v.firstChild))break;y=v;v=u}for(;;){if(v===a)break b;y===b&&++k===d&&(g=f);y===e&&++q===c&&(h=f);if(null!==(u=v.nextSibling))break;v=y;y=v.parentNode}v=u}b=-1===g||-1===h?null:
{start:g,end:h}}else b=null}b=b||{start:0,end:0}}else b=null;Mg={focusedElem:a,selectionRange:b};ud(!1)},resetAfterCommit:function(){var a=Mg,b=da(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&fa(document.documentElement,c)){if(Kd(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(window.getSelection){b=window.getSelection();var e=c[Eb()].length;a=Math.min(d.start,e);d=void 0===d.end?a:Math.min(d.end,e);!b.extend&&a>
d&&(e=d,d=a,a=e);e=Jd(c,a);var f=Jd(c,d);if(e&&f&&(1!==b.rangeCount||b.anchorNode!==e.node||b.anchorOffset!==e.offset||b.focusNode!==f.node||b.focusOffset!==f.offset)){var g=document.createRange();g.setStart(e.node,e.offset);b.removeAllRanges();a>d?(b.addRange(g),b.extend(f.node,f.offset)):(g.setEnd(f.node,f.offset),b.addRange(g))}}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});ia(c);for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=
a.top}Mg=null;ud(xg);xg=null},createInstance:function(a,b,c,d,e){a=ng(a,b,c,d);a[Q]=e;a[ob]=b;return a},appendInitialChild:function(a,b){a.appendChild(b)},finalizeInitialChildren:function(a,b,c,d){pg(a,b,c,d);a:{switch(b){case "button":case "input":case "select":case "textarea":a=!!c.autoFocus;break a}a=!1}return a},prepareUpdate:function(a,b,c,d,e){return sg(a,b,c,d,e)},shouldSetTextContent:function(a,b){return"textarea"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===
typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&"string"===typeof b.dangerouslySetInnerHTML.__html},shouldDeprioritizeSubtree:function(a,b){return!!b.hidden},createTextInstance:function(a,b,c,d){a=og(a,b);a[Q]=d;return a},now:rf,mutation:{commitMount:function(a){a.focus()},commitUpdate:function(a,b,c,d,e){a[ob]=e;tg(a,b,c,d,e)},resetTextContent:function(a){a.textContent=""},commitTextUpdate:function(a,b,c){a.nodeValue=c},appendChild:function(a,b){a.appendChild(b)},appendChildToContainer:function(a,
b){8===a.nodeType?a.parentNode.insertBefore(b,a):a.appendChild(b)},insertBefore:function(a,b,c){a.insertBefore(b,c)},insertInContainerBefore:function(a,b,c){8===a.nodeType?a.parentNode.insertBefore(b,c):a.insertBefore(b,c)},removeChild:function(a,b){a.removeChild(b)},removeChildFromContainer:function(a,b){8===a.nodeType?a.parentNode.removeChild(b):a.removeChild(b)}},hydration:{canHydrateInstance:function(a,b){return 1!==a.nodeType||b.toLowerCase()!==a.nodeName.toLowerCase()?null:a},canHydrateTextInstance:function(a,
b){return""===b||3!==a.nodeType?null:a},getNextHydratableSibling:function(a){for(a=a.nextSibling;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},getFirstHydratableChild:function(a){for(a=a.firstChild;a&&1!==a.nodeType&&3!==a.nodeType;)a=a.nextSibling;return a},hydrateInstance:function(a,b,c,d,e,f){a[Q]=f;a[ob]=c;return ug(a,b,c,e,d)},hydrateTextInstance:function(a,b,c){a[Q]=c;return vg(a,b)},didNotMatchHydratedContainerTextInstance:function(){},didNotMatchHydratedTextInstance:function(){},
didNotHydrateContainerInstance:function(){},didNotHydrateInstance:function(){},didNotFindHydratableContainerInstance:function(){},didNotFindHydratableContainerTextInstance:function(){},didNotFindHydratableInstance:function(){},didNotFindHydratableTextInstance:function(){}},scheduleDeferredCallback:sf,cancelDeferredCallback:tf,useSyncScheduling:!0});rc=Z.batchedUpdates;
function Pg(a,b,c,d,e){Ng(c)?void 0:E("200");var f=c._reactRootContainer;if(f)Z.updateContainer(b,f,a,e);else{d=d||Og(c);if(!d)for(f=void 0;f=c.lastChild;)c.removeChild(f);var g=Z.createContainer(c,d);f=c._reactRootContainer=g;Z.unbatchedUpdates(function(){Z.updateContainer(b,g,a,e)})}return Z.getPublicRootInstance(f)}function Qg(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;Ng(b)?void 0:E("200");return pf(a,b,null,c)}
function Rg(a,b){this._reactRootContainer=Z.createContainer(a,b)}Rg.prototype.render=function(a,b){Z.updateContainer(a,this._reactRootContainer,null,b)};Rg.prototype.unmount=function(a){Z.updateContainer(null,this._reactRootContainer,null,a)};
var Sg={createPortal:Qg,findDOMNode:function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(b)return Z.findHostInstance(b);"function"===typeof a.render?E("188"):E("213",Object.keys(a))},hydrate:function(a,b,c){return Pg(null,a,b,!0,c)},render:function(a,b,c){return Pg(null,a,b,!1,c)},unstable_renderSubtreeIntoContainer:function(a,b,c,d){null==a||void 0===a._reactInternalFiber?E("38"):void 0;return Pg(a,b,c,!1,d)},unmountComponentAtNode:function(a){Ng(a)?void 0:
E("40");return a._reactRootContainer?(Z.unbatchedUpdates(function(){Pg(null,null,a,!1,function(){a._reactRootContainer=null})}),!0):!1},unstable_createPortal:Qg,unstable_batchedUpdates:tc,unstable_deferredUpdates:Z.deferredUpdates,flushSync:Z.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{EventPluginHub:mb,EventPluginRegistry:Va,EventPropagators:Cb,ReactControlledComponent:qc,ReactDOMComponentTree:sb,ReactDOMEventListener:xd}};
Z.injectIntoDevTools({findFiberByHostInstance:pb,bundleType:0,version:"16.2.0",rendererPackageName:"react-dom"});var Tg=Object.freeze({default:Sg}),Ug=Tg&&Sg||Tg;module.exports=Ug["default"]?Ug["default"]:Ug;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(53);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var React = __webpack_require__(0);
var invariant = __webpack_require__(8);
var warning = __webpack_require__(12);
var ExecutionEnvironment = __webpack_require__(25);
var _assign = __webpack_require__(7);
var emptyFunction = __webpack_require__(6);
var EventListener = __webpack_require__(26);
var getActiveElement = __webpack_require__(27);
var shallowEqual = __webpack_require__(28);
var containsNode = __webpack_require__(29);
var focusNode = __webpack_require__(30);
var emptyObject = __webpack_require__(11);
var checkPropTypes = __webpack_require__(15);
var hyphenateStyleName = __webpack_require__(55);
var camelizeStyleName = __webpack_require__(57);

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;

// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS = {
  children: true,
  dangerouslySetInnerHTML: true,
  defaultValue: true,
  defaultChecked: true,
  innerHTML: true,
  suppressContentEditableWarning: true,
  suppressHydrationWarning: true,
  style: true
};

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,
  HAS_STRING_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    for (var propName in Properties) {
      !!properties.hasOwnProperty(propName) ? invariant(false, "injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.", propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),
        hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, "DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s", propName) : void 0;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];

        propertyInfo.attributeName = attributeName;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      // Downcase references to whitelist properties to check for membership
      // without case-sensitivity. This allows the whitelist to pick up
      // `allowfullscreen`, which should be written using the property configuration
      // for `allowFullscreen`
      properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */
var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";


var ROOT_ATTRIBUTE_NAME = 'data-reactroot';

/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */
var properties = {};

/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */
function shouldSetAttribute(name, value) {
  if (isReservedProp(name)) {
    return false;
  }
  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return false;
  }
  if (value === null) {
    return true;
  }
  switch (typeof value) {
    case 'boolean':
      return shouldAttributeAcceptBooleanValue(name);
    case 'undefined':
    case 'number':
    case 'string':
    case 'object':
      return true;
    default:
      // function, symbol
      return false;
  }
}

function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function shouldAttributeAcceptBooleanValue(name) {
  if (isReservedProp(name)) {
    return true;
  }
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;
  }
  var prefix = name.toLowerCase().slice(0, 5);
  return prefix === 'data-' || prefix === 'aria-';
}

/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */
function isReservedProp(name) {
  return RESERVED_PROPS.hasOwnProperty(name);
}

var injection = DOMPropertyInjection;

var MUST_USE_PROPERTY = injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = injection.HAS_OVERLOADED_BOOLEAN_VALUE;
var HAS_STRING_BOOLEAN_VALUE = injection.HAS_STRING_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  // When adding attributes to this list, be sure to also add them to
  // the `possibleStandardNames` module to ensure casing and incorrect
  // name warnings.
  Properties: {
    allowFullScreen: HAS_BOOLEAN_VALUE,
    // specifies target context for links with `preload` type
    async: HAS_BOOLEAN_VALUE,
    // Note: there is a special case that prevents it from being written to the DOM
    // on the client side because the browsers are inconsistent. Instead we call focus().
    autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_OVERLOADED_BOOLEAN_VALUE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    contentEditable: HAS_STRING_BOOLEAN_VALUE,
    controls: HAS_BOOLEAN_VALUE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: HAS_STRING_BOOLEAN_VALUE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    hidden: HAS_BOOLEAN_VALUE,
    loop: HAS_BOOLEAN_VALUE,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    playsInline: HAS_BOOLEAN_VALUE,
    readOnly: HAS_BOOLEAN_VALUE,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    scoped: HAS_BOOLEAN_VALUE,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    start: HAS_NUMERIC_VALUE,
    // support for projecting regular DOM Elements via V1 named slots ( shadow dom )
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: HAS_STRING_BOOLEAN_VALUE,
    // Style must be explicitly set in the attribute list. React components
    // expect a style object
    style: 0,
    // Keep it in the whitelist because it is case-sensitive for SVG.
    tabIndex: 0,
    // itemScope is for for Microdata support.
    // See http://schema.org/docs/gs.html
    itemScope: HAS_BOOLEAN_VALUE,
    // These attributes must stay in the white-list because they have
    // different attribute names (see DOMAttributeNames below)
    acceptCharset: 0,
    className: 0,
    htmlFor: 0,
    httpEquiv: 0,
    // Attributes with mutation methods must be specified in the whitelist
    // Set the string boolean flag to allow the behavior
    value: HAS_STRING_BOOLEAN_VALUE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMMutationMethods: {
    value: function (node, value) {
      if (value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + value);
      }
    }
  }
};

var HAS_STRING_BOOLEAN_VALUE$1 = injection.HAS_STRING_BOOLEAN_VALUE;


var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */
var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];

var SVGDOMPropertyConfig = {
  Properties: {
    autoReverse: HAS_STRING_BOOLEAN_VALUE$1,
    externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,
    preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1
  },
  DOMAttributeNames: {
    autoReverse: 'autoReverse',
    externalResourcesRequired: 'externalResourcesRequired',
    preserveAlpha: 'preserveAlpha'
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  }
};

var CAMELIZE = /[\-\:]([a-z])/g;
var capitalize = function (token) {
  return token[1].toUpperCase();
};

ATTRS.forEach(function (original) {
  var reactName = original.replace(CAMELIZE, capitalize);

  SVGDOMPropertyConfig.Properties[reactName] = 0;
  SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;
});

injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);

var ReactErrorUtils = {
  // Used by Fiber to simulate a try-catch.
  _caughtError: null,
  _hasCaughtError: false,

  // Used by event system to capture/rethrow the first error.
  _rethrowError: null,
  _hasRethrowError: false,

  injection: {
    injectErrorUtils: function (injectedErrorUtils) {
      !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;
      invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;
    }
  },

  /**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallback: function (name, func, context, a, b, c, d, e, f) {
    invokeGuardedCallback.apply(ReactErrorUtils, arguments);
  },

  /**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */
  invokeGuardedCallbackAndCatchFirstError: function (name, func, context, a, b, c, d, e, f) {
    ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);
    if (ReactErrorUtils.hasCaughtError()) {
      var error = ReactErrorUtils.clearCaughtError();
      if (!ReactErrorUtils._hasRethrowError) {
        ReactErrorUtils._hasRethrowError = true;
        ReactErrorUtils._rethrowError = error;
      }
    }
  },

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    return rethrowCaughtError.apply(ReactErrorUtils, arguments);
  },

  hasCaughtError: function () {
    return ReactErrorUtils._hasCaughtError;
  },

  clearCaughtError: function () {
    if (ReactErrorUtils._hasCaughtError) {
      var error = ReactErrorUtils._caughtError;
      ReactErrorUtils._caughtError = null;
      ReactErrorUtils._hasCaughtError = false;
      return error;
    } else {
      invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');
    }
  }
};

var invokeGuardedCallback = function (name, func, context, a, b, c, d, e, f) {
  ReactErrorUtils._hasCaughtError = false;
  ReactErrorUtils._caughtError = null;
  var funcArgs = Array.prototype.slice.call(arguments, 3);
  try {
    func.apply(context, funcArgs);
  } catch (error) {
    ReactErrorUtils._caughtError = error;
    ReactErrorUtils._hasCaughtError = true;
  }
};

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // untintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!

  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {
      // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.
      var didError = true;

      // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      function callCallback() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false);
        func.apply(context, funcArgs);
        didError = false;
      }

      // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.
      var error = void 0;
      // Use this to track whether the error event is ever called.
      var didSetError = false;
      var isCrossOriginError = false;

      function onError(event) {
        error = event.error;
        didSetError = true;
        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }
      }

      // Create a fake event type.
      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');

      // Attach our event handlers
      window.addEventListener('error', onError);
      fakeNode.addEventListener(evtType, callCallback, false);

      // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');
        }
        ReactErrorUtils._hasCaughtError = true;
        ReactErrorUtils._caughtError = error;
      } else {
        ReactErrorUtils._hasCaughtError = false;
        ReactErrorUtils._caughtError = null;
      }

      // Remove our event listeners
      window.removeEventListener('error', onError);
    };

    invokeGuardedCallback = invokeGuardedCallbackDev;
  }
}

var rethrowCaughtError = function () {
  if (ReactErrorUtils._hasRethrowError) {
    var error = ReactErrorUtils._rethrowError;
    ReactErrorUtils._rethrowError = null;
    ReactErrorUtils._hasRethrowError = false;
    throw error;
  }
};

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;
    if (plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;
    plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;
  eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;
  registrationNameModules[registrationName] = pluginModule;
  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */

/**
 * Ordered list of injected plugins.
 */
var plugins = [];

/**
 * Mapping from event name to dispatch config
 */
var eventNameDispatchConfigs = {};

/**
 * Mapping from registration name to plugin module
 */
var registrationNameModules = {};

/**
 * Mapping from registration name to event name
 */
var registrationNameDependencies = {};

/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */
var possibleRegistrationNames = {};
// Trust the developer to only use possibleRegistrationNames in true

/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */
function injectEventPluginOrder(injectedEventPluginOrder) {
  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;
  // Clone the ordering so it cannot be dynamically mutated.
  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
  recomputePluginOrdering();
}

/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */
function injectEventPluginsByName(injectedNamesToPlugins) {
  var isOrderingDirty = false;
  for (var pluginName in injectedNamesToPlugins) {
    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
      continue;
    }
    var pluginModule = injectedNamesToPlugins[pluginName];
    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;
      namesToPlugins[pluginName] = pluginModule;
      isOrderingDirty = true;
    }
  }
  if (isOrderingDirty) {
    recomputePluginOrdering();
  }
}

var EventPluginRegistry = Object.freeze({
	plugins: plugins,
	eventNameDispatchConfigs: eventNameDispatchConfigs,
	registrationNameModules: registrationNameModules,
	registrationNameDependencies: registrationNameDependencies,
	possibleRegistrationNames: possibleRegistrationNames,
	injectEventPluginOrder: injectEventPluginOrder,
	injectEventPluginsByName: injectEventPluginsByName
});

var getFiberCurrentPropsFromNode = null;
var getInstanceFromNode = null;
var getNodeFromInstance = null;

var injection$2 = {
  injectComponentTree: function (Injected) {
    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;
    getInstanceFromNode = Injected.getInstanceFromNode;
    getNodeFromInstance = Injected.getNodeFromInstance;

    {
      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');
    }
  }
};






var validateEventDispatches;
{
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = getNodeFromInstance(inst);
  ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */


/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */


/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */
function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */

/**
 * Methods for injecting dependencies.
 */
var injection$1 = {
  /**
   * @param {array} InjectedEventPluginOrder
   * @public
   */
  injectEventPluginOrder: injectEventPluginOrder,

  /**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */
  injectEventPluginsByName: injectEventPluginsByName
};

/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */
function getListener(inst, registrationName) {
  var listener;

  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
  // live here; needs to be moved to a better place soon
  var stateNode = inst.stateNode;
  if (!stateNode) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }
  var props = getFiberCurrentPropsFromNode(stateNode);
  if (!props) {
    // Work in progress.
    return null;
  }
  listener = props[registrationName];
  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }
  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;
  return listener;
}

/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */
function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events;
  for (var i = 0; i < plugins.length; i++) {
    // Not every plugin in the ordering may be loaded at runtime.
    var possiblePlugin = plugins[i];
    if (possiblePlugin) {
      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
      if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
      }
    }
  }
  return events;
}

/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */
function enqueueEvents(events) {
  if (events) {
    eventQueue = accumulateInto(eventQueue, events);
  }
}

/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */
function processEventQueue(simulated) {
  // Set `eventQueue` to null before processing it so that we can tell if more
  // events get enqueued while processing.
  var processingEventQueue = eventQueue;
  eventQueue = null;

  if (!processingEventQueue) {
    return;
  }

  if (simulated) {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
  } else {
    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
  }
  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;
  // This would be a good time to rethrow if any of the event handlers threw.
  ReactErrorUtils.rethrowCaughtError();
}

var EventPluginHub = Object.freeze({
	injection: injection$1,
	getListener: getListener,
	extractEvents: extractEvents,
	enqueueEvents: enqueueEvents,
	processEventQueue: processEventQueue
});

var IndeterminateComponent = 0; // Before we know whether it is functional or class
var FunctionalComponent = 1;
var ClassComponent = 2;
var HostRoot = 3; // Root of a host tree. Could be nested inside another node.
var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.
var HostComponent = 5;
var HostText = 6;
var CallComponent = 7;
var CallHandlerPhase = 8;
var ReturnComponent = 9;
var Fragment = 10;

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactInternalInstance$' + randomKey;
var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;

function precacheFiberNode$1(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest = void 0;
  var inst = node[internalInstanceKey];
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber, this will always be the deepest root.
    return inst;
  }
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode$1(node) {
  var inst = node[internalInstanceKey];
  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText) {
      return inst;
    } else {
      return null;
    }
  }
  return null;
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance$1(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  }

  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  invariant(false, 'getNodeFromInstance: Invalid argument.');
}

function getFiberCurrentPropsFromNode$1(node) {
  return node[internalEventHandlersKey] || null;
}

function updateFiberProps$1(node, props) {
  node[internalEventHandlersKey] = props;
}

var ReactDOMComponentTree = Object.freeze({
	precacheFiberNode: precacheFiberNode$1,
	getClosestInstanceFromNode: getClosestInstanceFromNode,
	getInstanceFromNode: getInstanceFromNode$1,
	getNodeFromInstance: getNodeFromInstance$1,
	getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode$1,
	updateFiberProps: updateFiberProps$1
});

function getParent(inst) {
  do {
    inst = inst['return'];
    // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);
  if (inst) {
    return inst;
  }
  return null;
}

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  var depthA = 0;
  for (var tempA = instA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = getParent(tempB)) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = getParent(instA);
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = getParent(instB);
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB || instA === instB.alternate) {
      return instA;
    }
    instA = getParent(instA);
    instB = getParent(instB);
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */


/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  return getParent(inst);
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = getParent(inst);
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (true) {
    if (!from) {
      break;
    }
    if (from === common) {
      break;
    }
    var alternate = from.alternate;
    if (alternate !== null && alternate === common) {
      break;
    }
    pathFrom.push(from);
    from = getParent(from);
  }
  var pathTo = [];
  while (true) {
    if (!to) {
      break;
    }
    if (to === common) {
      break;
    }
    var _alternate = to.alternate;
    if (_alternate !== null && _alternate === common) {
      break;
    }
    pathTo.push(to);
    to = getParent(to);
  }
  for (var i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (var _i = pathTo.length; _i-- > 0;) {
    fn(pathTo[_i], 'captured', argTo);
  }
}

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  {
    warning(inst, 'Dispatching inst must not be null');
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? getParentInstance(targetInst) : null;
    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (inst && event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

var EventPropagators = Object.freeze({
	accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches,
	accumulateDirectDispatches: accumulateDirectDispatches
});

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var compositionState = {
  _root: null,
  _startText: null,
  _fallbackText: null
};

function initialize(nativeEventTarget) {
  compositionState._root = nativeEventTarget;
  compositionState._startText = getText();
  return true;
}

function reset() {
  compositionState._root = null;
  compositionState._startText = null;
  compositionState._fallbackText = null;
}

function getData() {
  if (compositionState._fallbackText) {
    return compositionState._fallbackText;
  }

  var start;
  var startValue = compositionState._startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;
  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  compositionState._fallbackText = endValue.slice(start, sliceTail);
  return compositionState._fallbackText;
}

function getText() {
  if ('value' in compositionState._root) {
    return compositionState._root.value;
  }
  return compositionState._root[getTextContentAccessor()];
}

/* eslint valid-typeof: 0 */

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';
var EVENT_POOL_SIZE = 10;

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;
  addEventPoolingTo(Class);
};

/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */
{
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}

addEventPoolingTo(SyntheticEvent);

/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);
  }
}

function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {
  var EventConstructor = this;
  if (EventConstructor.eventPool.length) {
    var instance = EventConstructor.eventPool.pop();
    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);
    return instance;
  }
  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);
}

function releasePooledEvent(event) {
  var EventConstructor = this;
  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;
  event.destructor();
  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {
    EventConstructor.eventPool.push(event);
  }
}

function addEventPoolingTo(EventConstructor) {
  EventConstructor.eventPool = [];
  EventConstructor.getPooled = getPooledEvent;
  EventConstructor.release = releasePooledEvent;
}

var SyntheticEvent$1 = SyntheticEvent;

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticInputEvent, InputEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition status, if any.
var isComposing = false;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === eventTypes.compositionStart) {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

// Use to restore controlled state after a change event has fired.

var fiberHostComponent = null;

var ReactControlledComponentInjection = {
  injectFiberControlledHostComponent: function (hostComponentImpl) {
    // The fiber implementation doesn't use dynamic dispatch so we need to
    // inject the implementation.
    fiberHostComponent = hostComponentImpl;
  }
};

var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);
  if (!internalInstance) {
    // Unmounted
    return;
  }
  !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);
  fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);
}

var injection$3 = ReactControlledComponentInjection;

function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}

function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }
  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;

  restoreStateOfTarget(target);
  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

var ReactControlledComponent = Object.freeze({
	injection: injection$3,
	enqueueStateRestore: enqueueStateRestore,
	restoreStateIfNeeded: restoreStateIfNeeded
});

// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.

// Defaults
var fiberBatchedUpdates = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var isNestingBatched = false;
function batchedUpdates(fn, bookkeeping) {
  if (isNestingBatched) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state. Therefore, we add the target to
    // a queue of work.
    return fiberBatchedUpdates(fn, bookkeeping);
  }
  isNestingBatched = true;
  try {
    return fiberBatchedUpdates(fn, bookkeeping);
  } finally {
    // Here we wait until all updates have propagated, which is important
    // when using controlled components within layers:
    // https://github.com/facebook/react/issues/1698
    // Then we restore state of any controlled component.
    isNestingBatched = false;
    restoreStateIfNeeded();
  }
}

var ReactGenericBatchingInjection = {
  injectFiberBatchedUpdates: function (_batchedUpdates) {
    fiberBatchedUpdates = _batchedUpdates;
  }
};

var injection$4 = ReactGenericBatchingInjection;

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * HTML nodeType values that represent the type of the node
 */

var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';
  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

  var currentValue = '' + node[valueField];

  // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)
  if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable,
    configurable: true,
    get: function () {
      return descriptor.get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      descriptor.set.call(this, value);
    }
  });

  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  }

  // TODO: Once it's just Fiber we can move this to node._wrapperState
  node._valueTracker = trackValueOnNode(node);
}

function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node);
  // if there is no tracker at this point it's unlikely
  // that trying again will succeed
  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);
  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }
  return false;
}

var eventTypes$1 = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent$1.getPooled(eventTypes$1.change, inst, nativeEvent, target);
  event.type = 'change';
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  enqueueEvents(event);
  processEventQueue(false);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance$1(targetInst);
  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes$1,

  _isInputEventSupported: isInputEventSupported,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForChangeEvent;
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: null,
  detail: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticUIEvent, UIEventInterface);

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: null,
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

var eventTypes$2 = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes$2,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : getNodeFromInstance$1(from);
    var toNode = to == null ? win : getNodeFromInstance$1(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */

/**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */


function get(key) {
  return key._reactInternalFiber;
}

function has(key) {
  return key._reactInternalFiber !== undefined;
}

function set(key, value) {
  key._reactInternalFiber = value;
}

var ReactInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

var ReactCurrentOwner = ReactInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame = ReactInternals.ReactDebugCurrentFrame;

function getComponentName(fiber) {
  var type = fiber.type;

  if (typeof type === 'string') {
    return type;
  }
  if (typeof type === 'function') {
    return type.displayName || type.name;
  }
  return null;
}

// Don't change these two values:
var NoEffect = 0; //           0b00000000
var PerformedWork = 1; //      0b00000001

// You can change the rest (and add more).
var Placement = 2; //          0b00000010
var Update = 4; //             0b00000100
var PlacementAndUpdate = 6; // 0b00000110
var Deletion = 8; //           0b00001000
var ContentReset = 16; //      0b00010000
var Callback = 32; //          0b00100000
var Err = 64; //               0b01000000
var Ref = 128; //              0b10000000

var MOUNTING = 1;
var MOUNTED = 2;
var UNMOUNTED = 3;

function isFiberMountedImpl(fiber) {
  var node = fiber;
  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    if ((node.effectTag & Placement) !== NoEffect) {
      return MOUNTING;
    }
    while (node['return']) {
      node = node['return'];
      if ((node.effectTag & Placement) !== NoEffect) {
        return MOUNTING;
      }
    }
  } else {
    while (node['return']) {
      node = node['return'];
    }
  }
  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return MOUNTED;
  }
  // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.
  return UNMOUNTED;
}

function isFiberMounted(fiber) {
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;
    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;
      warning(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber) || 'A component');
      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);
  if (!fiber) {
    return false;
  }
  return isFiberMountedImpl(fiber) === MOUNTED;
}

function assertIsMounted(fiber) {
  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;
  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var state = isFiberMountedImpl(fiber);
    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
    if (state === MOUNTING) {
      return null;
    }
    return fiber;
  }
  // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.
  var a = fiber;
  var b = alternate;
  while (true) {
    var parentA = a['return'];
    var parentB = parentA ? parentA.alternate : null;
    if (!parentA || !parentB) {
      // We're at the root.
      break;
    }

    // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.
    if (parentA.child === parentB.child) {
      var child = parentA.child;
      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }
        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }
        child = child.sibling;
      }
      // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.
      invariant(false, 'Unable to find node on an unmounted component.');
    }

    if (a['return'] !== b['return']) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;
      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }
        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }
        _child = _child.sibling;
      }
      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;
        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }
          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }
          _child = _child.sibling;
        }
        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;
      }
    }

    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;
  }
  // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.
  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;
  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  }
  // Otherwise B has to be current branch.
  return alternate;
}

function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);
  if (!currentParent) {
    return null;
  }

  // Next we'll drill down this component to find the first HostComponent/Text.
  var node = currentParent;
  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child['return'] = node;
      node = node.child;
      continue;
    }
    if (node === currentParent) {
      return null;
    }
    while (!node.sibling) {
      if (!node['return'] || node['return'] === currentParent) {
        return null;
      }
      node = node['return'];
    }
    node.sibling['return'] = node['return'];
    node = node.sibling;
  }
  // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable
  return null;
}

var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;
var callbackBookkeepingPool = [];

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findRootContainerNode(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst['return']) {
    inst = inst['return'];
  }
  if (inst.tag !== HostRoot) {
    // This can happen if we're in a detached tree.
    return null;
  }
  return inst.stateNode.containerInfo;
}

// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {
  if (callbackBookkeepingPool.length) {
    var instance = callbackBookkeepingPool.pop();
    instance.topLevelType = topLevelType;
    instance.nativeEvent = nativeEvent;
    instance.targetInst = targetInst;
    return instance;
  }
  return {
    topLevelType: topLevelType,
    nativeEvent: nativeEvent,
    targetInst: targetInst,
    ancestors: []
  };
}

function releaseTopLevelCallbackBookKeeping(instance) {
  instance.topLevelType = null;
  instance.nativeEvent = null;
  instance.targetInst = null;
  instance.ancestors.length = 0;
  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {
    callbackBookkeepingPool.push(instance);
  }
}

function handleTopLevelImpl(bookKeeping) {
  var targetInst = bookKeeping.targetInst;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    if (!ancestor) {
      bookKeeping.ancestors.push(ancestor);
      break;
    }
    var root = findRootContainerNode(ancestor);
    if (!root) {
      break;
    }
    bookKeeping.ancestors.push(ancestor);
    ancestor = getClosestInstanceFromNode(root);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    _handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// TODO: can we stop exporting these?
var _enabled = true;
var _handleTopLevel = void 0;

function setHandleTopLevel(handleTopLevel) {
  _handleTopLevel = handleTopLevel;
}

function setEnabled(enabled) {
  _enabled = !!enabled;
}

function isEnabled() {
  return _enabled;
}

/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapBubbledEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.listen(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */
function trapCapturedEvent(topLevelType, handlerBaseName, element) {
  if (!element) {
    return null;
  }
  return EventListener.capture(element, handlerBaseName, dispatchEvent.bind(null, topLevelType));
}

function dispatchEvent(topLevelType, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);
  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {
    // If we get an event (ex: img onload) before committing that
    // component's mount, ignore it for now (that is, treat it as if it was an
    // event on a non-React tree). We might also consider queueing events and
    // dispatching them after the mount.
    targetInst = null;
  }

  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);

  try {
    // Event queue being processed in the same cycle allows
    // `preventDefault`.
    batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}

var ReactDOMEventListener = Object.freeze({
	get _enabled () { return _enabled; },
	get _handleTopLevel () { return _handleTopLevel; },
	setHandleTopLevel: setHandleTopLevel,
	setEnabled: setEnabled,
	isEnabled: isEnabled,
	trapBubbledEvent: trapBubbledEvent,
	trapCapturedEvent: trapCapturedEvent,
	dispatchEvent: dispatchEvent
});

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */
var topLevelTypes$1 = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCancel: 'cancel',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topClose: 'close',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoad: 'load',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topToggle: 'toggle',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

var BrowserEventConstants = {
  topLevelTypes: topLevelTypes$1
};

function runEventQueueInBatch(events) {
  enqueueEvents(events);
  processEventQueue(false);
}

/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */
function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
  runEventQueueInBatch(events);
}

var topLevelTypes = BrowserEventConstants.topLevelTypes;

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var reactTopListenersCounter = 0;

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */
function listenTo(registrationName, contentDocumentHandle) {
  var mountAt = contentDocumentHandle;
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];

  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      if (dependency === 'topScroll') {
        trapCapturedEvent('topScroll', 'scroll', mountAt);
      } else if (dependency === 'topFocus' || dependency === 'topBlur') {
        trapCapturedEvent('topFocus', 'focus', mountAt);
        trapCapturedEvent('topBlur', 'blur', mountAt);

        // to make sure blur and focus event listeners are only attached once
        isListening.topBlur = true;
        isListening.topFocus = true;
      } else if (dependency === 'topCancel') {
        if (isEventSupported('cancel', true)) {
          trapCapturedEvent('topCancel', 'cancel', mountAt);
        }
        isListening.topCancel = true;
      } else if (dependency === 'topClose') {
        if (isEventSupported('close', true)) {
          trapCapturedEvent('topClose', 'close', mountAt);
        }
        isListening.topClose = true;
      } else if (topLevelTypes.hasOwnProperty(dependency)) {
        trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);
      }

      isListening[dependency] = true;
    }
  }
}

function isListeningToAllDependencies(registrationName, mountAt) {
  var isListening = getListeningForDocument(mountAt);
  var dependencies = registrationNameDependencies[registrationName];
  for (var i = 0; i < dependencies.length; i++) {
    var dependency = dependencies[i];
    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
      return false;
    }
  }
  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */
function getOffsets(outerNode) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode$$1 = selection.focusNode,
      focusOffset = selection.focusOffset;

  // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode$$1.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset);
}

/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */
function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode$$1, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }
      if (node === focusNode$$1 && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      }
      // Moving from `node` to its first child `next`.
      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }
      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }
      if (parentNode === focusNode$$1 && ++indexWithinFocus === focusOffset) {
        end = length;
      }
      if ((next = node.nextSibling) !== null) {
        break;
      }
      node = parentNode;
      parentNode = node.parentNode;
    }

    // Moving from `node` to its next sibling `next`.
    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
}

function getSelectionInformation() {
  var focusedElem = getActiveElement();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null
  };
}

/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */
function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElement();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;
  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    }

    // Focusing a node can change the scroll position, which is undesirable
    var ancestors = [];
    var ancestor = priorFocusedElem;
    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    focusNode(priorFocusedElem);

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}

/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */
function getSelection$1(input) {
  var selection = void 0;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || { start: 0, end: 0 };
}

/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */
function setSelection(input, offsets) {
  var start = offsets.start,
      end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes$3 = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement$1);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent$1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement$1;

    accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes$3,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE ? nativeEventTarget : nativeEventTarget.ownerDocument;
    // Track whether all listeners exists for this plugin. If none exist, we do
    // not extract events. See #3639.
    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {
      return null;
    }

    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement$1 = targetNode;
          activeElementInst$1 = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement$1 = null;
        activeElementInst$1 = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  }
};

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent$1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes$4 = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes$4[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes = ['topAbort', 'topCancel', 'topCanPlay', 'topCanPlayThrough', 'topClose', 'topDurationChange', 'topEmptied', 'topEncrypted', 'topEnded', 'topError', 'topInput', 'topInvalid', 'topLoad', 'topLoadedData', 'topLoadedMetadata', 'topLoadStart', 'topPause', 'topPlay', 'topPlaying', 'topProgress', 'topRateChange', 'topReset', 'topSeeked', 'topSeeking', 'topStalled', 'topSubmit', 'topSuspend', 'topTimeUpdate', 'topToggle', 'topVolumeChange', 'topWaiting'];

var SimpleEventPlugin = {
  eventTypes: eventTypes$4,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
      default:
        {
          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {
            warning(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);
          }
        }
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent$1;
        break;
    }
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    accumulateTwoPhaseDispatches(event);
    return event;
  }
};

setHandleTopLevel(handleTopLevel);

/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */
injection$1.injectEventPluginOrder(DOMEventPluginOrder);
injection$2.injectComponentTree(ReactDOMComponentTree);

/**
 * Some important event plugins included by default (without having to require
 * them).
 */
injection$1.injectEventPluginsByName({
  SimpleEventPlugin: SimpleEventPlugin,
  EnterLeaveEventPlugin: EnterLeaveEventPlugin,
  ChangeEventPlugin: ChangeEventPlugin,
  SelectEventPlugin: SelectEventPlugin,
  BeforeInputEventPlugin: BeforeInputEventPlugin
});

var enableAsyncSubtreeAPI = true;
var enableAsyncSchedulingByDefaultInReactDOM = false;
// Exports ReactDOM.createRoot
var enableCreateRoot = false;
var enableUserTimingAPI = true;

// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler = true;
// Experimental noop mode (currently unused):
var enableNoopReconciler = false;
// Experimental persistent mode (CS):
var enablePersistentReconciler = false;

// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects = false;

// Only used in www builds.

var valueStack = [];

{
  var fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}



function pop(cursor, fiber) {
  if (index < 0) {
    {
      warning(false, 'Unexpected pop.');
    }
    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      warning(false, 'Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];

  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;

  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

function reset$1() {
  while (index > -1) {
    valueStack[index] = null;

    {
      fiberStack[index] = null;
    }

    index--;
  }
}

var describeComponentFrame = function (name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
};

function describeFiber(fiber) {
  switch (fiber.tag) {
    case IndeterminateComponent:
    case FunctionalComponent:
    case ClassComponent:
    case HostComponent:
      var owner = fiber._debugOwner;
      var source = fiber._debugSource;
      var name = getComponentName(fiber);
      var ownerName = null;
      if (owner) {
        ownerName = getComponentName(owner);
      }
      return describeComponentFrame(name, source, ownerName);
    default:
      return '';
  }
}

// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress) {
  var info = '';
  var node = workInProgress;
  do {
    info += describeFiber(node);
    // Otherwise this return pointer might point to the wrong tree:
    node = node['return'];
  } while (node);
  return info;
}

function getCurrentFiberOwnerName() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    var owner = fiber._debugOwner;
    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner);
    }
  }
  return null;
}

function getCurrentFiberStackAddendum() {
  {
    var fiber = ReactDebugCurrentFiber.current;
    if (fiber === null) {
      return null;
    }
    // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.
    return getStackAddendumByWorkInProgressFiber(fiber);
  }
  return null;
}

function resetCurrentFiber() {
  ReactDebugCurrentFrame.getCurrentStack = null;
  ReactDebugCurrentFiber.current = null;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentFiber(fiber) {
  ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum;
  ReactDebugCurrentFiber.current = fiber;
  ReactDebugCurrentFiber.phase = null;
}

function setCurrentPhase(phase) {
  ReactDebugCurrentFiber.phase = phase;
}

var ReactDebugCurrentFiber = {
  current: null,
  phase: null,
  resetCurrentFiber: resetCurrentFiber,
  setCurrentFiber: setCurrentFiber,
  setCurrentPhase: setCurrentPhase,
  getCurrentFiberOwnerName: getCurrentFiberOwnerName,
  getCurrentFiberStackAddendum: getCurrentFiberStackAddendum
};

// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji = '\u269B';
var warningEmoji = '\u26D4';
var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber = null;
// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase = null;
var currentPhaseFiber = null;
// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting = false;
var hasScheduledUpdateInCurrentCommit = false;
var hasScheduledUpdateInCurrentPhase = false;
var commitCountInCurrentWorkLoop = 0;
var effectCountInCurrentCommit = 0;
var isWaitingForCallback = false;
// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit = new Set();

var formatMarkName = function (markName) {
  return reactEmoji + ' ' + markName;
};

var formatLabel = function (label, warning$$1) {
  var prefix = warning$$1 ? warningEmoji + ' ' : reactEmoji + ' ';
  var suffix = warning$$1 ? ' Warning: ' + warning$$1 : '';
  return '' + prefix + label + suffix;
};

var beginMark = function (markName) {
  performance.mark(formatMarkName(markName));
};

var clearMark = function (markName) {
  performance.clearMarks(formatMarkName(markName));
};

var endMark = function (label, markName, warning$$1) {
  var formattedMarkName = formatMarkName(markName);
  var formattedLabel = formatLabel(label, warning$$1);
  try {
    performance.measure(formattedLabel, formattedMarkName);
  } catch (err) {}
  // If previous mark was missing for some reason, this will throw.
  // This could only happen if React crashed in an unexpected place earlier.
  // Don't pile on with more errors.

  // Clear marks immediately to avoid growing buffer.
  performance.clearMarks(formattedMarkName);
  performance.clearMeasures(formattedLabel);
};

var getFiberMarkName = function (label, debugID) {
  return label + ' (#' + debugID + ')';
};

var getFiberLabel = function (componentName, isMounted, phase) {
  if (phase === null) {
    // These are composite component total time measurements.
    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';
  } else {
    // Composite component methods.
    return componentName + '.' + phase;
  }
};

var beginFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);

  if (isCommitting && labelsInCurrentCommit.has(label)) {
    // During the commit phase, we don't show duplicate labels because
    // there is a fixed overhead for every measurement, and we don't
    // want to stretch the commit phase beyond necessary.
    return false;
  }
  labelsInCurrentCommit.add(label);

  var markName = getFiberMarkName(label, debugID);
  beginMark(markName);
  return true;
};

var clearFiberMark = function (fiber, phase) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  clearMark(markName);
};

var endFiberMark = function (fiber, phase, warning$$1) {
  var componentName = getComponentName(fiber) || 'Unknown';
  var debugID = fiber._debugID;
  var isMounted = fiber.alternate !== null;
  var label = getFiberLabel(componentName, isMounted, phase);
  var markName = getFiberMarkName(label, debugID);
  endMark(label, markName, warning$$1);
};

var shouldIgnoreFiber = function (fiber) {
  // Host components should be skipped in the timeline.
  // We could check typeof fiber.type, but does this work with RN?
  switch (fiber.tag) {
    case HostRoot:
    case HostComponent:
    case HostText:
    case HostPortal:
    case ReturnComponent:
    case Fragment:
      return true;
    default:
      return false;
  }
};

var clearPendingPhaseMeasurement = function () {
  if (currentPhase !== null && currentPhaseFiber !== null) {
    clearFiberMark(currentPhaseFiber, currentPhase);
  }
  currentPhaseFiber = null;
  currentPhase = null;
  hasScheduledUpdateInCurrentPhase = false;
};

var pauseTimers = function () {
  // Stops all currently active measurements so that they can be resumed
  // if we continue in a later deferred loop from the same unit of work.
  var fiber = currentFiber;
  while (fiber) {
    if (fiber._debugIsCurrentlyTiming) {
      endFiberMark(fiber, null, null);
    }
    fiber = fiber['return'];
  }
};

var resumeTimersRecursively = function (fiber) {
  if (fiber['return'] !== null) {
    resumeTimersRecursively(fiber['return']);
  }
  if (fiber._debugIsCurrentlyTiming) {
    beginFiberMark(fiber, null);
  }
};

var resumeTimers = function () {
  // Resumes all measurements that were active during the last deferred loop.
  if (currentFiber !== null) {
    resumeTimersRecursively(currentFiber);
  }
};

function recordEffect() {
  if (enableUserTimingAPI) {
    effectCountInCurrentCommit++;
  }
}

function recordScheduleUpdate() {
  if (enableUserTimingAPI) {
    if (isCommitting) {
      hasScheduledUpdateInCurrentCommit = true;
    }
    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {
      hasScheduledUpdateInCurrentPhase = true;
    }
  }
}

function startRequestCallbackTimer() {
  if (enableUserTimingAPI) {
    if (supportsUserTiming && !isWaitingForCallback) {
      isWaitingForCallback = true;
      beginMark('(Waiting for async callback...)');
    }
  }
}

function stopRequestCallbackTimer(didExpire) {
  if (enableUserTimingAPI) {
    if (supportsUserTiming) {
      isWaitingForCallback = false;
      var warning$$1 = didExpire ? 'React was blocked by main thread' : null;
      endMark('(Waiting for async callback...)', '(Waiting for async callback...)', warning$$1);
    }
  }
}

function startWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, this is the fiber to unwind from.
    currentFiber = fiber;
    if (!beginFiberMark(fiber, null)) {
      return;
    }
    fiber._debugIsCurrentlyTiming = true;
  }
}

function cancelWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // Remember we shouldn't complete measurement for this fiber.
    // Otherwise flamechart will be deep even for small updates.
    fiber._debugIsCurrentlyTiming = false;
    clearFiberMark(fiber, null);
  }
}

function stopWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    endFiberMark(fiber, null, null);
  }
}

function stopFailedWorkTimer(fiber) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {
      return;
    }
    // If we pause, its parent is the fiber to unwind from.
    currentFiber = fiber['return'];
    if (!fiber._debugIsCurrentlyTiming) {
      return;
    }
    fiber._debugIsCurrentlyTiming = false;
    var warning$$1 = 'An error was thrown inside this error boundary';
    endFiberMark(fiber, null, warning$$1);
  }
}

function startPhaseTimer(fiber, phase) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    clearPendingPhaseMeasurement();
    if (!beginFiberMark(fiber, phase)) {
      return;
    }
    currentPhaseFiber = fiber;
    currentPhase = phase;
  }
}

function stopPhaseTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    if (currentPhase !== null && currentPhaseFiber !== null) {
      var warning$$1 = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;
      endFiberMark(currentPhaseFiber, currentPhase, warning$$1);
    }
    currentPhase = null;
    currentPhaseFiber = null;
  }
}

function startWorkLoopTimer(nextUnitOfWork) {
  if (enableUserTimingAPI) {
    currentFiber = nextUnitOfWork;
    if (!supportsUserTiming) {
      return;
    }
    commitCountInCurrentWorkLoop = 0;
    // This is top level call.
    // Any other measurements are performed within.
    beginMark('(React Tree Reconciliation)');
    // Resume any measurements that were in progress during the last loop.
    resumeTimers();
  }
}

function stopWorkLoopTimer(interruptedBy) {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var warning$$1 = null;
    if (interruptedBy !== null) {
      if (interruptedBy.tag === HostRoot) {
        warning$$1 = 'A top-level update interrupted the previous render';
      } else {
        var componentName = getComponentName(interruptedBy) || 'Unknown';
        warning$$1 = 'An update to ' + componentName + ' interrupted the previous render';
      }
    } else if (commitCountInCurrentWorkLoop > 1) {
      warning$$1 = 'There were cascading updates';
    }
    commitCountInCurrentWorkLoop = 0;
    // Pause any measurements until the next loop.
    pauseTimers();
    endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning$$1);
  }
}

function startCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    isCommitting = true;
    hasScheduledUpdateInCurrentCommit = false;
    labelsInCurrentCommit.clear();
    beginMark('(Committing Changes)');
  }
}

function stopCommitTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }

    var warning$$1 = null;
    if (hasScheduledUpdateInCurrentCommit) {
      warning$$1 = 'Lifecycle hook scheduled a cascading update';
    } else if (commitCountInCurrentWorkLoop > 0) {
      warning$$1 = 'Caused by a cascading update in earlier commit';
    }
    hasScheduledUpdateInCurrentCommit = false;
    commitCountInCurrentWorkLoop++;
    isCommitting = false;
    labelsInCurrentCommit.clear();

    endMark('(Committing Changes)', '(Committing Changes)', warning$$1);
  }
}

function startCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Committing Host Effects)');
  }
}

function stopCommitHostEffectsTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);
  }
}

function startCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    effectCountInCurrentCommit = 0;
    beginMark('(Calling Lifecycle Methods)');
  }
}

function stopCommitLifeCyclesTimer() {
  if (enableUserTimingAPI) {
    if (!supportsUserTiming) {
      return;
    }
    var count = effectCountInCurrentCommit;
    effectCountInCurrentCommit = 0;
    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);
  }
}

{
  var warnedAboutMissingGetChildContext = {};
}

// A cursor to the current merged context object on the stack.
var contextStackCursor = createCursor(emptyObject);
// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor = createCursor(false);
// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext = emptyObject;

function getUnmaskedContext(workInProgress) {
  var hasOwnContext = isContextProvider(workInProgress);
  if (hasOwnContext) {
    // If the fiber is a context provider itself, when we read its context
    // we have already pushed its own child context on the stack. A context
    // provider should not "see" its own child context. Therefore we read the
    // previous (parent) context instead for a context provider.
    return previousContext;
  }
  return contextStackCursor.current;
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  var instance = workInProgress.stateNode;
  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
}

function getMaskedContext(workInProgress, unmaskedContext) {
  var type = workInProgress.type;
  var contextTypes = type.contextTypes;
  if (!contextTypes) {
    return emptyObject;
  }

  // Avoid recreating masked context unless unmasked context has changed.
  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
  // This may trigger infinite loops if componentWillReceiveProps calls setState.
  var instance = workInProgress.stateNode;
  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
    return instance.__reactInternalMemoizedMaskedChildContext;
  }

  var context = {};
  for (var key in contextTypes) {
    context[key] = unmaskedContext[key];
  }

  {
    var name = getComponentName(workInProgress) || 'Unknown';
    checkPropTypes(contextTypes, context, 'context', name, ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // Context is created before the class component is instantiated so check for instance.
  if (instance) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return context;
}

function hasContextChanged() {
  return didPerformWorkStackCursor.current;
}

function isContextConsumer(fiber) {
  return fiber.tag === ClassComponent && fiber.type.contextTypes != null;
}

function isContextProvider(fiber) {
  return fiber.tag === ClassComponent && fiber.type.childContextTypes != null;
}

function popContextProvider(fiber) {
  if (!isContextProvider(fiber)) {
    return;
  }

  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function popTopLevelContextObject(fiber) {
  pop(didPerformWorkStackCursor, fiber);
  pop(contextStackCursor, fiber);
}

function pushTopLevelContextObject(fiber, context, didChange) {
  !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  push(contextStackCursor, context, fiber);
  push(didPerformWorkStackCursor, didChange, fiber);
}

function processChildContext(fiber, parentContext) {
  var instance = fiber.stateNode;
  var childContextTypes = fiber.type.childContextTypes;

  // TODO (bvaughn) Replace this behavior with an invariant() in the future.
  // It has only been added in Fiber to match the (unintentional) behavior in Stack.
  if (typeof instance.getChildContext !== 'function') {
    {
      var componentName = getComponentName(fiber) || 'Unknown';

      if (!warnedAboutMissingGetChildContext[componentName]) {
        warnedAboutMissingGetChildContext[componentName] = true;
        warning(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
      }
    }
    return parentContext;
  }

  var childContext = void 0;
  {
    ReactDebugCurrentFiber.setCurrentPhase('getChildContext');
  }
  startPhaseTimer(fiber, 'getChildContext');
  childContext = instance.getChildContext();
  stopPhaseTimer();
  {
    ReactDebugCurrentFiber.setCurrentPhase(null);
  }
  for (var contextKey in childContext) {
    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', getComponentName(fiber) || 'Unknown', contextKey) : void 0;
  }
  {
    var name = getComponentName(fiber) || 'Unknown';
    checkPropTypes(childContextTypes, childContext, 'child context', name,
    // In practice, there is one case in which we won't get a stack. It's when
    // somebody calls unstable_renderSubtreeIntoContainer() and we process
    // context from the parent component instance. The stack will be missing
    // because it's outside of the reconciliation, and so the pointer has not
    // been set. This is rare and doesn't matter. We'll also remove that API.
    ReactDebugCurrentFiber.getCurrentFiberStackAddendum);
  }

  return _assign({}, parentContext, childContext);
}

function pushContextProvider(workInProgress) {
  if (!isContextProvider(workInProgress)) {
    return false;
  }

  var instance = workInProgress.stateNode;
  // We push the context as early as possible to ensure stack integrity.
  // If the instance does not exist yet, we will push null at first,
  // and replace it on the stack later when invalidating the context.
  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject;

  // Remember the parent context so we can merge with it later.
  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
  previousContext = contextStackCursor.current;
  push(contextStackCursor, memoizedMergedChildContext, workInProgress);
  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);

  return true;
}

function invalidateContextProvider(workInProgress, didChange) {
  var instance = workInProgress.stateNode;
  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  if (didChange) {
    // Merge parent and own context.
    // Skip this if we're not updating due to sCU.
    // This avoids unnecessarily recomputing memoized values.
    var mergedContext = processChildContext(workInProgress, previousContext);
    instance.__reactInternalMemoizedMergedChildContext = mergedContext;

    // Replace the old (or empty) context with the new one.
    // It is important to unwind the context in the reverse order.
    pop(didPerformWorkStackCursor, workInProgress);
    pop(contextStackCursor, workInProgress);
    // Now push the new context and mark that it has changed.
    push(contextStackCursor, mergedContext, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  } else {
    pop(didPerformWorkStackCursor, workInProgress);
    push(didPerformWorkStackCursor, didChange, workInProgress);
  }
}

function resetContext() {
  previousContext = emptyObject;
  contextStackCursor.current = emptyObject;
  didPerformWorkStackCursor.current = false;
}

function findCurrentUnmaskedContext(fiber) {
  // Currently this is only used with renderSubtreeIntoContainer; not sure if it
  // makes sense elsewhere
  !(isFiberMounted(fiber) && fiber.tag === ClassComponent) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;

  var node = fiber;
  while (node.tag !== HostRoot) {
    if (isContextProvider(node)) {
      return node.stateNode.__reactInternalMemoizedMergedChildContext;
    }
    var parent = node['return'];
    !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    node = parent;
  }
  return node.stateNode.context;
}

var NoWork = 0; // TODO: Use an opaque type once ESLint et al support the syntax

var Sync = 1;
var Never = 2147483647; // Max int32: Math.pow(2, 31) - 1

var UNIT_SIZE = 10;
var MAGIC_NUMBER_OFFSET = 2;

// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms) {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;
}

function expirationTimeToMs(expirationTime) {
  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
}

function ceiling(num, precision) {
  return ((num / precision | 0) + 1) * precision;
}

function computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {
  return ceiling(currentTime + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);
}

var NoContext = 0;
var AsyncUpdates = 1;

{
  var hasBadMapPolyfill = false;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */
    
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.


{
  var debugCounter = 1;
}

function FiberNode(tag, key, internalContextTag) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.type = null;
  this.stateNode = null;

  // Fiber
  this['return'] = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;

  this.ref = null;

  this.pendingProps = null;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;

  this.internalContextTag = internalContextTag;

  // Effects
  this.effectTag = NoEffect;
  this.nextEffect = null;

  this.firstEffect = null;
  this.lastEffect = null;

  this.expirationTime = NoWork;

  this.alternate = null;

  {
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugIsCurrentlyTiming = false;
    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
}

// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber = function (tag, key, internalContextTag) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, key, internalContextTag);
};

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps, expirationTime) {
  var workInProgress = current.alternate;
  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, current.key, current.internalContextTag);
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.effectTag = NoEffect;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;
  }

  workInProgress.expirationTime = expirationTime;
  workInProgress.pendingProps = pendingProps;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  return workInProgress;
}

function createHostRootFiber() {
  var fiber = createFiber(HostRoot, null, NoContext);
  return fiber;
}

function createFiberFromElement(element, internalContextTag, expirationTime) {
  var owner = null;
  {
    owner = element._owner;
  }

  var fiber = void 0;
  var type = element.type,
      key = element.key;

  if (typeof type === 'function') {
    fiber = shouldConstruct(type) ? createFiber(ClassComponent, key, internalContextTag) : createFiber(IndeterminateComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'string') {
    fiber = createFiber(HostComponent, key, internalContextTag);
    fiber.type = type;
    fiber.pendingProps = element.props;
  } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {
    // Currently assumed to be a continuation and therefore is a fiber already.
    // TODO: The yield system is currently broken for updates in some cases.
    // The reified yield stores a fiber, but we don't know which fiber that is;
    // the current or a workInProgress? When the continuation gets rendered here
    // we don't know if we can reuse that fiber or if we need to clone it.
    // There is probably a clever way to restructure this.
    fiber = type;
    fiber.pendingProps = element.props;
  } else {
    var info = '';
    {
      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }
      var ownerName = owner ? getComponentName(owner) : null;
      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }
    }
    invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);
  }

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  fiber.expirationTime = expirationTime;

  return fiber;
}

function createFiberFromFragment(elements, internalContextTag, expirationTime, key) {
  var fiber = createFiber(Fragment, key, internalContextTag);
  fiber.pendingProps = elements;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromText(content, internalContextTag, expirationTime) {
  var fiber = createFiber(HostText, null, internalContextTag);
  fiber.pendingProps = content;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, NoContext);
  fiber.type = 'DELETED';
  return fiber;
}

function createFiberFromCall(call, internalContextTag, expirationTime) {
  var fiber = createFiber(CallComponent, call.key, internalContextTag);
  fiber.type = call.handler;
  fiber.pendingProps = call;
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromReturn(returnNode, internalContextTag, expirationTime) {
  var fiber = createFiber(ReturnComponent, null, internalContextTag);
  fiber.expirationTime = expirationTime;
  return fiber;
}

function createFiberFromPortal(portal, internalContextTag, expirationTime) {
  var fiber = createFiber(HostPortal, portal.key, internalContextTag);
  fiber.pendingProps = portal.children || [];
  fiber.expirationTime = expirationTime;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null, // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
}

function createFiberRoot(containerInfo, hydrate) {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  var uninitializedFiber = createHostRootFiber();
  var root = {
    current: uninitializedFiber,
    containerInfo: containerInfo,
    pendingChildren: null,
    remainingExpirationTime: NoWork,
    isReadyForCommit: false,
    finishedWork: null,
    context: null,
    pendingContext: null,
    hydrate: hydrate,
    nextScheduledRoot: null
  };
  uninitializedFiber.stateNode = root;
  return root;
}

var onCommitFiberRoot = null;
var onCommitFiberUnmount = null;
var hasLoggedError = false;

function catchErrors(fn) {
  return function (arg) {
    try {
      return fn(arg);
    } catch (err) {
      if (true && !hasLoggedError) {
        hasLoggedError = true;
        warning(false, 'React DevTools encountered an error: %s', err);
      }
    }
  };
}

function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }
  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }
  if (!hook.supportsFiber) {
    {
      warning(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');
    }
    // DevTools exists, even though it doesn't support Fiber.
    return true;
  }
  try {
    var rendererID = hook.inject(internals);
    // We have successfully injected, so now it is safe to set up hooks.
    onCommitFiberRoot = catchErrors(function (root) {
      return hook.onCommitFiberRoot(rendererID, root);
    });
    onCommitFiberUnmount = catchErrors(function (fiber) {
      return hook.onCommitFiberUnmount(rendererID, fiber);
    });
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      warning(false, 'React DevTools encountered an error: %s.', err);
    }
  }
  // DevTools exists
  return true;
}

function onCommitRoot(root) {
  if (typeof onCommitFiberRoot === 'function') {
    onCommitFiberRoot(root);
  }
}

function onCommitUnmount(fiber) {
  if (typeof onCommitFiberUnmount === 'function') {
    onCommitFiberUnmount(fiber);
  }
}

{
  var didWarnUpdateInsideUpdate = false;
}

// Callbacks are not validated until invocation


// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.


function createUpdateQueue(baseState) {
  var queue = {
    baseState: baseState,
    expirationTime: NoWork,
    first: null,
    last: null,
    callbackList: null,
    hasForceUpdate: false,
    isInitialized: false
  };
  {
    queue.isProcessing = false;
  }
  return queue;
}

function insertUpdateIntoQueue(queue, update) {
  // Append the update to the end of the list.
  if (queue.last === null) {
    // Queue is empty
    queue.first = queue.last = update;
  } else {
    queue.last.next = update;
    queue.last = update;
  }
  if (queue.expirationTime === NoWork || queue.expirationTime > update.expirationTime) {
    queue.expirationTime = update.expirationTime;
  }
}

function insertUpdateIntoFiber(fiber, update) {
  // We'll have at least one and at most two distinct update queues.
  var alternateFiber = fiber.alternate;
  var queue1 = fiber.updateQueue;
  if (queue1 === null) {
    // TODO: We don't know what the base state will be until we begin work.
    // It depends on which fiber is the next current. Initialize with an empty
    // base state, then set to the memoizedState when rendering. Not super
    // happy with this approach.
    queue1 = fiber.updateQueue = createUpdateQueue(null);
  }

  var queue2 = void 0;
  if (alternateFiber !== null) {
    queue2 = alternateFiber.updateQueue;
    if (queue2 === null) {
      queue2 = alternateFiber.updateQueue = createUpdateQueue(null);
    }
  } else {
    queue2 = null;
  }
  queue2 = queue2 !== queue1 ? queue2 : null;

  // Warn if an update is scheduled from inside an updater function.
  {
    if ((queue1.isProcessing || queue2 !== null && queue2.isProcessing) && !didWarnUpdateInsideUpdate) {
      warning(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');
      didWarnUpdateInsideUpdate = true;
    }
  }

  // If there's only one queue, add the update to that queue and exit.
  if (queue2 === null) {
    insertUpdateIntoQueue(queue1, update);
    return;
  }

  // If either queue is empty, we need to add to both queues.
  if (queue1.last === null || queue2.last === null) {
    insertUpdateIntoQueue(queue1, update);
    insertUpdateIntoQueue(queue2, update);
    return;
  }

  // If both lists are not empty, the last update is the same for both lists
  // because of structural sharing. So, we should only append to one of
  // the lists.
  insertUpdateIntoQueue(queue1, update);
  // But we still need to update the `last` pointer of queue2.
  queue2.last = update;
}

function getUpdateExpirationTime(fiber) {
  if (fiber.tag !== ClassComponent && fiber.tag !== HostRoot) {
    return NoWork;
  }
  var updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return NoWork;
  }
  return updateQueue.expirationTime;
}

function getStateFromUpdate(update, instance, prevState, props) {
  var partialState = update.partialState;
  if (typeof partialState === 'function') {
    var updateFn = partialState;

    // Invoke setState callback an extra time to help detect side-effects.
    if (debugRenderPhaseSideEffects) {
      updateFn.call(instance, prevState, props);
    }

    return updateFn.call(instance, prevState, props);
  } else {
    return partialState;
  }
}

function processUpdateQueue(current, workInProgress, queue, instance, props, renderExpirationTime) {
  if (current !== null && current.updateQueue === queue) {
    // We need to create a work-in-progress queue, by cloning the current queue.
    var currentQueue = queue;
    queue = workInProgress.updateQueue = {
      baseState: currentQueue.baseState,
      expirationTime: currentQueue.expirationTime,
      first: currentQueue.first,
      last: currentQueue.last,
      isInitialized: currentQueue.isInitialized,
      // These fields are no longer valid because they were already committed.
      // Reset them.
      callbackList: null,
      hasForceUpdate: false
    };
  }

  {
    // Set this flag so we can warn if setState is called inside the update
    // function of another setState.
    queue.isProcessing = true;
  }

  // Reset the remaining expiration time. If we skip over any updates, we'll
  // increase this accordingly.
  queue.expirationTime = NoWork;

  // TODO: We don't know what the base state will be until we begin work.
  // It depends on which fiber is the next current. Initialize with an empty
  // base state, then set to the memoizedState when rendering. Not super
  // happy with this approach.
  var state = void 0;
  if (queue.isInitialized) {
    state = queue.baseState;
  } else {
    state = queue.baseState = workInProgress.memoizedState;
    queue.isInitialized = true;
  }
  var dontMutatePrevState = true;
  var update = queue.first;
  var didSkip = false;
  while (update !== null) {
    var updateExpirationTime = update.expirationTime;
    if (updateExpirationTime > renderExpirationTime) {
      // This update does not have sufficient priority. Skip it.
      var remainingExpirationTime = queue.expirationTime;
      if (remainingExpirationTime === NoWork || remainingExpirationTime > updateExpirationTime) {
        // Update the remaining expiration time.
        queue.expirationTime = updateExpirationTime;
      }
      if (!didSkip) {
        didSkip = true;
        queue.baseState = state;
      }
      // Continue to the next update.
      update = update.next;
      continue;
    }

    // This update does have sufficient priority.

    // If no previous updates were skipped, drop this update from the queue by
    // advancing the head of the list.
    if (!didSkip) {
      queue.first = update.next;
      if (queue.first === null) {
        queue.last = null;
      }
    }

    // Process the update
    var _partialState = void 0;
    if (update.isReplace) {
      state = getStateFromUpdate(update, instance, state, props);
      dontMutatePrevState = true;
    } else {
      _partialState = getStateFromUpdate(update, instance, state, props);
      if (_partialState) {
        if (dontMutatePrevState) {
          // $FlowFixMe: Idk how to type this properly.
          state = _assign({}, state, _partialState);
        } else {
          state = _assign(state, _partialState);
        }
        dontMutatePrevState = false;
      }
    }
    if (update.isForced) {
      queue.hasForceUpdate = true;
    }
    if (update.callback !== null) {
      // Append to list of callbacks.
      var _callbackList = queue.callbackList;
      if (_callbackList === null) {
        _callbackList = queue.callbackList = [];
      }
      _callbackList.push(update);
    }
    update = update.next;
  }

  if (queue.callbackList !== null) {
    workInProgress.effectTag |= Callback;
  } else if (queue.first === null && !queue.hasForceUpdate) {
    // The queue is empty. We can reset it.
    workInProgress.updateQueue = null;
  }

  if (!didSkip) {
    didSkip = true;
    queue.baseState = state;
  }

  {
    // No longer processing.
    queue.isProcessing = false;
  }

  return state;
}

function commitCallbacks(queue, context) {
  var callbackList = queue.callbackList;
  if (callbackList === null) {
    return;
  }
  // Set the list to null to make sure they don't get called more than once.
  queue.callbackList = null;
  for (var i = 0; i < callbackList.length; i++) {
    var update = callbackList[i];
    var _callback = update.callback;
    // This update might be processed again. Clear the callback so it's only
    // called once.
    update.callback = null;
    !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;
    _callback.call(context);
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray;

{
  var didWarnAboutStateAssignmentForComponent = {};

  var warnOnInvalidCallback = function (callback, callerName) {
    warning(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
  };

  // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.
  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');
    }
  });
  Object.freeze(fakeInternalInstance);
}

var ReactFiberClassComponent = function (scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState) {
  // Class component state updater
  var updater = {
    isMounted: isMounted,
    enqueueSetState: function (instance, partialState, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'setState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: partialState,
        callback: callback,
        isReplace: false,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueReplaceState: function (instance, state, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: state,
        callback: callback,
        isReplace: true,
        isForced: false,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    },
    enqueueForceUpdate: function (instance, callback) {
      var fiber = get(instance);
      callback = callback === undefined ? null : callback;
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }
      var expirationTime = computeExpirationForFiber(fiber);
      var update = {
        expirationTime: expirationTime,
        partialState: null,
        callback: callback,
        isReplace: false,
        isForced: true,
        nextCallback: null,
        next: null
      };
      insertUpdateIntoFiber(fiber, update);
      scheduleWork(fiber, expirationTime);
    }
  };

  function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {
    if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {
      // If the workInProgress already has an Update effect, return true
      return true;
    }

    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    if (typeof instance.shouldComponentUpdate === 'function') {
      startPhaseTimer(workInProgress, 'shouldComponentUpdate');
      var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);
      stopPhaseTimer();

      // Simulate an async bailout/interruption by invoking lifecycle twice.
      if (debugRenderPhaseSideEffects) {
        instance.shouldComponentUpdate(newProps, newState, newContext);
      }

      {
        warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(workInProgress) || 'Unknown');
      }

      return shouldUpdate;
    }

    if (type.prototype && type.prototype.isPureReactComponent) {
      return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
    }

    return true;
  }

  function checkClassInstance(workInProgress) {
    var instance = workInProgress.stateNode;
    var type = workInProgress.type;
    {
      var name = getComponentName(workInProgress);
      var renderPresent = instance.render;

      if (!renderPresent) {
        if (type.prototype && typeof type.prototype.render === 'function') {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
        } else {
          warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
        }
      }

      var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;
      warning(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
      var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;
      warning(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
      var noInstancePropTypes = !instance.propTypes;
      warning(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
      var noInstanceContextTypes = !instance.contextTypes;
      warning(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';
      warning(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
      if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
        warning(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(workInProgress) || 'A pure component');
      }
      var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';
      warning(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
      var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';
      warning(noComponentDidReceiveProps, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
      var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';
      warning(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
      var hasMutatedProps = instance.props !== workInProgress.pendingProps;
      warning(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
      var noInstanceDefaultProps = !instance.defaultProps;
      warning(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    var state = instance.state;
    if (state && (typeof state !== 'object' || isArray(state))) {
      warning(false, '%s.state: must be set to an object or null', getComponentName(workInProgress));
    }
    if (typeof instance.getChildContext === 'function') {
      warning(typeof workInProgress.type.childContextTypes === 'object', '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', getComponentName(workInProgress));
    }
  }

  function resetInputPointers(workInProgress, instance) {
    instance.props = workInProgress.memoizedProps;
    instance.state = workInProgress.memoizedState;
  }

  function adoptClassInstance(workInProgress, instance) {
    instance.updater = updater;
    workInProgress.stateNode = instance;
    // The instance needs access to the fiber so that it can schedule updates
    set(instance, workInProgress);
    {
      instance._reactInternalInstance = fakeInternalInstance;
    }
  }

  function constructClassInstance(workInProgress, props) {
    var ctor = workInProgress.type;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var needsContext = isContextConsumer(workInProgress);
    var context = needsContext ? getMaskedContext(workInProgress, unmaskedContext) : emptyObject;
    var instance = new ctor(props, context);
    adoptClassInstance(workInProgress, instance);

    // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // ReactFiberContext usually updates this cache but can't for newly-created instances.
    if (needsContext) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return instance;
  }

  function callComponentWillMount(workInProgress, instance) {
    startPhaseTimer(workInProgress, 'componentWillMount');
    var oldState = instance.state;
    instance.componentWillMount();
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillMount();
    }

    if (oldState !== instance.state) {
      {
        warning(false, '%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress));
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {
    startPhaseTimer(workInProgress, 'componentWillReceiveProps');
    var oldState = instance.state;
    instance.componentWillReceiveProps(newProps, newContext);
    stopPhaseTimer();

    // Simulate an async bailout/interruption by invoking lifecycle twice.
    if (debugRenderPhaseSideEffects) {
      instance.componentWillReceiveProps(newProps, newContext);
    }

    if (instance.state !== oldState) {
      {
        var componentName = getComponentName(workInProgress) || 'Component';
        if (!didWarnAboutStateAssignmentForComponent[componentName]) {
          warning(false, '%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
          didWarnAboutStateAssignmentForComponent[componentName] = true;
        }
      }
      updater.enqueueReplaceState(instance, instance.state, null);
    }
  }

  // Invokes the mount life-cycles on a previously never rendered instance.
  function mountClassInstance(workInProgress, renderExpirationTime) {
    var current = workInProgress.alternate;

    {
      checkClassInstance(workInProgress);
    }

    var instance = workInProgress.stateNode;
    var state = instance.state || null;

    var props = workInProgress.pendingProps;
    !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    var unmaskedContext = getUnmaskedContext(workInProgress);

    instance.props = props;
    instance.state = workInProgress.memoizedState = state;
    instance.refs = emptyObject;
    instance.context = getMaskedContext(workInProgress, unmaskedContext);

    if (enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {
      workInProgress.internalContextTag |= AsyncUpdates;
    }

    if (typeof instance.componentWillMount === 'function') {
      callComponentWillMount(workInProgress, instance);
      // If we had additional state updates during this life-cycle, let's
      // process them now.
      var updateQueue = workInProgress.updateQueue;
      if (updateQueue !== null) {
        instance.state = processUpdateQueue(current, workInProgress, updateQueue, instance, props, renderExpirationTime);
      }
    }
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.effectTag |= Update;
    }
  }

  // Called on a preexisting class instance. Returns false if a resumed render
  // could be reused.
  // function resumeMountClassInstance(
  //   workInProgress: Fiber,
  //   priorityLevel: PriorityLevel,
  // ): boolean {
  //   const instance = workInProgress.stateNode;
  //   resetInputPointers(workInProgress, instance);

  //   let newState = workInProgress.memoizedState;
  //   let newProps = workInProgress.pendingProps;
  //   if (!newProps) {
  //     // If there isn't any new props, then we'll reuse the memoized props.
  //     // This could be from already completed work.
  //     newProps = workInProgress.memoizedProps;
  //     invariant(
  //       newProps != null,
  //       'There should always be pending or memoized props. This error is ' +
  //         'likely caused by a bug in React. Please file an issue.',
  //     );
  //   }
  //   const newUnmaskedContext = getUnmaskedContext(workInProgress);
  //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);

  //   const oldContext = instance.context;
  //   const oldProps = workInProgress.memoizedProps;

  //   if (
  //     typeof instance.componentWillReceiveProps === 'function' &&
  //     (oldProps !== newProps || oldContext !== newContext)
  //   ) {
  //     callComponentWillReceiveProps(
  //       workInProgress,
  //       instance,
  //       newProps,
  //       newContext,
  //     );
  //   }

  //   // Process the update queue before calling shouldComponentUpdate
  //   const updateQueue = workInProgress.updateQueue;
  //   if (updateQueue !== null) {
  //     newState = processUpdateQueue(
  //       workInProgress,
  //       updateQueue,
  //       instance,
  //       newState,
  //       newProps,
  //       priorityLevel,
  //     );
  //   }

  //   // TODO: Should we deal with a setState that happened after the last
  //   // componentWillMount and before this componentWillMount? Probably
  //   // unsupported anyway.

  //   if (
  //     !checkShouldComponentUpdate(
  //       workInProgress,
  //       workInProgress.memoizedProps,
  //       newProps,
  //       workInProgress.memoizedState,
  //       newState,
  //       newContext,
  //     )
  //   ) {
  //     // Update the existing instance's state, props, and context pointers even
  //     // though we're bailing out.
  //     instance.props = newProps;
  //     instance.state = newState;
  //     instance.context = newContext;
  //     return false;
  //   }

  //   // Update the input pointers now so that they are correct when we call
  //   // componentWillMount
  //   instance.props = newProps;
  //   instance.state = newState;
  //   instance.context = newContext;

  //   if (typeof instance.componentWillMount === 'function') {
  //     callComponentWillMount(workInProgress, instance);
  //     // componentWillMount may have called setState. Process the update queue.
  //     const newUpdateQueue = workInProgress.updateQueue;
  //     if (newUpdateQueue !== null) {
  //       newState = processUpdateQueue(
  //         workInProgress,
  //         newUpdateQueue,
  //         instance,
  //         newState,
  //         newProps,
  //         priorityLevel,
  //       );
  //     }
  //   }

  //   if (typeof instance.componentDidMount === 'function') {
  //     workInProgress.effectTag |= Update;
  //   }

  //   instance.state = newState;

  //   return true;
  // }

  // Invokes the update life-cycles and returns false if it shouldn't rerender.
  function updateClassInstance(current, workInProgress, renderExpirationTime) {
    var instance = workInProgress.stateNode;
    resetInputPointers(workInProgress, instance);

    var oldProps = workInProgress.memoizedProps;
    var newProps = workInProgress.pendingProps;
    if (!newProps) {
      // If there aren't any new props, then we'll reuse the memoized props.
      // This could be from already completed work.
      newProps = oldProps;
      !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var oldContext = instance.context;
    var newUnmaskedContext = getUnmaskedContext(workInProgress);
    var newContext = getMaskedContext(workInProgress, newUnmaskedContext);

    // Note: During these life-cycles, instance.props/instance.state are what
    // ever the previously attempted to render - not the "current". However,
    // during componentDidUpdate we pass the "current" props.

    if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);
    }

    // Compute the next state using the memoized state and the update queue.
    var oldState = workInProgress.memoizedState;
    // TODO: Previous state can be null.
    var newState = void 0;
    if (workInProgress.updateQueue !== null) {
      newState = processUpdateQueue(current, workInProgress, workInProgress.updateQueue, instance, newProps, renderExpirationTime);
    } else {
      newState = oldState;
    }

    if (oldProps === newProps && oldState === newState && !hasContextChanged() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }
      return false;
    }

    var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);

    if (shouldUpdate) {
      if (typeof instance.componentWillUpdate === 'function') {
        startPhaseTimer(workInProgress, 'componentWillUpdate');
        instance.componentWillUpdate(newProps, newState, newContext);
        stopPhaseTimer();

        // Simulate an async bailout/interruption by invoking lifecycle twice.
        if (debugRenderPhaseSideEffects) {
          instance.componentWillUpdate(newProps, newState, newContext);
        }
      }
      if (typeof instance.componentDidUpdate === 'function') {
        workInProgress.effectTag |= Update;
      }
    } else {
      // If an update was already in progress, we should schedule an Update
      // effect even though we're bailing out, so that cWU/cDU are called.
      if (typeof instance.componentDidUpdate === 'function') {
        if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {
          workInProgress.effectTag |= Update;
        }
      }

      // If shouldComponentUpdate returned false, we should still update the
      // memoized props/state to indicate that this work can be reused.
      memoizeProps(workInProgress, newProps);
      memoizeState(workInProgress, newState);
    }

    // Update the existing instance's state, props, and context pointers even
    // if shouldComponentUpdate returns false.
    instance.props = newProps;
    instance.state = newState;
    instance.context = newContext;

    return shouldUpdate;
  }

  return {
    adoptClassInstance: adoptClassInstance,
    constructClassInstance: constructClassInstance,
    mountClassInstance: mountClassInstance,
    // resumeMountClassInstance,
    updateClassInstance: updateClassInstance
  };
};

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol['for'];

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';

function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable === 'undefined') {
    return null;
  }
  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }
  return null;
}

var getCurrentFiberStackAddendum$1 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnAboutMaps = false;
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */
  var ownerHasKeyUseWarning = {};
  var ownerHasFunctionTypeWarning = {};

  var warnForMissingKey = function (child) {
    if (child === null || typeof child !== 'object') {
      return;
    }
    if (!child._store || child._store.validated || child.key != null) {
      return;
    }
    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    child._store.validated = true;

    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$1() || '');
    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }
    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

    warning(false, 'Each child in an array or iterator should have a unique ' + '"key" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$1());
  };
}

var isArray$1 = Array.isArray;

function coerceRef(current, element) {
  var mixedRef = element.ref;
  if (mixedRef !== null && typeof mixedRef !== 'function') {
    if (element._owner) {
      var owner = element._owner;
      var inst = void 0;
      if (owner) {
        var ownerFiber = owner;
        !(ownerFiber.tag === ClassComponent) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;
        inst = ownerFiber.stateNode;
      }
      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;
      var stringRef = '' + mixedRef;
      // Check if previous string ref matches new string ref
      if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {
        return current.ref;
      }
      var ref = function (value) {
        var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };
      ref._stringRef = stringRef;
      return ref;
    } else {
      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;
      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;
    }
  }
  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    var addendum = '';
    {
      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$1() || '');
    }
    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);
  }
}

function warnOnFunctionType() {
  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + (getCurrentFiberStackAddendum$1() || '');

  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
    return;
  }
  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;

  warning(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$1() || '');
}

// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    }
    // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.
    var last = returnFiber.lastEffect;
    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
    childToDelete.nextEffect = null;
    childToDelete.effectTag = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    }

    // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.
    var childToDelete = currentFirstChild;
    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }
    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    var existingChildren = new Map();

    var existingChild = currentFirstChild;
    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }
      existingChild = existingChild.sibling;
    }
    return existingChildren;
  }

  function useFiber(fiber, pendingProps, expirationTime) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;
    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }
    var current = newFiber.alternate;
    if (current !== null) {
      var oldIndex = current.index;
      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.effectTag = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.effectTag = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.effectTag = Placement;
    }
    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, expirationTime) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, expirationTime) {
    if (current !== null && current.type === element.type) {
      // Move based on index
      var existing = useFiber(current, element.props, expirationTime);
      existing.ref = coerceRef(current, element);
      existing['return'] = returnFiber;
      {
        existing._debugSource = element._source;
        existing._debugOwner = element._owner;
      }
      return existing;
    } else {
      // Insert
      var created = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      created.ref = coerceRef(current, element);
      created['return'] = returnFiber;
      return created;
    }
  }

  function updateCall(returnFiber, current, call, expirationTime) {
    // TODO: Should this also compare handler to determine whether to reuse?
    if (current === null || current.tag !== CallComponent) {
      // Insert
      var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, call, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateReturn(returnFiber, current, returnNode, expirationTime) {
    if (current === null || current.tag !== ReturnComponent) {
      // Insert
      var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
      created.type = returnNode.value;
      created['return'] = returnFiber;
      return created;
    } else {
      // Move based on index
      var existing = useFiber(current, null, expirationTime);
      existing.type = returnNode.value;
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updatePortal(returnFiber, current, portal, expirationTime) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || [], expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, expirationTime, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.internalContextTag, expirationTime, key);
      created['return'] = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.internalContextTag, expirationTime);
      created['return'] = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              var _created = createFiberFromFragment(newChild.props.children, returnFiber.internalContextTag, expirationTime, newChild.key);
              _created['return'] = returnFiber;
              return _created;
            } else {
              var _created2 = createFiberFromElement(newChild, returnFiber.internalContextTag, expirationTime);
              _created2.ref = coerceRef(null, newChild);
              _created2['return'] = returnFiber;
              return _created2;
            }
          }

        case REACT_CALL_TYPE:
          {
            var _created3 = createFiberFromCall(newChild, returnFiber.internalContextTag, expirationTime);
            _created3['return'] = returnFiber;
            return _created3;
          }

        case REACT_RETURN_TYPE:
          {
            var _created4 = createFiberFromReturn(newChild, returnFiber.internalContextTag, expirationTime);
            _created4.type = newChild.value;
            _created4['return'] = returnFiber;
            return _created4;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created5 = createFiberFromPortal(newChild, returnFiber.internalContextTag, expirationTime);
            _created5['return'] = returnFiber;
            return _created5;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created6 = createFiberFromFragment(newChild, returnFiber.internalContextTag, expirationTime, null);
        _created6['return'] = returnFiber;
        return _created6;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
    // Update the fiber if the keys match, otherwise return null.

    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }
      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);
              }
              return updateElement(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_CALL_TYPE:
          {
            if (newChild.key === key) {
              return updateCall(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys. If the previous node is implicitly keyed
            // we can continue to replace it without aborting even if it is not a
            // yield.
            if (key === null) {
              return updateReturn(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);
            }
            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);
          }

        case REACT_CALL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updateCall(returnFiber, _matchedFiber2, newChild, expirationTime);
          }

        case REACT_RETURN_TYPE:
          {
            // Returns don't have keys, so we neither have to check the old nor
            // new node for the key. If both are returns, they match.
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateReturn(returnFiber, _matchedFiber3, newChild, expirationTime);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
            return updatePortal(returnFiber, _matchedFiber4, newChild, expirationTime);
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber5 = existingChildren.get(newIdx) || null;
        return updateFragment(returnFiber, _matchedFiber5, newChild, expirationTime, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }

    return null;
  }

  /**
   * Warns if there is a duplicate or missing key
   */
  function warnOnInvalidKey(child, knownKeys) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_CALL_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child);
          var key = child.key;
          if (typeof key !== 'string') {
            break;
          }
          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          warning(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$1());
          break;
        default:
          break;
      }
    }
    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {
    // This algorithm can't optimize by searching from boths ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.

    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.

    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.

    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.

    {
      // First, validate keys.
      var knownKeys = null;
      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);
        if (!_newFiber) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }
        previousNewFiber = _newFiber;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);
      if (_newFiber2) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }
        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.

    var iteratorFn = getIteratorFn(newChildrenIterable);
    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    {
      // Warn about using Maps as children
      if (typeof newChildrenIterable.entries === 'function') {
        var possibleMap = newChildrenIterable;
        if (possibleMap.entries === iteratorFn) {
          warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$1());
          didWarnAboutMaps = true;
        }
      }

      // First, validate keys.
      // We'll get a different iterator later for the main pass.
      var _newChildren = iteratorFn.call(newChildrenIterable);
      if (_newChildren) {
        var knownKeys = null;
        var _step = _newChildren.next();
        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);
    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;

    var resultingFirstChild = null;
    var previousNewFiber = null;

    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    var step = newChildren.next();
    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }
      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);
      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (!oldFiber) {
          oldFiber = nextOldFiber;
        }
        break;
      }
      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }
      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
        if (_newFiber3 === null) {
          continue;
        }
        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }
        previousNewFiber = _newFiber3;
      }
      return resultingFirstChild;
    }

    // Add all children to a key map for quick lookups.
    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);

    // Keep scanning and use the map to restore deleted items as moves.
    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);
      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }
        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }
        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent, expirationTime);
      existing['return'] = returnFiber;
      return existing;
    }
    // The existing first child is not a text node so we need to create one
    // and delete the existing ones.
    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {
    var key = element.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);
          existing.ref = coerceRef(child, element);
          existing['return'] = returnFiber;
          {
            existing._debugSource = element._source;
            existing._debugOwner = element._owner;
          }
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.internalContextTag, expirationTime, element.key);
      created['return'] = returnFiber;
      return created;
    } else {
      var _created7 = createFiberFromElement(element, returnFiber.internalContextTag, expirationTime);
      _created7.ref = coerceRef(currentFirstChild, element);
      _created7['return'] = returnFiber;
      return _created7;
    }
  }

  function reconcileSingleCall(returnFiber, currentFirstChild, call, expirationTime) {
    var key = call.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === CallComponent) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, call, expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromCall(call, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSingleReturn(returnFiber, currentFirstChild, returnNode, expirationTime) {
    // There's no need to check for keys on yields since they're stateless.
    var child = currentFirstChild;
    if (child !== null) {
      if (child.tag === ReturnComponent) {
        deleteRemainingChildren(returnFiber, child.sibling);
        var existing = useFiber(child, null, expirationTime);
        existing.type = returnNode.value;
        existing['return'] = returnFiber;
        return existing;
      } else {
        deleteRemainingChildren(returnFiber, child);
      }
    }

    var created = createFiberFromReturn(returnNode, returnFiber.internalContextTag, expirationTime);
    created.type = returnNode.value;
    created['return'] = returnFiber;
    return created;
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {
    var key = portal.key;
    var child = currentFirstChild;
    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || [], expirationTime);
          existing['return'] = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }
      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.internalContextTag, expirationTime);
    created['return'] = returnFiber;
    return created;
  }

  // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.
  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.

    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    if (typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null) {
      newChild = newChild.props.children;
    }

    // Handle object types
    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));

        case REACT_CALL_TYPE:
          return placeSingleChild(reconcileSingleCall(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_RETURN_TYPE:
          return placeSingleChild(reconcileSingleReturn(returnFiber, currentFirstChild, newChild, expirationTime));
        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));
      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType();
      }
    }
    if (typeof newChild === 'undefined') {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;
              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough
        case FunctionalComponent:
          {
            var Component = returnFiber.type;
            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');
          }
      }
    }

    // Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);

function cloneChildFibers(current, workInProgress) {
  !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
  workInProgress.child = newChild;

  newChild['return'] = workInProgress;
  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);
    newChild['return'] = workInProgress;
  }
  newChild.sibling = null;
}

{
  var warnedAboutStatelessRefs = {};
}

var ReactFiberBeginWork = function (config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber) {
  var shouldSetTextContent = config.shouldSetTextContent,
      useSyncScheduling = config.useSyncScheduling,
      shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;
  var pushHostContext = hostContext.pushHostContext,
      pushHostContainer = hostContext.pushHostContainer;
  var enterHydrationState = hydrationContext.enterHydrationState,
      resetHydrationState = hydrationContext.resetHydrationState,
      tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;

  var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleWork, computeExpirationForFiber, memoizeProps, memoizeState),
      adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,
      constructClassInstance = _ReactFiberClassCompo.constructClassInstance,
      mountClassInstance = _ReactFiberClassCompo.mountClassInstance,
      updateClassInstance = _ReactFiberClassCompo.updateClassInstance;

  // TODO: Remove this and use reconcileChildrenAtExpirationTime directly.


  function reconcileChildren(current, workInProgress, nextChildren) {
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, workInProgress.expirationTime);
  }

  function reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime) {
    if (current === null) {
      // If this is a fresh new component that hasn't been rendered yet, we
      // won't update its child set by applying minimal side-effects. Instead,
      // we will add them all to the child before it gets rendered. That means
      // we can optimize this reconciliation pass by not tracking side-effects.
      workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
    } else {
      // If the current child is the same as the work in progress, it means that
      // we haven't yet started any work on these children. Therefore, we use
      // the clone algorithm to create a copy of all the current children.

      // If we had any progressed work already, that is invalid at this point so
      // let's throw it out.
      workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderExpirationTime);
    }
  }

  function updateFragment(current, workInProgress) {
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = workInProgress.memoizedProps;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextChildren);
    return workInProgress.child;
  }

  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (ref !== null && (!current || current.ref !== ref)) {
      // Schedule a Ref effect
      workInProgress.effectTag |= Ref;
    }
  }

  function updateFunctionalComponent(current, workInProgress) {
    var fn = workInProgress.type;
    var nextProps = workInProgress.pendingProps;

    var memoizedProps = workInProgress.memoizedProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextProps === null) {
        nextProps = memoizedProps;
      }
    } else {
      if (nextProps === null || memoizedProps === nextProps) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      // TODO: consider bringing fn.shouldComponentUpdate() back.
      // It used to be here.
    }

    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var nextChildren;

    {
      ReactCurrentOwner.current = workInProgress;
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = fn(nextProps, context);
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateClassComponent(current, workInProgress, renderExpirationTime) {
    // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.
    var hasContext = pushContextProvider(workInProgress);

    var shouldUpdate = void 0;
    if (current === null) {
      if (!workInProgress.stateNode) {
        // In the initial pass we might need to construct the instance.
        constructClassInstance(workInProgress, workInProgress.pendingProps);
        mountClassInstance(workInProgress, renderExpirationTime);
        shouldUpdate = true;
      } else {
        invariant(false, 'Resuming work not yet implemented.');
        // In a resume, we'll already have an instance we can reuse.
        // shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
      }
    } else {
      shouldUpdate = updateClassInstance(current, workInProgress, renderExpirationTime);
    }
    return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);
  }

  function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {
    // Refs should update even if shouldComponentUpdate returns false
    markRef(current, workInProgress);

    if (!shouldUpdate) {
      // Context providers should defer to sCU for rendering
      if (hasContext) {
        invalidateContextProvider(workInProgress, false);
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var instance = workInProgress.stateNode;

    // Rerender
    ReactCurrentOwner.current = workInProgress;
    var nextChildren = void 0;
    {
      ReactDebugCurrentFiber.setCurrentPhase('render');
      nextChildren = instance.render();
      if (debugRenderPhaseSideEffects) {
        instance.render();
      }
      ReactDebugCurrentFiber.setCurrentPhase(null);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;
    reconcileChildren(current, workInProgress, nextChildren);
    // Memoize props and state using the values we just used to render.
    // TODO: Restructure so we never read values from the instance.
    memoizeState(workInProgress, instance.state);
    memoizeProps(workInProgress, instance.props);

    // The context might have changed so we need to recalculate it.
    if (hasContext) {
      invalidateContextProvider(workInProgress, true);
    }

    return workInProgress.child;
  }

  function pushHostRootContext(workInProgress) {
    var root = workInProgress.stateNode;
    if (root.pendingContext) {
      pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
    } else if (root.context) {
      // Should always be set
      pushTopLevelContextObject(workInProgress, root.context, false);
    }
    pushHostContainer(workInProgress, root.containerInfo);
  }

  function updateHostRoot(current, workInProgress, renderExpirationTime) {
    pushHostRootContext(workInProgress);
    var updateQueue = workInProgress.updateQueue;
    if (updateQueue !== null) {
      var prevState = workInProgress.memoizedState;
      var state = processUpdateQueue(current, workInProgress, updateQueue, null, null, renderExpirationTime);
      if (prevState === state) {
        // If the state is the same as before, that's a bailout because we had
        // no work that expires at this time.
        resetHydrationState();
        return bailoutOnAlreadyFinishedWork(current, workInProgress);
      }
      var element = state.element;
      var root = workInProgress.stateNode;
      if ((current === null || current.child === null) && root.hydrate && enterHydrationState(workInProgress)) {
        // If we don't have any current children this might be the first pass.
        // We always try to hydrate. If this isn't a hydration pass there won't
        // be any children to hydrate which is effectively the same thing as
        // not hydrating.

        // This is a bit of a hack. We track the host root as a placement to
        // know that we're currently in a mounting state. That way isMounted
        // works as expected. We must reset this before committing.
        // TODO: Delete this when we delete isMounted and findDOMNode.
        workInProgress.effectTag |= Placement;

        // Ensure that children mount into this root without tracking
        // side-effects. This ensures that we don't store Placement effects on
        // nodes that will be hydrated.
        workInProgress.child = mountChildFibers(workInProgress, null, element, renderExpirationTime);
      } else {
        // Otherwise reset hydration state in case we aborted and resumed another
        // root.
        resetHydrationState();
        reconcileChildren(current, workInProgress, element);
      }
      memoizeState(workInProgress, state);
      return workInProgress.child;
    }
    resetHydrationState();
    // If there is no update queue, that's a bailout because the root has no props.
    return bailoutOnAlreadyFinishedWork(current, workInProgress);
  }

  function updateHostComponent(current, workInProgress, renderExpirationTime) {
    pushHostContext(workInProgress);

    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }

    var type = workInProgress.type;
    var memoizedProps = workInProgress.memoizedProps;
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = memoizedProps;
      !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    }
    var prevProps = current !== null ? current.memoizedProps : null;

    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
    } else if (nextProps === null || memoizedProps === nextProps) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextProps.children;
    var isDirectTextChild = shouldSetTextContent(type, nextProps);

    if (isDirectTextChild) {
      // We special case a direct text child of a host node. This is a common
      // case. We won't handle it as a reified child. We will instead handle
      // this in the host environment that also have access to this prop. That
      // avoids allocating another HostText fiber and traversing it.
      nextChildren = null;
    } else if (prevProps && shouldSetTextContent(type, prevProps)) {
      // If we're switching from a direct text child to a normal child, or to
      // empty, we need to schedule the text content to be reset.
      workInProgress.effectTag |= ContentReset;
    }

    markRef(current, workInProgress);

    // Check the host config to see if the children are offscreen/hidden.
    if (renderExpirationTime !== Never && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {
      // Down-prioritize the children.
      workInProgress.expirationTime = Never;
      // Bailout and come back to this fiber later.
      return null;
    }

    reconcileChildren(current, workInProgress, nextChildren);
    memoizeProps(workInProgress, nextProps);
    return workInProgress.child;
  }

  function updateHostText(current, workInProgress) {
    if (current === null) {
      tryToClaimNextHydratableInstance(workInProgress);
    }
    var nextProps = workInProgress.pendingProps;
    if (nextProps === null) {
      nextProps = workInProgress.memoizedProps;
    }
    memoizeProps(workInProgress, nextProps);
    // Nothing to do here. This is terminal. We'll do the completion step
    // immediately after.
    return null;
  }

  function mountIndeterminateComponent(current, workInProgress, renderExpirationTime) {
    !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    var fn = workInProgress.type;
    var props = workInProgress.pendingProps;
    var unmaskedContext = getUnmaskedContext(workInProgress);
    var context = getMaskedContext(workInProgress, unmaskedContext);

    var value;

    {
      if (fn.prototype && typeof fn.prototype.render === 'function') {
        var componentName = getComponentName(workInProgress);
        warning(false, "The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);
      }
      ReactCurrentOwner.current = workInProgress;
      value = fn(props, context);
    }
    // React DevTools reads this flag.
    workInProgress.effectTag |= PerformedWork;

    if (typeof value === 'object' && value !== null && typeof value.render === 'function') {
      // Proceed under the assumption that this is a class instance
      workInProgress.tag = ClassComponent;

      // Push context providers early to prevent context stack mismatches.
      // During mounting we don't know the child context yet as the instance doesn't exist.
      // We will invalidate the child context in finishClassComponent() right after rendering.
      var hasContext = pushContextProvider(workInProgress);
      adoptClassInstance(workInProgress, value);
      mountClassInstance(workInProgress, renderExpirationTime);
      return finishClassComponent(current, workInProgress, true, hasContext);
    } else {
      // Proceed under the assumption that this is a functional component
      workInProgress.tag = FunctionalComponent;
      {
        var Component = workInProgress.type;

        if (Component) {
          warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');
        }
        if (workInProgress.ref !== null) {
          var info = '';
          var ownerName = ReactDebugCurrentFiber.getCurrentFiberOwnerName();
          if (ownerName) {
            info += '\n\nCheck the render method of `' + ownerName + '`.';
          }

          var warningKey = ownerName || workInProgress._debugID || '';
          var debugSource = workInProgress._debugSource;
          if (debugSource) {
            warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
          }
          if (!warnedAboutStatelessRefs[warningKey]) {
            warnedAboutStatelessRefs[warningKey] = true;
            warning(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber.getCurrentFiberStackAddendum());
          }
        }
      }
      reconcileChildren(current, workInProgress, value);
      memoizeProps(workInProgress, props);
      return workInProgress.child;
    }
  }

  function updateCallComponent(current, workInProgress, renderExpirationTime) {
    var nextCall = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextCall === null) {
        nextCall = current && current.memoizedProps;
        !(nextCall !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextCall === null || workInProgress.memoizedProps === nextCall) {
      nextCall = workInProgress.memoizedProps;
      // TODO: When bailing out, we might need to return the stateNode instead
      // of the child. To check it for work.
      // return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    var nextChildren = nextCall.children;

    // The following is a fork of reconcileChildrenAtExpirationTime but using
    // stateNode to store the child.
    if (current === null) {
      workInProgress.stateNode = mountChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    } else {
      workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, renderExpirationTime);
    }

    memoizeProps(workInProgress, nextCall);
    // This doesn't take arbitrary time so we could synchronously just begin
    // eagerly do the work of workInProgress.child as an optimization.
    return workInProgress.stateNode;
  }

  function updatePortalComponent(current, workInProgress, renderExpirationTime) {
    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
    var nextChildren = workInProgress.pendingProps;
    if (hasContextChanged()) {
      // Normally we can bail out on props equality but if context has changed
      // we don't do the bailout and we have to reuse existing props instead.
      if (nextChildren === null) {
        nextChildren = current && current.memoizedProps;
        !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;
      }
    } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress);
    }

    if (current === null) {
      // Portals are special because we don't append the children during mount
      // but at commit. Therefore we need to track insertions which the normal
      // flow doesn't do during mount. This doesn't happen at the root because
      // the root always starts with a "current" with a null child.
      // TODO: Consider unifying this with how the root works.
      workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);
      memoizeProps(workInProgress, nextChildren);
    } else {
      reconcileChildren(current, workInProgress, nextChildren);
      memoizeProps(workInProgress, nextChildren);
    }
    return workInProgress.child;
  }

  /*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */

  function bailoutOnAlreadyFinishedWork(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: We should ideally be able to bail out early if the children have no
    // more work to do. However, since we don't have a separation of this
    // Fiber's priority and its children yet - we don't know without doing lots
    // of the same work we do anyway. Once we have that separation we can just
    // bail out here if the children has no more work at this priority level.
    // if (workInProgress.priorityOfChildren <= priorityLevel) {
    //   // If there are side-effects in these children that have not yet been
    //   // committed we need to ensure that they get properly transferred up.
    //   if (current && current.child !== workInProgress.child) {
    //     reuseChildrenEffects(workInProgress, child);
    //   }
    //   return null;
    // }

    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }

  function bailoutOnLowPriority(current, workInProgress) {
    cancelWorkTimer(workInProgress);

    // TODO: Handle HostComponent tags here as well and call pushHostContext()?
    // See PR 8590 discussion for context
    switch (workInProgress.tag) {
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostPortal:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
    }
    // TODO: What if this is currently in progress?
    // How can that happen? How is this not being cloned?
    return null;
  }

  // TODO: Delete memoizeProps/State and move to reconcile/bailout instead
  function memoizeProps(workInProgress, nextProps) {
    workInProgress.memoizedProps = nextProps;
  }

  function memoizeState(workInProgress, nextState) {
    workInProgress.memoizedState = nextState;
    // Don't reset the updateQueue, in case there are pending updates. Resetting
    // is handled by processUpdateQueue.
  }

  function beginWork(current, workInProgress, renderExpirationTime) {
    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    switch (workInProgress.tag) {
      case IndeterminateComponent:
        return mountIndeterminateComponent(current, workInProgress, renderExpirationTime);
      case FunctionalComponent:
        return updateFunctionalComponent(current, workInProgress);
      case ClassComponent:
        return updateClassComponent(current, workInProgress, renderExpirationTime);
      case HostRoot:
        return updateHostRoot(current, workInProgress, renderExpirationTime);
      case HostComponent:
        return updateHostComponent(current, workInProgress, renderExpirationTime);
      case HostText:
        return updateHostText(current, workInProgress);
      case CallHandlerPhase:
        // This is a restart. Reset the tag to the initial phase.
        workInProgress.tag = CallComponent;
      // Intentionally fall through since this is now the same.
      case CallComponent:
        return updateCallComponent(current, workInProgress, renderExpirationTime);
      case ReturnComponent:
        // A return component is just a placeholder, we can just run through the
        // next one immediately.
        return null;
      case HostPortal:
        return updatePortalComponent(current, workInProgress, renderExpirationTime);
      case Fragment:
        return updateFragment(current, workInProgress);
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function beginFailedWork(current, workInProgress, renderExpirationTime) {
    // Push context providers here to avoid a push/pop context mismatch.
    switch (workInProgress.tag) {
      case ClassComponent:
        pushContextProvider(workInProgress);
        break;
      case HostRoot:
        pushHostRootContext(workInProgress);
        break;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }

    // Add an error effect so we can handle the error during the commit phase
    workInProgress.effectTag |= Err;

    // This is a weird case where we do "resume" work — work that failed on
    // our first attempt. Because we no longer have a notion of "progressed
    // deletions," reset the child to the current child to make sure we delete
    // it again. TODO: Find a better way to handle this, perhaps during a more
    // general overhaul of error handling.
    if (current === null) {
      workInProgress.child = null;
    } else if (workInProgress.child !== current.child) {
      workInProgress.child = current.child;
    }

    if (workInProgress.expirationTime === NoWork || workInProgress.expirationTime > renderExpirationTime) {
      return bailoutOnLowPriority(current, workInProgress);
    }

    // If we don't bail out, we're going be recomputing our children so we need
    // to drop our effect list.
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    // Unmount the current children as if the component rendered null
    var nextChildren = null;
    reconcileChildrenAtExpirationTime(current, workInProgress, nextChildren, renderExpirationTime);

    if (workInProgress.tag === ClassComponent) {
      var instance = workInProgress.stateNode;
      workInProgress.memoizedProps = instance.props;
      workInProgress.memoizedState = instance.state;
    }

    return workInProgress.child;
  }

  return {
    beginWork: beginWork,
    beginFailedWork: beginFailedWork
  };
};

var ReactFiberCompleteWork = function (config, hostContext, hydrationContext) {
  var createInstance = config.createInstance,
      createTextInstance = config.createTextInstance,
      appendInitialChild = config.appendInitialChild,
      finalizeInitialChildren = config.finalizeInitialChildren,
      prepareUpdate = config.prepareUpdate,
      mutation = config.mutation,
      persistence = config.persistence;
  var getRootHostContainer = hostContext.getRootHostContainer,
      popHostContext = hostContext.popHostContext,
      getHostContext = hostContext.getHostContext,
      popHostContainer = hostContext.popHostContainer;
  var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,
      prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,
      popHydrationState = hydrationContext.popHydrationState;


  function markUpdate(workInProgress) {
    // Tag the fiber with an update effect. This turns a Placement into
    // an UpdateAndPlacement.
    workInProgress.effectTag |= Update;
  }

  function markRef(workInProgress) {
    workInProgress.effectTag |= Ref;
  }

  function appendAllReturns(returns, workInProgress) {
    var node = workInProgress.stateNode;
    if (node) {
      node['return'] = workInProgress;
    }
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText || node.tag === HostPortal) {
        invariant(false, 'A call cannot have host component children.');
      } else if (node.tag === ReturnComponent) {
        returns.push(node.type);
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function moveCallToHandlerPhase(current, workInProgress, renderExpirationTime) {
    var call = workInProgress.memoizedProps;
    !call ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    // First step of the call has completed. Now we need to do the second.
    // TODO: It would be nice to have a multi stage call represented by a
    // single component, or at least tail call optimize nested ones. Currently
    // that requires additional fields that we don't want to add to the fiber.
    // So this requires nested handlers.
    // Note: This doesn't mutate the alternate node. I don't think it needs to
    // since this stage is reset for every pass.
    workInProgress.tag = CallHandlerPhase;

    // Build up the returns.
    // TODO: Compare this to a generator or opaque helpers like Children.
    var returns = [];
    appendAllReturns(returns, workInProgress);
    var fn = call.handler;
    var props = call.props;
    var nextChildren = fn(props, returns);

    var currentFirstChild = current !== null ? current.child : null;
    workInProgress.child = reconcileChildFibers(workInProgress, currentFirstChild, nextChildren, renderExpirationTime);
    return workInProgress.child;
  }

  function appendAllChildren(parent, workInProgress) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;
    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) {
        // If we have a portal child, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === workInProgress) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === workInProgress) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  var updateHostContainer = void 0;
  var updateHostComponent = void 0;
  var updateHostText = void 0;
  if (mutation) {
    if (enableMutatingReconciler) {
      // Mutation mode
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // TODO: Type this specific to this type of component.
        workInProgress.updateQueue = updatePayload;
        // If the update payload indicates that there is a change or if there
        // is a new ref we mark this as an update. All the work is done in commitWork.
        if (updatePayload) {
          markUpdate(workInProgress);
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // If the text differs, mark it as an update. All the work in done in commitWork.
        if (oldText !== newText) {
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Mutating reconciler is disabled.');
    }
  } else if (persistence) {
    if (enablePersistentReconciler) {
      // Persistent host tree mode
      var cloneInstance = persistence.cloneInstance,
          createContainerChildSet = persistence.createContainerChildSet,
          appendChildToContainerChildSet = persistence.appendChildToContainerChildSet,
          finalizeContainerChildren = persistence.finalizeContainerChildren;

      // An unfortunate fork of appendAllChildren because we have two different parent types.

      var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {
        // We only have the top Fiber that was created but we need recurse down its
        // children to find all the terminal nodes.
        var node = workInProgress.child;
        while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
            appendChildToContainerChildSet(containerChildSet, node.stateNode);
          } else if (node.tag === HostPortal) {
            // If we have a portal child, then we don't want to traverse
            // down its children. Instead, we'll get insertions from each child in
            // the portal directly.
          } else if (node.child !== null) {
            node.child['return'] = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress) {
            return;
          }
          while (node.sibling === null) {
            if (node['return'] === null || node['return'] === workInProgress) {
              return;
            }
            node = node['return'];
          }
          node.sibling['return'] = node['return'];
          node = node.sibling;
        }
      };
      updateHostContainer = function (workInProgress) {
        var portalOrRoot = workInProgress.stateNode;
        var childrenUnchanged = workInProgress.firstEffect === null;
        if (childrenUnchanged) {
          // No changes, just reuse the existing instance.
        } else {
          var container = portalOrRoot.containerInfo;
          var newChildSet = createContainerChildSet(container);
          if (finalizeContainerChildren(container, newChildSet)) {
            markUpdate(workInProgress);
          }
          portalOrRoot.pendingChildren = newChildSet;
          // If children might have changed, we have to add them all to the set.
          appendAllChildrenToContainer(newChildSet, workInProgress);
          // Schedule an update on the container to swap out the container.
          markUpdate(workInProgress);
        }
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // If there are no effects associated with this node, then none of our children had any updates.
        // This guarantees that we can reuse all of them.
        var childrenUnchanged = workInProgress.firstEffect === null;
        var currentInstance = current.stateNode;
        if (childrenUnchanged && updatePayload === null) {
          // No changes, just reuse the existing instance.
          // Note that this might release a previous clone.
          workInProgress.stateNode = currentInstance;
        } else {
          var recyclableInstance = workInProgress.stateNode;
          var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);
          if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance)) {
            markUpdate(workInProgress);
          }
          workInProgress.stateNode = newInstance;
          if (childrenUnchanged) {
            // If there are no other effects in this tree, we need to flag this node as having one.
            // Even though we're not going to use it for anything.
            // Otherwise parents won't know that there are new children to propagate upwards.
            markUpdate(workInProgress);
          } else {
            // If children might have changed, we have to add them all to the set.
            appendAllChildren(newInstance, workInProgress);
          }
        }
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        if (oldText !== newText) {
          // If the text content differs, we'll create a new text instance for it.
          var rootContainerInstance = getRootHostContainer();
          var currentHostContext = getHostContext();
          workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);
          // We'll have to mark it as having an effect, even though we won't use the effect for anything.
          // This lets the parents know that at least one of their children has changed.
          markUpdate(workInProgress);
        }
      };
    } else {
      invariant(false, 'Persistent reconciler is disabled.');
    }
  } else {
    if (enableNoopReconciler) {
      // No host operations
      updateHostContainer = function (workInProgress) {
        // Noop
      };
      updateHostComponent = function (current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance) {
        // Noop
      };
      updateHostText = function (current, workInProgress, oldText, newText) {
        // Noop
      };
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }

  function completeWork(current, workInProgress, renderExpirationTime) {
    // Get the latest props.
    var newProps = workInProgress.pendingProps;
    if (newProps === null) {
      newProps = workInProgress.memoizedProps;
    } else if (workInProgress.expirationTime !== Never || renderExpirationTime === Never) {
      // Reset the pending props, unless this was a down-prioritization.
      workInProgress.pendingProps = null;
    }

    switch (workInProgress.tag) {
      case FunctionalComponent:
        return null;
      case ClassComponent:
        {
          // We are leaving this subtree, so pop context if any.
          popContextProvider(workInProgress);
          return null;
        }
      case HostRoot:
        {
          popHostContainer(workInProgress);
          popTopLevelContextObject(workInProgress);
          var fiberRoot = workInProgress.stateNode;
          if (fiberRoot.pendingContext) {
            fiberRoot.context = fiberRoot.pendingContext;
            fiberRoot.pendingContext = null;
          }

          if (current === null || current.child === null) {
            // If we hydrated, pop so that we can delete any remaining children
            // that weren't hydrated.
            popHydrationState(workInProgress);
            // This resets the hacky state to fix isMounted before committing.
            // TODO: Delete this when we delete isMounted and findDOMNode.
            workInProgress.effectTag &= ~Placement;
          }
          updateHostContainer(workInProgress);
          return null;
        }
      case HostComponent:
        {
          popHostContext(workInProgress);
          var rootContainerInstance = getRootHostContainer();
          var type = workInProgress.type;
          if (current !== null && workInProgress.stateNode != null) {
            // If we have an alternate, that means this is an update and we need to
            // schedule a side-effect to do the updates.
            var oldProps = current.memoizedProps;
            // If we get updated because one of our children updated, we don't
            // have newProps so we'll have to reuse them.
            // TODO: Split the update API as separate for the props vs. children.
            // Even better would be if children weren't special cased at all tho.
            var instance = workInProgress.stateNode;
            var currentHostContext = getHostContext();
            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);

            updateHostComponent(current, workInProgress, updatePayload, type, oldProps, newProps, rootContainerInstance);

            if (current.ref !== workInProgress.ref) {
              markRef(workInProgress);
            }
          } else {
            if (!newProps) {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }

            var _currentHostContext = getHostContext();
            // TODO: Move createInstance to beginWork and keep it on a context
            // "stack" as the parent. Then append children as we go in beginWork
            // or completeWork depending on we want to add then top->down or
            // bottom->up. Top->down is faster in IE11.
            var wasHydrated = popHydrationState(workInProgress);
            if (wasHydrated) {
              // TODO: Move this and createInstance step into the beginPhase
              // to consolidate.
              if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {
                // If changes to the hydrated node needs to be applied at the
                // commit-phase we mark this as such.
                markUpdate(workInProgress);
              }
            } else {
              var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);

              appendAllChildren(_instance, workInProgress);

              // Certain renderers require commit-time effects for initial mount.
              // (eg DOM renderer supports auto-focus for certain elements).
              // Make sure such renderers get scheduled for later work.
              if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {
                markUpdate(workInProgress);
              }
              workInProgress.stateNode = _instance;
            }

            if (workInProgress.ref !== null) {
              // If there is a ref on a host node we need to schedule a callback
              markRef(workInProgress);
            }
          }
          return null;
        }
      case HostText:
        {
          var newText = newProps;
          if (current && workInProgress.stateNode != null) {
            var oldText = current.memoizedProps;
            // If we have an alternate, that means this is an update and we need
            // to schedule a side-effect to do the updates.
            updateHostText(current, workInProgress, oldText, newText);
          } else {
            if (typeof newText !== 'string') {
              !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;
              // This can happen when we abort work.
              return null;
            }
            var _rootContainerInstance = getRootHostContainer();
            var _currentHostContext2 = getHostContext();
            var _wasHydrated = popHydrationState(workInProgress);
            if (_wasHydrated) {
              if (prepareToHydrateHostTextInstance(workInProgress)) {
                markUpdate(workInProgress);
              }
            } else {
              workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);
            }
          }
          return null;
        }
      case CallComponent:
        return moveCallToHandlerPhase(current, workInProgress, renderExpirationTime);
      case CallHandlerPhase:
        // Reset the tag to now be a first phase call.
        workInProgress.tag = CallComponent;
        return null;
      case ReturnComponent:
        // Does nothing.
        return null;
      case Fragment:
        return null;
      case HostPortal:
        popHostContainer(workInProgress);
        updateHostContainer(workInProgress);
        return null;
      // Error cases
      case IndeterminateComponent:
        invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');
      // eslint-disable-next-line no-fallthrough
      default:
        invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  return {
    completeWork: completeWork
  };
};

var invokeGuardedCallback$2 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError$1 = ReactErrorUtils.hasCaughtError;
var clearCaughtError$1 = ReactErrorUtils.clearCaughtError;


var ReactFiberCommitWork = function (config, captureError) {
  var getPublicInstance = config.getPublicInstance,
      mutation = config.mutation,
      persistence = config.persistence;


  var callComponentWillUnmountWithTimer = function (current, instance) {
    startPhaseTimer(current, 'componentWillUnmount');
    instance.props = current.memoizedProps;
    instance.state = current.memoizedState;
    instance.componentWillUnmount();
    stopPhaseTimer();
  };

  // Capture errors so they don't interrupt unmounting.
  function safelyCallComponentWillUnmount(current, instance) {
    {
      invokeGuardedCallback$2(null, callComponentWillUnmountWithTimer, null, current, instance);
      if (hasCaughtError$1()) {
        var unmountError = clearCaughtError$1();
        captureError(current, unmountError);
      }
    }
  }

  function safelyDetachRef(current) {
    var ref = current.ref;
    if (ref !== null) {
      {
        invokeGuardedCallback$2(null, ref, null, null);
        if (hasCaughtError$1()) {
          var refError = clearCaughtError$1();
          captureError(current, refError);
        }
      }
    }
  }

  function commitLifeCycles(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          var instance = finishedWork.stateNode;
          if (finishedWork.effectTag & Update) {
            if (current === null) {
              startPhaseTimer(finishedWork, 'componentDidMount');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidMount();
              stopPhaseTimer();
            } else {
              var prevProps = current.memoizedProps;
              var prevState = current.memoizedState;
              startPhaseTimer(finishedWork, 'componentDidUpdate');
              instance.props = finishedWork.memoizedProps;
              instance.state = finishedWork.memoizedState;
              instance.componentDidUpdate(prevProps, prevState);
              stopPhaseTimer();
            }
          }
          var updateQueue = finishedWork.updateQueue;
          if (updateQueue !== null) {
            commitCallbacks(updateQueue, instance);
          }
          return;
        }
      case HostRoot:
        {
          var _updateQueue = finishedWork.updateQueue;
          if (_updateQueue !== null) {
            var _instance = finishedWork.child !== null ? finishedWork.child.stateNode : null;
            commitCallbacks(_updateQueue, _instance);
          }
          return;
        }
      case HostComponent:
        {
          var _instance2 = finishedWork.stateNode;

          // Renderers may schedule work to be done after host components are mounted
          // (eg DOM renderer may schedule auto-focus for inputs and form controls).
          // These effects should only be committed when components are first mounted,
          // aka when there is no current/alternate.
          if (current === null && finishedWork.effectTag & Update) {
            var type = finishedWork.type;
            var props = finishedWork.memoizedProps;
            commitMount(_instance2, type, props, finishedWork);
          }

          return;
        }
      case HostText:
        {
          // We have no life-cycles associated with text.
          return;
        }
      case HostPortal:
        {
          // We have no life-cycles associated with portals.
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitAttachRef(finishedWork) {
    var ref = finishedWork.ref;
    if (ref !== null) {
      var instance = finishedWork.stateNode;
      switch (finishedWork.tag) {
        case HostComponent:
          ref(getPublicInstance(instance));
          break;
        default:
          ref(instance);
      }
    }
  }

  function commitDetachRef(current) {
    var currentRef = current.ref;
    if (currentRef !== null) {
      currentRef(null);
    }
  }

  // User-originating errors (lifecycles and refs) should not interrupt
  // deletion, so don't let them throw. Host-originating errors should
  // interrupt deletion, so it's okay
  function commitUnmount(current) {
    if (typeof onCommitUnmount === 'function') {
      onCommitUnmount(current);
    }

    switch (current.tag) {
      case ClassComponent:
        {
          safelyDetachRef(current);
          var instance = current.stateNode;
          if (typeof instance.componentWillUnmount === 'function') {
            safelyCallComponentWillUnmount(current, instance);
          }
          return;
        }
      case HostComponent:
        {
          safelyDetachRef(current);
          return;
        }
      case CallComponent:
        {
          commitNestedUnmounts(current.stateNode);
          return;
        }
      case HostPortal:
        {
          // TODO: this is recursive.
          // We are also not using this parent because
          // the portal will get pushed immediately.
          if (enableMutatingReconciler && mutation) {
            unmountHostComponents(current);
          } else if (enablePersistentReconciler && persistence) {
            emptyPortalContainer(current);
          }
          return;
        }
    }
  }

  function commitNestedUnmounts(root) {
    // While we're inside a removed host node we don't want to call
    // removeChild on the inner nodes because they're removed by the top
    // call anyway. We also want to call componentWillUnmount on all
    // composites before this host node is removed from the tree. Therefore
    var node = root;
    while (true) {
      commitUnmount(node);
      // Visit children because they may contain more composite or host nodes.
      // Skip portals because commitUnmount() currently visits them recursively.
      if (node.child !== null && (
      // If we use mutation we drill down into portals using commitUnmount above.
      // If we don't use mutation we drill down into portals here instead.
      !mutation || node.tag !== HostPortal)) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === root) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === root) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function detachFiber(current) {
    // Cut off the return pointers to disconnect it from the tree. Ideally, we
    // should clear the child pointer of the parent alternate to let this
    // get GC:ed but we don't know which for sure which parent is the current
    // one so we'll settle for GC:ing the subtree of this child. This child
    // itself will be GC:ed when the parent updates the next time.
    current['return'] = null;
    current.child = null;
    if (current.alternate) {
      current.alternate.child = null;
      current.alternate['return'] = null;
    }
  }

  if (!mutation) {
    var commitContainer = void 0;
    if (persistence) {
      var replaceContainerChildren = persistence.replaceContainerChildren,
          createContainerChildSet = persistence.createContainerChildSet;

      var emptyPortalContainer = function (current) {
        var portal = current.stateNode;
        var containerInfo = portal.containerInfo;

        var emptyChildSet = createContainerChildSet(containerInfo);
        replaceContainerChildren(containerInfo, emptyChildSet);
      };
      commitContainer = function (finishedWork) {
        switch (finishedWork.tag) {
          case ClassComponent:
            {
              return;
            }
          case HostComponent:
            {
              return;
            }
          case HostText:
            {
              return;
            }
          case HostRoot:
          case HostPortal:
            {
              var portalOrRoot = finishedWork.stateNode;
              var containerInfo = portalOrRoot.containerInfo,
                  _pendingChildren = portalOrRoot.pendingChildren;

              replaceContainerChildren(containerInfo, _pendingChildren);
              return;
            }
          default:
            {
              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
            }
        }
      };
    } else {
      commitContainer = function (finishedWork) {
        // Noop
      };
    }
    if (enablePersistentReconciler || enableNoopReconciler) {
      return {
        commitResetTextContent: function (finishedWork) {},
        commitPlacement: function (finishedWork) {},
        commitDeletion: function (current) {
          // Detach refs and call componentWillUnmount() on the whole subtree.
          commitNestedUnmounts(current);
          detachFiber(current);
        },
        commitWork: function (current, finishedWork) {
          commitContainer(finishedWork);
        },

        commitLifeCycles: commitLifeCycles,
        commitAttachRef: commitAttachRef,
        commitDetachRef: commitDetachRef
      };
    } else if (persistence) {
      invariant(false, 'Persistent reconciler is disabled.');
    } else {
      invariant(false, 'Noop reconciler is disabled.');
    }
  }
  var commitMount = mutation.commitMount,
      commitUpdate = mutation.commitUpdate,
      resetTextContent = mutation.resetTextContent,
      commitTextUpdate = mutation.commitTextUpdate,
      appendChild = mutation.appendChild,
      appendChildToContainer = mutation.appendChildToContainer,
      insertBefore = mutation.insertBefore,
      insertInContainerBefore = mutation.insertInContainerBefore,
      removeChild = mutation.removeChild,
      removeChildFromContainer = mutation.removeChildFromContainer;


  function getHostParentFiber(fiber) {
    var parent = fiber['return'];
    while (parent !== null) {
      if (isHostParent(parent)) {
        return parent;
      }
      parent = parent['return'];
    }
    invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');
  }

  function isHostParent(fiber) {
    return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
  }

  function getHostSibling(fiber) {
    // We're going to search forward into the tree until we find a sibling host
    // node. Unfortunately, if multiple insertions are done in a row we have to
    // search past them. This leads to exponential search for the next sibling.
    var node = fiber;
    siblings: while (true) {
      // If we didn't find anything, let's try the next sibling.
      while (node.sibling === null) {
        if (node['return'] === null || isHostParent(node['return'])) {
          // If we pop out of the root or hit the parent the fiber we are the
          // last sibling.
          return null;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
      while (node.tag !== HostComponent && node.tag !== HostText) {
        // If it is not host node and, we might have a host node inside it.
        // Try to search down until we find one.
        if (node.effectTag & Placement) {
          // If we don't have a child, try the siblings instead.
          continue siblings;
        }
        // If we don't have a child, try the siblings instead.
        // We also skip portals because they are not part of this host tree.
        if (node.child === null || node.tag === HostPortal) {
          continue siblings;
        } else {
          node.child['return'] = node;
          node = node.child;
        }
      }
      // Check if this host node is stable or about to be placed.
      if (!(node.effectTag & Placement)) {
        // Found it!
        return node.stateNode;
      }
    }
  }

  function commitPlacement(finishedWork) {
    // Recursively insert all host nodes into the parent.
    var parentFiber = getHostParentFiber(finishedWork);
    var parent = void 0;
    var isContainer = void 0;
    switch (parentFiber.tag) {
      case HostComponent:
        parent = parentFiber.stateNode;
        isContainer = false;
        break;
      case HostRoot:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      case HostPortal:
        parent = parentFiber.stateNode.containerInfo;
        isContainer = true;
        break;
      default:
        invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');
    }
    if (parentFiber.effectTag & ContentReset) {
      // Reset the text content of the parent before doing any insertions
      resetTextContent(parent);
      // Clear ContentReset from the effect tag
      parentFiber.effectTag &= ~ContentReset;
    }

    var before = getHostSibling(finishedWork);
    // We only have the top Fiber that was inserted but we need recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;
    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        if (before) {
          if (isContainer) {
            insertInContainerBefore(parent, node.stateNode, before);
          } else {
            insertBefore(parent, node.stateNode, before);
          }
        } else {
          if (isContainer) {
            appendChildToContainer(parent, node.stateNode);
          } else {
            appendChild(parent, node.stateNode);
          }
        }
      } else if (node.tag === HostPortal) {
        // If the insertion itself is a portal, then we don't want to traverse
        // down its children. Instead, we'll get insertions from each child in
        // the portal directly.
      } else if (node.child !== null) {
        node.child['return'] = node;
        node = node.child;
        continue;
      }
      if (node === finishedWork) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === finishedWork) {
          return;
        }
        node = node['return'];
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function unmountHostComponents(current) {
    // We only have the top Fiber that was inserted but we need recurse down its
    var node = current;

    // Each iteration, currentParent is populated with node's host parent if not
    // currentParentIsValid.
    var currentParentIsValid = false;
    var currentParent = void 0;
    var currentParentIsContainer = void 0;

    while (true) {
      if (!currentParentIsValid) {
        var parent = node['return'];
        findParent: while (true) {
          !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          switch (parent.tag) {
            case HostComponent:
              currentParent = parent.stateNode;
              currentParentIsContainer = false;
              break findParent;
            case HostRoot:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
            case HostPortal:
              currentParent = parent.stateNode.containerInfo;
              currentParentIsContainer = true;
              break findParent;
          }
          parent = parent['return'];
        }
        currentParentIsValid = true;
      }

      if (node.tag === HostComponent || node.tag === HostText) {
        commitNestedUnmounts(node);
        // After all the children have unmounted, it is now safe to remove the
        // node from the tree.
        if (currentParentIsContainer) {
          removeChildFromContainer(currentParent, node.stateNode);
        } else {
          removeChild(currentParent, node.stateNode);
        }
        // Don't visit children because we already visited them.
      } else if (node.tag === HostPortal) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        // Visit children because portals might contain host components.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      } else {
        commitUnmount(node);
        // Visit children because we may find more host components below.
        if (node.child !== null) {
          node.child['return'] = node;
          node = node.child;
          continue;
        }
      }
      if (node === current) {
        return;
      }
      while (node.sibling === null) {
        if (node['return'] === null || node['return'] === current) {
          return;
        }
        node = node['return'];
        if (node.tag === HostPortal) {
          // When we go out of the portal, we need to restore the parent.
          // Since we don't keep a stack of them, we will search for it.
          currentParentIsValid = false;
        }
      }
      node.sibling['return'] = node['return'];
      node = node.sibling;
    }
  }

  function commitDeletion(current) {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(current);
    detachFiber(current);
  }

  function commitWork(current, finishedWork) {
    switch (finishedWork.tag) {
      case ClassComponent:
        {
          return;
        }
      case HostComponent:
        {
          var instance = finishedWork.stateNode;
          if (instance != null) {
            // Commit the work prepared earlier.
            var newProps = finishedWork.memoizedProps;
            // For hydration we reuse the update path but we treat the oldProps
            // as the newProps. The updatePayload will contain the real change in
            // this case.
            var oldProps = current !== null ? current.memoizedProps : newProps;
            var type = finishedWork.type;
            // TODO: Type the updateQueue to be specific to host components.
            var updatePayload = finishedWork.updateQueue;
            finishedWork.updateQueue = null;
            if (updatePayload !== null) {
              commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);
            }
          }
          return;
        }
      case HostText:
        {
          !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          var textInstance = finishedWork.stateNode;
          var newText = finishedWork.memoizedProps;
          // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.
          var oldText = current !== null ? current.memoizedProps : newText;
          commitTextUpdate(textInstance, oldText, newText);
          return;
        }
      case HostRoot:
        {
          return;
        }
      default:
        {
          invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');
        }
    }
  }

  function commitResetTextContent(current) {
    resetTextContent(current.stateNode);
  }

  if (enableMutatingReconciler) {
    return {
      commitResetTextContent: commitResetTextContent,
      commitPlacement: commitPlacement,
      commitDeletion: commitDeletion,
      commitWork: commitWork,
      commitLifeCycles: commitLifeCycles,
      commitAttachRef: commitAttachRef,
      commitDetachRef: commitDetachRef
    };
  } else {
    invariant(false, 'Mutating reconciler is disabled.');
  }
};

var NO_CONTEXT = {};

var ReactFiberHostContext = function (config) {
  var getChildHostContext = config.getChildHostContext,
      getRootHostContext = config.getRootHostContext;


  var contextStackCursor = createCursor(NO_CONTEXT);
  var contextFiberStackCursor = createCursor(NO_CONTEXT);
  var rootInstanceStackCursor = createCursor(NO_CONTEXT);

  function requiredContext(c) {
    !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    return c;
  }

  function getRootHostContainer() {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    return rootInstance;
  }

  function pushHostContainer(fiber, nextRootInstance) {
    // Push current root instance onto the stack;
    // This allows us to reset root when portals are popped.
    push(rootInstanceStackCursor, nextRootInstance, fiber);

    var nextRootContext = getRootHostContext(nextRootInstance);

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextRootContext, fiber);
  }

  function popHostContainer(fiber) {
    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }

  function getHostContext() {
    var context = requiredContext(contextStackCursor.current);
    return context;
  }

  function pushHostContext(fiber) {
    var rootInstance = requiredContext(rootInstanceStackCursor.current);
    var context = requiredContext(contextStackCursor.current);
    var nextContext = getChildHostContext(context, fiber.type, rootInstance);

    // Don't push this Fiber's context unless it's unique.
    if (context === nextContext) {
      return;
    }

    // Track the context and the Fiber that provided it.
    // This enables us to pop only Fibers that provide unique contexts.
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, nextContext, fiber);
  }

  function popHostContext(fiber) {
    // Do not pop unless this Fiber provided the current context.
    // pushHostContext() only pushes Fibers that provide unique contexts.
    if (contextFiberStackCursor.current !== fiber) {
      return;
    }

    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
  }

  function resetHostContainer() {
    contextStackCursor.current = NO_CONTEXT;
    rootInstanceStackCursor.current = NO_CONTEXT;
  }

  return {
    getHostContext: getHostContext,
    getRootHostContainer: getRootHostContainer,
    popHostContainer: popHostContainer,
    popHostContext: popHostContext,
    pushHostContainer: pushHostContainer,
    pushHostContext: pushHostContext,
    resetHostContainer: resetHostContainer
  };
};

var ReactFiberHydrationContext = function (config) {
  var shouldSetTextContent = config.shouldSetTextContent,
      hydration = config.hydration;

  // If this doesn't have hydration mode.

  if (!hydration) {
    return {
      enterHydrationState: function () {
        return false;
      },
      resetHydrationState: function () {},
      tryToClaimNextHydratableInstance: function () {},
      prepareToHydrateHostInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      prepareToHydrateHostTextInstance: function () {
        invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');
      },
      popHydrationState: function (fiber) {
        return false;
      }
    };
  }

  var canHydrateInstance = hydration.canHydrateInstance,
      canHydrateTextInstance = hydration.canHydrateTextInstance,
      getNextHydratableSibling = hydration.getNextHydratableSibling,
      getFirstHydratableChild = hydration.getFirstHydratableChild,
      hydrateInstance = hydration.hydrateInstance,
      hydrateTextInstance = hydration.hydrateTextInstance,
      didNotMatchHydratedContainerTextInstance = hydration.didNotMatchHydratedContainerTextInstance,
      didNotMatchHydratedTextInstance = hydration.didNotMatchHydratedTextInstance,
      didNotHydrateContainerInstance = hydration.didNotHydrateContainerInstance,
      didNotHydrateInstance = hydration.didNotHydrateInstance,
      didNotFindHydratableContainerInstance = hydration.didNotFindHydratableContainerInstance,
      didNotFindHydratableContainerTextInstance = hydration.didNotFindHydratableContainerTextInstance,
      didNotFindHydratableInstance = hydration.didNotFindHydratableInstance,
      didNotFindHydratableTextInstance = hydration.didNotFindHydratableTextInstance;

  // The deepest Fiber on the stack involved in a hydration context.
  // This may have been an insertion or a hydration.

  var hydrationParentFiber = null;
  var nextHydratableInstance = null;
  var isHydrating = false;

  function enterHydrationState(fiber) {
    var parentInstance = fiber.stateNode.containerInfo;
    nextHydratableInstance = getFirstHydratableChild(parentInstance);
    hydrationParentFiber = fiber;
    isHydrating = true;
    return true;
  }

  function deleteHydratableInstance(returnFiber, instance) {
    {
      switch (returnFiber.tag) {
        case HostRoot:
          didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
          break;
        case HostComponent:
          didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
          break;
      }
    }

    var childToDelete = createFiberFromHostInstanceForDeletion();
    childToDelete.stateNode = instance;
    childToDelete['return'] = returnFiber;
    childToDelete.effectTag = Deletion;

    // This might seem like it belongs on progressedFirstDeletion. However,
    // these children are not part of the reconciliation list of children.
    // Even if we abort and rereconcile the children, that will try to hydrate
    // again and the nodes are still in the host tree so these will be
    // recreated.
    if (returnFiber.lastEffect !== null) {
      returnFiber.lastEffect.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }
  }

  function insertNonHydratedInstance(returnFiber, fiber) {
    fiber.effectTag |= Placement;
    {
      switch (returnFiber.tag) {
        case HostRoot:
          {
            var parentContainer = returnFiber.stateNode.containerInfo;
            switch (fiber.tag) {
              case HostComponent:
                var type = fiber.type;
                var props = fiber.pendingProps;
                didNotFindHydratableContainerInstance(parentContainer, type, props);
                break;
              case HostText:
                var text = fiber.pendingProps;
                didNotFindHydratableContainerTextInstance(parentContainer, text);
                break;
            }
            break;
          }
        case HostComponent:
          {
            var parentType = returnFiber.type;
            var parentProps = returnFiber.memoizedProps;
            var parentInstance = returnFiber.stateNode;
            switch (fiber.tag) {
              case HostComponent:
                var _type = fiber.type;
                var _props = fiber.pendingProps;
                didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);
                break;
              case HostText:
                var _text = fiber.pendingProps;
                didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
                break;
            }
            break;
          }
        default:
          return;
      }
    }
  }

  function tryHydrate(fiber, nextInstance) {
    switch (fiber.tag) {
      case HostComponent:
        {
          var type = fiber.type;
          var props = fiber.pendingProps;
          var instance = canHydrateInstance(nextInstance, type, props);
          if (instance !== null) {
            fiber.stateNode = instance;
            return true;
          }
          return false;
        }
      case HostText:
        {
          var text = fiber.pendingProps;
          var textInstance = canHydrateTextInstance(nextInstance, text);
          if (textInstance !== null) {
            fiber.stateNode = textInstance;
            return true;
          }
          return false;
        }
      default:
        return false;
    }
  }

  function tryToClaimNextHydratableInstance(fiber) {
    if (!isHydrating) {
      return;
    }
    var nextInstance = nextHydratableInstance;
    if (!nextInstance) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    }
    if (!tryHydrate(fiber, nextInstance)) {
      // If we can't hydrate this instance let's try the next one.
      // We use this as a heuristic. It's based on intuition and not data so it
      // might be flawed or unnecessary.
      nextInstance = getNextHydratableSibling(nextInstance);
      if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
        // Nothing to hydrate. Make it an insertion.
        insertNonHydratedInstance(hydrationParentFiber, fiber);
        isHydrating = false;
        hydrationParentFiber = fiber;
        return;
      }
      // We matched the next one, we'll now assume that the first one was
      // superfluous and we'll delete it. Since we can't eagerly delete it
      // we'll have to schedule a deletion. To do that, this node needs a dummy
      // fiber associated with it.
      deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);
    }
    hydrationParentFiber = fiber;
    nextHydratableInstance = getFirstHydratableChild(nextInstance);
  }

  function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
    var instance = fiber.stateNode;
    var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);
    // TODO: Type this specific to this type of component.
    fiber.updateQueue = updatePayload;
    // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update.
    if (updatePayload !== null) {
      return true;
    }
    return false;
  }

  function prepareToHydrateHostTextInstance(fiber) {
    var textInstance = fiber.stateNode;
    var textContent = fiber.memoizedProps;
    var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
    {
      if (shouldUpdate) {
        // We assume that prepareToHydrateHostTextInstance is called in a context where the
        // hydration parent is the parent host component of this host text.
        var returnFiber = hydrationParentFiber;
        if (returnFiber !== null) {
          switch (returnFiber.tag) {
            case HostRoot:
              {
                var parentContainer = returnFiber.stateNode.containerInfo;
                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
                break;
              }
            case HostComponent:
              {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
                break;
              }
          }
        }
      }
    }
    return shouldUpdate;
  }

  function popToNextHostParent(fiber) {
    var parent = fiber['return'];
    while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {
      parent = parent['return'];
    }
    hydrationParentFiber = parent;
  }

  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) {
      // We're deeper than the current hydration context, inside an inserted
      // tree.
      return false;
    }
    if (!isHydrating) {
      // If we're not currently hydrating but we're in a hydration context, then
      // we were an insertion and now need to pop up reenter hydration of our
      // siblings.
      popToNextHostParent(fiber);
      isHydrating = true;
      return false;
    }

    var type = fiber.type;

    // If we have any remaining hydratable nodes, we need to delete them now.
    // We only do this deeper than head and body since they tend to have random
    // other nodes in them. We also ignore components with pure text content in
    // side of them.
    // TODO: Better heuristic.
    if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
      var nextInstance = nextHydratableInstance;
      while (nextInstance) {
        deleteHydratableInstance(fiber, nextInstance);
        nextInstance = getNextHydratableSibling(nextInstance);
      }
    }

    popToNextHostParent(fiber);
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
    return true;
  }

  function resetHydrationState() {
    hydrationParentFiber = null;
    nextHydratableInstance = null;
    isHydrating = false;
  }

  return {
    enterHydrationState: enterHydrationState,
    resetHydrationState: resetHydrationState,
    tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,
    prepareToHydrateHostInstance: prepareToHydrateHostInstance,
    prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,
    popHydrationState: popHydrationState
  };
};

// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation = {
  debugTool: null
};

var ReactFiberInstrumentation_1 = ReactFiberInstrumentation;

var defaultShowDialog = function (capturedError) {
  return true;
};

var showDialog = defaultShowDialog;

function logCapturedError(capturedError) {
  var logError = showDialog(capturedError);

  // Allow injected showDialog() to prevent default console.error logging.
  // This enables renderers like ReactNative to better manage redbox behavior.
  if (logError === false) {
    return;
  }

  var error = capturedError.error;
  var suppressLogging = error && error.suppressReactErrorLogging;
  if (suppressLogging) {
    return;
  }

  {
    var componentName = capturedError.componentName,
        componentStack = capturedError.componentStack,
        errorBoundaryName = capturedError.errorBoundaryName,
        errorBoundaryFound = capturedError.errorBoundaryFound,
        willRetry = capturedError.willRetry;


    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';

    var errorBoundaryMessage = void 0;
    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
    if (errorBoundaryFound && errorBoundaryName) {
      if (willRetry) {
        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');
      } else {
        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';
      }
    } else {
      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';
    }
    var combinedMessage = '' + componentNameMessage + componentStack + '\n\n' + ('' + errorBoundaryMessage);

    // In development, we provide our own message with just the component stack.
    // We don't include the original error message and JS stack because the browser
    // has already printed it. Even if the application swallows the error, it is still
    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
    console.error(combinedMessage);
  }
}

var invokeGuardedCallback$1 = ReactErrorUtils.invokeGuardedCallback;
var hasCaughtError = ReactErrorUtils.hasCaughtError;
var clearCaughtError = ReactErrorUtils.clearCaughtError;


{
  var didWarnAboutStateTransition = false;
  var didWarnSetStateChildContext = false;
  var didWarnStateUpdateForUnmountedComponent = {};

  var warnAboutUpdateOnUnmounted = function (fiber) {
    var componentName = getComponentName(fiber) || 'ReactClass';
    if (didWarnStateUpdateForUnmountedComponent[componentName]) {
      return;
    }
    warning(false, 'Can only update a mounted or mounting ' + 'component. This usually means you called setState, replaceState, ' + 'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease ' + 'check the code for the %s component.', componentName);
    didWarnStateUpdateForUnmountedComponent[componentName] = true;
  };

  var warnAboutInvalidUpdates = function (instance) {
    switch (ReactDebugCurrentFiber.phase) {
      case 'getChildContext':
        if (didWarnSetStateChildContext) {
          return;
        }
        warning(false, 'setState(...): Cannot call setState() inside getChildContext()');
        didWarnSetStateChildContext = true;
        break;
      case 'render':
        if (didWarnAboutStateTransition) {
          return;
        }
        warning(false, 'Cannot update during an existing state transition (such as within ' + "`render` or another component's constructor). Render methods should " + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');
        didWarnAboutStateTransition = true;
        break;
    }
  };
}

var ReactFiberScheduler = function (config) {
  var hostContext = ReactFiberHostContext(config);
  var hydrationContext = ReactFiberHydrationContext(config);
  var popHostContainer = hostContext.popHostContainer,
      popHostContext = hostContext.popHostContext,
      resetHostContainer = hostContext.resetHostContainer;

  var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleWork, computeExpirationForFiber),
      beginWork = _ReactFiberBeginWork.beginWork,
      beginFailedWork = _ReactFiberBeginWork.beginFailedWork;

  var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),
      completeWork = _ReactFiberCompleteWo.completeWork;

  var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),
      commitResetTextContent = _ReactFiberCommitWork.commitResetTextContent,
      commitPlacement = _ReactFiberCommitWork.commitPlacement,
      commitDeletion = _ReactFiberCommitWork.commitDeletion,
      commitWork = _ReactFiberCommitWork.commitWork,
      commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,
      commitAttachRef = _ReactFiberCommitWork.commitAttachRef,
      commitDetachRef = _ReactFiberCommitWork.commitDetachRef;

  var now = config.now,
      scheduleDeferredCallback = config.scheduleDeferredCallback,
      cancelDeferredCallback = config.cancelDeferredCallback,
      useSyncScheduling = config.useSyncScheduling,
      prepareForCommit = config.prepareForCommit,
      resetAfterCommit = config.resetAfterCommit;

  // Represents the current time in ms.

  var startTime = now();
  var mostRecentCurrentTime = msToExpirationTime(0);

  // Represents the expiration time that incoming updates should use. (If this
  // is NoWork, use the default strategy: async updates in async mode, sync
  // updates in sync mode.)
  var expirationContext = NoWork;

  var isWorking = false;

  // The next work in progress fiber that we're currently working on.
  var nextUnitOfWork = null;
  var nextRoot = null;
  // The time at which we're currently rendering work.
  var nextRenderExpirationTime = NoWork;

  // The next fiber with an effect that we're currently committing.
  var nextEffect = null;

  // Keep track of which fibers have captured an error that need to be handled.
  // Work is removed from this collection after componentDidCatch is called.
  var capturedErrors = null;
  // Keep track of which fibers have failed during the current batch of work.
  // This is a different set than capturedErrors, because it is not reset until
  // the end of the batch. This is needed to propagate errors correctly if a
  // subtree fails more than once.
  var failedBoundaries = null;
  // Error boundaries that captured an error during the current commit.
  var commitPhaseBoundaries = null;
  var firstUncaughtError = null;
  var didFatal = false;

  var isCommitting = false;
  var isUnmounting = false;

  // Used for performance tracking.
  var interruptedBy = null;

  function resetContextStack() {
    // Reset the stack
    reset$1();
    // Reset the cursors
    resetContext();
    resetHostContainer();
  }

  function commitAllHostEffects() {
    while (nextEffect !== null) {
      {
        ReactDebugCurrentFiber.setCurrentFiber(nextEffect);
      }
      recordEffect();

      var effectTag = nextEffect.effectTag;
      if (effectTag & ContentReset) {
        commitResetTextContent(nextEffect);
      }

      if (effectTag & Ref) {
        var current = nextEffect.alternate;
        if (current !== null) {
          commitDetachRef(current);
        }
      }

      // The following switch statement is only concerned about placement,
      // updates, and deletions. To avoid needing to add a case for every
      // possible bitmap value, we remove the secondary effects from the
      // effect tag and switch on that value.
      var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);
      switch (primaryEffectTag) {
        case Placement:
          {
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            // TODO: findDOMNode doesn't rely on this any more but isMounted
            // does and isMounted is deprecated anyway so we should be able
            // to kill this.
            nextEffect.effectTag &= ~Placement;
            break;
          }
        case PlacementAndUpdate:
          {
            // Placement
            commitPlacement(nextEffect);
            // Clear the "placement" from effect tag so that we know that this is inserted, before
            // any life-cycles like componentDidMount gets called.
            nextEffect.effectTag &= ~Placement;

            // Update
            var _current = nextEffect.alternate;
            commitWork(_current, nextEffect);
            break;
          }
        case Update:
          {
            var _current2 = nextEffect.alternate;
            commitWork(_current2, nextEffect);
            break;
          }
        case Deletion:
          {
            isUnmounting = true;
            commitDeletion(nextEffect);
            isUnmounting = false;
            break;
          }
      }
      nextEffect = nextEffect.nextEffect;
    }

    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
  }

  function commitAllLifeCycles() {
    while (nextEffect !== null) {
      var effectTag = nextEffect.effectTag;

      if (effectTag & (Update | Callback)) {
        recordEffect();
        var current = nextEffect.alternate;
        commitLifeCycles(current, nextEffect);
      }

      if (effectTag & Ref) {
        recordEffect();
        commitAttachRef(nextEffect);
      }

      if (effectTag & Err) {
        recordEffect();
        commitErrorHandling(nextEffect);
      }

      var next = nextEffect.nextEffect;
      // Ensure that we clean these up so that we don't accidentally keep them.
      // I'm not actually sure this matters because we can't reset firstEffect
      // and lastEffect since they're on every node, not just the effectful
      // ones. So we have to clean everything as we reuse nodes anyway.
      nextEffect.nextEffect = null;
      // Ensure that we reset the effectTag here so that we can rely on effect
      // tags to reason about the current life-cycle.
      nextEffect = next;
    }
  }

  function commitRoot(finishedWork) {
    // We keep track of this so that captureError can collect any boundaries
    // that capture an error during the commit phase. The reason these aren't
    // local to this function is because errors that occur during cWU are
    // captured elsewhere, to prevent the unmount from being interrupted.
    isWorking = true;
    isCommitting = true;
    startCommitTimer();

    var root = finishedWork.stateNode;
    !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    root.isReadyForCommit = false;

    // Reset this to null before calling lifecycles
    ReactCurrentOwner.current = null;

    var firstEffect = void 0;
    if (finishedWork.effectTag > PerformedWork) {
      // A fiber's effect list consists only of its children, not itself. So if
      // the root has an effect, we need to add it to the end of the list. The
      // resulting list is the set that would belong to the root's parent, if
      // it had one; that is, all the effects in the tree including the root.
      if (finishedWork.lastEffect !== null) {
        finishedWork.lastEffect.nextEffect = finishedWork;
        firstEffect = finishedWork.firstEffect;
      } else {
        firstEffect = finishedWork;
      }
    } else {
      // There is no effect on the root.
      firstEffect = finishedWork.firstEffect;
    }

    prepareForCommit();

    // Commit all the side-effects within a tree. We'll do this in two passes.
    // The first pass performs all the host insertions, updates, deletions and
    // ref unmounts.
    nextEffect = firstEffect;
    startCommitHostEffectsTimer();
    while (nextEffect !== null) {
      var didError = false;
      var _error = void 0;
      {
        invokeGuardedCallback$1(null, commitAllHostEffects, null);
        if (hasCaughtError()) {
          didError = true;
          _error = clearCaughtError();
        }
      }
      if (didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error);
        // Clean-up
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }
    stopCommitHostEffectsTimer();

    resetAfterCommit();

    // The work-in-progress tree is now the current tree. This must come after
    // the first pass of the commit phase, so that the previous tree is still
    // current during componentWillUnmount, but before the second pass, so that
    // the finished work is current during componentDidMount/Update.
    root.current = finishedWork;

    // In the second pass we'll perform all life-cycles and ref callbacks.
    // Life-cycles happen as a separate pass so that all placements, updates,
    // and deletions in the entire tree have already been invoked.
    // This pass also triggers any renderer-specific initial effects.
    nextEffect = firstEffect;
    startCommitLifeCyclesTimer();
    while (nextEffect !== null) {
      var _didError = false;
      var _error2 = void 0;
      {
        invokeGuardedCallback$1(null, commitAllLifeCycles, null);
        if (hasCaughtError()) {
          _didError = true;
          _error2 = clearCaughtError();
        }
      }
      if (_didError) {
        !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;
        captureError(nextEffect, _error2);
        if (nextEffect !== null) {
          nextEffect = nextEffect.nextEffect;
        }
      }
    }

    isCommitting = false;
    isWorking = false;
    stopCommitLifeCyclesTimer();
    stopCommitTimer();
    if (typeof onCommitRoot === 'function') {
      onCommitRoot(finishedWork.stateNode);
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);
    }

    // If we caught any errors during this commit, schedule their boundaries
    // to update.
    if (commitPhaseBoundaries) {
      commitPhaseBoundaries.forEach(scheduleErrorRecovery);
      commitPhaseBoundaries = null;
    }

    if (firstUncaughtError !== null) {
      var _error3 = firstUncaughtError;
      firstUncaughtError = null;
      onUncaughtError(_error3);
    }

    var remainingTime = root.current.expirationTime;

    if (remainingTime === NoWork) {
      capturedErrors = null;
      failedBoundaries = null;
    }

    return remainingTime;
  }

  function resetExpirationTime(workInProgress, renderTime) {
    if (renderTime !== Never && workInProgress.expirationTime === Never) {
      // The children of this component are hidden. Don't bubble their
      // expiration times.
      return;
    }

    // Check for pending updates.
    var newExpirationTime = getUpdateExpirationTime(workInProgress);

    // TODO: Calls need to visit stateNode

    // Bubble up the earliest expiration time.
    var child = workInProgress.child;
    while (child !== null) {
      if (child.expirationTime !== NoWork && (newExpirationTime === NoWork || newExpirationTime > child.expirationTime)) {
        newExpirationTime = child.expirationTime;
      }
      child = child.sibling;
    }
    workInProgress.expirationTime = newExpirationTime;
  }

  function completeUnitOfWork(workInProgress) {
    while (true) {
      // The current, flushed, state of this fiber is the alternate.
      // Ideally nothing should rely on this, but relying on it here
      // means that we don't need an additional field on the work in
      // progress.
      var current = workInProgress.alternate;
      {
        ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
      }
      var next = completeWork(current, workInProgress, nextRenderExpirationTime);
      {
        ReactDebugCurrentFiber.resetCurrentFiber();
      }

      var returnFiber = workInProgress['return'];
      var siblingFiber = workInProgress.sibling;

      resetExpirationTime(workInProgress, nextRenderExpirationTime);

      if (next !== null) {
        stopWorkTimer(workInProgress);
        if (true && ReactFiberInstrumentation_1.debugTool) {
          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
        }
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        return next;
      }

      if (returnFiber !== null) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = workInProgress.firstEffect;
        }
        if (workInProgress.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;
          }
          returnFiber.lastEffect = workInProgress.lastEffect;
        }

        // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if
        // needed, by doing multiple passes over the effect list. We don't want
        // to schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.
        var effectTag = workInProgress.effectTag;
        // Skip both NoWork and PerformedWork tags when creating the effect list.
        // PerformedWork effect is read by React DevTools but shouldn't be committed.
        if (effectTag > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = workInProgress;
          } else {
            returnFiber.firstEffect = workInProgress;
          }
          returnFiber.lastEffect = workInProgress;
        }
      }

      stopWorkTimer(workInProgress);
      if (true && ReactFiberInstrumentation_1.debugTool) {
        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);
      }

      if (siblingFiber !== null) {
        // If there is more work to do in this returnFiber, do that next.
        return siblingFiber;
      } else if (returnFiber !== null) {
        // If there's no more work in this returnFiber. Complete the returnFiber.
        workInProgress = returnFiber;
        continue;
      } else {
        // We've reached the root.
        var root = workInProgress.stateNode;
        root.isReadyForCommit = true;
        return null;
      }
    }

    // Without this explicit null return Flow complains of invalid return type
    // TODO Remove the above while(true) loop
    // eslint-disable-next-line no-unreachable
    return null;
  }

  function performUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }

    var next = beginWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function performFailedUnitOfWork(workInProgress) {
    // The current, flushed, state of this fiber is the alternate.
    // Ideally nothing should rely on this, but relying on it here
    // means that we don't need an additional field on the work in
    // progress.
    var current = workInProgress.alternate;

    // See if beginning this work spawns more work.
    startWorkTimer(workInProgress);
    {
      ReactDebugCurrentFiber.setCurrentFiber(workInProgress);
    }
    var next = beginFailedWork(current, workInProgress, nextRenderExpirationTime);
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }
    if (true && ReactFiberInstrumentation_1.debugTool) {
      ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);
    }

    if (next === null) {
      // If this doesn't spawn new work, complete the current work.
      next = completeUnitOfWork(workInProgress);
    }

    ReactCurrentOwner.current = null;

    return next;
  }

  function workLoop(expirationTime) {
    if (capturedErrors !== null) {
      // If there are unhandled errors, switch to the slow work loop.
      // TODO: How to avoid this check in the fast path? Maybe the renderer
      // could keep track of which roots have unhandled errors and call a
      // forked version of renderRoot.
      slowWorkLoopThatChecksForFailedWork(expirationTime);
      return;
    }
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
      }
    }
  }

  function slowWorkLoopThatChecksForFailedWork(expirationTime) {
    if (nextRenderExpirationTime === NoWork || nextRenderExpirationTime > expirationTime) {
      return;
    }

    if (nextRenderExpirationTime <= mostRecentCurrentTime) {
      // Flush all expired work.
      while (nextUnitOfWork !== null) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    } else {
      // Flush asynchronous work until the deadline runs out of time.
      while (nextUnitOfWork !== null && !shouldYield()) {
        if (hasCapturedError(nextUnitOfWork)) {
          // Use a forked version of performUnitOfWork
          nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);
        } else {
          nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
        }
      }
    }
  }

  function renderRootCatchBlock(root, failedWork, boundary, expirationTime) {
    // We're going to restart the error boundary that captured the error.
    // Conceptually, we're unwinding the stack. We need to unwind the
    // context stack, too.
    unwindContexts(failedWork, boundary);

    // Restart the error boundary using a forked version of
    // performUnitOfWork that deletes the boundary's children. The entire
    // failed subree will be unmounted. During the commit phase, a special
    // lifecycle method is called on the error boundary, which triggers
    // a re-render.
    nextUnitOfWork = performFailedUnitOfWork(boundary);

    // Continue working.
    workLoop(expirationTime);
  }

  function renderRoot(root, expirationTime) {
    !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    isWorking = true;

    // We're about to mutate the work-in-progress tree. If the root was pending
    // commit, it no longer is: we'll need to complete it again.
    root.isReadyForCommit = false;

    // Check if we're starting from a fresh stack, or if we're resuming from
    // previously yielded work.
    if (root !== nextRoot || expirationTime !== nextRenderExpirationTime || nextUnitOfWork === null) {
      // Reset the stack and start working from the root.
      resetContextStack();
      nextRoot = root;
      nextRenderExpirationTime = expirationTime;
      nextUnitOfWork = createWorkInProgress(nextRoot.current, null, expirationTime);
    }

    startWorkLoopTimer(nextUnitOfWork);

    var didError = false;
    var error = null;
    {
      invokeGuardedCallback$1(null, workLoop, null, expirationTime);
      if (hasCaughtError()) {
        didError = true;
        error = clearCaughtError();
      }
    }

    // An error was thrown during the render phase.
    while (didError) {
      if (didFatal) {
        // This was a fatal error. Don't attempt to recover from it.
        firstUncaughtError = error;
        break;
      }

      var failedWork = nextUnitOfWork;
      if (failedWork === null) {
        // An error was thrown but there's no current unit of work. This can
        // happen during the commit phase if there's a bug in the renderer.
        didFatal = true;
        continue;
      }

      // "Capture" the error by finding the nearest boundary. If there is no
      // error boundary, we use the root.
      var boundary = captureError(failedWork, error);
      !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;

      if (didFatal) {
        // The error we just captured was a fatal error. This happens
        // when the error propagates to the root more than once.
        continue;
      }

      didError = false;
      error = null;
      {
        invokeGuardedCallback$1(null, renderRootCatchBlock, null, root, failedWork, boundary, expirationTime);
        if (hasCaughtError()) {
          didError = true;
          error = clearCaughtError();
          continue;
        }
      }
      // We're finished working. Exit the error loop.
      break;
    }

    var uncaughtError = firstUncaughtError;

    // We're done performing work. Time to clean up.
    stopWorkLoopTimer(interruptedBy);
    interruptedBy = null;
    isWorking = false;
    didFatal = false;
    firstUncaughtError = null;

    if (uncaughtError !== null) {
      onUncaughtError(uncaughtError);
    }

    return root.isReadyForCommit ? root.current.alternate : null;
  }

  // Returns the boundary that captured the error, or null if the error is ignored
  function captureError(failedWork, error) {
    // It is no longer valid because we exited the user code.
    ReactCurrentOwner.current = null;
    {
      ReactDebugCurrentFiber.resetCurrentFiber();
    }

    // Search for the nearest error boundary.
    var boundary = null;

    // Passed to logCapturedError()
    var errorBoundaryFound = false;
    var willRetry = false;
    var errorBoundaryName = null;

    // Host containers are a special case. If the failed work itself is a host
    // container, then it acts as its own boundary. In all other cases, we
    // ignore the work itself and only search through the parents.
    if (failedWork.tag === HostRoot) {
      boundary = failedWork;

      if (isFailedBoundary(failedWork)) {
        // If this root already failed, there must have been an error when
        // attempting to unmount it. This is a worst-case scenario and
        // should only be possible if there's a bug in the renderer.
        didFatal = true;
      }
    } else {
      var node = failedWork['return'];
      while (node !== null && boundary === null) {
        if (node.tag === ClassComponent) {
          var instance = node.stateNode;
          if (typeof instance.componentDidCatch === 'function') {
            errorBoundaryFound = true;
            errorBoundaryName = getComponentName(node);

            // Found an error boundary!
            boundary = node;
            willRetry = true;
          }
        } else if (node.tag === HostRoot) {
          // Treat the root like a no-op error boundary
          boundary = node;
        }

        if (isFailedBoundary(node)) {
          // This boundary is already in a failed state.

          // If we're currently unmounting, that means this error was
          // thrown while unmounting a failed subtree. We should ignore
          // the error.
          if (isUnmounting) {
            return null;
          }

          // If we're in the commit phase, we should check to see if
          // this boundary already captured an error during this commit.
          // This case exists because multiple errors can be thrown during
          // a single commit without interruption.
          if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {
            // If so, we should ignore this error.
            return null;
          }

          // The error should propagate to the next boundary -— we keep looking.
          boundary = null;
          willRetry = false;
        }

        node = node['return'];
      }
    }

    if (boundary !== null) {
      // Add to the collection of failed boundaries. This lets us know that
      // subsequent errors in this subtree should propagate to the next boundary.
      if (failedBoundaries === null) {
        failedBoundaries = new Set();
      }
      failedBoundaries.add(boundary);

      // This method is unsafe outside of the begin and complete phases.
      // We might be in the commit phase when an error is captured.
      // The risk is that the return path from this Fiber may not be accurate.
      // That risk is acceptable given the benefit of providing users more context.
      var _componentStack = getStackAddendumByWorkInProgressFiber(failedWork);
      var _componentName = getComponentName(failedWork);

      // Add to the collection of captured errors. This is stored as a global
      // map of errors and their component stack location keyed by the boundaries
      // that capture them. We mostly use this Map as a Set; it's a Map only to
      // avoid adding a field to Fiber to store the error.
      if (capturedErrors === null) {
        capturedErrors = new Map();
      }

      var capturedError = {
        componentName: _componentName,
        componentStack: _componentStack,
        error: error,
        errorBoundary: errorBoundaryFound ? boundary.stateNode : null,
        errorBoundaryFound: errorBoundaryFound,
        errorBoundaryName: errorBoundaryName,
        willRetry: willRetry
      };

      capturedErrors.set(boundary, capturedError);

      try {
        logCapturedError(capturedError);
      } catch (e) {
        // Prevent cycle if logCapturedError() throws.
        // A cycle may still occur if logCapturedError renders a component that throws.
        var suppressLogging = e && e.suppressReactErrorLogging;
        if (!suppressLogging) {
          console.error(e);
        }
      }

      // If we're in the commit phase, defer scheduling an update on the
      // boundary until after the commit is complete
      if (isCommitting) {
        if (commitPhaseBoundaries === null) {
          commitPhaseBoundaries = new Set();
        }
        commitPhaseBoundaries.add(boundary);
      } else {
        // Otherwise, schedule an update now.
        // TODO: Is this actually necessary during the render phase? Is it
        // possible to unwind and continue rendering at the same priority,
        // without corrupting internal state?
        scheduleErrorRecovery(boundary);
      }
      return boundary;
    } else if (firstUncaughtError === null) {
      // If no boundary is found, we'll need to throw the error
      firstUncaughtError = error;
    }
    return null;
  }

  function hasCapturedError(fiber) {
    // TODO: capturedErrors should store the boundary instance, to avoid needing
    // to check the alternate.
    return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));
  }

  function isFailedBoundary(fiber) {
    // TODO: failedBoundaries should store the boundary instance, to avoid
    // needing to check the alternate.
    return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));
  }

  function commitErrorHandling(effectfulFiber) {
    var capturedError = void 0;
    if (capturedErrors !== null) {
      capturedError = capturedErrors.get(effectfulFiber);
      capturedErrors['delete'](effectfulFiber);
      if (capturedError == null) {
        if (effectfulFiber.alternate !== null) {
          effectfulFiber = effectfulFiber.alternate;
          capturedError = capturedErrors.get(effectfulFiber);
          capturedErrors['delete'](effectfulFiber);
        }
      }
    }

    !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    switch (effectfulFiber.tag) {
      case ClassComponent:
        var instance = effectfulFiber.stateNode;

        var info = {
          componentStack: capturedError.componentStack
        };

        // Allow the boundary to handle the error, usually by scheduling
        // an update to itself
        instance.componentDidCatch(capturedError.error, info);
        return;
      case HostRoot:
        if (firstUncaughtError === null) {
          firstUncaughtError = capturedError.error;
        }
        return;
      default:
        invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');
    }
  }

  function unwindContexts(from, to) {
    var node = from;
    while (node !== null) {
      switch (node.tag) {
        case ClassComponent:
          popContextProvider(node);
          break;
        case HostComponent:
          popHostContext(node);
          break;
        case HostRoot:
          popHostContainer(node);
          break;
        case HostPortal:
          popHostContainer(node);
          break;
      }
      if (node === to || node.alternate === to) {
        stopFailedWorkTimer(node);
        break;
      } else {
        stopWorkTimer(node);
      }
      node = node['return'];
    }
  }

  function computeAsyncExpiration() {
    // Given the current clock time, returns an expiration time. We use rounding
    // to batch like updates together.
    // Should complete within ~1000ms. 1200ms max.
    var currentTime = recalculateCurrentTime();
    var expirationMs = 1000;
    var bucketSizeMs = 200;
    return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
  }

  function computeExpirationForFiber(fiber) {
    var expirationTime = void 0;
    if (expirationContext !== NoWork) {
      // An explicit expiration context was set;
      expirationTime = expirationContext;
    } else if (isWorking) {
      if (isCommitting) {
        // Updates that occur during the commit phase should have sync priority
        // by default.
        expirationTime = Sync;
      } else {
        // Updates during the render phase should expire at the same time as
        // the work that is being rendered.
        expirationTime = nextRenderExpirationTime;
      }
    } else {
      // No explicit expiration context was set, and we're not currently
      // performing work. Calculate a new expiration time.
      if (useSyncScheduling && !(fiber.internalContextTag & AsyncUpdates)) {
        // This is a sync update
        expirationTime = Sync;
      } else {
        // This is an async update
        expirationTime = computeAsyncExpiration();
      }
    }
    return expirationTime;
  }

  function scheduleWork(fiber, expirationTime) {
    return scheduleWorkImpl(fiber, expirationTime, false);
  }

  function checkRootNeedsClearing(root, fiber, expirationTime) {
    if (!isWorking && root === nextRoot && expirationTime < nextRenderExpirationTime) {
      // Restart the root from the top.
      if (nextUnitOfWork !== null) {
        // This is an interruption. (Used for performance tracking.)
        interruptedBy = fiber;
      }
      nextRoot = null;
      nextUnitOfWork = null;
      nextRenderExpirationTime = NoWork;
    }
  }

  function scheduleWorkImpl(fiber, expirationTime, isErrorRecovery) {
    recordScheduleUpdate();

    {
      if (!isErrorRecovery && fiber.tag === ClassComponent) {
        var instance = fiber.stateNode;
        warnAboutInvalidUpdates(instance);
      }
    }

    var node = fiber;
    while (node !== null) {
      // Walk the parent path to the root and update each node's
      // expiration time.
      if (node.expirationTime === NoWork || node.expirationTime > expirationTime) {
        node.expirationTime = expirationTime;
      }
      if (node.alternate !== null) {
        if (node.alternate.expirationTime === NoWork || node.alternate.expirationTime > expirationTime) {
          node.alternate.expirationTime = expirationTime;
        }
      }
      if (node['return'] === null) {
        if (node.tag === HostRoot) {
          var root = node.stateNode;

          checkRootNeedsClearing(root, fiber, expirationTime);
          requestWork(root, expirationTime);
          checkRootNeedsClearing(root, fiber, expirationTime);
        } else {
          {
            if (!isErrorRecovery && fiber.tag === ClassComponent) {
              warnAboutUpdateOnUnmounted(fiber);
            }
          }
          return;
        }
      }
      node = node['return'];
    }
  }

  function scheduleErrorRecovery(fiber) {
    scheduleWorkImpl(fiber, Sync, true);
  }

  function recalculateCurrentTime() {
    // Subtract initial time so it fits inside 32bits
    var ms = now() - startTime;
    mostRecentCurrentTime = msToExpirationTime(ms);
    return mostRecentCurrentTime;
  }

  function deferredUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = computeAsyncExpiration();
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  function syncUpdates(fn) {
    var previousExpirationContext = expirationContext;
    expirationContext = Sync;
    try {
      return fn();
    } finally {
      expirationContext = previousExpirationContext;
    }
  }

  // TODO: Everything below this is written as if it has been lifted to the
  // renderers. I'll do this in a follow-up.

  // Linked-list of roots
  var firstScheduledRoot = null;
  var lastScheduledRoot = null;

  var callbackExpirationTime = NoWork;
  var callbackID = -1;
  var isRendering = false;
  var nextFlushedRoot = null;
  var nextFlushedExpirationTime = NoWork;
  var deadlineDidExpire = false;
  var hasUnhandledError = false;
  var unhandledError = null;
  var deadline = null;

  var isBatchingUpdates = false;
  var isUnbatchingUpdates = false;

  // Use these to prevent an infinite loop of nested updates
  var NESTED_UPDATE_LIMIT = 1000;
  var nestedUpdateCount = 0;

  var timeHeuristicForUnitOfWork = 1;

  function scheduleCallbackWithExpiration(expirationTime) {
    if (callbackExpirationTime !== NoWork) {
      // A callback is already scheduled. Check its expiration time (timeout).
      if (expirationTime > callbackExpirationTime) {
        // Existing callback has sufficient timeout. Exit.
        return;
      } else {
        // Existing callback has insufficient timeout. Cancel and schedule a
        // new one.
        cancelDeferredCallback(callbackID);
      }
      // The request callback timer is already running. Don't start a new one.
    } else {
      startRequestCallbackTimer();
    }

    // Compute a timeout for the given expiration time.
    var currentMs = now() - startTime;
    var expirationMs = expirationTimeToMs(expirationTime);
    var timeout = expirationMs - currentMs;

    callbackExpirationTime = expirationTime;
    callbackID = scheduleDeferredCallback(performAsyncWork, { timeout: timeout });
  }

  // requestWork is called by the scheduler whenever a root receives an update.
  // It's up to the renderer to call renderRoot at some point in the future.
  function requestWork(root, expirationTime) {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
      invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');
    }

    // Add the root to the schedule.
    // Check if this root is already part of the schedule.
    if (root.nextScheduledRoot === null) {
      // This root is not already scheduled. Add it.
      root.remainingExpirationTime = expirationTime;
      if (lastScheduledRoot === null) {
        firstScheduledRoot = lastScheduledRoot = root;
        root.nextScheduledRoot = root;
      } else {
        lastScheduledRoot.nextScheduledRoot = root;
        lastScheduledRoot = root;
        lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
      }
    } else {
      // This root is already scheduled, but its priority may have increased.
      var remainingExpirationTime = root.remainingExpirationTime;
      if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {
        // Update the priority.
        root.remainingExpirationTime = expirationTime;
      }
    }

    if (isRendering) {
      // Prevent reentrancy. Remaining work will be scheduled at the end of
      // the currently rendering batch.
      return;
    }

    if (isBatchingUpdates) {
      // Flush work at the end of the batch.
      if (isUnbatchingUpdates) {
        // ...unless we're inside unbatchedUpdates, in which case we should
        // flush it now.
        nextFlushedRoot = root;
        nextFlushedExpirationTime = Sync;
        performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      }
      return;
    }

    // TODO: Get rid of Sync and use current time?
    if (expirationTime === Sync) {
      performWork(Sync, null);
    } else {
      scheduleCallbackWithExpiration(expirationTime);
    }
  }

  function findHighestPriorityRoot() {
    var highestPriorityWork = NoWork;
    var highestPriorityRoot = null;

    if (lastScheduledRoot !== null) {
      var previousScheduledRoot = lastScheduledRoot;
      var root = firstScheduledRoot;
      while (root !== null) {
        var remainingExpirationTime = root.remainingExpirationTime;
        if (remainingExpirationTime === NoWork) {
          // This root no longer has work. Remove it from the scheduler.

          // TODO: This check is redudant, but Flow is confused by the branch
          // below where we set lastScheduledRoot to null, even though we break
          // from the loop right after.
          !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
          if (root === root.nextScheduledRoot) {
            // This is the only root in the list.
            root.nextScheduledRoot = null;
            firstScheduledRoot = lastScheduledRoot = null;
            break;
          } else if (root === firstScheduledRoot) {
            // This is the first root in the list.
            var next = root.nextScheduledRoot;
            firstScheduledRoot = next;
            lastScheduledRoot.nextScheduledRoot = next;
            root.nextScheduledRoot = null;
          } else if (root === lastScheduledRoot) {
            // This is the last root in the list.
            lastScheduledRoot = previousScheduledRoot;
            lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
            root.nextScheduledRoot = null;
            break;
          } else {
            previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;
            root.nextScheduledRoot = null;
          }
          root = previousScheduledRoot.nextScheduledRoot;
        } else {
          if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {
            // Update the priority, if it's higher
            highestPriorityWork = remainingExpirationTime;
            highestPriorityRoot = root;
          }
          if (root === lastScheduledRoot) {
            break;
          }
          previousScheduledRoot = root;
          root = root.nextScheduledRoot;
        }
      }
    }

    // If the next root is the same as the previous root, this is a nested
    // update. To prevent an infinite loop, increment the nested update count.
    var previousFlushedRoot = nextFlushedRoot;
    if (previousFlushedRoot !== null && previousFlushedRoot === highestPriorityRoot) {
      nestedUpdateCount++;
    } else {
      // Reset whenever we switch roots.
      nestedUpdateCount = 0;
    }
    nextFlushedRoot = highestPriorityRoot;
    nextFlushedExpirationTime = highestPriorityWork;
  }

  function performAsyncWork(dl) {
    performWork(NoWork, dl);
  }

  function performWork(minExpirationTime, dl) {
    deadline = dl;

    // Keep working on roots until there's no more work, or until the we reach
    // the deadline.
    findHighestPriorityRoot();

    if (enableUserTimingAPI && deadline !== null) {
      var didExpire = nextFlushedExpirationTime < recalculateCurrentTime();
      stopRequestCallbackTimer(didExpire);
    }

    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || nextFlushedExpirationTime <= minExpirationTime) && !deadlineDidExpire) {
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime);
      // Find the next highest priority work.
      findHighestPriorityRoot();
    }

    // We're done flushing work. Either we ran out of time in this callback,
    // or there's no more work left with sufficient priority.

    // If we're inside a callback, set this to false since we just completed it.
    if (deadline !== null) {
      callbackExpirationTime = NoWork;
      callbackID = -1;
    }
    // If there's work left over, schedule a new callback.
    if (nextFlushedExpirationTime !== NoWork) {
      scheduleCallbackWithExpiration(nextFlushedExpirationTime);
    }

    // Clean-up.
    deadline = null;
    deadlineDidExpire = false;
    nestedUpdateCount = 0;

    if (hasUnhandledError) {
      var _error4 = unhandledError;
      unhandledError = null;
      hasUnhandledError = false;
      throw _error4;
    }
  }

  function performWorkOnRoot(root, expirationTime) {
    !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;

    isRendering = true;

    // Check if this is async work or sync/expired work.
    // TODO: Pass current time as argument to renderRoot, commitRoot
    if (expirationTime <= recalculateCurrentTime()) {
      // Flush sync work.
      var finishedWork = root.finishedWork;
      if (finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(finishedWork);
      } else {
        root.finishedWork = null;
        finishedWork = renderRoot(root, expirationTime);
        if (finishedWork !== null) {
          // We've completed the root. Commit it.
          root.remainingExpirationTime = commitRoot(finishedWork);
        }
      }
    } else {
      // Flush async work.
      var _finishedWork = root.finishedWork;
      if (_finishedWork !== null) {
        // This root is already complete. We can commit it.
        root.finishedWork = null;
        root.remainingExpirationTime = commitRoot(_finishedWork);
      } else {
        root.finishedWork = null;
        _finishedWork = renderRoot(root, expirationTime);
        if (_finishedWork !== null) {
          // We've completed the root. Check the deadline one more time
          // before committing.
          if (!shouldYield()) {
            // Still time left. Commit the root.
            root.remainingExpirationTime = commitRoot(_finishedWork);
          } else {
            // There's no time left. Mark this root as complete. We'll come
            // back and commit it later.
            root.finishedWork = _finishedWork;
          }
        }
      }
    }

    isRendering = false;
  }

  // When working on async work, the reconciler asks the renderer if it should
  // yield execution. For DOM, we implement this with requestIdleCallback.
  function shouldYield() {
    if (deadline === null) {
      return false;
    }
    if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {
      // Disregard deadline.didTimeout. Only expired work should be flushed
      // during a timeout. This path is only hit for non-expired work.
      return false;
    }
    deadlineDidExpire = true;
    return true;
  }

  // TODO: Not happy about this hook. Conceptually, renderRoot should return a
  // tuple of (isReadyForCommit, didError, error)
  function onUncaughtError(error) {
    !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;
    // Unschedule this root so we don't work on it again until there's
    // another update.
    nextFlushedRoot.remainingExpirationTime = NoWork;
    if (!hasUnhandledError) {
      hasUnhandledError = true;
      unhandledError = error;
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function batchedUpdates(fn, a) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return fn(a);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      if (!isBatchingUpdates && !isRendering) {
        performWork(Sync, null);
      }
    }
  }

  // TODO: Batching should be implemented at the renderer level, not inside
  // the reconciler.
  function unbatchedUpdates(fn) {
    if (isBatchingUpdates && !isUnbatchingUpdates) {
      isUnbatchingUpdates = true;
      try {
        return fn();
      } finally {
        isUnbatchingUpdates = false;
      }
    }
    return fn();
  }

  // TODO: Batching should be implemented at the renderer level, not within
  // the reconciler.
  function flushSync(fn) {
    var previousIsBatchingUpdates = isBatchingUpdates;
    isBatchingUpdates = true;
    try {
      return syncUpdates(fn);
    } finally {
      isBatchingUpdates = previousIsBatchingUpdates;
      !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;
      performWork(Sync, null);
    }
  }

  return {
    computeAsyncExpiration: computeAsyncExpiration,
    computeExpirationForFiber: computeExpirationForFiber,
    scheduleWork: scheduleWork,
    batchedUpdates: batchedUpdates,
    unbatchedUpdates: unbatchedUpdates,
    flushSync: flushSync,
    deferredUpdates: deferredUpdates
  };
};

{
  var didWarnAboutNestedUpdates = false;
}

// 0 is PROD, 1 is DEV.
// Might add PROFILE later.


function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);
  return isContextProvider(fiber) ? processChildContext(fiber, parentContext) : parentContext;
}

var ReactFiberReconciler$1 = function (config) {
  var getPublicInstance = config.getPublicInstance;

  var _ReactFiberScheduler = ReactFiberScheduler(config),
      computeAsyncExpiration = _ReactFiberScheduler.computeAsyncExpiration,
      computeExpirationForFiber = _ReactFiberScheduler.computeExpirationForFiber,
      scheduleWork = _ReactFiberScheduler.scheduleWork,
      batchedUpdates = _ReactFiberScheduler.batchedUpdates,
      unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,
      flushSync = _ReactFiberScheduler.flushSync,
      deferredUpdates = _ReactFiberScheduler.deferredUpdates;

  function scheduleTopLevelUpdate(current, element, callback) {
    {
      if (ReactDebugCurrentFiber.phase === 'render' && ReactDebugCurrentFiber.current !== null && !didWarnAboutNestedUpdates) {
        didWarnAboutNestedUpdates = true;
        warning(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(ReactDebugCurrentFiber.current) || 'Unknown');
      }
    }

    callback = callback === undefined ? null : callback;
    {
      warning(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
    }

    var expirationTime = void 0;
    // Check if the top-level element is an async wrapper component. If so,
    // treat updates to the root as async. This is a bit weird but lets us
    // avoid a separate `renderAsync` API.
    if (enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true) {
      expirationTime = computeAsyncExpiration();
    } else {
      expirationTime = computeExpirationForFiber(current);
    }

    var update = {
      expirationTime: expirationTime,
      partialState: { element: element },
      callback: callback,
      isReplace: false,
      isForced: false,
      nextCallback: null,
      next: null
    };
    insertUpdateIntoFiber(current, update);
    scheduleWork(current, expirationTime);
  }

  function findHostInstance(fiber) {
    var hostFiber = findCurrentHostFiber(fiber);
    if (hostFiber === null) {
      return null;
    }
    return hostFiber.stateNode;
  }

  return {
    createContainer: function (containerInfo, hydrate) {
      return createFiberRoot(containerInfo, hydrate);
    },
    updateContainer: function (element, container, parentComponent, callback) {
      // TODO: If this is a nested container, this won't be the root.
      var current = container.current;

      {
        if (ReactFiberInstrumentation_1.debugTool) {
          if (current.alternate === null) {
            ReactFiberInstrumentation_1.debugTool.onMountContainer(container);
          } else if (element === null) {
            ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);
          } else {
            ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);
          }
        }
      }

      var context = getContextForSubtree(parentComponent);
      if (container.context === null) {
        container.context = context;
      } else {
        container.pendingContext = context;
      }

      scheduleTopLevelUpdate(current, element, callback);
    },


    batchedUpdates: batchedUpdates,

    unbatchedUpdates: unbatchedUpdates,

    deferredUpdates: deferredUpdates,

    flushSync: flushSync,

    getPublicRootInstance: function (container) {
      var containerFiber = container.current;
      if (!containerFiber.child) {
        return null;
      }
      switch (containerFiber.child.tag) {
        case HostComponent:
          return getPublicInstance(containerFiber.child.stateNode);
        default:
          return containerFiber.child.stateNode;
      }
    },


    findHostInstance: findHostInstance,

    findHostInstanceWithNoPortals: function (fiber) {
      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
      if (hostFiber === null) {
        return null;
      }
      return hostFiber.stateNode;
    },
    injectIntoDevTools: function (devToolsConfig) {
      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;

      return injectInternals(_assign({}, devToolsConfig, {
        findHostInstanceByFiber: function (fiber) {
          return findHostInstance(fiber);
        },
        findFiberByHostInstance: function (instance) {
          if (!findFiberByHostInstance) {
            // Might not be implemented by the renderer.
            return null;
          }
          return findFiberByHostInstance(instance);
        }
      }));
    }
  };
};

var ReactFiberReconciler$2 = Object.freeze({
	default: ReactFiberReconciler$1
});

var ReactFiberReconciler$3 = ( ReactFiberReconciler$2 && ReactFiberReconciler$1 ) || ReactFiberReconciler$2;

// TODO: bundle Flow types with the package.



// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler = ReactFiberReconciler$3['default'] ? ReactFiberReconciler$3['default'] : ReactFiberReconciler$3;

function createPortal$1(children, containerInfo,
// TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

// TODO: this is special because it gets imported during build.

var ReactVersion = '16.2.0';

// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.

{
  if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {
    warning(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

var now = void 0;
if (hasNativePerformanceNow) {
  now = function () {
    return performance.now();
  };
} else {
  now = function () {
    return Date.now();
  };
}

// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC = void 0;
var cIC = void 0;

if (!ExecutionEnvironment.canUseDOM) {
  rIC = function (frameCallback) {
    return setTimeout(function () {
      frameCallback({
        timeRemaining: function () {
          return Infinity;
        }
      });
    });
  };
  cIC = function (timeoutID) {
    clearTimeout(timeoutID);
  };
} else if (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {
  // Polyfill requestIdleCallback and cancelIdleCallback

  var scheduledRICCallback = null;
  var isIdleScheduled = false;
  var timeoutTime = -1;

  var isAnimationFrameScheduled = false;

  var frameDeadline = 0;
  // We start out assuming that we run at 30fps but then the heuristic tracking
  // will adjust this value to a faster fps if we get more frequent animation
  // frames.
  var previousFrameTime = 33;
  var activeFrameTime = 33;

  var frameDeadlineObject;
  if (hasNativePerformanceNow) {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // We assume that if we have a performance timer that the rAF callback
        // gets a performance timer value. Not sure if this is always true.
        var remaining = frameDeadline - performance.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  } else {
    frameDeadlineObject = {
      didTimeout: false,
      timeRemaining: function () {
        // Fallback to Date.now()
        var remaining = frameDeadline - Date.now();
        return remaining > 0 ? remaining : 0;
      }
    };
  }

  // We use the postMessage trick to defer idle work until after the repaint.
  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);
  var idleTick = function (event) {
    if (event.source !== window || event.data !== messageKey) {
      return;
    }

    isIdleScheduled = false;

    var currentTime = now();
    if (frameDeadline - currentTime <= 0) {
      // There's no time left in this idle period. Check if the callback has
      // a timeout and whether it's been exceeded.
      if (timeoutTime !== -1 && timeoutTime <= currentTime) {
        // Exceeded the timeout. Invoke the callback even though there's no
        // time left.
        frameDeadlineObject.didTimeout = true;
      } else {
        // No timeout.
        if (!isAnimationFrameScheduled) {
          // Schedule another animation callback so we retry later.
          isAnimationFrameScheduled = true;
          requestAnimationFrame(animationTick);
        }
        // Exit without invoking the callback.
        return;
      }
    } else {
      // There's still time left in this idle period.
      frameDeadlineObject.didTimeout = false;
    }

    timeoutTime = -1;
    var callback = scheduledRICCallback;
    scheduledRICCallback = null;
    if (callback !== null) {
      callback(frameDeadlineObject);
    }
  };
  // Assumes that we have addEventListener in this environment. Might need
  // something better for old IE.
  window.addEventListener('message', idleTick, false);

  var animationTick = function (rafTime) {
    isAnimationFrameScheduled = false;
    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;
    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
      if (nextFrameTime < 8) {
        // Defensive coding. We don't support higher frame rates than 120hz.
        // If we get lower than that, it is probably a bug.
        nextFrameTime = 8;
      }
      // If one frame goes long, then the next one can be short to catch up.
      // If two frames are short in a row, then that's an indication that we
      // actually have a higher frame rate than what we're currently optimizing.
      // We adjust our heuristic dynamically accordingly. For example, if we're
      // running on 120hz display or 90hz VR display.
      // Take the max of the two in case one of them was an anomaly due to
      // missed frame deadlines.
      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
    } else {
      previousFrameTime = nextFrameTime;
    }
    frameDeadline = rafTime + activeFrameTime;
    if (!isIdleScheduled) {
      isIdleScheduled = true;
      window.postMessage(messageKey, '*');
    }
  };

  rIC = function (callback, options) {
    // This assumes that we only schedule one callback at a time because that's
    // how Fiber uses it.
    scheduledRICCallback = callback;
    if (options != null && typeof options.timeout === 'number') {
      timeoutTime = now() + options.timeout;
    }
    if (!isAnimationFrameScheduled) {
      // If rAF didn't already schedule one, we need to schedule a frame.
      // TODO: If this rAF doesn't materialize because the browser throttles, we
      // might want to still have setTimeout trigger rIC as a backup to ensure
      // that we keep performing work.
      isAnimationFrameScheduled = true;
      requestAnimationFrame(animationTick);
    }
    return 0;
  };

  cIC = function () {
    scheduledRICCallback = null;
    isIdleScheduled = false;
    timeoutTime = -1;
  };
} else {
  rIC = window.requestIdleCallback;
  cIC = window.cancelIdleCallback;
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  {
    warning(false, 'Invalid attribute name: `%s`', attributeName);
  }
  return false;
}

// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */





/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected) {
  {
    var propertyInfo = getPropertyInfo(name);
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod || propertyInfo.mustUseProperty) {
        return node[propertyInfo.propertyName];
      } else {
        var attributeName = propertyInfo.attributeName;

        var stringValue = null;

        if (propertyInfo.hasOverloadedBooleanValue) {
          if (node.hasAttribute(attributeName)) {
            var value = node.getAttribute(attributeName);
            if (value === '') {
              return true;
            }
            if (shouldIgnoreValue(propertyInfo, expected)) {
              return value;
            }
            if (value === '' + expected) {
              return expected;
            }
            return value;
          }
        } else if (node.hasAttribute(attributeName)) {
          if (shouldIgnoreValue(propertyInfo, expected)) {
            // We had an attribute but shouldn't have had one, so read it
            // for the error message.
            return node.getAttribute(attributeName);
          }
          if (propertyInfo.hasBooleanValue) {
            // If this was a boolean, it doesn't matter what the value is
            // the fact that we have it is the same as the expected.
            return expected;
          }
          // Even if this property uses a namespace we use getAttribute
          // because we assume its namespaced name is the same as our config.
          // To use getAttributeNS we need the local name which we don't have
          // in our config atm.
          stringValue = node.getAttribute(attributeName);
        }

        if (shouldIgnoreValue(propertyInfo, expected)) {
          return stringValue === null ? expected : stringValue;
        } else if (stringValue === '' + expected) {
          return expected;
        } else {
          return stringValue;
        }
      }
    }
  }
}

/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */
function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }
    var value = node.getAttribute(name);
    if (value === '' + expected) {
      return expected;
    }
    return value;
  }
}

/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */
function setValueForProperty(node, name, value) {
  var propertyInfo = getPropertyInfo(name);

  if (propertyInfo && shouldSetAttribute(name, value)) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, value);
    } else if (shouldIgnoreValue(propertyInfo, value)) {
      deleteValueForProperty(node, name);
      return;
    } else if (propertyInfo.mustUseProperty) {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyInfo.propertyName] = value;
    } else {
      var attributeName = propertyInfo.attributeName;
      var namespace = propertyInfo.attributeNamespace;
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      if (namespace) {
        node.setAttributeNS(namespace, attributeName, '' + value);
      } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        node.setAttribute(attributeName, '');
      } else {
        node.setAttribute(attributeName, '' + value);
      }
    }
  } else {
    setValueForAttribute(node, name, shouldSetAttribute(name, value) ? value : null);
    return;
  }

  {
    
  }
}

function setValueForAttribute(node, name, value) {
  if (!isAttributeNameSafe(name)) {
    return;
  }
  if (value == null) {
    node.removeAttribute(name);
  } else {
    node.setAttribute(name, '' + value);
  }

  {
    
  }
}

/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForAttribute(node, name) {
  node.removeAttribute(name);
}

/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */
function deleteValueForProperty(node, name) {
  var propertyInfo = getPropertyInfo(name);
  if (propertyInfo) {
    var mutationMethod = propertyInfo.mutationMethod;
    if (mutationMethod) {
      mutationMethod(node, undefined);
    } else if (propertyInfo.mustUseProperty) {
      var propName = propertyInfo.propertyName;
      if (propertyInfo.hasBooleanValue) {
        node[propName] = false;
      } else {
        node[propName] = '';
      }
    } else {
      node.removeAttribute(propertyInfo.attributeName);
    }
  } else {
    node.removeAttribute(name);
  }
}

var ReactControlledValuePropTypes = {
  checkPropTypes: null
};

{
  var hasReadOnlyValue = {
    button: true,
    checkbox: true,
    image: true,
    hidden: true,
    radio: true,
    reset: true,
    submit: true
  };

  var propTypes = {
    value: function (props, propName, componentName) {
      if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    },
    checked: function (props, propName, componentName) {
      if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
        return null;
      }
      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  };

  /**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */
  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {
    checkPropTypes(propTypes, props, 'prop', tagName, getStack);
  };
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$3 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */

function getHostProps(element, props) {
  var node = element;
  var value = props.value;
  var checked = props.checked;

  var hostProps = _assign({
    // Make sure we set .type before any other properties (setting .value
    // before .type means .value is lost in IE11 and below)
    type: undefined,
    // Make sure we set .step before .value (setting .value before .step
    // means .value is rounded on mount, based upon step precision)
    step: undefined,
    // Make sure we set .min & .max before .value (to ensure proper order
    // in corner cases such as min or max deriving from value, e.g. Issue #7170)
    min: undefined,
    max: undefined
  }, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: value != null ? value : node._wrapperState.initialValue,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}

function initWrapperState(element, props) {
  {
    ReactControlledValuePropTypes.checkPropTypes('input', props, getCurrentFiberStackAddendum$3);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnCheckedDefaultChecked = true;
    }
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$2() || 'A component', props.type);
      didWarnValueDefaultValue = true;
    }
  }

  var defaultValue = props.defaultValue;
  var node = element;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: props.value != null ? props.value : defaultValue,
    controlled: isControlled(props)
  };
}

function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;
  if (checked != null) {
    setValueForProperty(node, 'checked', checked);
  }
}

function updateWrapper(element, props) {
  var node = element;
  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      warning(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnUncontrolledToControlled = true;
    }
    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      warning(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$3());
      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);

  var value = props.value;
  if (value != null) {
    if (value === 0 && node.value === '') {
      node.value = '0';
      // Note: IE9 reports a number inputs as 'text', so check props instead.
    } else if (props.type === 'number') {
      // Simulate `input.valueAsNumber`. IE9 does not support it
      var valueAsNumber = parseFloat(node.value) || 0;

      if (
      // eslint-disable-next-line
      value != valueAsNumber ||
      // eslint-disable-next-line
      value == valueAsNumber && node.value != value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else if (node.value !== '' + value) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      node.value = '' + value;
    }
  } else {
    if (props.value == null && props.defaultValue != null) {
      // In Chrome, assigning defaultValue to certain input types triggers input validation.
      // For number inputs, the display value loses trailing decimal points. For email inputs,
      // Chrome raises "The specified value <x> is not a valid email address".
      //
      // Here we check to see if the defaultValue has actually changed, avoiding these problems
      // when the user is inputting text
      //
      // https://github.com/facebook/react/issues/7253
      if (node.defaultValue !== '' + props.defaultValue) {
        node.defaultValue = '' + props.defaultValue;
      }
    }
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}

function postMountWrapper(element, props) {
  var node = element;

  // Detach value from defaultValue. We won't do anything if we're working on
  // submit or reset inputs as those values & defaultValues are linked. They
  // are not resetable nodes so this operation doesn't matter and actually
  // removes browser-default values (eg "Submit Query") when no value is
  // provided.

  switch (props.type) {
    case 'submit':
    case 'reset':
      break;
    case 'color':
    case 'date':
    case 'datetime':
    case 'datetime-local':
    case 'month':
    case 'time':
    case 'week':
      // This fixes the no-show issue on iOS Safari and Android Chrome:
      // https://github.com/facebook/react/issues/7233
      node.value = '';
      node.value = node.defaultValue;
      break;
    default:
      node.value = node.value;
      break;
  }

  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.
  var name = node.name;
  if (name !== '') {
    node.name = '';
  }
  node.defaultChecked = !node.defaultChecked;
  node.defaultChecked = !node.defaultChecked;
  if (name !== '') {
    node.name = name;
  }
}

function restoreControlledState$1(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);
      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;

      // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set
      updateValueIfChanged(otherNode);

      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      updateWrapper(otherNode, otherProps);
    }
  }
}

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  // We can silently skip them because invalid DOM nesting warning
  // catches these cases in Fiber.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */

function validateProps(element, props) {
  // TODO (yungsters): Remove support for `selected` in <option>.
  {
    warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');
  }
}

function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', props.value);
  }
}

function getHostProps$1(element, props) {
  var hostProps = _assign({ children: undefined }, props);
  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$4 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;


{
  var didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerName$3();
  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 */
function checkSelectPropTypes(props) {
  ReactControlledValuePropTypes.checkPropTypes('select', props, getCurrentFiberStackAddendum$4);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
    } else if (!props.multiple && isArray) {
      warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};
    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }
    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);
      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }
      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = '' + propValue;
    var defaultSelected = null;
    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;
        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }
        return;
      }
      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }
    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */

function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}

function initWrapperState$1(element, props) {
  var node = element;
  {
    checkSelectPropTypes(props);
  }

  var value = props.value;
  node._wrapperState = {
    initialValue: value != null ? value : props.defaultValue,
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValueDefaultValue$1 = true;
    }
  }
}

function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}

function postUpdateWrapper(element, props) {
  var node = element;
  // After the initial mount, we control selected-ness manually so don't pass
  // this value down
  node._wrapperState.initialValue = undefined;

  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;

  var value = props.value;
  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}

function restoreControlledState$2(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */

function getHostProps$3(element, props) {
  var node = element;
  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;

  // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.
  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: '' + node._wrapperState.initialValue
  });

  return hostProps;
}

function initWrapperState$2(element, props) {
  var node = element;
  {
    ReactControlledValuePropTypes.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$5);
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');
      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value;

  // Only bother fetching default value if we're going to use it
  if (initialValue == null) {
    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      {
        warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }
      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: '' + initialValue
  };
}

function updateWrapper$1(element, props) {
  var node = element;
  var value = props.value;
  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = '' + value;

    // To avoid side effects (such as losing text selection), only set value if changed
    if (newValue !== node.value) {
      node.value = newValue;
    }
    if (props.defaultValue == null) {
      node.defaultValue = newValue;
    }
  }
  if (props.defaultValue != null) {
    node.defaultValue = props.defaultValue;
  }
}

function postMountWrapper$3(element, props) {
  var node = element;
  // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.
  var textContent = node.textContent;

  // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
  if (textContent === node._wrapperState.initialValue) {
    node.value = textContent;
  }
}

function restoreControlledState$3(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

var Namespaces = {
  html: HTML_NAMESPACE$1,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
};

// Assumes there is no parent namespace.
function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;
    case 'math':
      return MATH_NAMESPACE;
    default:
      return HTML_NAMESPACE$1;
  }
}

function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }
  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE$1;
  }
  // By default, pass namespace below.
  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer = void 0;

/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node

  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var warnValidStyle = emptyFunction;

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var warnHyphenatedStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), getStack());
  };

  var warnBadVendoredStyleName = function (name, getStack) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), getStack());
  };

  var warnStyleValueWithSemicolon = function (name, value, getStack) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    warning(false, "Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.%s', name, value.replace(badStyleValueWithSemicolonPattern, ''), getStack());
  };

  var warnStyleValueIsNaN = function (name, value, getStack) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  var warnStyleValueIsInfinity = function (name, value, getStack) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;
    warning(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, getStack());
  };

  warnValidStyle = function (name, value, getStack) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, getStack);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, getStack);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, getStack);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value, getStack);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value, getStack);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */
function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + hyphenateStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);

        delimiter = ';';
      }
    }
    return serialized || null;
  }
}

/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */
function setValueForStyles(node, styles, getStack) {
  var style = node.style;
  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }
    var isCustomProperty = styleName.indexOf('--') === 0;
    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName], getStack);
      }
    }
    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
    if (styleName === 'float') {
      styleName = 'cssFloat';
    }
    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML$1 = '__html';

function assertValidProps(tag, props, getStack) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getStack()) : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;
  }
  {
    warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.%s', getStack());
  }
  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getStack()) : void 0;
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }
  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this whitelist too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;
    default:
      return true;
  }
}

var ariaProperties = {
  'aria-current': 0, // state
  'aria-details': 0,
  'aria-disabled': 0, // state
  'aria-hidden': 0, // state
  'aria-invalid': 0, // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

var hasOwnProperty = Object.prototype.hasOwnProperty;

function getStackAddendum() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperty(tagName, name) {
  if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
    return true;
  }

  if (rARIACamel.test(name)) {
    var ariaName = 'aria-' + name.slice(4).toLowerCase();
    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (correctName == null) {
      warning(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== correctName) {
      warning(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      warning(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum());
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  var invalidProps = [];

  for (var key in props) {
    var isValid = validateProperty(type, key);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  } else if (invalidProps.length > 1) {
    warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum());
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;

function getStackAddendum$1() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

function validateProperties$1(type, props) {
  if (type !== 'input' && type !== 'textarea' && type !== 'select') {
    return;
  }

  if (props != null && props.value === null && !didWarnValueNull) {
    didWarnValueNull = true;
    if (type === 'select' && props.multiple) {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.%s', type, getStackAddendum$1());
    } else {
      warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1());
    }
  }
}

// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  'class': 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  'default': 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  'for': 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',

  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  'in': 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  'typeof': 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

function getStackAddendum$2() {
  var stack = ReactDebugCurrentFrame.getStackAddendum();
  return stack != null ? stack : '';
}

{
  var warnedProperties$1 = {};
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  var validateProperty$1 = function (tagName, name, value, canUseEventSystem) {
    if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();
    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      warning(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');
      warnedProperties$1[name] = true;
      return true;
    }

    // We can't rely on the event system being injected on the server.
    if (canUseEventSystem) {
      if (registrationNameModules.hasOwnProperty(name)) {
        return true;
      }
      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
      if (registrationName != null) {
        warning(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
      if (EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        warning(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.%s', name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Let the ARIA attribute hook validate ARIA attributes
    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      warning(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      warning(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');
      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      warning(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      warning(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    var isReserved = isReservedProp(name);

    // Known attributes should match the casing specified in the property config.
    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];
      if (standardName !== name) {
        warning(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2());
        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      warning(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2());
      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && !shouldAttributeAcceptBooleanValue(name)) {
      if (value) {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.%s', value, name, name, value, name, getStackAddendum$2());
      } else {
        warning(false, 'Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', value, name, name, value, name, name, name, getStackAddendum$2());
      }
      warnedProperties$1[name] = true;
      return true;
    }

    // Now that we've validated casing, do not validate
    // data types for reserved props
    if (isReserved) {
      return true;
    }

    // Warn when a known attribute is a bad type
    if (!shouldSetAttribute(name, value)) {
      warnedProperties$1[name] = true;
      return false;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, canUseEventSystem) {
  var unknownProps = [];
  for (var key in props) {
    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');
  if (unknownProps.length === 1) {
    warning(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  } else if (unknownProps.length > 1) {
    warning(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2());
  }
};

function validateProperties$2(type, props, canUseEventSystem) {
  if (isCustomComponent(type, props)) {
    return;
  }
  warnUnknownProperties(type, props, canUseEventSystem);
}

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1 = ReactDebugCurrentFiber.getCurrentFiberOwnerName;
var getCurrentFiberStackAddendum$2 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var didWarnInvalidHydration = false;
var didWarnShadyDOM = false;

var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML = '__html';

var HTML_NAMESPACE = Namespaces.html;


var getStack = emptyFunction.thatReturns('');

{
  getStack = getCurrentFiberStackAddendum$2;

  var warnedUnknownTags = {
    // Chrome is the only major browser not shipping <time>. But as of July
    // 2017 it intends to ship it due to widespread usage. We intentionally
    // *don't* warn for <time> even if it's unrecognized by Chrome because
    // it soon will be, and many apps have been using it anyway.
    time: true,
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true
  };

  var validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, /* canUseEventSystem */true);
  };

  // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  var normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  var warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
    if (normalizedServerText === normalizedClientText) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  var warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }
    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
    if (normalizedServerValue === normalizedClientValue) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  var warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });
    warning(false, 'Extra attributes from the server: %s', names);
  };

  var warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      warning(false, 'Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.%s', registrationName, registrationName, registrationName, getCurrentFiberStackAddendum$2());
    } else {
      warning(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum$2());
    }
  };

  // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.
  var normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function ensureListeningTo(rootContainerElement, registrationName) {
  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;
  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;
  listenTo(registrationName, doc);
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = emptyFunction;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = nextProps[propKey];
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      // Relies on `updateStylesByID` not mutating `styleUpdates`.
      setValueForStyles(domElement, nextProp, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';
        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // We polyfill it separately on the client during commit.
      // We blacklist it here rather than in the property list because we emit it in SSR.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else if (isCustomComponentTag) {
      setValueForAttribute(domElement, propKey, nextProp);
    } else if (nextProp != null) {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      setValueForProperty(domElement, propKey, nextProp);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];
    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue, getStack);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else if (isCustomComponentTag) {
      if (propValue != null) {
        setValueForAttribute(domElement, propKey, propValue);
      } else {
        deleteValueForAttribute(domElement, propKey);
      }
    } else if (propValue != null) {
      setValueForProperty(domElement, propKey, propValue);
    } else {
      // If we're updating to null or undefined, we should remove the property
      // from the DOM node instead of inadvertently setting to a string. This
      // brings us in line with the same behavior we have on initial render.
      deleteValueForProperty(domElement, propKey);
    }
  }
}

function createElement$1(type, props, rootContainerElement, parentNamespace) {
  // We create tags in the namespace of their parent container, except HTML
  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;
  if (namespaceURI === HTML_NAMESPACE) {
    namespaceURI = getIntrinsicNamespace(type);
  }
  if (namespaceURI === HTML_NAMESPACE) {
    {
      var isCustomComponentTag = isCustomComponent(type, props);
      // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.
      warning(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');
      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.
      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, { is: props.is });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type);
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;
        warning(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}

function createTextNode$1(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}

function setInitialProperties$1(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);
  {
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  var props;
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      props = rawProps;
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      props = rawProps;
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      props = rawProps;
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      props = rawProps;
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      props = rawProps;
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    default:
      props = rawProps;
  }

  assertValidProps(tag, props, getStack);

  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;
    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;
    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }
}

// Calculate the diff between the two objects.
function diffProperties$1(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;

  var lastProps;
  var nextProps;
  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;
    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;
    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;
      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  assertValidProps(tag, nextProps, getStack);

  var propKey;
  var styleName;
  var styleUpdates = null;
  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }
    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];
      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }
          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
      // Noop. This is handled by the clear text mechanism.
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (propKey === AUTOFOCUS) {
      // Noop. It doesn't work on updates anyway.
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the whitelist in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }
  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;
    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }
    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }
      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = '';
          }
        }
        // Update styles that changed since `lastProp`.
        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }
            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }
          updatePayload.push(propKey, styleUpdates);
        }
        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML] : undefined;
      var lastHtml = lastProp ? lastProp[HTML] : undefined;
      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);
        }
      } else {
        // TODO: It might be too late to clear this if we have children
        // inserted already.
      }
    } else if (propKey === CHILDREN) {
      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {
      // Noop
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the whitelist during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }
  if (styleUpdates) {
    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }
  return updatePayload;
}

// Apply the diff.
function updateProperties$1(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
  // Apply the diff.
  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);

  // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.
  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;
    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;
    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function diffHydratedProperties$1(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  {
    var suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;
    var isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {
      warning(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName$1() || 'A component');
      didWarnShadyDOM = true;
    }
  }

  // TODO: Make sure that we check isMounted before firing any of these events.
  switch (tag) {
    case 'iframe':
    case 'object':
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'video':
    case 'audio':
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          trapBubbledEvent(event, mediaEvents[event], domElement);
        }
      }
      break;
    case 'source':
      trapBubbledEvent('topError', 'error', domElement);
      break;
    case 'img':
    case 'image':
      trapBubbledEvent('topError', 'error', domElement);
      trapBubbledEvent('topLoad', 'load', domElement);
      break;
    case 'form':
      trapBubbledEvent('topReset', 'reset', domElement);
      trapBubbledEvent('topSubmit', 'submit', domElement);
      break;
    case 'details':
      trapBubbledEvent('topToggle', 'toggle', domElement);
      break;
    case 'input':
      initWrapperState(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'option':
      validateProps(domElement, rawProps);
      break;
    case 'select':
      initWrapperState$1(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      trapBubbledEvent('topInvalid', 'invalid', domElement);
      // For controlled components we always need to ensure we're listening
      // to onChange. Even if there is no listener.
      ensureListeningTo(rootContainerElement, 'onChange');
      break;
  }

  assertValidProps(tag, rawProps, getStack);

  {
    var extraAttributeNames = new Set();
    var attributes = domElement.attributes;
    for (var i = 0; i < attributes.length; i++) {
      var name = attributes[i].name.toLowerCase();
      switch (name) {
        // Built-in SSR attribute is whitelisted
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.
        case 'value':
          break;
        case 'checked':
          break;
        case 'selected':
          break;
        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[i].name);
      }
    }
  }

  var updatePayload = null;
  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }
    var nextProp = rawProps[propKey];
    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if (true && !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }
          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameModules.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if (true && typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }
        ensureListeningTo(rootContainerElement, propKey);
      }
    } else {
      // Validate that the properties correspond to their expected values.
      var serverValue;
      var propertyInfo;
      if (suppressHydrationWarning) {
        // Don't bother comparing. We're ignoring all these warnings.
      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||
      // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {
        // Noop
      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var rawHtml = nextProp ? nextProp[HTML] || '' : '';
        var serverHTML = domElement.innerHTML;
        var expectedHTML = normalizeHTML(domElement, rawHtml);
        if (expectedHTML !== serverHTML) {
          warnForPropDifference(propKey, serverHTML, expectedHTML);
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey);
        var expectedStyle = createDangerousStringForStyles(nextProp);
        serverValue = domElement.getAttribute('style');
        if (expectedStyle !== serverValue) {
          warnForPropDifference(propKey, serverValue, expectedStyle);
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames['delete'](propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (shouldSetAttribute(propKey, nextProp)) {
        if (propertyInfo = getPropertyInfo(propKey)) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames['delete'](propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp);
        } else {
          var ownNamespace = parentNamespace;
          if (ownNamespace === HTML_NAMESPACE) {
            ownNamespace = getIntrinsicNamespace(tag);
          }
          if (ownNamespace === HTML_NAMESPACE) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey.toLowerCase());
          } else {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames['delete'](propKey);
          }
          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps);
      break;
    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement, rawProps);
      break;
    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;
    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }
      break;
  }

  return updatePayload;
}

function diffHydratedText$1(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}

function warnForUnmatchedText$1(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}

function warnForDeletedHydratableElement$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}

function warnForDeletedHydratableText$1(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedElement$1(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}

function warnForInsertedHydratedText$1(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }
    if (didWarnInvalidHydration) {
      return;
    }
    didWarnInvalidHydration = true;
    warning(false, 'Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}

function restoreControlledState(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState$1(domElement, props);
      return;
    case 'textarea':
      restoreControlledState$3(domElement, props);
      return;
    case 'select':
      restoreControlledState$2(domElement, props);
      return;
  }
}

var ReactDOMFiberComponent = Object.freeze({
	createElement: createElement$1,
	createTextNode: createTextNode$1,
	setInitialProperties: setInitialProperties$1,
	diffProperties: diffProperties$1,
	updateProperties: updateProperties$1,
	diffHydratedProperties: diffHydratedProperties$1,
	diffHydratedText: diffHydratedText$1,
	warnForUnmatchedText: warnForUnmatchedText$1,
	warnForDeletedHydratableElement: warnForDeletedHydratableElement$1,
	warnForDeletedHydratableText: warnForDeletedHydratableText$1,
	warnForInsertedHydratedElement: warnForInsertedHydratedElement$1,
	warnForInsertedHydratedText: warnForInsertedHydratedText$1,
	restoreControlledState: restoreControlledState
});

// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6 = ReactDebugCurrentFiber.getCurrentFiberStackAddendum;

var validateDOMNesting = emptyFunction;

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo$1 = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;
    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var addendum = getCurrentFiberStackAddendum$6();

    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;
    if (didWarn[warnKey]) {
      return;
    }
    didWarn[warnKey] = true;

    var tagDisplayName = childTag;
    var whitespaceInfo = '';
    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';
      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
      }
      warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);
    } else {
      warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);
    }
  };

  // TODO: turn this into a named export
  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo$1;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

var validateDOMNesting$1 = validateDOMNesting;

// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement = createElement$1;
var createTextNode = createTextNode$1;
var setInitialProperties = setInitialProperties$1;
var diffProperties = diffProperties$1;
var updateProperties = updateProperties$1;
var diffHydratedProperties = diffHydratedProperties$1;
var diffHydratedText = diffHydratedText$1;
var warnForUnmatchedText = warnForUnmatchedText$1;
var warnForDeletedHydratableElement = warnForDeletedHydratableElement$1;
var warnForDeletedHydratableText = warnForDeletedHydratableText$1;
var warnForInsertedHydratedElement = warnForInsertedHydratedElement$1;
var warnForInsertedHydratedText = warnForInsertedHydratedText$1;
var updatedAncestorInfo = validateDOMNesting$1.updatedAncestorInfo;
var precacheFiberNode = precacheFiberNode$1;
var updateFiberProps = updateFiberProps$1;


{
  var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
  if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');
  }
}

injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);

var eventsEnabled = null;
var selectionInformation = null;

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }
  return false;
}

var DOMRenderer = reactReconciler({
  getRootHostContext: function (rootContainerInstance) {
    var type = void 0;
    var namespace = void 0;
    var nodeType = rootContainerInstance.nodeType;
    switch (nodeType) {
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        {
          type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
          var root = rootContainerInstance.documentElement;
          namespace = root ? root.namespaceURI : getChildNamespace(null, '');
          break;
        }
      default:
        {
          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
          var ownNamespace = container.namespaceURI || null;
          type = container.tagName;
          namespace = getChildNamespace(ownNamespace, type);
          break;
        }
    }
    {
      var validatedTag = type.toLowerCase();
      var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);
      return { namespace: namespace, ancestorInfo: _ancestorInfo };
    }
    return namespace;
  },
  getChildHostContext: function (parentHostContext, type) {
    {
      var parentHostContextDev = parentHostContext;
      var _namespace = getChildNamespace(parentHostContextDev.namespace, type);
      var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);
      return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };
    }
    var parentNamespace = parentHostContext;
    return getChildNamespace(parentNamespace, type);
  },
  getPublicInstance: function (instance) {
    return instance;
  },
  prepareForCommit: function () {
    eventsEnabled = isEnabled();
    selectionInformation = getSelectionInformation();
    setEnabled(false);
  },
  resetAfterCommit: function () {
    restoreSelection(selectionInformation);
    selectionInformation = null;
    setEnabled(eventsEnabled);
    eventsEnabled = null;
  },
  createInstance: function (type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
    var parentNamespace = void 0;
    {
      // TODO: take namespace into account when validating.
      var hostContextDev = hostContext;
      validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);
      if (typeof props.children === 'string' || typeof props.children === 'number') {
        var string = '' + props.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
      parentNamespace = hostContextDev.namespace;
    }
    var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
    precacheFiberNode(internalInstanceHandle, domElement);
    updateFiberProps(domElement, props);
    return domElement;
  },
  appendInitialChild: function (parentInstance, child) {
    parentInstance.appendChild(child);
  },
  finalizeInitialChildren: function (domElement, type, props, rootContainerInstance) {
    setInitialProperties(domElement, type, props, rootContainerInstance);
    return shouldAutoFocusHostComponent(type, props);
  },
  prepareUpdate: function (domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
    {
      var hostContextDev = hostContext;
      if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
        var string = '' + newProps.children;
        var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);
        validateDOMNesting$1(null, string, ownAncestorInfo);
      }
    }
    return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);
  },
  shouldSetTextContent: function (type, props) {
    return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';
  },
  shouldDeprioritizeSubtree: function (type, props) {
    return !!props.hidden;
  },
  createTextInstance: function (text, rootContainerInstance, hostContext, internalInstanceHandle) {
    {
      var hostContextDev = hostContext;
      validateDOMNesting$1(null, text, hostContextDev.ancestorInfo);
    }
    var textNode = createTextNode(text, rootContainerInstance);
    precacheFiberNode(internalInstanceHandle, textNode);
    return textNode;
  },


  now: now,

  mutation: {
    commitMount: function (domElement, type, newProps, internalInstanceHandle) {
      domElement.focus();
    },
    commitUpdate: function (domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
      // Update the props handle so that we know which props are the ones with
      // with current event handlers.
      updateFiberProps(domElement, newProps);
      // Apply the diff to the DOM node.
      updateProperties(domElement, updatePayload, type, oldProps, newProps);
    },
    resetTextContent: function (domElement) {
      domElement.textContent = '';
    },
    commitTextUpdate: function (textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    },
    appendChild: function (parentInstance, child) {
      parentInstance.appendChild(child);
    },
    appendChildToContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, container);
      } else {
        container.appendChild(child);
      }
    },
    insertBefore: function (parentInstance, child, beforeChild) {
      parentInstance.insertBefore(child, beforeChild);
    },
    insertInContainerBefore: function (container, child, beforeChild) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.insertBefore(child, beforeChild);
      } else {
        container.insertBefore(child, beforeChild);
      }
    },
    removeChild: function (parentInstance, child) {
      parentInstance.removeChild(child);
    },
    removeChildFromContainer: function (container, child) {
      if (container.nodeType === COMMENT_NODE) {
        container.parentNode.removeChild(child);
      } else {
        container.removeChild(child);
      }
    }
  },

  hydration: {
    canHydrateInstance: function (instance, type, props) {
      if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
        return null;
      }
      // This has now been refined to an element node.
      return instance;
    },
    canHydrateTextInstance: function (instance, text) {
      if (text === '' || instance.nodeType !== TEXT_NODE) {
        // Empty strings are not parsed by HTML so there won't be a correct match here.
        return null;
      }
      // This has now been refined to a text node.
      return instance;
    },
    getNextHydratableSibling: function (instance) {
      var node = instance.nextSibling;
      // Skip non-hydratable nodes.
      while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {
        node = node.nextSibling;
      }
      return node;
    },
    getFirstHydratableChild: function (parentInstance) {
      var next = parentInstance.firstChild;
      // Skip non-hydratable nodes.
      while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {
        next = next.nextSibling;
      }
      return next;
    },
    hydrateInstance: function (instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, instance);
      // TODO: Possibly defer this until the commit phase where all the events
      // get attached.
      updateFiberProps(instance, props);
      var parentNamespace = void 0;
      {
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
      }
      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);
    },
    hydrateTextInstance: function (textInstance, text, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, textInstance);
      return diffHydratedText(textInstance, text);
    },
    didNotMatchHydratedContainerTextInstance: function (parentContainer, textInstance, text) {
      {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotMatchHydratedTextInstance: function (parentType, parentProps, parentInstance, textInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForUnmatchedText(textInstance, text);
      }
    },
    didNotHydrateContainerInstance: function (parentContainer, instance) {
      {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentContainer, instance);
        } else {
          warnForDeletedHydratableText(parentContainer, instance);
        }
      }
    },
    didNotHydrateInstance: function (parentType, parentProps, parentInstance, instance) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        if (instance.nodeType === 1) {
          warnForDeletedHydratableElement(parentInstance, instance);
        } else {
          warnForDeletedHydratableText(parentInstance, instance);
        }
      }
    },
    didNotFindHydratableContainerInstance: function (parentContainer, type, props) {
      {
        warnForInsertedHydratedElement(parentContainer, type, props);
      }
    },
    didNotFindHydratableContainerTextInstance: function (parentContainer, text) {
      {
        warnForInsertedHydratedText(parentContainer, text);
      }
    },
    didNotFindHydratableInstance: function (parentType, parentProps, parentInstance, type, props) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedElement(parentInstance, type, props);
      }
    },
    didNotFindHydratableTextInstance: function (parentType, parentProps, parentInstance, text) {
      if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {
        warnForInsertedHydratedText(parentInstance, text);
      }
    }
  },

  scheduleDeferredCallback: rIC,
  cancelDeferredCallback: cIC,

  useSyncScheduling: !enableAsyncSchedulingByDefaultInReactDOM
});

injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);

var warnedAboutHydrateAPI = false;

function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;

  {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);
      if (hostInstance) {
        warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));

    warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');

    warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
  }

  var root = container._reactRootContainer;
  if (!root) {
    var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
    // First clear any existing content.
    if (!shouldHydrate) {
      var warned = false;
      var rootSibling = void 0;
      while (rootSibling = container.lastChild) {
        {
          if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
            warned = true;
            warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
          }
        }
        container.removeChild(rootSibling);
      }
    }
    {
      if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
        warnedAboutHydrateAPI = true;
        lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
      }
    }
    var newRoot = DOMRenderer.createContainer(container, shouldHydrate);
    root = container._reactRootContainer = newRoot;
    // Initial mount should not be batched.
    DOMRenderer.unbatchedUpdates(function () {
      DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);
    });
  } else {
    DOMRenderer.updateContainer(children, root, parentComponent, callback);
  }
  return DOMRenderer.getPublicRootInstance(root);
}

function createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;
  // TODO: pass ReactDOM portal implementation as third argument
  return createPortal$1(children, container, null, key);
}

function ReactRoot(container, hydrate) {
  var root = DOMRenderer.createContainer(container, hydrate);
  this._reactRootContainer = root;
}
ReactRoot.prototype.render = function (children, callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(children, root, null, callback);
};
ReactRoot.prototype.unmount = function (callback) {
  var root = this._reactRootContainer;
  DOMRenderer.updateContainer(null, root, null, callback);
};

var ReactDOM = {
  createPortal: createPortal,

  findDOMNode: function (componentOrElement) {
    {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
        warning(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner) || 'A component');
        owner.stateNode._warnedAboutRefsInRender = true;
      }
    }
    if (componentOrElement == null) {
      return null;
    }
    if (componentOrElement.nodeType === ELEMENT_NODE) {
      return componentOrElement;
    }

    var inst = get(componentOrElement);
    if (inst) {
      return DOMRenderer.findHostInstance(inst);
    }

    if (typeof componentOrElement.render === 'function') {
      invariant(false, 'Unable to find node on an unmounted component.');
    } else {
      invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));
    }
  },
  hydrate: function (element, container, callback) {
    // TODO: throw or warn if we couldn't hydrate?
    return renderSubtreeIntoContainer(null, element, container, true, callback);
  },
  render: function (element, container, callback) {
    return renderSubtreeIntoContainer(null, element, container, false, callback);
  },
  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {
    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;
    return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
  },
  unmountComponentAtNode: function (container) {
    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;

    if (container._reactRootContainer) {
      {
        var rootEl = getReactRootElementInContainer(container);
        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);
        warning(!renderedByDifferentReact, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }

      // Unmount should not be batched.
      DOMRenderer.unbatchedUpdates(function () {
        renderSubtreeIntoContainer(null, null, container, false, function () {
          container._reactRootContainer = null;
        });
      });
      // If you call unmountComponentAtNode twice in quick succession, you'll
      // get `true` twice. That's probably fine?
      return true;
    } else {
      {
        var _rootEl = getReactRootElementInContainer(container);
        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));

        // Check if the container itself is a React root node.
        var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

        warning(!hasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }

      return false;
    }
  },


  // Temporary alias since we already shipped React 16 RC with it.
  // TODO: remove in React 17.
  unstable_createPortal: createPortal,

  unstable_batchedUpdates: batchedUpdates,

  unstable_deferredUpdates: DOMRenderer.deferredUpdates,

  flushSync: DOMRenderer.flushSync,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    // For TapEventPlugin which is popular in open source
    EventPluginHub: EventPluginHub,
    // Used by test-utils
    EventPluginRegistry: EventPluginRegistry,
    EventPropagators: EventPropagators,
    ReactControlledComponent: ReactControlledComponent,
    ReactDOMComponentTree: ReactDOMComponentTree,
    ReactDOMEventListener: ReactDOMEventListener
  }
};

if (enableCreateRoot) {
  ReactDOM.createRoot = function createRoot(container, options) {
    var hydrate = options != null && options.hydrate === true;
    return new ReactRoot(container, hydrate);
  };
}

var foundDevTools = DOMRenderer.injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType: 1,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol;
      // Don't warn in exotic cases like chrome-extension://.
      if (/^(https?|file):$/.test(protocol)) {
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}



var ReactDOM$2 = Object.freeze({
	default: ReactDOM
});

var ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;

// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom = ReactDOM$3['default'] ? ReactDOM$3['default'] : ReactDOM$3;

module.exports = reactDom;
  })();
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(56);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(58);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createBrowserHistory__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createBrowserHistory___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_history_createBrowserHistory__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(20);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = function (_React$Component) {
  _inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = __WEBPACK_IMPORTED_MODULE_3_history_createBrowserHistory___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, '<BrowserRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { BrowserRouter as Router }`.');
  };

  BrowserRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

BrowserRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.string,
  forceRefresh: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.bool,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  keyLength: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (BrowserRouter);

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(6);
var invariant = __webpack_require__(8);
var warning = __webpack_require__(12);
var assign = __webpack_require__(7);

var ReactPropTypesSecret = __webpack_require__(16);
var checkPropTypes = __webpack_require__(15);

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(6);
var invariant = __webpack_require__(8);
var ReactPropTypesSecret = __webpack_require__(16);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(18);

var _PathUtils = __webpack_require__(9);

var _createTransitionManager = __webpack_require__(19);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(33);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createHashHistory__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createHashHistory___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_history_createHashHistory__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(20);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = function (_React$Component) {
  _inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = __WEBPACK_IMPORTED_MODULE_3_history_createHashHistory___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, '<HashRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { HashRouter as Router }`.');
  };

  HashRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

HashRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.string,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  hashType: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.oneOf(['hashbang', 'noslash', 'slash']),
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (HashRouter);

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(5);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(18);

var _PathUtils = __webpack_require__(9);

var _createTransitionManager = __webpack_require__(19);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(33);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_MemoryRouter__ = __webpack_require__(66);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_MemoryRouter__["a" /* default */]);

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createMemoryHistory__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_history_createMemoryHistory___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_history_createMemoryHistory__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Router__ = __webpack_require__(21);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = function (_React$Component) {
  _inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = __WEBPACK_IMPORTED_MODULE_3_history_createMemoryHistory___default()(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, '<MemoryRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { MemoryRouter as Router }`.');
  };

  MemoryRouter.prototype.render = function render() {
    return __WEBPACK_IMPORTED_MODULE_1_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_4__Router__["a" /* default */], { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(__WEBPACK_IMPORTED_MODULE_1_react___default.a.Component);

MemoryRouter.propTypes = {
  initialEntries: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.array,
  initialIndex: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  getUserConfirmation: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.func,
  keyLength: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.number,
  children: __WEBPACK_IMPORTED_MODULE_2_prop_types___default.a.node
};


/* harmony default export */ __webpack_exports__["a"] = (MemoryRouter);

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _warning = __webpack_require__(1);

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__(9);

var _LocationUtils = __webpack_require__(18);

var _createTransitionManager = __webpack_require__(19);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Route__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Link__ = __webpack_require__(34);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      ariaCurrent = _ref.ariaCurrent,
      rest = _objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive', 'ariaCurrent']);

  return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_2__Route__["a" /* default */], {
    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__Link__["a" /* default */], _extends({
        to: to,
        className: isActive ? [className, activeClassName].filter(function (i) {
          return i;
        }).join(' ') : className,
        style: isActive ? _extends({}, style, activeStyle) : style,
        'aria-current': isActive && ariaCurrent
      }, rest));
    }
  });
};

NavLink.propTypes = {
  to: __WEBPACK_IMPORTED_MODULE_3__Link__["a" /* default */].propTypes.to,
  exact: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  strict: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  location: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  activeClassName: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  className: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  activeStyle: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  style: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object,
  isActive: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func,
  ariaCurrent: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOf(['page', 'step', 'location', 'true'])
};

NavLink.defaultProps = {
  activeClassName: 'active',
  ariaCurrent: 'true'
};

/* harmony default export */ __webpack_exports__["a"] = (NavLink);

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var isarray = __webpack_require__(70)

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}


/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Prompt__ = __webpack_require__(72);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Prompt__["a" /* default */]);

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_invariant__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt = function (_React$Component) {
  _inherits(Prompt, _React$Component);

  function Prompt() {
    _classCallCheck(this, Prompt);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_2_invariant___default()(this.context.router, 'You should not use <Prompt> outside a <Router>');

    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Prompt.propTypes = {
  when: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  message: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string]).isRequired
};
Prompt.defaultProps = {
  when: true
};
Prompt.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      block: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Prompt);

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Redirect__ = __webpack_require__(74);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Redirect__["a" /* default */]);

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history__ = __webpack_require__(75);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for updating the location programmatically
 * with a component.
 */

var Redirect = function (_React$Component) {
  _inherits(Redirect, _React$Component);

  function Redirect() {
    _classCallCheck(this, Redirect);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_3_invariant___default()(this.context.router, 'You should not use <Redirect> outside a <Router>');

    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {
    var prevTo = Object(__WEBPACK_IMPORTED_MODULE_4_history__["a" /* createLocation */])(prevProps.to);
    var nextTo = Object(__WEBPACK_IMPORTED_MODULE_4_history__["a" /* createLocation */])(this.props.to);

    if (Object(__WEBPACK_IMPORTED_MODULE_4_history__["b" /* locationsAreEqual */])(prevTo, nextTo)) {
      __WEBPACK_IMPORTED_MODULE_2_warning___default()(false, 'You tried to redirect to the same route you\'re currently on: ' + ('"' + nextTo.pathname + nextTo.search + '"'));
      return;
    }

    this.perform();
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var _props = this.props,
        push = _props.push,
        to = _props.to;


    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Redirect.propTypes = {
  push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.bool,
  from: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string,
  to: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object]).isRequired
};
Redirect.defaultProps = {
  push: false
};
Redirect.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    history: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
      push: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired,
      replace: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired
    }).isRequired,
    staticContext: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
  }).isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (Redirect);

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__createBrowserHistory__ = __webpack_require__(76);
/* unused harmony reexport createBrowserHistory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__createHashHistory__ = __webpack_require__(77);
/* unused harmony reexport createHashHistory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__createMemoryHistory__ = __webpack_require__(78);
/* unused harmony reexport createMemoryHistory */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LocationUtils__ = __webpack_require__(14);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_3__LocationUtils__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__LocationUtils__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__PathUtils__ = __webpack_require__(10);
/* unused harmony reexport parsePath */
/* unused harmony reexport createPath */










/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PathUtils__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createTransitionManager__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DOMUtils__ = __webpack_require__(37);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  __WEBPACK_IMPORTED_MODULE_1_invariant___default()(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["b" /* canUseDOM */], 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["g" /* supportsHistory */])();
  var needsHashChangeListener = !Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["h" /* supportsPopStateOnHashChange */])();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? __WEBPACK_IMPORTED_MODULE_5__DOMUtils__["c" /* getConfirmation */] : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["g" /* stripTrailingSlash */])(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */])(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!basename || Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["c" /* hasBasename */])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["e" /* stripBasename */])(path, basename);

    return Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_4__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["d" /* isExtraneousPopstateEvent */])(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
  };

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* unused harmony default export */ var _unused_webpack_default_export = (createBrowserHistory);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__PathUtils__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__createTransitionManager__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DOMUtils__ = __webpack_require__(37);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["f" /* stripLeadingSlash */])(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["f" /* stripLeadingSlash */],
    decodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */]
  },
  slash: {
    encodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */],
    decodePath: __WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */]
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  __WEBPACK_IMPORTED_MODULE_1_invariant___default()(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["b" /* canUseDOM */], 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["f" /* supportsGoWithoutReloadUsingHash */])();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? __WEBPACK_IMPORTED_MODULE_5__DOMUtils__["c" /* getConfirmation */] : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["g" /* stripTrailingSlash */])(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["a" /* addLeadingSlash */])(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!basename || Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["c" /* hasBasename */])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["e" /* stripBasename */])(path, basename);

    return Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path);
  };

  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_4__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["b" /* locationsAreEqual */])(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location));
  };

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        __WEBPACK_IMPORTED_MODULE_0_warning___default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(Object(__WEBPACK_IMPORTED_MODULE_3__PathUtils__["b" /* createPath */])(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["a" /* addEventListener */])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(__WEBPACK_IMPORTED_MODULE_5__DOMUtils__["e" /* removeEventListener */])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* unused harmony default export */ var _unused_webpack_default_export = (createHashHistory);

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__PathUtils__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LocationUtils__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__createTransitionManager__ = __webpack_require__(23);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = Object(__WEBPACK_IMPORTED_MODULE_3__createTransitionManager__["a" /* default */])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(entry, undefined, createKey()) : Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = __WEBPACK_IMPORTED_MODULE_1__PathUtils__["b" /* createPath */];

  var push = function push(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(__WEBPACK_IMPORTED_MODULE_2__LocationUtils__["a" /* createLocation */])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

/* unused harmony default export */ var _unused_webpack_default_export = (createMemoryHistory);

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_StaticRouter__ = __webpack_require__(80);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_StaticRouter__["a" /* default */]);

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history_PathUtils__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_history_PathUtils___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__Router__ = __webpack_require__(21);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var normalizeLocation = function normalizeLocation(object) {
  var _object$pathname = object.pathname,
      pathname = _object$pathname === undefined ? '/' : _object$pathname,
      _object$search = object.search,
      search = _object$search === undefined ? '' : _object$search,
      _object$hash = object.hash,
      hash = _object$hash === undefined ? '' : _object$hash;


  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return _extends({}, location, {
    pathname: Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["addLeadingSlash"])(basename) + location.pathname
  });
};

var stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["addLeadingSlash"])(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var createLocation = function createLocation(location) {
  return typeof location === 'string' ? Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["parsePath"])(location) : normalizeLocation(location);
};

var createURL = function createURL(location) {
  return typeof location === 'string' ? location : Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["createPath"])(location);
};

var staticHandler = function staticHandler(methodName) {
  return function () {
    __WEBPACK_IMPORTED_MODULE_1_invariant___default()(false, 'You cannot %s with <StaticRouter>', methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter = function (_React$Component) {
  _inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return Object(__WEBPACK_IMPORTED_MODULE_4_history_PathUtils__["addLeadingSlash"])(_this.props.basename + createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = 'PUSH';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = 'REPLACE';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_0_warning___default()(!this.props.history, '<StaticRouter> ignores the history prop. To use a custom history, ' + 'use `import { Router }` instead of `import { StaticRouter as Router }`.');
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = _objectWithoutProperties(_props, ['basename', 'context', 'location']);

    var history = {
      createHref: this.createHref,
      action: 'POP',
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler('go'),
      goBack: staticHandler('goBack'),
      goForward: staticHandler('goForward'),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return __WEBPACK_IMPORTED_MODULE_2_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_5__Router__["a" /* default */], _extends({}, props, { history: history }));
  };

  return StaticRouter;
}(__WEBPACK_IMPORTED_MODULE_2_react___default.a.Component);

StaticRouter.propTypes = {
  basename: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string,
  context: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired,
  location: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.oneOfType([__WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.string, __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object])
};
StaticRouter.defaultProps = {
  basename: '',
  location: '/'
};
StaticRouter.childContextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object.isRequired
};


/* harmony default export */ __webpack_exports__["a"] = (StaticRouter);

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_Switch__ = __webpack_require__(82);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_Switch__["a" /* default */]);

/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_warning___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_warning__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_invariant___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_invariant__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__matchPath__ = __webpack_require__(22);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
  _inherits(Switch, _React$Component);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillMount = function componentWillMount() {
    __WEBPACK_IMPORTED_MODULE_3_invariant___default()(this.context.router, 'You should not use <Switch> outside a <Router>');
  };

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    __WEBPACK_IMPORTED_MODULE_2_warning___default()(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    __WEBPACK_IMPORTED_MODULE_2_warning___default()(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.forEach(children, function (element) {
      if (!__WEBPACK_IMPORTED_MODULE_0_react___default.a.isValidElement(element)) return;

      var _element$props = element.props,
          pathProp = _element$props.path,
          exact = _element$props.exact,
          strict = _element$props.strict,
          sensitive = _element$props.sensitive,
          from = _element$props.from;

      var path = pathProp || from;

      if (match == null) {
        child = element;
        match = path ? Object(__WEBPACK_IMPORTED_MODULE_4__matchPath__["a" /* default */])(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }) : route.match;
      }
    });

    return match ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

Switch.contextTypes = {
  router: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.shape({
    route: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired
  }).isRequired
};
Switch.propTypes = {
  children: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.node,
  location: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object
};


/* harmony default export */ __webpack_exports__["a"] = (Switch);

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_matchPath__ = __webpack_require__(22);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_matchPath__["a" /* default */]);

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react_router_es_withRouter__ = __webpack_require__(85);
// Written in this round about way for babel-transform-imports


/* harmony default export */ __webpack_exports__["a"] = (__WEBPACK_IMPORTED_MODULE_0_react_router_es_withRouter__["a" /* default */]);

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Route__ = __webpack_require__(36);
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }






/**
 * A public higher-order component to access the imperative API
 */
var withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutProperties(props, ['wrappedComponentRef']);

    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3__Route__["a" /* default */], { render: function render(routeComponentProps) {
        return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(Component, _extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));
      } });
  };

  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func
  };

  return __WEBPACK_IMPORTED_MODULE_2_hoist_non_react_statics___default()(C, Component);
};

/* harmony default export */ __webpack_exports__["a"] = (withRouter);

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(88);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"minimize":true,"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(95)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js??ref--1-1!../../node_modules/sass-loader/lib/loader.js??ref--1-2!../../node_modules/postcss-loader/lib/index.js!./main.scss", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js??ref--1-1!../../node_modules/sass-loader/lib/loader.js??ref--1-2!../../node_modules/postcss-loader/lib/index.js!./main.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var escape = __webpack_require__(89);
exports = module.exports = __webpack_require__(90)(false);
// imports


// module
exports.push([module.i, "*{box-sizing:border-box}body{font-family:Lato,sans-serif;font-weight:400;font-size:18px;line-height:1.5;margin:0;padding:0}h1,h2,h3{margin:0;text-transform:uppercase}h1{font-size:50px}h1,h2{font-weight:900}h2{font-size:30px}h3{font-size:24px;font-weight:300;text-transform:none}a{color:inherit;text-decoration:none}button{background:none;border:0;outline:0;cursor:pointer}svg path{transition:fill .3s}.padding{padding-top:100px;padding-bottom:100px}.wrapper{max-width:840px;margin:0 auto;padding:0 20px}.wrapper-small{max-width:620px;margin:0 auto;padding-right:20px;padding-left:20px}main{margin-top:80px}header{background:#000;height:80px;text-align:left;position:relative;position:fixed;width:100%;z-index:3;top:0}header .tamtam-icon,header nav{position:relative;top:50%;transform:translateY(-50%);display:block;float:left}header .tamtam-icon{margin:0 20px 0 30px;max-width:32px}header .tamtam-icon svg{display:block;transition:-webkit-transform .3s;transition:transform .3s;transition:transform .3s,-webkit-transform .3s}header .tamtam-icon:hover svg{-webkit-transform:rotate(180deg);transform:rotate(180deg)}header nav ul{padding:0;margin:0}header nav ul li{display:inline-block;list-style-type:none}header nav ul li a{color:#fff;opacity:.7;font-size:16px;padding:30px 20px;transition:opacity .3s,color .3s}header nav ul li a:hover{opacity:1;color:#fd5454}header nav ul li a.active{opacity:1}.hamburger{z-index:3;margin-left:20px;float:left;width:30px;height:22px;-webkit-transform:rotate(0deg) translateY(-50%);transform:rotate(0deg) translateY(-50%);position:relative;top:50%;transition:.5s ease-in-out;cursor:pointer;display:none}.hamburger span{display:block;position:absolute;height:3px;width:100%;background:#fff;opacity:1;left:0;-webkit-transform:rotate(0deg);transform:rotate(0deg);transition:.25s ease-in-out}.hamburger span:first-child{top:0}.hamburger span:nth-child(2),.hamburger span:nth-child(3){top:11px}.hamburger span:nth-child(4){top:22px}header.active .hamburger span:first-child{top:12px;width:0;left:50%}header.active .hamburger span:nth-child(2){-webkit-transform:rotate(45deg);transform:rotate(45deg)}header.active .hamburger span:nth-child(3){-webkit-transform:rotate(-45deg);transform:rotate(-45deg)}header.active .hamburger span:nth-child(4){top:11px;width:0;left:50%}.slider{position:relative}.slider .overlay{background:linear-gradient(180deg,transparent 0,transparent 50%,rgba(0,0,0,.3));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=\"$color-black00000\",endColorstr=\"#4d000000\",GradientType=0);height:100%}.slider .scroll-down{bottom:39px;background:#fff;width:54px;height:54px;border-radius:50%}.slider .scroll-down,.slider .scroll-down svg{position:absolute;left:0;right:0;margin:0 auto}.slider .scroll-down svg{top:50%;transform:translateY(-50%);display:block}.slider .scroll-down svg.arrows-down{display:none}.slider .scroll-down svg.mouse{display:block}.slider .scroll-down:hover svg path{fill:#fd5454}.slider .chevron-down{position:absolute;left:0;right:0;bottom:25px;margin:0 auto;max-width:10px}.slider .slide{background-size:cover;background-position:50%;background-repeat:no-repeat;height:700px;width:100%}.slider .slide .slide-container{text-align:center;position:relative;top:50%;transform:translateY(-50%)}.slider .slide .slide-container nav{margin-top:40px}.slider .slide .slide-container a,.slider .slide .slide-container button{display:inline-block;margin:0 10px;vertical-align:middle}.control-arrow{visibility:hidden}.slider .slide .slide-container .arrow{width:40px;height:40px;background:#000;border-radius:50%;text-align:center;position:relative;transition:background .3s}.slider .slide .slide-container .arrow:hover{background:#fd5454}.slider .slide .slide-container .arrow svg{position:absolute;display:block;margin:auto;left:0;right:0;top:0;bottom:0}.slider .slide .slide-container .radius-button{height:40px;line-height:40px;width:150px;background:#000;color:#fff;border-radius:40px;font-size:16px;transition:background .3s}.slider .slide .slide-container .radius-button:hover{background:#fd5454}.intro{font-size:20px;color:#292929}.feed,.intro{text-align:center}.feed{background-size:cover;background-position:50%;background-repeat:no-repeat;background-image:url(" + escape(__webpack_require__(38)) + ")}.feed .padding{padding-bottom:200px}.feed h2{color:#789199;margin-bottom:10px}.feed h3{color:#fff}.feed .feed-content{-webkit-column-count:3;column-count:3;-webkit-column-gap:20px;column-gap:20px;margin-top:50px}.feed .feed-content .post{background-color:#eee;display:inline-block;margin:0 0 20px;width:100%;cursor:pointer}.feed .feed-content .post img{width:100%;display:block}.feed .feed-content .post .content{padding:10px;background:#fff;font-size:16px;text-align:left}.feed .feed-content .post .content p{margin:0}.feed .feed-popup,.feed .feed-popup .overlay{position:fixed;top:0;left:0;width:100%;height:100%}.feed .feed-popup .overlay{background:rgba(0,0,0,.5);cursor:pointer}.feed .feed-popup .container{height:calc(100% - 160px);width:100%;max-width:800px;margin:0 auto;z-index:3;position:relative;margin-top:120px}.feed .feed-popup .container .content{background:#fff;max-width:800px;margin:0 auto;overflow-y:scroll;height:100%}.feed .feed-popup .container .content .image{width:calc(100% - 300px);float:left;background-size:cover;background-position:50%;background-repeat:no-repeat;height:100%}.feed .feed-popup .container .content .infobox{width:100%;max-width:300px;float:left;padding:20px;text-align:left}.feed .feed-popup .container .content .infobox .cross{position:absolute;right:20px;top:20px}.feed .feed-popup .container .content .infobox .cross svg{fill:#8e8e8e;width:15px;height:15px}.feed .feed-popup .container .content .infobox .user{padding-bottom:20px;border-bottom:1px solid #e9e9e9}.feed .feed-popup .container .content .infobox .user img{display:inline-block;vertical-align:middle;border-radius:50%;max-width:50px;margin-right:10px}.feed .feed-popup .container .content .infobox .user .username{display:inline-block;vertical-align:middle;font-weight:900;font-size:16px}.feed .feed-popup .container .content .infobox .text{font-size:16px;padding:20px 0}.feed .feed-popup .container .content .infobox .likes{font-size:16px}.feed .feed-popup .container .content .infobox .likes span:before{content:\"\\2665\";font-size:30px;margin-right:10px;color:#fd5454;display:inline-block;line-height:.7}.feed-button{background:#fd5454;border:0;outline:0;width:150px;height:40px;color:#fff;border-radius:40px;cursor:pointer;margin-top:40px;position:relative;transition:background .3s}.feed-button.loading{color:transparent}.feed-button.loading:after{content:\"\";background-image:url(" + escape(__webpack_require__(91)) + ");background-repeat:no-repeat;background-size:contain;background-position:50%;width:20px;height:20px;position:absolute;left:0;right:0;margin:auto;top:10px}.feed-button:hover{background:#ff7676}.contact-form{text-align:center;background-size:cover;background-position:50%;background-repeat:no-repeat;background-image:url(" + escape(__webpack_require__(38)) + ")}.contact-form .padding{padding-bottom:215px}.contact-form h1{color:#fff;font-size:40px;max-width:500px;margin:0 auto 40px}.contact-form form{transition:opacity .3s;pointer-events:auto}.contact-form form.hide{opacity:0;pointer-events:none}.contact-form form .form-container{background:hsla(0,0%,100%,.2);padding:10px 0 20px 10px;overflow:hidden}.contact-form form .form-container .field{padding:10px 10px 0 0;position:relative}.contact-form form .form-container .field.full{clear:both;padding-top:20px}.contact-form form .form-container .field.half{width:50%;display:inline-block;vertical-align:top}.contact-form form .form-container .field input,.contact-form form .form-container .field textarea{width:100%;border:0;background:#fff;outline:0;font-size:16px;padding-left:20px;transition:color .3s}.contact-form form .form-container .field input::-webkit-input-placeholder,.contact-form form .form-container .field textarea::-webkit-input-placeholder{transition:color .3s}.contact-form form .form-container .field input:-ms-input-placeholder,.contact-form form .form-container .field textarea:-ms-input-placeholder{transition:color .3s}.contact-form form .form-container .field input::placeholder,.contact-form form .form-container .field textarea::placeholder{transition:color .3s}.contact-form form .form-container .field input:hover::-webkit-input-placeholder,.contact-form form .form-container .field textarea:hover::-webkit-input-placeholder{color:#000}.contact-form form .form-container .field input:hover:-ms-input-placeholder,.contact-form form .form-container .field textarea:hover:-ms-input-placeholder{color:#000}.contact-form form .form-container .field input:hover::placeholder,.contact-form form .form-container .field textarea:hover::placeholder{color:#000}.contact-form form .form-container .field input{height:50px}.contact-form form .form-container .field.valid:after{content:\"\";background-image:url(" + escape(__webpack_require__(92)) + ");background-repeat:no-repeat;background-size:contain;background-position:50%;width:24px;height:24px;display:block;position:absolute;top:23px;right:23px}.contact-form form .form-container .field.full.valid:after{top:33px}.contact-form form .form-container .field textarea{height:120px;padding-top:20px;font-family:Lato,sans-serif;display:block}.contact-form form .submit-button{background:#fd5454;border:0;outline:0;width:150px;height:40px;color:#fff;border-radius:40px;cursor:pointer;margin-top:40px;transition:background .3s}.contact-form form .submit-button:hover{background:#ff7676}.message{width:100%;background:rgba(0,0,0,.2);padding:15px 20px;text-align:left}.message-icon{display:inline-block;background-color:rgba(0,0,0,.2);border-radius:50%;width:30px;height:30px;vertical-align:middle;margin-right:20px}.message-icon .icon{background-repeat:no-repeat;background-size:contain;background-position:50%;width:14px;height:14px;margin:0 auto;position:relative;top:50%;transform:translateY(-50%)}.message-icon .icon.success{background-image:url(" + escape(__webpack_require__(93)) + ")}.message-icon .icon.error{background-image:url(" + escape(__webpack_require__(94)) + ")}.message-text{color:#fff;vertical-align:middle;width:calc(100% - 70px);display:inline-block}.error-popup{background:#555d60;color:#fff;text-align:left;padding:10px 20px;font-size:16px;position:relative}.error-popup .triangle{position:absolute;top:-10px;width:0;height:0;border-left:7px solid transparent;border-right:7px solid transparent;border-bottom:10px solid #555d60}.people img.cat{width:100%;display:block}footer{height:100px;background:#000;text-align:center}footer .footer-content{position:relative;top:50%;transform:translateY(-50%)}footer .footer-content a.social{display:inline-block;margin:0 20px}footer .footer-content a.social:hover svg path{fill:#fd5454}footer .footer-content a.social svg{width:100%;max-width:20px}@media screen and (max-width:800px){.contact-form h1{font-size:30px;max-width:300px}.slider h1{font-size:40px}.feed .feed-content{-webkit-column-count:2;column-count:2}.padding{padding-top:80px;padding-bottom:80px}.slider .scroll-down{width:40px;height:40px;bottom:20px}.slider .scroll-down svg.arrows-down{display:block}.slider .chevron-down,.slider .scroll-down svg.mouse{display:none}}@media screen and (max-width:640px){.contact-form form .form-container .field.half{width:100%;float:none}.feed .feed-content{-webkit-column-count:1;column-count:1}.feed h2,.intro h2{font-size:24px}.feed h3{font-size:20px}.feed .feed-popup .container{margin-top:80px;height:calc(100% - 100px)}.feed .feed-popup .container .content .image{width:100%;float:none;max-height:300px}.feed .feed-popup .container .content .infobox{width:100%;float:none;max-width:none}.slider .slide{height:508px}.slider h1{font-size:30px}.slider .slide .slide-container nav{margin-top:30px}.feed .padding{padding-bottom:100px;padding-top:60px}.padding{padding-top:60px;padding-bottom:60px}.feed .feed-content{margin-top:30px}.intro p{margin-top:10px}}@media screen and (max-width:480px){header{height:60px}main{margin-top:60px}.contact-form .padding{padding:40px 0 100px}.contact-form h1{font-size:24px;margin-bottom:20px}.contact-form form .submit-button{margin-top:20px}header .tamtam-icon{position:absolute;left:0;right:0;margin:auto}header .tamtam-icon svg{max-width:22px;margin:0 auto}.hamburger{display:block}header nav{position:fixed;height:100%;width:100%;top:60px;left:0;background:#000;opacity:0;pointer-events:none;z-index:2;-webkit-transform:translateY(0);transform:translateY(0);transition:opacity .3s}header.active nav{opacity:1;pointer-events:auto}header nav ul{text-align:center;border-top:1px solid #fff;padding-top:20px}header nav ul li{display:block}header nav ul li a{font-size:30px;font-weight:900;width:100%;padding:20px 0;display:block;opacity:1;transition:color .3s}header nav ul li a.active,header nav ul li a:hover{color:#fd5454}}", ""]);

// exports


/***/ }),
/* 89 */
/***/ (function(module, exports) {

module.exports = function escape(url) {
    // If url is already wrapped in quotes, remove them
    if (/^['"].*['"]$/.test(url)) {
        url = url.slice(1, -1);
    }
    // Should url be wrapped?
    // See https://drafts.csswg.org/css-values-3/#urls
    if (/["'() \t\n]/.test(url)) {
        return '"' + url.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"'
    }

    return url
}


/***/ }),
/* 90 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 91 */
/***/ (function(module, exports) {

module.exports = "data:image/gif;base64,R0lGODlhyADIAOZ/AP////P09Ovs7NHT1ICChY+RlMHCxNnb3K+xtJ+hpMnLzOLj5Pz8/Pj4+Pr6+v39/fHx8uvr7P7+/tfY2fn5+fX19ezt7ePj5Kutr+/w8PX29vDx8fb398/Q0e/v8Pv7+/f398fIydXW1+bn58XGyNvd3uTl5szOz6WnqtTW1/T19bS2uZaYm4iKjdzd3s3O0P3+/vPz9Pn5+vX19vj4+fv7/Pf3+Pr6+/z9/err6+fn6OHi4tHR093e3+Pk5be5u8PFx6ChpOnq6+fo6cnKy9DS0vHy8p2foeXm57m7vd7g4NfZ2e7u7pCSlL/AwuDg4ejp6eTl5fT09ff4+Nvc3fr7++7u7+jo6eHi49rb3NjZ2uLk5NLT1fT09PPz88PExufp6e3u7t3f37m6vLCxs/j5+cDBw8nKzLi5u9/g4ODi47GztdPV1s3Nz77AwpianKSmqOTk5e7v8PLz8+3t7uzs7Nzc3fb29/v8/PDw8e7v76ipq9/h4b2+wbK0tv///yH/C05FVFNDQVBFMi4wAwEAAAAh+QQJBwB/ACwAAAAAyADIAAAH/4B/goOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLmuALy9ur/Aj73DvsHGx4LEygDIzbrLy87StdDK09ew1dHY3Kra1t3hpt/E4uaj5MPn65/pxezwme688dIUf/eh88ygTn/+9TZVCECwYIV28z41IcCwYZOAlsoUnFiwTKd9ndA03NgQDcRJFEMGuJiQE8eTBD5GEimSE8ZNKFGqdNSAZUgQm15m2hPzJJmZjAbapJizZKaeJx8CVTQ05EF5Ri8tRMpxKdOmRKG600T1pNVEWCmq0JouU4uuVb8eUhF2osVLOv8raUTbsIXaQzXbFsQUlxLdjT/vGtJbkAPcqJOC/G0o+JBEwiMt9ZW0mGFjRGwJP6U0GdLUv3YvH4IcIN+kzo8qE+gg+pAGyGM5I4Z0dvGb1ohIN5C9dRIZ1bgRgSDNu+wk1XuC54ZsWBLqRYorKwcL+fTsRsCnIxKqd7Ow64s+01Wq3VAV4pGeI3KSvfwhDrDTg09U+28Q99QJ4/ze2xFP6fghkhdhkKhniGqBBbgWZBrwZ1wjb1QWmoLLEeiIgYS0R+Eh3LUVGyMYClLfeBteRZhpioTIHoAlIgJfdSDOl2Fl97WYn17NpSijINEtBpEXTAggpAVegPKYhTr2l4j/ah59MgYLBUR5xBirCGnllV18kll3ixgoHloTcmJGlGSWiUoXV6Y55CfoJWKghptAWeacBZhhipp4CpBBJx2G9eEh6o2IFnmawEHnoQWUEmSeeBrBCWlvATrfXD5u4geiiB5BCqOcemfJi0ga8pxqNWISAqaojlIBp5wyoQlpORaCWo9/aXIEqqiGMAqrrG6ACQVtygqeagBZggGuuKrKK69FWrJlW54mc92XXYU5yRjIIqurKMvyakG0kJCGorRKCrJipZXImW2qu3bLq6uUvEbYn+Q+OIigXd1Gya3rIkvKou72Skmw9ZJzIIuRHNsvsppuGvCyWUYynGai2isI/7VUJRfJmAtnawqaD3srybNhVWxwIRJKom7HqNp5SsjLwvsIjMJqcwjCjfDLcrKqGAEzr7460mdTiNh881+ELqLwzqj64QrAP+cJ7mgeJvnOIfj25MipTKPaMCwWRM2oBY2A2tRumfyGVqmKrNz1nCzUArLYeO65SFsmocWIoW8j6rItG9Cdp6OJHGlTpJlQ2lOTiFza96EYAAO14GsmMmBLnyCVoCEhuP14AV8HEzblV8q8oFgOgBICvtYWovPnUcbtjBekpxm0gBwYVkUpZARxH2uILA17lFReE3jtVkYMDMfDRxl5OJNT3qwu2DYPOjuj1w6M9Sxsy47PtZOdi//nbzsNUQba5zI8HEtlL/b0tVTft+xWrUr37bUIz7T3ah3/M/600F/Hniea6HVLF0wLHW7c160pqK9j9NPO3JYlPlyQD1N/w4//WPULriGLgBsy4JXghwv5ZcpGhGCglZCBqAiiUBBdABiRnPEkMh0hgy/MoQ53yMMe+vCHQCyEEBZAxCIa8YhITKISl1hEIbDjBwmIohSnSMUqWvGKWJTiDygxBCZ68YtgROIQxLGGLJrxjGis4hoiYYIwuvGNSzRBN1CQxjraEYsoeEQX4cjHPi5gjNco4x0HScgErLERfkwkHLFRyEbesRFDVKQkv+hEaUDRkZg84xYXMclOenH/GpkMpRkZ4clSJhGUokxlFUlpylYSEZWqjGUCWOlKU8JSlqlkRCRr2clKOuOSuAzlJjnJy04yMpihdMQei5lIQE5DkMhs5CEb0UZm9lGO3KBjNAmZR0gs05phdCY3oLnNNE4zErsE5xJ9aQ5glhOLwwyiPOdJz3ra8574xEUOlHCAfpYADM54wQoQQNAkcKGHJeinQhWaA2NwgaAQhegKdMjPhVr0AMF4QUQ3WlAb+eCiID1ABXHB0ZIiAAgUykFIQ1oCXQzUpCU9qHsSutKQ6gKmMJ3odCpa05AC9BYaxSlMk4Cbj/a0pj7ABRCEKlSUCsYCRz1qUm+xVKYKdQJq/6FpVGt6U6sKVaczUcNWo9pVrwrVDR9Bwlij2tJcvNSsQj1DPCyg1bXWVA66cAFcrQpWc/DUrlwFRlD3KlSihsOogO1pQ41BWKs6dRpgSKxUE2GFP/SgB1soxRX+wAMeaEERVW0sTl8gjbpK9qJKUEQKBsDa1qZAFCQwgGxnSwJFJEG0OO0rMP56WouWYKSF2EJrh9vazHZCC7NN7mw/m4i34pajhtUFYnt7USQoAgnEze4AOuEC5XrXAIs4w3Nh+thaqJS6IFUDI7SrXU5897uMcMN4TSrTWZgWvQdo6yJ6wN7sGhcTyH2vcnnQCOfOl6C6bQVv8StSR/Q3u69NxP8EFEBhBWA1EbEVsHIdMYEDQ9cVamXwQqfaiCU8OLuIYEOFV6wANiBCw94lwiNC62GCylUVIl5oah8BhROj2BAnYDGLT3AIGHv3CZC4bY0hiorz5li/j1itj4drCBULmcUuLoSRlVvbSBj4wPUdRY77uVhI8GHKw12CIa58ZUMQYcvJzTIkHrpkBJRiwb0lcSTQPFzrEmLCbGbxhQkB5+RSgsbzjW4oRLzjSWSBz6yNMCEC3eZCZLjQbaiEkg88CqiiF8qTgDRrD0FpIRviCYWe7SW+3NhBgwK9P62ElPms5jWXesWHeHOqu1yJweK203nGRI9FjYhb47rIqTYAki//gei9uvoTkm30JUQ9gB4U29gURgQPkg3eTGx6r6RILHArwV9iXxvbieA2gTPRYcKSAs8r9bMmqC1vW6MbEd1NNifEa1ZFLzqq6uWEiSEtaVJjWwGKuDScZcwJ+VrVFE5m6SeovYiDI1wR3P4EqyMa5nCHtMycmDWaa50Iiy9C14XmNSfoXNJVgIGn/wQFds2tCJMvgtsuAIVAIZoE0gaE2tau+MEZsW19+7DckG6EzW+e7HXzkNpQUPrQGYFqo+9w4HwueM2nzgiFb5nhORx20h2xdEZwe9kvFPmUs/CIsi+iDclWeYuES3Op39sRGX8htfkACbcvgg15bxHS0ax1/0b4fRFeN7LTN0TxSBye6aluEdZHLonHKwLlC9+Q2Pk8CctjPNloxw/QO891SBQ98gE6c937XnpIcFvO5aH2fx3f+kcEGPXleTTBK+F5xCc707FfPe3vPonAK0ftPiY56YkvCcxvWe6imfnYeV/7SOBcOaO3RO+JbvzL0H361Gd+8ZPNXNEg/8T1psT2GZHvlONG1IVfvrEzkXgYvx/82q/++At9f8pnYv2N4Hz21xqTd2KbAICNUGhg531oxneagICMAHhbVn6igWacAIFmt2XT4WOdgIEZqGHaIX3alX6Y4IGL0H7flXPlUYADoHwHqH+XIIALiB9RF3WgYIKPgExkoZdPhgeDPLgKOPiDnxCEQtiBPliEp0CESKgJgHZrz7aEQDh/UPgKVkZpsDeFrBBkgUZkWAgLVYhlXTgLTWhhYViGZniGaJiGnBAIACH5BAkHAH8ALAAAAADIAMgAAAf/gH+Cg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ua4cAb0BHLrBwo8avsYBGsPKy4Mqx8cqzNK6xc/HydPZtNbW2t6wvNzHwN/lquLd5uqm6M/r76Ptx/D0n/LG9fmb97762RV/AIbi14sBKAB/EPrbxESAw4dM7BH8BKCixYoLLXV5yPFhl04EA3S6SNJixkkdUwoAOZFTyZInI6lUySmky5cwYzbyMjOlkX0EDWbCiVMno4Y9OwLlt4noS6OLkqaMmMnmUKc5oSKSmlKTVUxYs2o1xLWjhaotL4UVO5aQhbIc/z9eCim00lq2bQXxhPsQ01e7dy/mPcT34Ya5aSkFFjyYcOGVlv5OWoyx8aG3halSkhyJcmXLZB8LnEQXMGXQhzI8Prs5cWfPqLc+9tKa6WTYsQ8ZeQxZEmdHnhXmDl34sG/XwHEPN1SBN+mgkpQvN4SUr+ZHvxcFn57IeaTsibZzR7Rh9Xfk2qWPL8T7J3b04dWvJ7S3MKTSyU/PR4SZb4b3tjUi3n6y2ecIeIbIRyAh1cHFGiMIEjLggo4VNpoiEQoyIYWGlPdYI/gpsiGH7D1mHIbwSaggPGGMsMCLJoQBykYfLpLhiJqQ0QIBPDZBxiovBimkB5/0B9d1h0SII/8maPDo5JOoeCDklDB+4l0iSurXyY5PdkkAGqZQKeYCQ3TSYFkPJgkdIktW8oaXcBJQiotjitlbJrzJpWaACa5IyR5xxtkEKXUWeuIlHhq45z3xaXmJE4FGOsoGhRY6gia8HUpIdm1G0kSkkToxSqWVCoFJczUawqmfjwQBKqiTkkqqjJYYWRaSgoQ4SKeNkPHqq6KKIiupJmgqk2iqIscrI1z+Kumow5J6KSWqFZZmrsqyusinzr5KCp3RlkrJlYOEIw85Ki5GiavdvjoooeHKSmQku2WWrDx9OupIk+3+aoqU8RIria1cGVINOtikG5gkzfYbKZinBCzrtI+kSoj/M+JEk+9dnjrsryoCSEyqqY6cKRUiB1/DprqOsOtxpHu4Aq7IYxpbIFfXFmLuLyIu3AikL0f6Liwm0FynCY0kKhVtV3HMbNCBtlALwEaLWWZUZd0UFiNvQh0nxLYIUfWYdxpCY1J6No2VIoB6DWcQwsw8dpWJ1EcTRU4l4kTDbvfITNFzC0nxZSlZgO5IRSXCbd9OSj1NGIFPSTIiXmxw2BSlmCScIS4zzuOP3ogdeZDzCsOv5zzCrY7cc9Oqi6+oEzD0O4BHLkzsLQRbT8iRI50L317HnNEQtufi+RtQ1W6067XA7rXjWlFa9eS1dP6y7m2JLjL1tFjfr+qgsT6s/y4vzx6b8sNKYXy/0E9Htay+4wL8wwRqX2kwQL8K/oLiC8k8Ls4TFIkIgb4gMSNO7RugIDwArhhNQ0dOagLYFEjBClrwghjMoAY3aAgfHOCDIAyhCEdIwhKaEIQ+qAcGCsDCFrrwhTCMoQxn2EIMUEINJ8yhDnc4QjWsAw40DKIQhwhDOESiBDxMohJNWAJzsICIUIziDFnwCBwu8YpYPIAPvQFEKXrxiwUwYiOySMYlfgOMaJRiIzxYxjbqMIXZWGEa5yhEGy7CjXjMoTboyMcgMiKPgCThHvtISBj+MZCI/OAgC8nIAhwykYFcZCMJyQg2QhKPcJyGHCfJRzve8f+SeDwjJ/noCCuCkoxb1EYXR4lGMTYCiafEYhPL8URWfpGKkDBlLHmYynKs0pZEdGUkLLlLE2byHZsE5gw9ycFmOvOZ0IymNKeJCyQsYQDYTMEWpvEFFCTgmxg4AwZTgM1ylhMJyjjDN9e5ThRU8JrmjOcAhvEFdtoTnCTqgTz3OQAoBOOeAE3ADwiEBH7yMwW68GZAASrO8ZDToPzUxUIX6s7lwBOi/NzmLeo50YUyszH6xChEe4CLH3S0owMdDBREKlKS3sKkJ+1oB9ryUJZCVKIx7SgKqGCULNiUpTjNaUfXcBI+/JSlCM2FQoXa0T7oAwo1PSpEy1YLETA1pij/mCk8LirVmwqDo1ftKAZ4ao6QdhWj6FRGWGOaUm1s4awtTUQE/jCBCYihFFj4AxCA8AJFwHStE/1CNqIKV3kuQREnUIBiF3sCUawAAZCN7AoUgQHATjSry+BqYeOZAn8iQgyLDe1i79qJF0T2tJHtayKWatl7fvQWZt2sPPmgiB2I9rYK6AQXUMtbBCyiD61daFtrUVDZ7jMLjMAtbjnR294yYg3BDWhDZ0FY4w4gqYuYgHJvS1pMmLa5qAVCI1gb3W9WFBaatW4/HbHd2zY2ETwwgHwNwANFPBa8qHVEB8rrWlcYVb3mdGkjitDe2yKiDfNNsAHagAj88jYJj/gr/3+/6VRVANich31EFApsYEOQQMEKJsEhHMzbCUCishNepwhOUdwLY/cRieVwaA2BYBArmMGFIDFqJxsJ8pb3FBfGZlohkQUZh7YIhrCxjQ2RBB2fdrqPUGeKE1CK9G5WwJEwcmh3UIj4KlnB9c2xkyNLCQlH97WeAHCGJ8EGLSv2vYT48pILcd8xu6ESKP6xKFZq3BdPws2KPYScQWyICYyZzJbw8Vq1GgrjarQSMdYykpM86AQfosmH5nElwGrZUfAZrlimxIYBjYhKW3rEh0aAiS9h5qsyGhRwXfMlAK2AVVPa1AZABBBS7dtM5PmqpDirZzGhXVKXGte5bnCqxf+bif2GlRRWNihtN0FrLh8b14nYbao5AVyhojnNLEUuJwjsZjgLGtn2TTWEOQHdmJqixQf9BK0XgexkJ4LXn1A0O6EcbH4OmRORNvKkE1HvRWB6zJrmhJQBuootXFSboLCtsRVR8EXwmgug6OY6MSDYhdDa1gRH9yJ2ve0MFtvNjai4xZedQVpHIeUizy6+L0huLZub4jFfRJ2dvG4KjhrljlA5I3gNchIFXMZseITQF+GGVCecQ6CdOMyx/YiZD5DW4g56zhlxBqtT6ORGvjkjls6IneuY2RSadyTIPvSSL6jmApcE2w2u7gX9XMuTmPvKD1107nw871t3BMkPvZ//IksdEnrf+5j5vRxad3ftgXfEdwk/njaXuxKJ13mq7+z3w0Oe6pTwem6OzuGBAx70kzi4k58OGokDHfORh8TFh/N3S2SeEYMfc26i/nrYoz70qVYtaEhfYGvbPvaQ0DbCYwNosZ/e1JkwO4mZ3/vj/74SbreMm01vfehnQvXTRw3cC7yJ21ed57HhfYGzjgnzO6LrOhY+aIzMCfc7wsmNJ3/9kQ98/E7H9bhlfJpgf46gfL2FcdwxfgrAfQPIf5UAfgjQc/Pxci8HCgQoCSbWd9SEc9e3ga5wgR4oCiAYghbogCRoCiN4gp3gZZUWZir4gd73gq5QY3KGYzLoCh/2G2UidoOwQIM3xoOzwIL0BYREWIRGeIRIyAmBAAAh+QQJBwB/ACwAAAAAyADIAAAH/4B/goOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLmuGwK9Ahu6wcKPGb7GAhnDysuDFsfHFszSusXPx8nT2bTW1tresLzcx8Df5ari3ebqpujP6++j7cfw9J/yxvX5m/e++tnA5EDx6xWKwh+D/jaNWMCw4Qh7Az9VCECxYoWEljw03NjQQ6eBAjqVqUiyYhmMkziqXPAxIqeSMAOgjLRyJSeQL2PCnOkoTE2VITXh1ARCJ8wGPBkt/Mlxn8tMRmFeTKqIqcqHmYZimhi1JNWqVptmfXqp686viMJyNDGWXyYVZv+9oj1kQu1Gj5e0VhoZt6KKuYd82m2ISS+lviSRAjY0uKGQvGQncUBccfEhjY1ZWjIsiTJFy4jqNsZKiTMkroj/gj6UeUFASaYfeQ5QZfWhIZnZlo4MCS5lDbbTZg6z2+2kBrODIxLQuvi9w55BKBfe+DFs3o0me56eqPl145GSc0e0dDDpR7EVoe47dbwhKd4hpUdEQbz7Q0JyR5p/yDdiDvd1l1lQjvBXSFHbBYiIYI3Jh10isymmIF2ZDYHeg4do4JlqE1I32IXgMWJfh4eUZ5dujBgoiH/skQhWY68lomJ9CbqISH6ZNaLibADaKGB1KWI4iHaUYQSGEgckWQL/GKBg1uAiBs520icAVGklAKskqeWWOXwimnlQCvnHenFxyMmVaGJ5Sg5btqnkJ/EtJ+aIm6Rppylu5nmAGp2YqBaKh8zHYlztaWLnoaUgqWeeSHDSGl6BYshXkXUeaikpi2YaTSY4PhlpiIXwaKilpI5iQaaZKqFJa9YZEhuRiI1KaqmioIqqD5hsECchsc2GkCWzBmuqrbYyacmXdp03iGlkmmXmJMFGq2YoxNpawqaUtBbjH5zRSGkl0go7SrXEqkoJbo0BKghng5oFHCXhRkuKouTemm2OhYQjz7Z0PhKvtKXUW22X+2WmLLfPFdJsV9JF8i/ApbApsLWSIKuW/yHVoIMNIRtK8jDEeE5sq7mP4FuIM+Jgy/G3jnwsrypIiGwrro74aRUiGV+DCGWFLuLyy6zQK7OeKr8Ylrr5GrMtIe0a1fLPs8pSwtCLltBIp1YRlwlycfXoM9SX0iIx1XnyuYhdOZnFCNi02uID2Xo2moiTP0GayaRGTYkI22HrIjTcbybCoE2fRCWhIXwjuszUgG9JMoVrzQGKA+0+W0jiaWYDRuNt0rygEI9JUUoDHABY296Yo/nN25xrSbAwqauuzt+AG6tL7FbWwzjnsOOuT8ycW52L7xipwfvwmFO1O9W215I8WqeS7bnzfFvGuszT08J2cLRXe7vL4y1fLf8EyP8b4NjECo/Lwx1ej2ow8frY/ZbNry+uj4KIryUzfeM/SA70WtI07uS/AhrwgAhMoAIXyEBE9GAAEIygBCdIwQpa8IIR7EE9gkCADnrwgyAMoQhHSEIPBoESWcCgClfIQgpmYR1vKKEMZ0jDEL4hEilooQ53eMEUmKMFNQyiEEnYgkekkIdITOIAXuiNGA7xiVAkwA0bocQq8vAbUcziEBvxQCt6cYUazAYHtUjGGZ5wEV9Mowq1UcY2ypARaoxjBdnoxjqGEI5yzCME6WjHPhIAj3qUIx/9WEdGdDGQaQzjNMZIyDaeEY2ITCMWG9lGRxwxklVkojacSMksTrH/ETnEZBJ9WA4gdhKKRYTEJUXZQk2Wg5OnrOEnI3FIVl5Qke9gZCxJ+MgG+vKXwAymMIdJTFzsoAgKSOYJxDCNMbCgANA8ghkSeIJkWtOaO1CGGaDJTW6ywIDIvKY4FTCMMXTznNH00QTGyU4FRCEY6IxnATDQoR20s50n0MUz5RnPad6nmvdspy74yc9vciecAW0nM29hToLy8wjBWWdCAzoBXGDAoQ6l52KiMNGJVvQWF8WoQ0MwF4B2NKADFalDDcoTNpy0oylVqUPhgJIsvLSj+czFPmXqUD/oIwomvWlALZSLF/BUpCx9B0KFilJhNPSoDoWoOiTK1IRmUxlQ/xWpRrUhhqp6NBFX+AMPeKCFUlDhDz/4wRcUEdKsEnQM2QiqV8dZBEWQwAB4zSsJRIGCBPj1ryhQxBHcStCkCmOpcxXnCd6JCC3k9bF5LWsnvvDXyv51rYnYKWHRKVVdUDWx43SlIVwA2dIaoBNnsKxqE7AIP2yWn1uthT1By042MMK0puXEalfLCDi8Vp7+nIVcaauAnC6CB7gtrWQxQdndWvYHjdDsb6Fp2FYglrjudERyS7vXRAABAeBFABAU0VfnWtYRIZguZ11hU+xe86ONIMJ2S4sIN4T3vghwAyLMq9rYLqKt6oWmT1Xh3mvW9RFPmC99DbEC/OJ3BYfgr/9qOwCJwQaYm6iYbYGN+4i7KvixhrCvg/Gr30JI2LKBjYR0pxvcURQ4mVeFBBs+/FgiGGLEIzYEBk5c2T5IYpsXLkAprptY+EaCxo91QSG+i2P8jtfEPP4rJQD8286Gwr0HnkQbkIzX7hKiyTkuRHmjvIZKWHi6o+AobTk8CS7j9RBgdrAhOhBlKVtixVklqShou9BKeBjJNr5xnO97iB3XOcWVeCph01xkTCTYzYgYNKEjXOcEUPgSVD6qnq9c1Sxfws0G4EGkJQ1eRPyg0qzNxJmPSoqqMhYTyIX0ISJA6lLvt9LQzUR6oUoKIt9TtJ92s5JHTepEpLbSnHCtTK3/zOmJ2pYT8uWyl+Fca/JW2r+Y8K1ITaFhfH4C1IuoNQIWgepP4LmbLW51O2PMiT/TONCIoHW12VppRHMCyPFchRgQukxQkFbWihA3I1B9BlA4k5tHgGtCQC3qcM9bEadGtgJjzeVGCHzguFYgqJ9g8Ycrgs4SP2C0kTztRMi72I0YM4+xbaNHV9wRF28Eqi/tP3d/uA2PiDkj1lDvAjoW4B1HuSPK7T9QPxvmHmdEH4huI4rTuOSLOLmkI6HyE+faReCOhM6HHvIOjfzdkth6IwwdZZaPx+VInoTYZV5pmgeI4WpPuiMiXucJzRjoj5D6oCmBah+/3c3L1brcHdHc/7rfZ8vSrsTaHVF1CZfZPVmnxOK5bnju2FzB8I670CdBdh7b2zb/fjkl9B7nSxB8OnC3xOTnzvTV/Fz0ih98JFCN2dVcfr7DVr3sIXHsKH9+MW6GuuanjonG8zc4eB/96iHRdctwOfO637wlOi/h4Hx9vptYPvNXHpzXz/fomND+I5Z+4tqvhsacEP8jeMwdBXOC9GDuRPW5E3rT5l4T6n9E71dbcPdc3wDQh3+7N339RSIcx3GgkH+TQGFuV0yMoIAOOArw12QROAsQWIGhcIEY+AkauIGdwGSD9mQe6ArSN4KrIGJgVmIm6AoN1mQQtoKwgIIkBoOzAILiRYM4mAmDOriDPMgJgQAAIfkECQcAfwAsAAAAAMgAyAAAB/+Af4KDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5rkILvQtCusHCj0O+xgtDw8rLgybHxybM0rrFz8fJ09m01tba3rC83MfA3+Wq4t3m6qboz+vvo+3H8PSf8sb1+Zv3vvrZFn8AhuLXK1SFPwf9bVJyoKFDJfYIfmIioKJFJgot5XDI0WGOTgQXdOpisaTFLhkndVx5AKRETiZjCkgZiSVLTiFhyoxJ0xEYmyuR7HuZycjOmF56MmIItONQfpuOxsSoVFHTlRAz5cxEUarJqlavOtVK9JJXnmARie1YgixUTBb/zn5Ne6jEWo4fL221RFKuRYF0C/286xDT3kp+SyYNbIiwQx96y07akNgi40MbHbe0dHhS5YqXEdl1nJVS50hdEwMOXUjzgdWRTkP6LGAK60NqNLc1LRlS3MoZbqvVDIb3W0leaAtHhMS18XuUaBtZPtwxZEmyGVH+TD2Rc+y9Gynvjogp4dKPsitK7ZcqeUMQvkNSj6jC+PeHfOiOHV7R78Qb4OedZkKl1x8iRnEnICKDOTbfgYfQttiCdWmmhoHHMZLBZ7BR2JpmGELnyH0eHmLeXbsxQh8h/7VXYliOdXjIioLYp+CLiOgHoooQDkJbgDgOaB2PGSKyXWUZbbHE/wBMprAFKJk5uAiNtKH0SQMqBKBlBQ2swuSXYBbYyWjnTdkje3LJiEkZWrbpJipIgClnk5/Ih8iKJG6SpZt8BlCGKXMGOkAWnZy4VoozQtiiXO5pokGfkAZQypKCBsoHJ67llWiRhPSF5CYgRBppQqJUaioUmugo5aYiRvgZkJhQIOqso0BhqqlLaOLadYZkd2RimlQw66wUjHLrrT3AZSch2dFGaiUcDDtsrcce+6QlZN6F3iCyoXmWmo80IK20xZZa7a0poFqJax2eZuOnlew5Lq3GnntsrpTk5hiigpy26FnBUSLsvNKSQqm9yFKy7B/hyEMOIXk+Ei3B0j4bCv/C54r5SHOk9drqIN56NV0kbFI8rilxYnxsCpJku5Yh1aCDDcSVgZuIvCbP+ucpKleL7yM7FuKMONEYcqMjA+c8rSp89Hxsso4YehUiMV+DSGWNLjKx0rOC4MrBTguqLiOE8VtIw7/4B2wjsnI9q8WtpBB2pSwzoupVxWWSnFywKoKz23yqUEvKcwdK6CJ36XQWI48CHunOtvRQuKCXJhIlUJpm4ulRViISquOQciAM2JPTmUiDN30i1YSGUPA36AHArYvcpYP5c4VsyQEKB//anDTsWgo+zRa1ywk1gz5ABkEpXmwQoG2IbA28ll16I3nxX2qsS8nTaym6OqSXfq3/LuJ2H3s9tBcvjPkqlFtP08XXjcvrgHudURbq5zK9BlWlP/f4tSif44QHFlsV7ni1kB7X3EeX6zkNgbRQoMm+x5rwnUsXXJNdaPx3Livoz2QEJA/hqiW/W9BPVJATkANvFYy2SYuCJbIgmACICwGOKkiE4OCXmBGpEOJQEEg4mJOmgaU2VSCFP0yiEpfIxCY68YlQLMQEFEDFKlrxiljMoha3WMUJ1AMAYAyjGMdIxjKa8YxjpAQbuMjGNroRi2xYBxrnSMc6mjESJ3ijHve4xROYw46ADOQcH7FGPhrykAqIozcEychGitERiIwkH7/hyEoKshFTlKQm2+jFbFjy/5OAZMQmR8lGbYDylINcBClXmUVTovKVZBQlK2dJRVfC8pYAkCUtWWlLXL6SEZnc5Sg7OQ1f3rIRwiQlJY15SkcUMpmRVGQvmVnJR+QRmof0YzmoaclIPBObb5TmNrnJSEoEE5xbJOY7yGnHKLrznfCMpzznSc9guIAIBsgnCbQwDTK0gAAAbQIamkiCfBrUoC5QBhoAylCGtkCJ+DyoRA0wDDI09KIBDRIPJspRAzwhGBgNKQGC4CEXdLSjJNDFP0Ua0oHip6An7aguWMrSh3YnojHtKD9vYVGasrQJwtloTmPKA1wEwac+JSljnjDUoRb1FkdFqk+dQBeYNjWmM/+Vqk9t2pM2XLWpWdWqT9+QEjZ8takpzcVKxerTPejjCVY9a0zjoIsQsFWqXH0HTuWKVWH09K4+Bao6hMrXnCZUGYCVqlK1oYXCOjURWPgDEIDwglKI4A8YwMAYFBHVxNKUDNmIq2MnSgRFrAABqE3tCkTBggK49rUsUEQTPEvTvApjr6OVKAk+iogXpPa3qa1sJ8bw2uK+drOJWCttMSpYXRA2txMVpyG4ANzqIqATZjCudguwiD0sl6WLrYVJocvRNjDCutblxHa3y4g3fFekLp2FaMlrgLQuAgjora5wMUHc9RoXA41Q7nsBattW4Ja+HnVEfqu72kT8IAEQTsD/DxTRWv8a1xFOGDBzXWFWBB/0qY1IwoKri4g1RPjECVgDIiys3SM8orMaBqhbVeHhg5b2ERMYMYkNgQIUoxgFh2CxdkMAidnGmKGoGG+N7fuI0+r4t4YwsY9RrOJCCNm4sY2EgAcc31HUOJ+HhcQZnvzbJBhiylM2xBGuXFw/SGKhRyZAKQ6cWxBHgsy/5UIhHoxmFE/Yymx+LSVg/N7mhsLDN56EG/CM2gYTos9pLkSFAw2HShh5wKNgKnmZPAlGo/YQkPaxIUIQaEFbYsuJpaooyLvTSjgZz2Y+c6hPfIg1lzrLlfgrbTNdZ0zk2NOImDWtg1zqAhD5EoS+q6oP/13YRF/C0wgAQrCFDWFEYKDY3M3Epe9KisLyFhP4Bfa0qZ0IbAM4ExkGLCnofFLpPtvTeh63sBOR3WJzwrtiNTSzh2peToiY0Y4GNbUTQOFiu5gT7pWqKZSM0k9AexEDJ7gisP0JVDe0y93uaJg58WoyxzoREV+ErQONa07AOaSr0AJO9wkK6opbESFfBLbNAAp/MrQJoFUItKUN8YEz4tr2dmK4Gd2ImMu82OdmIrTVCXKfM4LUQV/iv/EccJg7nRGTZvPBk/hrojvC6IzA9rF/2PEnu+ERYF8EHIpdchz59uVFv3ojKP5DaJ8BEmlfhB/ojqOhk7nqjMj7IrJ+5f+kl+jhkRD80UuNo6l7XBKKV8TItV6iruN5EpGfeLHHLqCdY17ujwA64xc0ZrjjHfSPwLabO+/p/SYe9Y7o7+jfs2iAVyLzgy92pd+DeErgfvGBfk/Zdfzxz5O7EpO/cttZ43Kv3x72kJg5dTxvid8vQvTBF87bnf/841sC28hlzfBHHO/qQx8S9Sa5cDwNeOPPGxOEF/L6uW9+718i6qFhdPHr/35MJJ/FwuF4I7YJ1ucIgbZ1obF9I3Z3mlCAjbB3VxZ+rEFmnOCAc3dl3aFjnWCBF2hh5NF81lV+DXh+lJB+20Vz7yGACLB/I2h/m/B/CCggXsR0FUiCmEBknFdJT4FngzqYChzYg6Lwg0AICkI4hJ5QhEbICXw2a3+WhK7ggk64ClIGaVUWha7QY30GZFYIC1NIZVs4C0soYV84hmRYhmZ4hpwQCAAh+QQJBwB/ACwAAAAAyADIAAAH/4B/goOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLmuPge9Bz66wcKPar7GB2rDysuDJcfHJczSusXPx8nT2bTW1tresLzcx8Df5ari3ebqpujP6++j7cfw9J/yxvX5m/e++tlQfwCG4tdLA6gNfxD627RkgMOHS+wR/DRigcWLIxZaQvKw40MknQge6OThosmLHjRO8shyQMiJnE7KXKAyUsuWnETGnCmzpqMtN1ny2UfQYCYBPGWG8cmoYVCPRPltSiozI1NFT1lGzKQzU0WqJ69izQqVK0xMYHuKRUTWYwqzUv8xmUgbdu2hFG07grwk0milknQvmrB7CGjeh5i6WgpscilhQ4cf9uB7lpIQxhcfH+IY2aUlxZQwW9SMCG/krZRAS/rKeDDpQ50HCJzUt5LoBVJeH8rS+W3qypHmYh6im23nLb/jSgpzuzgiPrGT3wstWoBz45EnS1Lt6LLo64miby8qqTl4RE4Po37EnRHrwFbPG7IiHlJ7RRvMyz/Uo3ek+4kIx5gQ+4XX2VDsAbcIUt8ViIhhkdlHniO3OebgXZ1lkaByjAwhmmsXYnfYhtNR2GCI6PnXCICFCAgfimNFNpsiLA6S34kw8lcfjRMqchuBORqYHSM1/uEdZhqJUYT/AkyeIAYonEW4SJG3pfSJFxYIoCUTXqzC5Jdg7vCJaepNqWAh79EFIiddaOnmm6jsAOacTX6y4yE16sdJlm/2KUAXptApqAJsdJJeXr4hUhsiLtIVnyYZ+CmpdaQsOaigGm4S2154nikIYEhuYsSkkzJByqWoRqFJf50lAuCPmlRA6qyjRIEqqkVoEpt2htx3JGOaMDHrrBWMcuutE2ACxZ2D3HebQpZsMOywtR577JOWkJnXes32OEiaaa05iRfTTlusKNYee4KqlcQ2oyDc3RhqJXyWS6ux6R6bKyW8RZZotxwK0mhaxFEirL3TVpqvtcmu1Goh4chDDiF6QiIt/8LTmnrqwtaKGQl0p/VaIiHggkUpJG1iXK4pcnKsriTatmVINehgQzFm4jZSr8qzAnqKy9bu+8jDhTgjTjSG4NjIwTxTq0oWQB/bcCOHkoUIzdcggtmji1zc9KxGuGJp1Jeyy8hh/xoS8S+KDJyUI7J+PavGsJxA9qUnNMIqWchlwhxdQC6ys9x9WlBLy3cLWugiee2UFiOREj6pz7ZMkPigmSISZVCcZgJqUlYiMqrkkkKby9iXf5l3IhDi9AlVFhpSweCkC0D3MHanDqbQGLp1cidzDJwzIUzXrqXh04ih+5xTF9bDZFaUEoYQBOaGiNfGa9mlN5Yv/6XHwqScvf+Wpn+Duu7Y6kLu+LbXk/vywrBvwbn1QL386rjQTnjYGrEBfy7Zy8BV3ne39NVifZJDnlhslbjm0QJ7X6OfXboXNQfOAoIqK99jzpcvXXztdsUhYLoiAECVKfA8iLMW/m6hP1JRrkAUvFUw4jYtDTqIg3MyIC4QWKogEUKEX2LGpE7oQ0HsYGxOmgaW3MSEFxbxiVCMohSnSMUqWrEQPDCAFrfIxS568YtgDOMWeVAPDgTgjGhMoxrXyMY2uhGNHKBEG8RIxzra0YttWIcG3sjHPvpxjX5xBAnuSMhChpEE5lDBHxfJSDeq4BFzNKQkJ2mAPHpjj43MpCYDEEhFUPL/k4b8xiZH2chGZBGUqKwjGbNhRlK6so9xXEQqZ0lHbbzylnxkBC13+UVb4vKXa9QlL4epRV8C85gBECYxeWlMZP6SEadc5ixXOY1WOvOWsZSlNGcpymve0hGR3OYnLakNTHpzlJ1UxCDFOUlElkOR59TkIyERTnbekZzlMGc8/5hOR0TTnmGk5jusuU83ZvOKCE2oQhfK0IY6FBdcSAICJrqCF0wDABjNKACmuIKJetSjXFCGRke60SdK9KMoRcAwSMrSIAEhpTBFgAVrwdKahogLMY3pCnRR056WVD4dzWlMeepTm4LnpEKNqUVvUdSiFuelSRUqEHDR1KZqZgJR/43qVJlaVauuJahZFSpRu+pUn7ghrFkdK1l9qpIzoDWrO83FWruqjwmA9a1CdYFa51rWdyAVr2IVBl/Jqg6oAjapIRXpYL2qjRccVquJoMIffvCDL5SiA38IQhDIoIjFVjUbd31sSpOgCBQk4LSoRYEoWkCA1rq2BZ31bF+F8VfRonQFMxXEF1DLW9RathNkcK1wXcvZRMiWrcEwrG1TegZFnKG30E1AJ9Aw3OoSYBHHRa4tcLpcmLqBEdGNLiesa11GZLentQhtdxEQ10X8ILzQ/S0mgkve4QahEedtaSxqu16ZOgK+0FVtIjBQgAIXAAOKYG19h+uI/OqXFW7t7/9Ht9oIDAAYuoiAg4E3XAA4IGLB1W3CIxxM0lVI+KOkfUQHLoxhQ7CAwxxmwSFAXF0nQILEIz0Fd0/c3keYlsW8NYSGYcxhDxeCxsOFbSRwjNFTnHiiiYVEH4DMWwQXgshENkQTkCzcPUiCyT8VBX9tS+FIUJm3zSUEgbHMYSsTgsvCpQSTSSHhFE9iDWc+rYAJweYsF0LBcH5DJUg8Cqx2t8eTyPNpD9FnGBvCCXB27SUcPIruLrUSPz6zm/nc6A0fYsuRVvKgs1toMmNixYpGRKc9PeNIE8DGkz5upQ9r50soOgE/UPWqC4yIILj6upnwLJ0Bm1tJvDfVut71BT7/7Or7BnuwpBhzTtOsiVtT2xC75jUiqOtqTvC1FGH9LicsnOc9MzrbCXa1iL1N11LsWKefuPUisl2ARfz6E591ckyjzIlMU3nT5971IkANZ1Gz26ipeAFSKwqK5yJbEfRetiJ+jQZQPFgft871vNG9CF93m4rHznMj6N2IXztbirfGLCNIzghIfzyK5D6zuSHOcUYAmsvrfiKqRe6IiDvi17Auor+BvIZHsLwRb3C1wXO024ePvOYlf3mQbt0HSBy9EXu4d5BCTuWZrxzqjbg5kk+OInlHwueQ0DqKYv5vSVzdEQTHOYp2fuZJvP3nrg56gTJud7A7wuORvtCUnW51/7/jPdJe3rui5Xv2bEs8EvQN/H7wXO5K3P0RYqexoOVjdkpc/hFqv87QWQzwxgu8EnFH8tJf43CeW97waXd1xZ3Dd0ugnRKAh7Nzmu7615/eEr8u7mtGf+Frex72kOB2wYujaK/3/feWyDyImd972yM/ElLXTJ5Lf3xlZyL109cN2y+8ic9PAs45Jw3vL1x1TZhfEllHsvBfQ2VOvF8SXAYPiztxf/yH/zqtF13Ghwm3lwnKZ12zdx7jlwDcR4DXh3ohNnd/oHKf0H+WYGN691BfB30aCAsW2IGmUIAg2AofOIKjUIImGApr1mkNmIKowIEuuApD1mdGFoOu8GJsJhljNggLM1hkOzgLK3hgPziERFiERniEnBAIACH5BAUHAH8ALAAAAADIAMgAAAf/gH+Cg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ua49A70DPbrBwo9ZvsYDWcPKy4Mpx8cpzNK6xc/HydPZtNbW2t6wvNzHwN/lquLd5uqm6M/r76Ptx/D0n/LG9fmb97762VF/AIbi1yuUhT8H/W0qoqChwyL2CH5ScqCiRSUKLe1wyNHhjk4EB3TKYbGkxRwZJ3VcqQCkRE4mYx5IGYklS04hYcqMSdORGJsrsWXKqQnJzphgejJiCLTjvpeZjsbEqFRR05UQh0K9RFGqyapWrzrVyk+TV55gEYnteILsvUwl/85+TXvoxFqOHy8RtURSrsUSdA/9vOsQ095KfksmDWyIsMMJerdO8pHYIuNDGx23tHR4UuWKlxHZdZyVUudIXRMDDn1IswKBk05D+nwAAutDbDS3NS0ZUtzKam6r1SyGd9lJYGgLR5TFtfG3nj8jWT7cMWRJshlR/kw9kXPsvRsp746IKeHSj7IrSu2XKnlDEb5DUo/Iwvj3hybojkT/0O/EPuDnnWZCNdJfIUZxJyAigzk2X3iJ0LbYgnVpxkZ6EB6ixmerUVgdYRgeJ56CHpa3n4EZFvJfeyWG5RhsihyI0H0t5idfjCkOQluANQ5oHSMHbldZRloQYcCRJGgBSv9mDi5yIG0ofRKGCQtUOUIYqxyp5ZYufDLaeU7myJ5cHXLiQZVopomKC1u2ieQnNx7SH42bUJnmnQt4YIqbfBrQRifm3bUbIvStKJd7mgyB56ILlGJkn3xeuIlrecmZYV9DbiIAo4yOQAqkoD6hiX6aJaLejppswOmqozwBKqhEaOLadYZkJ2Rimoyw6qobjPLqqzxgEkWcg2RHW0KWCLHrrq3++quSlnx5F3rFhjfmWWVOEsayy/YqirO/kiBqJa7BKMhp9pFIiZ3csuoruL/GSklujg1arYiDGHpWcJTo2u6ypDwKL7CUEBuOPOQQQucjyv67rKefDuxsl5E0R1r/rdARcq1X00VypsPcmsKmxOFKIu1ahlSDToGCcCgJuyCvqucpJDsr7yOlGuKMONEYom4j/sbMrCps1PxrsI4EKhZz3LCsY2KILtKw0KsK4IrARvc5LiOE2WvIwb8oou9RjqhK9aoQw0JC1pCS0AipYhWXSXJy8bgIzGffaUItI7PN55+L3KXTWYwomjejM9vCg999SooIk0BVmgmmR0WJyKaHLyqEMFgz/mYiDd70iVQTGrIB3pkvkPYwa3u+5c0VsjUEKHLom20hQade5d7TaOF6m0gzOAFkEZQChg8B2obI1LpXiaU3i/+uJcXCfNx8lZur07nn0Oqy7fWq19P6/+/CgG+Ct/UU/bvbuaCet9UZtUF+Ls3PrtT4bHdfy/eH8w6Wq34LXi2YRzX00SV6RhMgLQgIsuyxZnvg0gXVVicc/IHrCvQDmf/I0zdnsQ8X7uNU4gSEwFcFw2zLcmCJILgl/eGCf53qESEsqCVmMGqDMhSECwSWpGlMCU0jGGEOh0jEIhrxiEhMohILAQQEOPGJUIyiFKdIxSo+EQj12IAAtsjFLnrxi2AMoxi5aEBIuMGKaEyjGqXohnVkYIxwjKMcv5iBSKxgjXjMYxVXYA4LzPGPgBQjshhxRj0a8pAIaKM33hjIRjpSAHVsBCInqcdvPPKSgWxEEynJyTRiMf8bWsSkKONYxkN08pRo1MYoVwlHRqDylVNUJStn+UVXwvKWTpQlLXcJP0XgEpe65OUsGbHJX57yk9MIpTBXWUpTGvOUllzmKh1RyGdOUpHaYKQ0LxnJRtzRmofkYzn8uE1HDrIR1QTnGrFZDm2Wc47djEQx1VlFZL5Dme8UYzOXyM9++vOfAA2oQGlxBgwk4KAo+MI0GqCCADi0AmU4IgoOSlGKnkEZZXCoRjWqAiIatKIgTcAwGrDRkj60Rz8IqUoT0IFgmPSlAeCAh86w0pWiQBcNhelLI4qfidZ0pbrQqU472p2P/nSlCr0FSYWq0woIJ6VH/ekPcMEBpjJVpoz/6UBUozrVW1TVqkylAF18utWfBhWsTCVqT9ZQ1q2eFa1M1UBK+tDWrd40FzmFK1NBoI8OkLWuPxWBLhygV7Cq9R1GBaxZhbHUwjLVqeqAqmKPelFlOBasWNXGFybL1UQIFgMYGEMpAPAHAJhWEV+9rFAbkI2/cjakGFAECwpA29qyQBSmzW1uFVEB1Qr1sMJI7GtBioKWImIMtU1ubUXbCd06d7eJyKtvTQpZXUh2uCHtgyLMoNzuFqC5z33uIkAwXZ1mthY0xa5K18AI73qXE+ENLyM0UF6Y8nQWrlVvAu66CAy4t7vMxUR849sI6dbXocBthXD1y1JH/Le7t01E/xAIQGECBEERA5ZvIyhwYOq6gq4MrmhXG3GEB3cXEW+osIoJ8AZEZFjDjUhthx3KV1WEuKKxfUQITHxiQ7RgxStuwSFeDONG9HbGGkVFem/M30fMlsfJNUSKgbziFheCyOKNhIEPfN9R3PiglYWEH6Cc3CMYgspUNgSWswyJjCI5AKVY8HBHHAkyJ9cMhZgwmld84SuvGbqSkHF9qxuKEOd4EnCwM20jTIg9p9nPfz4tJY584FFoVb1NnoSiaXsIRwNZzZGWdCW2fFmxikK9Sa3Ek+1s5jN7WsVDDjVpLdFY31p6zpjY8aYR8WpYxzrUmBB0YU1d6Mke+hKbLsCxG//dawq7WNaaoHRhSTFZ42LCv7vmdbMJkAhZzxoTHHYsKeRcU+1uItl41nazuw3tTZAXroQudlTZy4kSK5rRnd42htu9CfqC1RRLtuknkr2IbXN735H+BKk32mVqrzTMnFg1mVudCIMvwtufcPNLV/EFoyYUFNzNtiIsfnF+d4KhGq0AaxWS7GXne90lBzYSsa3oRpA85gk/YrJDYHN9MwLjRrS3nfE9cp//3OQy1HXNHXHzo8s8hxKHMhwe0XSc/3mIyBV5z2HuCKS3KNl+gETVrb5mGdKczERnxNjJjuUeETwSa2f7i2sk9IlLIu4IzzmFlG7nSeA971enUMv9bnT/SABdQGPWutgLb3ivUyfZAYY74x9xePIk+t6V+Lvc5/6et1NC85sf8HuizmOKE57rk6j8bUK+9MxPPhKqD83gLQH60IteOFlvvetRT4nYB4b0Jk437V8Pe8fTZdNpP32vM2H8tCh+98tnvt5lz2pN1L4RTw9N3U28ietjP/Csyb2Jw2594qce/KwhMye8/30id4fHnWB/+29PHdZ7V/jl572AOU+e7RfA9N1nfpZAYB7CczwHCvIHe6U1UIunfwzoCgn4gKEQgRL4CRRYgfEngBhoCnr2an22gRAYfSDoClPmaFY2gq7wY3smZCgICyVYZS04Cx1oYTFYgzZ4gziYBIOcEAgAIfkECQcAfwAsCAAIALwAvAAAB/+Af4KDhIWGh4iJiouMjRMKkAoTjZSVlpeYmZqbnIVskaAKbJ2kpaanqKQnoaEnqa+wsbKan6yho7O5uruwtra8wMHClY++oZPDycrDxr/Lz9CyzazR1dal06HX29yW2aDd4eKH35Hj55pPf+rS5QqyUH/x6LtEBvf4RL3usEsD/wCX0IvlAp9BfC5SuXuHCgnAhwCRDEx1sKIBhfxQQdw4YOIpixZRLdTIcaNHUlpAVsSFLWMpPiU3bjnJyZ7Kg6dGmoq5USBNTTcr6mtZzpQ/nhB/Ag2Kk+i3nUiTKsXE9CAJp9lKpYgqdaolElUNJuykk5NDrgBTeL2UMiw+UmX/N6F9OHOtJbf4eJB1qanHXIB2LxXEe5FT3Ex//wXGBBbvUE2HLx2dq3bxJcIG2GWKbCnxACuWL7UhfBUy30tb/2YJTZWwFtNFM23xzBoTG8ywnyJOzKd2a7x6MXFm5Dex70y4hZ+mRPs4JptuH1carmgyWp/OLV1J7m35IijNs1/iQfoSdUSp5/YQj5wwy0bnDcE0zh5TW7zdYzNPXLf+pcZutTGdd4hkkVhl/v3m1oD6MRJegpdAF1ZpjMQ3SHrXQbgUXpopYqE8D2poCXmEwUdgIZ6tJ2J7wFV44iDF/WXXC0kgYOMKLxDEXSIWeiYRLGCUcMCQSoABi41IJskF/ywAhiUdOS/+YR1XCKKSw5BYZokKF0l2eSMsO0LZ4CEhmiJklmgekIMpXraJgBupSFgVhWLqhl5i2JmiRpp8HlBKjW62eQYqmI1VZ1aInCXjKUj02acSpAQqKTKkkIgfItSlaIoFjnbayQSSSpqEKZgFZ8hwMc5lihKddmpBJ6GGCgQpT4Q5yHCezcOJD622+mmssebISZNVPSkIZ1NGVWUmYPTa66ucABvrCpSy6FaHxy4HHn2bnOmsp7BKG+uomoyGF53ZjvkHhlytpgmr3/ZKCqDiyrrhgoUUk021gpRJCa/x9gpppPUCu+Qltzl2qp2DJItUb5dcGbCzpnBZ8P+0jJXoSTbv9fvXso14O3Gna55yMbDkVqJxIasY44oh3FIC78i+vnLGybHOSomcQSFSCysdD/JXnosATHOnP8ZCL85u8puIW+jmC4rThLDLEyWcHt3pwLqswHSgKzRiaVCvlTIbVyouIrLWaJYgjMVftwnnImGRFBUje7LdZ8nDABG3m4MmMthNhpaiaExJH9Ko3nz6EM3Sf3+ZyH0hwcJTf4ZYsDbjB3BdjdeRJ5nyIcQaQEIcsQhgNciEzMz5kG5380LoXeqMiBY86HXFLlv0sB5oiBj9+pBGjuM37UgeTI/Eww/p+ECQRy7sOc023/lPoNNOj/UlQPvTzbSHPc7/5mwnPpUb2o8zvBqsZf/19NxUr3fstYEat+3cCH+098cdjzP+29DfxJ5Xn+hJ6xxH81yC3CctLKhvYvRbEdyAJT5xkM9RfFvRIPwXKnRkrVcE1KAhDJgk+IlDfo8SISMYiKST9CmCKlQEF+iFo58ECUtKyGAMd8jDHvrwh0AMohCHqIgfJOCISEyiEpfIxCY6EYk/8I0QFkDFKlrxiljMoha3WEUhIGINTwyjGMe4xDVYZghcTKMa14jFIRQCBWSMoxydiILAmICNeMzjFk0wCDDO8Y+ATIAZvYJGPRrykAtw4x8Cycg5rgWRkNTjH4zYyEqKMYpKmWIkN6lGIVjy/5NhnAonR5lGUJqSiaIkpSqxeMpWIjGVq4zlAlzpSljKUpWUpOUnMfkTTd5ylF7UJSgf+ctRCsKPwmTkIKdSyGJCUpF/gGMyAVlHu9zRmYfkIyGQOU0yLtMuzcQmG6FZiFx204m8DI0vxblFLxLxnfCMpzznSc962tMUZjhCAfbJgjH8xAsWEIBAmdCFeLJgnwhFqBkm0gWBOtSh/AOiPhNK0QIMxAsPzehAgYiBinq0ACFAh0ZHKoAN8NAMH/0oC84RUJKOtKAiPGhKP3oOl7o0ov6Z6Ew/6s9wYNSmLmVCgjq605liQBwbACpQTZqdEBS1qEcNR1KVCtQKHEemT/+daU2pClScrgUOWX3qVrkK1AwExg9hfepKx9FSsgLVCFMJAVbTOlMTcoMDbqWqV9GhU7pqlR4/zStQhToQovp1pwudiGCpylRxjOGwUE1EB/4QhCCQYRdV+AMHONAARUx1sTb1QjjmCtmKHkERLSCAalfbglmoIACwja0KFMEE0Np0r8roa2kpyoKQIoIMqw3uai+bigbE9rix7Wwi2mpbjRL2GYbdbUX9oAg0CPe6BEhFGZDL3QAswgjNdWljhYFS6XoUDozALnZR0d3uMiID4SUpTIFBWvMWYK2LCIJ6r0tcUhi3vcjlQCOYG1+B4jYVurUvSCmx3+u2NhEAiLD/hBXxWgAjlxIVKLBzZ4FWBSc0qo1oQoOviwgJm3jCh7Awd61Kic9qWKBwfYWHE3raSjhhxCQ2xIl3DIAUqxi5FLBEbV/sUFSUd8b4rURqcRxcHfN4x4b4MXJnewkCF3i+nZjxPhNriT0wObhNcPKTTWyICkj5uCDAREOJLIBSJHi3IL7El4OLhkKMmcdRPnNsNeHi+D53Ex6ucSbeMGfVPpgQd4ZyISqsZw1sYsgF7oRTzZvkTBRatYdI9IkNQQE975kTVl4siwEt3Z5uYslzDrOYNd3jMns6AFTeRGBtK2k4k+LGly4xqyOMiFcHIMid6HNeR60JyAq6E5cmQBB0/71rRHDA16aAdF5JcVjfkkK/uWY2qxPhawGXIsOCJcWbU0rdUyS7ztrWdCK2+2pUgJesfyZ1UdGLChEX+tCZ3nWrEcHoMxO7FPClKj53WmlTJHsR+t53r9v9ilA/FMvU/iiXUYHqL6sawvpehJk9HWtUrHmksBiDTvsZC+tmWxEJZ4SvyxALgDqUCaJdS7KXjfCML+LZDI8ntgvdiJSr/NXehmeyndBzmy+i0zknor3njG+UG30R/Zbyv4GIa55TwueN8DWwhVhxJr+hElhnhAZe3fEfAvfkRW92JaAtxGTvwRJhZwQI2P7DnX+56YyIOyOi/uOg9/Dgl9D7zz39w/+lWxwTgtf4q6euwarPOROJX4TWeThzyD+9EjgnfAy9jHa4X37tr06zCpPd38B/nhL/1bwGCX3vTUR+7692tAYBr4nXD17PGuw6ji9uebVrYuN6Lnt9TG5115/eEivXUOU5YXtGZB73CTp78Y3v+034Wrn10f2I0c3841uC3cFP0KXx3vttk4LvKhb/9LtffU4kXTyF5j37zU8K4Es5QYYf8SmaD3qpR//Lb2cK/EcJcydl2FcfX4YKA0gJZyYiOJYKC8iA6ScixIdd3CeA3qcJ4NddLKdB+UcA8oeB7WcK9gdbjLciREd0sRCBmBBkW3dP5aduMDgOLDiDwVCDNsglCziYg7qwgzw4Cz74g7IwgkIYDURYhNAgg0jIDXe2hDS4aSsSCAAh+QQJBwB/ACwAAAAAyADIAAAH/4B/goOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLmuPAa9Bjy6wcKPbb7GBm3DysuDJMfHJMzSusXPx8nT2bTW1tresLzcx8Df5ari3ebqpujP6++j7cfw9J/yxvX5m/e++tkTfwCG4tcrA6gofxD625QEgcOHSewR/FREgcWLRRZa4vKw40MunQga6LTjosmLOzRO8sgSQciJnE7KVKAyUsuWnETGnCmzpqMXN1me2UfQYKYsPGWK8cmoYVCPRPltSiozI1NFT1lGzKQzU0WqJ69izQqVK0xMYHuKRUTW4wqzUv8xnUgbdu2hFW07grwk0milknQvnrB7CGjeh5i6WgpscilhQ4cfAuF7ltIExhcfH+IY2aUlxZQwW9SMCG/krZRAS/rKeDDpQ50RCJzUt5JoBRFeH3LT+W3qypHmYmajm23nF7/jShJzuziiM7GT3wstOotz45EnS1Lt6LLo64miby8qqTl4RE4Po37EnRHrwFbPG8IiHlJ7RVHMyz8EpHek+4kIx9hs+0HW2VDsAbcIUt8ViIhhkdlHniO3OebgXZ25kaByjLAhmmsXYnfYhtNR2GCI6PnXCICFCAgfimNFRmAiLA6S34kw8lefIrUtctuMORYSm3Y8KmiId5hp9AX/Bgk0icIXoHAW4SI1/nFbSp9skcIAXC6xxSpNhikmgp2Yph6VRhLyHl0gcoIEl3DGicoZYtbp5Cc7HlKjfpxsGeefAyBhip2EJrBGJ+nl5RsiPR7iIl3xaZIFoJQOUAqThRLaByex7aVnmn8AluQmfFRa6RKkZKpqB5r01xmNoP6oCRSm1jpKB6qqioEmQzKaJpKMabJErbVCMUquuf6AyQR5DnLfbQpZ0gOxxN6KLLJQWmJmXus5O6GaH16yBbXUGivKtciiwGolsQHJ3Y2jVuInubYeiy6yu1LCW2SLesuhII+mRRwlw9JLLSmY3pssJc2GIw85hPAJybQGU4tq/6oKX0vmI9CdZsi/f6yZlnWRvFkxuabQmXG6kmzbliHVoINNxJi16ci8J9cq6CkrX5vvI68a4ow40RiCYyMF51ytKn30jKyyjiRKFiIxX4MIZpEuQrHStfLhSsJOF7ouI4f1a4jDvygScFKO0Mp1rRfDgkLYmaLQiKtkIZcJc3QBeQjOb/+ZQi0q003ooYvktVNajEwaeKU72/KD4YVumoiUQXmaiahJYYlIqY9T2oMwYFN+ZyIQ4vQJVRYaAgXgoQ8Q9zBzmy7mzxi65QIoQwRscyFJx87l4NN8YXudUD8IxGRYlCLGBADlhsjWwnP5pTeTHx/mxrqYXD2Xo6tTuv/p2eoy7vey11P78cKgn4K59TR9vN25wB641xqtwX4u1ZPs0/p0K18tzvc44okFV4ZLXi2oxzX42SV7TlMgLRh4svC9Znzo0gXXZlccAKKLCvw7mQHPU7hr0Q8X9jNV5AoEwVwFw23UsiCKMCgmAeKCgKcKEiE8GCZmVGqEOhTEGRL2pGloCU5LWGEQl8jEJjrxiVCMohQLgYECWPGKWMyiFrfIxS5eEXfr8MEBxkjGMprxjGhMoxrJ6ANKwMGLcIyjHLUIh3WoYY14zKMez6iGSLBgjoAMZBdZYI4S7PGQiFRjCR7xRkE68pEFqKM37pjISlryAH1sBCQ3KchvXPL/k4lsRBU5Sco4gnEZYgSlKvPYxkWU8pVw1MYqZ4lHRsDylluUJS13eUZb4vKXVtQlL4d5AF8CE5fCJOYuGTHKY77ylMpIpTJn2UpXOvOVnpzmLB3RyGtuUpLaoKQ2P5nJRvzRm48kZDkMOU5LLhIS3UTnHMFZDnG2c4/ljEQz5dlFaJZDmvdUYzWnSNCCGvSgCE2oQnGBhiYQ4KEtIMM0wmCCBVh0BB5wohNa8NCOdhQNyvCARUc6UhMscQIO9ahKCTCMMJD0pRcNUhBWSlMCOCEYMM3pAoQQIjTUtKYt0EVFdZrTjMonBBz9aU11QVSimmAO4EmpUmsq0Vu4tKlE/x1BcWY6VaUGARdCwCpWefoYJ3S1q1+9RVjFitUNrKUDST2rUpnKVqyaQApMeYNcz0rXumJ1CCrZw17PGtRcDNWvWBWAPjY62LOGQBdzQCxbTeBWeEi1sXMVxlUli9UR4NUcXMXsVEGqDM6ylazaIINo0ZoIAPwBALAtxRT+sIENeEERazVtU8MwDcau9qdNUARshztcUVhAAMhNrgUUMQLdNpWyy7jsb1XagpsigrjYLW4nvJDc7ib3tok4rHNhqtVghHa6K92DcLOb3U50wbvwVawiBDBeoqK2Fj5FL03fwAj2spcT8Y0vI4ZQX50adRZx1W9HC7sI//pXE9wNsP93K7sI8RbYoiaNhXQVbFNHOPi/ieBAAEYcAA4o4rgS9q4jNnBh8rpCsBz2aFob8WEQG0IDJM5xADSAiBTDlwmPyG2LLSrfVMTYo8F9RI1tTAgV6FjHKjiEj+FbAUg0d8gjhaop8ntkBit5ydi98ZOfzONCTNm7y42EhS98iiM/lLSQAHN7CzHmMRuCCWfurhEkIVIsL6AUG57ujCMh5zATQsR11rGJzZzn5FJCyAUuryhinORJFJq4hki0nQuB4kb7RRJXZrMozKpfL1v60q7NtKZ1bIgKNNrRllizaSkMCv1WtRKojq2qV03iQ+D51WmuxGadOwpSr3bQlMh1qnf/zesA9PjVAqjyJSAtWVp/YrWVvoSyEdHsXh9iA9Au8iVCLVlSiNa6mNg2t7sdAAY8+9XWrgSLOUuKQP9UvZtQ9yHY7WxEvBfaAEaspCd9Vv5yQt/7ZveJoQ1kThCYrVueqqk1ketF8HsR4f6ErEl64FL8FM4Hr7giLq6IXzc62Jzoc05XQQapRhQUCF93t909X2h3ARQUHekIeLuQmCe824wAN8Ch6POfN7sR4Y53EIvObF43wtVDbyLTm75qR3Q6zw1f4tSprmmaMyLc0l66yBtB8kZkANooz9HWuZ5oSGRc7KiGRNkbYYS3q33sjph7I65+ZqUXCO95Z7fXHWH3/xCt3ehOj4TJsY6iwyO+6pIAu+EBH3igS0Lor76Q4x+vaUqEe89/p3zlmz34R0Q48/vZPOfbTgm+T/nT1xH9I/QeicI7R/Wrr7MlFn/mtL8G97nfdCXCffPby372grcE5htt/LhfgvaRhzZ4f3985FveEv8+eXGqb/2jY8L1Pt7+pTUB/UlEnTTOxwS/S08J3odfN+Mnv8I10eiso7/Qmyj/JOp+5ulTf8mcoH/md2bgAYABOH+bMGXnYYD5l3ybkH3xVXwLyGQNeH2c4H7293evFQoCiAlVFnYLRXYIGIKx0IEkiArrd4IlOIIq2Aom2IKkgGi8tmgw6AoWWIOsgCRjq1ZmOOgKTpZoUdaDsKCDZCaEsyCDJWaESriETNiETsgJgQAAIfkECQcAfwAsAAAAAMgAyAAAB/+Af4KDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5rkAIvQhAusHCj26+xghuw8rLgyvHxyvM0rrFz8fJ09m01tba3rC83MfA3+Wq4t3m6qboz+vvo+3H8PSf8sb1+Zv3vvrZHX8AhuLXK9STPwf9bcKQoKFDDPYIfiJioKJFIgotnXHI0eGZTgQRdHJhsaRFFxkndVyZAKRETiZjGkgZiSVLTiFhyoxJ09EXmyv77HuZic3OmFp6MmIItONQfpuOxsSoVFHTlRAz5cxEUarJqlavOtVK9JJXnmARie2IgixUTCT/zn5NewjFWo4fL221RFKuRRJ0D/286xDT3kp+SyYNbIiwwx96y07ikdgi40MbHbe0dHhS5YqXEdl1nJVS50hdEwMOfUhzAoGTTkP6bOAK60NrNLc1LRlS3MptbqvV/IX3W0laaAtH1Me18XuUaLNZPtwxZEmyGVH+TD2Rc+y9Gynvjogp4dKPsitK7ZcqeUNUvkNSj+jJ+PeHfuiORP/Q78Q84OedZkKlF14iRnEnICKDOTbfgYjQttiCdWm2hoHHMdLGZ6tRWB1hGELnyH0eHmLeXbsx0t8g/7VXYliOwabIigiR+KIh+mnWCI20BXjjgNapCOEg21WW0RhHFKAk/wtjgJKZg4usSBtKn4hxggJYFiHGKkp26aUZn4x2XpRD/sGeXB1ysgOWbLaJihlexrnkJ/Ih0p+NmlzZ5p4K7GCKnIAWAEcnJ66V4iH0tSiXe5qwweejCpSSZKCA+sGJa3khCmFfRm6SBaSQFkEKpaSGoEmOUGqaYSE9ahIFqLCOEgKppB6hiWvXGZJdkYlpUgSssEYxCq20okdJB3USkh1tCVkyAbDAykossU1aIuZdxgoi25lnpTmJGNBCK6wo0xLLgqmVuCajtr3Zp2AleoYb67DlEmsrJbk5dii7q/6h6FnBUfKrvNCSMmm9xVKS7B/hyEMOIXg68izB0Io6Kv/C04IZSXOk6SoiIdx6NV0ka1IcrilwYmyuJNeuZUg16GADcWXeNhKvybD6eYrK0977iI6GOCNONIa868jAOEerih88E5ttIoVehQjM10SYGKOLTJw0rFm4cnDTgaLLCGH7FtLwL4r8e5Qjr24Nq8WwsAA2pSw0gupVxWWSnFw+LnKz23ueUEvKcwM66CJ36XQWI44CDqnOtmBQeKCWJvIkUJlmwulRVCLyqeOPTiDM15PPmUiDN30i1YSGRPE36ArAPYzcpXvpc4VsiQBKHP/WTAjSsGMp+DRj1B7n04N88QNkVJSiBQ8B2oaI1sFjuaU3khvfpcbClFw9lqKrQ3r/6dXqAu73sddDu/HCoH/CuPUwbXzdubwOeNcZwcF+LtWP3NP6cytfLc7nuOGBZVaFQx4sqLc1+NEle01T4CsYaLLwsWZ85dLF1mQnHACWS3e4wJkByUO4adEPF/YDFeQEBEFaBaNt0LJgiTDoJQHigoCh+hEhPNglZkBqhDoUhBkOxqRpWIlNRVhhEJfIxCY68YlQjKIUCxEEAljxiljMoha3yMUuXjEI9ejBAMZIxjKa8YxoTKMaydgDSrzBi3CMoxy1+IZ1ZGGNeMyjHs+Iv0e0YI6ADGQXW2COFOzxkIhUYwoe8UZBOvKRBKijN+6YyEpacgB9XAQkNynIb1zy/5OJbEQVOUnKOIIxG2IEpSrz2EZNlvKVXtTGKmeJR0bA8pZblCUtd3lGW+Lyl1bUJS+HOQBfAhOXwiTmLhkxymO+8pTTSKUyZ9lKVzqzlJ6c5iwd0chrblKS2qCkNj+ZyUX80ZuPJGQ5DDlOSy4SEt1E5xzBWQ5xtnOP5XxEM+XZRWi+Q5r3VGM1p0jQghr0oAhNqEJxAYCGOhQA0wBDCQ5AUSXk4IkPzShEh5EDinrUoyWwwBI1qtFhgOGjKK3oj0jK0o3mIqUwPYAPGkChlrZUFxONKUwXZNObvlSnMS2BHLrT057i4qRA1akShFPUouLCB0lNqg8u09SmPjWqUf8VaVqq6tSfYhWoJYCAUrhqVa9+FahqSAlZq4rTs2IVCfpYK1d1IQe3YjWk9JBrWYOBVLsmVQliNYde2aoMv2J1qt4Y7F4NUYU/cIADNCWFFP4gBCGEQRFQNWxSwZANxRo1ESoIgGhHqwJRmGABqE2tCRShBM2CVavD8OxnD9GA0dp2tJHlRBhSy9vUXjYROXUtTJcaDNnaVBFluK1yA9AJD/T2uQtYBBKEq1PE2sK4PlXEcpfLCehClxFqoG5ML0oL7JK0ERzYrnJze4ndere3QmhEcMULUlmY97yNUK9yS5uIDQjgvwLYgCJO+97eOsIC9E0pcVlx35I6ogL6VS7/IjIA4AoLIAOIKPBzR/CIzCbYo3BVRYMfCgkKRFjChrCAhS0MW0Jo+LkCfkRrP+xRVIzYoZII7YltawgKr9jCGC7Ei3u72kjMN8HkJcWNXfoIEOzYthUwxI9/bIgRDJm3ApBER2l8gFLcmBJPtm0ZCuHfKVs4xi6+cmop4WH6LjgUDa6EBsIsWv4SwsxULgSB1TyESsyYvqO47yXoLNpD4HnFhtiAmtdsiSNrtsWfwO4ldBzmKEv50BU+hJUXXeRK9NW1gZYtJkxMaERgOtOHWDRq0VyJNvsV0p5QrCYIHQAOmPrU/0WEEFQd3Uz82a5K1qsm0lvqW+M6EbyObyYQ/+zXYJOVE7Qes7FPnQjnqpoT0z3rm+FM2E1AmM52NjSus5yIPV+Zw5wIL1ZNsdhN0HoR4yY3sq/tCUejNMlezi4nKP1kSyci3ovYtJo7zYkt71TEDvZEcoutCIAvgtceAIVEPaoEziqE1raG97gZsWt6P5HYdG6Ewx+uamU7kdYUEPnGGaFojzPx22EOd8NXzghzDxndSyR1yB0xckbwmtU/4veONfCIni9iCKom+I1qy3CVH/sRvF4irUEACaPDO+o/AvmTZc4Iqy/C5i82eYneHQmvk3zRN4J5vyVhdkUI/Nwl0nmYJ9F2RfzcQxinO80h0XG0L8jJTa/63iHBa/95v4fW7BX80yXhXr+/Z87grkTdv67qPh8+8GUffCSw3h2hn9jfel/8JN4+ZKWzZuE7l7zmN6/qiC8n75aYPMc5zxqmp171oqcEr3/LGs9HWNqxX30krD1w4RCa66GnNibArmHj3z74ua+Eyy9DZ9BDX/mYIH3zb6P2CG9C9lCH+21sH2GqawL8PL8y71nzZE6g3xFX7s6JO/F++G+fOqhfLvDPL/xKEB+6rkce3RcA1sd/0ZcJ2odzC5JyKQcK9ScJAgZ0C6VxBziBrfCAFigKGJiBDth/HIgKG/iBnVBmmCaBIqgKFXiCqOBjeBZkKugKKmZmsPaCq8CCQEaDs0APggGGgzzYgz74g0DICYEAACH5BAkHAH8ALAAAAADIAMgAAAf/gH+Cg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ua4/Cb0JP7rBwo9rvsYJa8PKy4Mox8cozNK6xc/HydPZtNbW2t6wvNzHwN/lquLd5uqm6M/r76Ptx/D0n/LG9fmb97762SF/AIbi1yvUhD8H/W06UqChwyP2CH5KgqCixSQKLZlxyNGhmU4EE3TiYrGkRS4ZJ3VcWQCkRE4mYyJIGYklS04hYcqMSdPRGJsr/ex7menMzpgvejJiCLTjUH6bjsbEqFRR05UQM+XMRFGqyapWrzrVSvSSV55gEYntyIIsVEwr/85+TXuIxVqOHy9ttURSrsUVdA/9vOsQ095KfksmDWyIsEMMestOApLYIuNDGx23tHR4UuWKlxHZdZyVUudIXRMDDn1IcwGBk05D+owAC+tDcDS3NS0ZUtzKbm6r1TyG91tJL2gLR+THtfF7lGifWT7cMWRJshlR/kw9kXPsvRsp746IKeHSj7IrSu2XKnlDIr5DUo9owvj3hzDojkT/0O/EQODnnWZCpRdeIkZxJyAigzk234GI0LbYgnVpBoeBxzHixmerUVgdYRhC58h9Hh5i3l27MdLfIP+1V2JYjsGmyIoIkfiiIfpp1giNtAV444DWqQjhINtVlhEZTRCgZP8LZICSmYOLrEgbSp9oQYIBWBKhxSpKduklGp+Mdl6UQ/7BnlwdcuIClmy2iQoaXsa55CfyIdKfjZpc2eaeBrhgipyAEvBGJyeuleIh9LUol3uatMHnowaUkmSggO7BiWt5IQphX0ZuwgakkBJBCqWkOqFJjlBqmmEhPWryBKiwjuIEqaQ2oYlr1xmSXZGJaUIErLA+MQqttAaBSQh1EpIdbQlZwgOwwMpKLLFNWiLmXegNItuZZ6U5iRbQQiusKNMS24KplbgmoyCn2adgJXqGG+uw5RJrKyW5OXYou70pelZwlPwqL7SkTFpvsZQk+0c48pBDCJ6OPDswtKKOevD/tGBG0hxpuopICLdeTRfJmhOHawqcF5srybVrGVINOtg8XJm3jcRbMqx+npLytPc+oqMhzogTjSHvOiLwzdGqssfOxBrrSKFXIfLyNREmxugiEiMNKxuuGMx0oOgyQti+hTD8iyL+HuXIq1rDWjEsLXxNaQuNoHpVcZkkJ5ePi9jc9p4k1IKy3IAOushdOp3FiKN/Q5qzLUEQHqiliTwJVKaZcHoUlYh82vijPAjjteRzJtLgTZ9INaEhT/j9uQFvDxM36V72XCFbq6vpL82EHP06loFPQwbtcTrNIAaQiVDKC0AEaBsiWf+O5ZbeRE58lxkLQ7L0WIauzuikV6sL/7jcw17P7MQLUz4J49azNPF05+L631xn9Eb6uUjfRlXoyy1+LeRrXPDAMivCGa8W0dNa++hiPaYdkBYJLJn3WAO+culCa7ETTv/K1YH8lWyA5BnctOKHi/mB6nECaiCtgsE2aE2wRBX00v9wEcBQ/YgQG+wSMyAFwhsKAg0GY9I0rMQmIqDQh0hMohKXyMQmOvGJhQCAFKdIxSpa8YpYzGIV6zEBBXjxi2AMoxjHSMYyfrFZkdCiGtfIRiyugw1mjKMc5yjG+j2ijXjMoxrNcQI6+vGPZTzBHfVIyEJO8RtwBKQiF6kAOy7CkJDU4zcYSUlANiKSmMSjNrpYyU7KEf+NiMikKPeYDU+aMo6MGKUqr6iNU7pyjKlcpSyl2MpX2tKLsZzlKmt5y1fmUpej3GQvXQnKUAJTlJMcpikdcUxkeiORyqSkIx/ZTEjyMZqMFCQkqlnIN2ITkNMcJDfXyMVvfhKK6EynOtfJzna6MxhlqEAA5qmCBkxjCykYgD6XgAQmqmCeAAVoGZSBBH0a1KApSKI8A8rQAAxjCweN6D5/xIGGWjQAFAiGRDc6gB54qAwXvagKdJFPjm60n/j5Z0gvqguTmjSh3VnoSi9qz1tA1KUmXYJwKjrTlXIAFz3AKU49yhgK9LSnP71FUIWKUyjQRaVHXWlLmYpTmPZEA1H/PepUqYrTLKQEBFk96khzUVKu4pQP+qAAVMO6UgfoQgBmZapV3yFTtkpVGDeNK051qg6e2nWmA1WGXplKVG004K9ITcQU/rCBDXihFBD4gw98AAZFLHWwLt1CNtaK2IZWQBEWEIBoR2sBUZTgAKhNbQkUsQTMunSuwqhrZxmqgowiwgujze1oH9sJMKT2t6mtbCLK6lqJ8lUXfp1tQ0GgiC7o9rkC6EQOgEvdAyyCD8U1aWFrAVLlWlQDjIAudDlR3eoyIgvZ5ShKZ8FZ7wZgrIvYgHify1tM+La8wPVBI4ibXn3CthWydS9GHTHf55Y2EUJYgIIXIARFnBa/wHUE/xT6a1xXgFXAAU1qI5hQ4OciYggLDvEChoAICFNXCY+4LIX1iVZVYDign31EBTrsYUOYQMQiNsEhTEzdAzuitSs2KCq6+2L4PiK0NM6tIUCMYxGTuBA8Bu5qI8Hf/q53FC+eZ2AhYYQk55YJhmhykw2hhCj/9sqOKGiQB1CKAM9Ww5Hwcm67UIgEi1nEDYaymVNLCRWn97ihwHCMJ5EBOYvWx4O485gL8eA9q6ESQO7vKIzqXSNPwtCiPYSicWwIC+yZz5ao8mCdKgrv1rQSSJYzmMO86RAfosyfnnIl8uraSb8ZEzPGNCJa7eodf/oAiO5zcUkd6L8O+hKYFsAGdv/NawUjwge/tm4mIh1XUvzVtpiQr66Z3exERFu/mZiwXknh5pAydxPJpjO3eZ2I6f6aE9jlKqCL3VPwcoLDhg52IZrt7EQ02swo5gR6mWoKIov0E8leBL8XsIhof0LUB0Uzli+6ZU6k2surTsTCFwHrPcuaE2re6CoaINN6gsK521bExhv+6xyAAp8GXYJmFZLsZSuc34yA9rubqG1DN2LlLP80uJeY7GNrHOeM8PTOlYhvOet73a12xL+jHHAk5trnjgA6I6L99BJdPMkZeITWF6GGX3/8RrhN+c+R7giH+zDZRoDE2BeBBLffqOde7vrRuw2JqfN46CVKeCTmvvX/pXuo6RiXBOE5/uuqL+jqcp7E4oO+Z70vp+aSZzskdP5pCnVZ7XLXPCSiLXHqJLu+gxf9I+7befwUOt+VmDwj/G7iR79H8JSQfeFb352v0zjjmec7JTpu5rOzBuVYj73qIxFtl18e0zZXvvApwfk9LyftyZc+uy8RbeGyxvcdVrcldN8Id3tcOJi2vNiXLwnaQxj92R8/+yVh+MsYGvjyn74liM9j4SC+w5tAfo+wZ453GdjXYXGnCQKYZmbmfazhZZywgG0XZd1BY50ggRP4ft2BfNAlfgo4f5RgftXlfOTxfwKAfx+of5rAfwdQgPjxWUYXgSCICaWlfu+0bzN4RYOpgIE6OAo82IOh8INA+AlCOISdYGetlmdG6AoquISqwGSK9mRO6Ao3dmc6NoWwAIVOhoWzgIQMxoVgGIZiOIZkyAmBAAAh+QQJBwB/ACwAAAAAyADIAAAH/4B/goOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLmuGAW9BRi6wcKPcL7GBXDDysuDLMfHLMzSusXPx8nT2bTW1tresLzcx8Df5ari3ebqpujP6++j7cfw9J/yxvX5m/e++tlOfwCG4tfrAqgOfxD629SEgMOHTewR/IQhgcWL5BZSQvOw40M0nQgW6HTmosmLZzRO8siSQMiJnE7KTKAyUsuWnETGnCmzpiMyN1nu2UfQYKY+PGV+8cmoYVCPRPltSiozI1NET1lGzKQzU0WqJ68qyspSU1dMYHuKxUq2YwuuMP8voUgbdu2hFm07grwk0milknQvorB7CGjeh5jOVgpscilhQ4cfBuEbl9IPxhcfs41MWaolzBY1I8IbeSslxZK+Mh4s+lBkhwIn9V0MmkrrQ29evz1dOdJczGtubz5MhrdnSV9A0xR+aM9rl7J7P1Leh/nwvJMloXZ0GbR1RE6eR+fnd7r374icHjb9aDsj1YGtoi8kPpJ7RR2Uz08URLd96Yv8xtgP+yXy3FDtAZgIUucVWFh9jszmiHKOOXjXa28keBwja4DGmoXXtaXhPeZhBqIi6uW1GyP3GSJgfCeO9VpsirRISH4NxnhIf681IqEiyhGoo4GvZVejgoR0Z+L/QgA06SQAoHDU4yI2CqJcSp+8sAICXCbxwipPhgmlJ6StRyWSgsBH14eccMHlm3CiIuacn0CISJX6ebIlnHwiwIUpcwbaSYptrXjIjy6CJh8mbvTpKAKlBCrpmJo8t9ehSAK2pCZnPPpoEqRMOqkmPHJ2J5JBajKBp6yOIqqolRZ56oZJ5olJEqyyOoGrr456SXhTGnKfcgpZAkSuufLaK6yWlJkXe4MgmqaHl7yALLK7irJsr5Y8R6Mg2+G4KSV7Xtuqstv6OklukRkKrnQv0hUcJbiai2yo6XK7UrCDhCPPorZGcqy9yIKKb76vSuJcacKSWIiaaVUXiZsEXwso/8L6QuKsiIVUgw42hFAbSbkVs/rnKRhn7Ai/zaATjSE5NlJvycmqkrLKixCaFSIeX4MIZosmMjDNrGLJys0JN3KYuw8bE/Qg8VLlyKpEs2owLEirq0ipWRWXSXJ0CbkIyVXzuUItWWsd4k07pcVIo2U/erItaUuqiJRPXZqJpkkZfUincTsKhDB105mIYWx/QlWFhkxAduAIXD1M4WIqsjEBLYQAighRs2nIzJBzefY0lFd+eBCTFSvKFz8QaBsiQ4fO5ZfelB6mMhTLzuXg6tjupDDW6h55Pb4LI/wK2RJvuy6Pl+23PqXrIrsbV1GOS/Bxjy5W4bjETnTydqXdff/ZvLd2s/Q0Sy5cyrmUrD16CDNP8NwFbhsM1ciWfyLOt2D/6ZCEsNsyHvU+AArCcMzQ0puSQD8DOvCBEIygBCdIwQoWggMByKAGN8jBDnrwgyDUIAfqwQMDmPCEKEyhClfIwhaekAeU0EAIZ0jDGnZQA+togwt3yMMeqrANkVCBDYdIRBCqwBwk8KESl9hCEjxChkWMohQDgENv6JCJWMyiAYDYiCl6sYjf0KIYmdgIDH7xjDQcYTZKOMY28hCGi0CjHGeoDTfacYeMmKMePVjHO/pRhXncoyAz2Mc/GtIAgRzkHgt5SD8ywoyKlKMap8HGRtoRjnGMpBzDaEk7OgL/ipr0YhW1ccVOipGLjRBiKKV4xHIk0ZRZdCIkQLlKG46yHKWEpQ9RGQlI1hKEk3xHJXXZQkxa8JjITKYyl8nMZuKiC0wQgDQt4IVpiOEECshmEXYQwQpYQJrgBGcXlLGDbJrTnCdwIAWiGc52CmAYYjinPLU5pA24854CqEAw5slPBYBvP13AJz4toAts9pOf3JwPB74pUHzq4qAHPcEQvsPOhuKzmreIJ0QPWgTh2NOiDd0ALiaw0Y3+UywVAClIRXoLkpZ0o1FYyxQYqtKGPvSlGz1BBJiSgZqq9KY43SgbVGIEn6qUoLkwaFA3mgV9eNOoKg2mLYaw1JeeIKbw/6goVG0qDI1WdaNF2Kk5PrpVi45TGV996UmZ4YWyrjQRUviDEIQQhlJY4Q896MEWFOHStEJUDNN4qlsFygRFmGABiE2sCUSRggE49rEpUEQR/ArRqy5Dq4NtpwX0iYgwJPazia1rJ7bw2NI+dq+JUCpl59nRYJA1s+40giI8ANraLqATSDCtbgewiCys9qBrjUVAYXvPDDDCtrblxG53ywg2/LafCZ0FTYkLTqQuQgjIra1oMUHa5Zq2B41Q7XOzmc5YYJa6+XREdmu72ET44ADwPYAPFNFY75rWEVEYL2tdUVT0hpOljRjBemuLCDXE98AHUAMi7KvbJTyir/rNZv9TVeHfcBb2ERsYMIENUQIEI7gEh2CwbqEAiclG2JwTNcVwK2zdRxxWw581hIE9jGAFF0LEpo1sJMQ73lNUWJpnhYQAYPzZERiCxjQ2xBJwXFo+SKKcJ1ZAKc6bWQBHgsif9UAh3otkBM/3xkx+LCUg/NzWisK/F57EELCM2PYSostJLkR9wzzhSZi4x6JIKXFbPAk2I/YQcPawIaAQZjFbgsdpxWooiIvRSrwYy0Y+cqAPfIglF1rHlfAqZUehZ7damRIZ9jMiJk3pEBd6ACS+BJmrqmhQuDXNl/DzAoQwalLDFxE9ODVvM3HnqpKirJzFBHZFXWtbJ0LX4M1Efr//SgoqC1S2m5C1lotN6kTk9tSc8G1QzXxmlRqXEwJms5sBbesD0PfUDuaEc1+qYovyWROyXkS5za0IXX8C0eeMbikEGmROPJrIkU7EvBdh6TBjmhNQ5ucqvFBRaoKCtsRWxMAXoWskgOKa5iwCYBcia1rLu9yMyDW2JzhsNjdi4hQ/dbIjKOtPU3vSjSD0yCEYbiyPW+Igb8ScmZxuB4ba5I5AOSN0nWoD/hvGKT55zhuRhVMfXEeejbjSjf0IextQ1u98hNAZwQer66jkRL45I7bOiJ3jeOUninckyD70mYOo5gCXBNsJju4T/RzLk5h7ygtd9AJ1PO9Lh4TIC22h/yFLHRJ633uYnex3P2937YGHRHcJv581i7sSiV+E2UVc5++onRKZVzyT53N0DQcc8FSnRMGZ/PTWQBzomI+8JCpunb9bIvSLGHyYmRN12Mc+9ZXQNWpbU/oBT/v2spfEtQ0uHD+LHfXVxsTmGdx83yMf+JZwu2bYfPrrRx8TqxexcOA+4E3g3hFh7rloej/grGfi/I3oOo6H3xoicwL+jRh97ct//+Rnn/rf8Xq2dXyagH+NsHy7ZXHzQX4L0H0F6H+XEH4DoH4FIlIuZ34QmAkk1nfONHYZ2IGqYIAgKAoiOIKgUIIm6AkomIKcwGWT9mUs6ArYF4OrMGNwZmM06B4KHdZlIJaDsGCDNeaDs+CC8iWERniESJiESsgJgQAAIfkEBQcAfwAsAAAAAMgAyAAAB/+Af4KDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5rkEEvQRBusHCj2++xgRvw8rLgy3Hxy3M0rrFz8fJ09m01tba3rC83MfA3+Wq4t3m6qboz+vvo+3H8PSf8sb1+Zv3vvrZAH8AhuLXK1SIPwf9bQLAsCFDewQ/HSlAseIRhZYcamzYiSCBTmYqiqxoBuOkjRs7RuQ0smUBk5FQouTkkaXLljAdyZS5b2UmPzdbjsnJaOdMTTU1BW15kagio0cxJcU0celIp0+hakTq85JVnFgRaU0ptWslFl+vhj00lqylqZX/QqatyGIt27YOy/LDNFfkULuG8OZ9a1YShr4VAd8VLLAS3EmIKSoWy7jxpMeRqvatO3mxYMeFIUUuIKKzZ7yg91JCixiOacqMKWF2NGb0a9ifL4duNNrPbdyoJc1mdDjy70SVdauOZPs48LbCdyvSPLep88DJIw1PFKL59dPQIW1HxLovhu/IszsabwiocfTPx4qXfmj0X/jg5a+nXwhOZM74xQfVI+wR4l2A+Wm133KLlFcdglnFxkiBCB0IIXYSLkLhaOddmF6GiRRYHGIYNVBBACiq0AAolVmGSIGjlfTJFygkYCMGX6yC4o48lvFJixryR11aAHJyho1IJolK/xk8NpnijyAewp6FmtSY5JUJnGGKk1wGoEEnQIZIn4NpWafJGlimmUApJ3bJJQichCmldHKRuEkfaqrZoShu9kmBJnIash2HmnSQ56GjUNBnnxUAql4hw43YlyYYHHpoB6MsuigHmARKyHCjJWTJD5Zamqimmq6Y0aODzDbkV0VO8kWppWLKJ6qLqvBnJZ7+gVl371ViJa2IZoqrpo1S0itmZH7lGiWVElsqKW0eu6myUf4RjjzkGBhsJKRKW+qet1qrqY8xserrPYa8apVvkRwpLq2mMGmupipIom416GDj7WaSDDvvoVqeci+qyT6S7R/OiBONId82Eu3ApqoCwv/BmnKqU26G8HsNIoiZuUi4FB/ahyvVYtzlrkUFh8i2vyjSbFCOGFryoeS6ooLKbubbcniY1JZWzogIfPOVKNRiL89cfrkI0JnMxQiaR6tZsC0cMN0lnB8OuEmdQcmICJ5Vp/mDMClr/WTXUXWy1H2GdGB02QkQrcvOavOYcIIubvJCs7EWMjHdNiY9TQN5N6kxbAGVMgYG55WGCMmE25ijN1knviO6wshbuY1nq5O22qrqMuvnddeDd+LCoI6CrfVcnLjPuMx99MkYacB6LpWv4dTqPJdey+lVG46VokwvXgvlJcO+VuYYK08L8/OG3tnouOpSst2TAY9rFbzPa7z/c0ujSvsttud5NXrQLxqMzaVajyD2PAqPC/F6ekiI9zsyo+b4+hNEGaqlomnQCEkYWF8AF8jABjrwgRCMoAQLsQEBWPCCGMygBjfIwQ5ecAP1AAICRkjCEprwhChMoQpJCARKZMCDMIyhDDWYgXW4YYU4zKEOT+iGSFhghkAMYgctYI4V7PCISFThCh7xQiE68YkCqKE3bpjEKloRAT1sBBS3KMRvXPGLSWxEBblIxhiCMBsiBKMac9jCRZTxjTDUxhrniENGwPGOG5QjHfd4Qjvi8Y8W1CMfB4kAPwISj4Ik5B4ZMcZDvvGM00ijIufYRjc68o1enOQcHdHES25R/4raoKImv5jFRvzQk08kYjmMOEorLhESnUTlDEFZDlG2coeljEQjZdlBSL5DkrdUYSUnSMxiGvOYyEymMnHhgREs4JkmCMM0tEACA1iTCC54oAmeyU1uekAZLrCmOMVJgics0JndTOcChqGFcbrzmh4SgjrnuQBf3uKd+DQADwKAHw/Qk54m0EU184lP+Gzzn/TUBUEJSoI4HAedCKWnNG/RzoUSlAivkWdEESoEXPDAohblgWI2sNGNdvQWHwWpRc0ZloOWFKEKValFSXAFogzhpSWNqUwt2gaTCACnJQ1oLga6U4uyQR8bcClQEToHXcShqCotJz0gulSYCqOiUP+1KBFqag6NVjWi31RGVlUqUm+E4asmTQQE/uADH4ChFBH4wwQmIAZFpHSsC9VCNpSKVnWOQBElOIBgB1sCUZxAAYhN7AkUQQS8LlSqyqBqX9NpAnsSAgyDzexg39oJMST2s4mtayKI6th3YjQYXp2sOgWgiBxo9rUH6MQOQEtbBSyCDaUlaFlt4U/VznMIjIAtbDlR29oyog25zWc2acFX3y5AqIvwgXBfy1lMeLa4oJ1AI0ibXGuSQBaSdW49HTHd1xY2ET0YgHoH0ANFHBa7oHXEE7prWlf8VLzdPGkjlFDe1yIiC+sN8ACygAj40rYIj7grfa15VFXgt5t/fYT/BfrrX0OkQMACTsEhDEzbKECisQsWJyp6+2DoPiKwFM6sIQCMYQETuBAcBu1iI8Hd7i6XFA9+ZlghgYQUZ1YJhmhxiw1RhBh/9sWQCGeIDVCK8E5Wv5HwcWZzUIj0ClnA7YWxkRNLCQUn97SiwG+EJ6EGKQv2vIS48pAL8d4tN3gSIO7uKEjqWxNPwsyCPYSaMWyIKGyZy5ao8VhZGgrfTrQSKJYykIO85wAfosh/nnElsOrYOT8ZExPGMyIa7egN/1kBHr6El6FKaFCgdcyXwPMBfLBpTqsXERP4tG0zEWeo4riqlqWEdDV9iAC4+tUF/rR2MzHfrJLCyf9k7SZU/03lVrs6EbP9NCdwu1Mwh7mkwOUEf82MZj3/2r2fRjAnkKtSU5AYoJ9Q9SJ+PYBFyPoTgh7njUvxzx1zItE+XjQifP1tRUB6y5LmhJILqoowQDSaoHAtrxXBbkbIegegoKY4iaBXhaia1evutyJiLW0I7trMjWi4w4UNQVWrMuPPZoSfO97AbUu524ngd8oZ0WYji3uBmQa5I0TeCFmHOoD4TrEaHsFzRrDh0wG/EGYXHnKN95zlHlI1EiBRdEZk4d0e+riPYb4ImXM6EjWP8bAhpO5IVP3pf76Qy/MtibMz4t82R1DOpTwJt4/8zz9Hz8Xr7vRHcDzt8Okx0x/h9f9GU0LWSL6Oqqtr9r4/4rqAv06ZuV0Juzci7Bx+83HKTgnLo33L1wk6hfXN95lPAu4xTnpnFK5zShR+z5d4+G/2bgnPN+LvoH/N0ltfecdLQtai7Yzo+9vs2vs+EtEG+GvwzPXSfx0TmDfw8nlfiderWRNQV4yZSW9801sC9dI3zdr7uwnbQ2LLN5/M7vs7dU2Y/xFXj3HwO+NjTrz/EUbePPk3Yf0rd4LDzsF6sFV87nd8lZB8tQVx1zF+B8B9Beh9mgB+6YceRHRynnB/lOBhebdMjICBHEgK/SdkHzgLHjiColCCJggKKJiCnmBljZZlLOgKEBiDqsBiapZ4NMgeChd2ZRqWg7Bggy7mg7PgguwlhEZ4hEiYhErICYEAADs="

/***/ }),
/* 92 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMjRweCIgaGVpZ2h0PSIxOC40OTdweCIgdmlld0JveD0iMCAwIDI0IDE4LjQ5NyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMjQgMTguNDk3IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwYXRoIGZpbGw9IiM4NkM1NEQiIGQ9Ik04LjIwNSwxOC4xMTdsMC4xNDMsMC4xNDNMMjQsMi42MDhMMjEuMzkxLDBMNy45NjgsMTMuNDIzbC01LjM1OS01LjM2TDAsMTAuNjcxbDcuODI1LDcuODI2TDguMjA1LDE4LjExNw0KCUw4LjIwNSwxOC4xMTd6Ii8+DQo8L3N2Zz4NCg=="

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iMThweCIgaGVpZ2h0PSIxMy44NzJweCIgdmlld0JveD0iMCAwIDE4IDEzLjg3MiIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwIDAgMTggMTMuODcyIiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwb2x5Z29uIGZpbGw9IiNGRkZGRkYiIHBvaW50cz0iNi4xNTQsMTMuNTg4IDYuMjYxLDEzLjY5NSAxOCwxLjk1NiAxNi4wNDQsMCA1Ljk3NywxMC4wNjggMS45NTYsNi4wNDggMCw4LjAwMiA1Ljg3LDEzLjg3MiANCgk2LjE1NCwxMy41ODcgIi8+DQo8L3N2Zz4NCg=="

/***/ }),
/* 94 */
/***/ (function(module, exports) {

module.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNi4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB3aWR0aD0iM3B4IiBoZWlnaHQ9IjE0cHgiIHZpZXdCb3g9IjAgMCAzIDE0IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCAzIDE0IiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik0yLjk3MSwwdjUuNDgyYzAsMC41ODgtMC4wMzksMS4xNzEtMC4xMTMsMS43NUMyLjc3OSw3LjgyNSwyLjY4LDguNDE1LDIuNTYxLDlIMC40MQ0KCUMwLjI4Nyw4LjQsMC4xODgsNy44MSwwLjExMyw3LjIzMkMwLjAzNyw2LjY1MiwwLDYuMDY3LDAsNS40ODJWMEgyLjk3MXoiLz4NCjxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Ik0wLDEyLjVjLTAuMDA0LTAuMzk3LDAuMTUxLTAuNzc4LDAuNDMtMS4wNjFjMC40MzYtMC40MzcsMS4wOTItMC41NjMsMS42NTgtMC4zMg0KCWMwLjE4MiwwLjA3OCwwLjM0MiwwLjE4NSwwLjQ3NywwLjMyYzAuMTM4LDAuMTM0LDAuMjQ0LDAuMjkyLDAuMzIsMC40NzNDMi45NjIsMTIuMDk0LDMsMTIuMjg5LDMsMTIuNQ0KCWMwLDAuMjEtMC4wMzgsMC40MDgtMC4xMTUsMC41OTJjLTAuMTQ2LDAuMzYyLTAuNDM1LDAuNjQ4LTAuNzk3LDAuNzk0QzEuOTAxLDEzLjk2MywxLjcwMSwxNC4wMDEsMS41LDE0DQoJYy0wLjIxNiwwLTAuNDE1LTAuMDM4LTAuNTk4LTAuMTE0Yy0wLjM1Ny0wLjE0OC0wLjY0My0wLjQzNS0wLjc4Ny0wLjc5NEMwLjAzNywxMi45MDQtMC4wMDIsMTIuNzAzLDAsMTIuNXoiLz4NCjwvc3ZnPg0K"

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(96);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 96 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _Header = __webpack_require__(98);

var _Header2 = _interopRequireDefault(_Header);

var _Footer = __webpack_require__(100);

var _Footer2 = _interopRequireDefault(_Footer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Layout = function (_React$Component) {
	_inherits(Layout, _React$Component);

	function Layout() {
		_classCallCheck(this, Layout);

		return _possibleConstructorReturn(this, (Layout.__proto__ || Object.getPrototypeOf(Layout)).apply(this, arguments));
	}

	_createClass(Layout, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(_Header2.default, null),
				_react2.default.createElement(
					'main',
					null,
					this.props.children
				),
				_react2.default.createElement(_Footer2.default, null)
			);
		}
	}]);

	return Layout;
}(_react2.default.Component);

exports.default = Layout;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(13);

var _Nav = __webpack_require__(99);

var _Nav2 = _interopRequireDefault(_Nav);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Header = function (_React$Component) {
	_inherits(Header, _React$Component);

	function Header() {
		_classCallCheck(this, Header);

		return _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).apply(this, arguments));
	}

	_createClass(Header, [{
		key: 'menuController',
		value: function menuController() {
			var header = document.querySelector('header');
			header.classList.toggle('active');
		}
	}, {
		key: 'closeMenu',
		value: function closeMenu() {
			var header = document.querySelector('header');
			header.classList.remove('active');
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'header',
				{ ref: 'header' },
				_react2.default.createElement(
					'button',
					{ className: 'hamburger', onClick: this.menuController.bind(this) },
					_react2.default.createElement('span', null),
					_react2.default.createElement('span', null),
					_react2.default.createElement('span', null),
					_react2.default.createElement('span', null)
				),
				_react2.default.createElement(
					_reactRouterDom.NavLink,
					{ onClick: this.closeMenu.bind(this), to: '/', className: 'tamtam-icon' },
					_react2.default.createElement(
						'svg',
						{ width: '32px', height: '32px', viewBox: '0 0 32 32', enableBackground: 'new 0 0 32 32', xmlSpace: 'preserve' },
						_react2.default.createElement('polyline', { fill: '#FFFFFF', points: '6.4,32 0,25.601 25.6,0 32,6.402 6.4,32 ' })
					)
				),
				_react2.default.createElement(_Nav2.default, { menuController: this.menuController })
			);
		}
	}]);

	return Header;
}(_react2.default.Component);

exports.default = Header;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Nav = function (_React$Component) {
	_inherits(Nav, _React$Component);

	function Nav() {
		_classCallCheck(this, Nav);

		return _possibleConstructorReturn(this, (Nav.__proto__ || Object.getPrototypeOf(Nav)).apply(this, arguments));
	}

	_createClass(Nav, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'nav',
				{ ref: 'nav' },
				_react2.default.createElement(
					'ul',
					null,
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement(
							_reactRouterDom.NavLink,
							{ onClick: this.props.menuController, exact: true, to: '/' },
							' Home '
						)
					),
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement(
							_reactRouterDom.NavLink,
							{ onClick: this.props.menuController, to: '/people' },
							' People '
						)
					),
					_react2.default.createElement(
						'li',
						null,
						_react2.default.createElement(
							_reactRouterDom.NavLink,
							{ onClick: this.props.menuController, to: '/contact' },
							' Contact '
						)
					)
				)
			);
		}
	}]);

	return Nav;
}(_react2.default.Component);

exports.default = Nav;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Footer = function (_React$Component) {
	_inherits(Footer, _React$Component);

	function Footer() {
		_classCallCheck(this, Footer);

		return _possibleConstructorReturn(this, (Footer.__proto__ || Object.getPrototypeOf(Footer)).apply(this, arguments));
	}

	_createClass(Footer, [{
		key: "render",
		value: function render() {
			return _react2.default.createElement(
				"footer",
				null,
				_react2.default.createElement(
					"article",
					{ className: "footer-content" },
					_react2.default.createElement(
						"a",
						{ target: "_blank", className: "social", href: "https://www.facebook.com/tamtamnl/" },
						_react2.default.createElement(
							"svg",
							{ width: "10.813px", height: "20px", viewBox: "0 0 10.813 20", enableBackground: "new 0 0 10.813 20", xmlSpace: "preserve" },
							_react2.default.createElement("path", { fill: "#FFFFFF", d: "M10.406,0.004L7.813,0C4.898,0,3.016,1.932,3.016,4.922v2.27H0.408C0.184,7.192,0,7.374,0,7.599v3.289\r c0,0.225,0.184,0.407,0.408,0.407h2.607v8.297C3.016,19.818,3.198,20,3.423,20h3.403c0.225,0,0.406-0.184,0.406-0.408v-8.297h3.051\r c0.225,0,0.406-0.182,0.406-0.407l0.002-3.289c0-0.226-0.182-0.408-0.407-0.408c-0.001,0-0.001,0-0.001,0H7.232V5.268\r c0-0.925,0.221-1.394,1.426-1.394l1.746-0.001c0.227,0,0.408-0.183,0.408-0.408V0.412C10.813,0.187,10.631,0.004,10.406,0.004\r L10.406,0.004z" })
						)
					),
					_react2.default.createElement(
						"a",
						{ target: "_blank", className: "social", href: "https://twitter.com/tamtamnl" },
						_react2.default.createElement(
							"svg",
							{ width: "24.659px", height: "20px", viewBox: "0 0 24.659 20", enableBackground: "new 0 0 24.659 20", xmlSpace: "preserve" },
							_react2.default.createElement("path", { fill: "#FFFFFF", d: "M24.659,2.366c-0.908,0.402-1.882,0.674-2.905,0.796c1.055-0.631,1.846-1.624,2.225-2.793\r c-0.98,0.579-2.063,0.999-3.215,1.227C19.808,0.576,18.471-0.002,17.072,0c-2.792-0.002-5.057,2.259-5.06,5.051\r c-0.001,0.387,0.044,0.772,0.132,1.149C8.078,5.998,4.289,4.08,1.718,0.923C1.268,1.693,1.031,2.57,1.034,3.462\r c0,1.752,0.894,3.299,2.25,4.203C2.48,7.639,1.695,7.421,0.992,7.031v0.063C0.994,9.5,2.691,11.57,5.049,12.047\r c-0.423,0.114-0.869,0.178-1.332,0.178c-0.326,0-0.643-0.033-0.953-0.095c0.664,2.06,2.563,3.47,4.726,3.509\r c-1.793,1.402-4.005,2.163-6.282,2.158c-0.409,0-0.811-0.025-1.207-0.07C2.313,19.213,5.005,20.002,7.754,20\r c9.305,0,14.393-7.695,14.393-14.37l-0.018-0.654C23.123,4.266,23.98,3.382,24.659,2.366z" })
						)
					),
					_react2.default.createElement(
						"a",
						{ target: "_blank", className: "social", href: "https://www.instagram.com/tamtamnl/" },
						_react2.default.createElement(
							"svg",
							{ width: "20px", height: "20px", viewBox: "0 0 20 20", enableBackground: "new 0 0 20 20", xmlSpace: "preserve" },
							_react2.default.createElement("path", { fill: "#FFFFFF", d: "M2.566,0h14.867C18.846,0,20,1.045,20,2.567v14.867C20,18.955,18.846,20,17.434,20H2.566\r C1.154,20,0,18.955,0,17.434V2.567C0,1.045,1.154,0,2.566,0z M14.568,2.222c-0.5,0.005-0.902,0.415-0.899,0.916v2.193\r c-0.003,0.501,0.399,0.911,0.899,0.916h2.261c0.496,0,0.901-0.412,0.901-0.916V3.138c0.003-0.501-0.399-0.911-0.9-0.916h-2.26\r H14.568z M17.738,8.458h-1.76c0.171,0.556,0.258,1.134,0.258,1.716c0,3.326-2.784,6.023-6.217,6.023\r c-3.434,0-6.217-2.697-6.217-6.023c0-0.597,0.09-1.173,0.256-1.716H2.223v8.448c0,0.438,0.357,0.795,0.795,0.795h13.928\r c0.438-0.002,0.793-0.356,0.795-0.795V8.458H17.738z M10.02,6.065c-2.219,0-4.018,1.742-4.018,3.892c0,2.15,1.799,3.893,4.018,3.893\r c2.217,0,4.017-1.744,4.017-3.893C14.036,7.807,12.236,6.065,10.02,6.065z" })
						)
					)
				)
			);
		}
	}]);

	return Footer;
}(_react2.default.Component);

exports.default = Footer;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _Slider = __webpack_require__(102);

var _Slider2 = _interopRequireDefault(_Slider);

var _Intro = __webpack_require__(111);

var _Intro2 = _interopRequireDefault(_Intro);

var _Feed = __webpack_require__(112);

var _Feed2 = _interopRequireDefault(_Feed);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Home = function (_React$Component) {
	_inherits(Home, _React$Component);

	function Home() {
		_classCallCheck(this, Home);

		return _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).apply(this, arguments));
	}

	_createClass(Home, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(_Slider2.default, null),
				_react2.default.createElement(_Intro2.default, null),
				_react2.default.createElement(_Feed2.default, null)
			);
		}
	}]);

	return Home;
}(_react2.default.Component);

exports.default = Home;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactResponsiveCarousel = __webpack_require__(103);

var _animatedScrollTo = __webpack_require__(109);

var _animatedScrollTo2 = _interopRequireDefault(_animatedScrollTo);

var _Slide = __webpack_require__(110);

var _Slide2 = _interopRequireDefault(_Slide);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Slider = function (_React$Component) {
	_inherits(Slider, _React$Component);

	function Slider() {
		_classCallCheck(this, Slider);

		return _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).apply(this, arguments));
	}

	_createClass(Slider, [{
		key: 'scrollTo',
		value: function scrollTo() {
			(0, _animatedScrollTo2.default)(document.querySelector('.intro'));
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'section',
				{ className: 'slider' },
				_react2.default.createElement(
					_reactResponsiveCarousel.Carousel,
					{ showStatus: false, infiniteLoop: true, showIndicators: false },
					_react2.default.createElement(_Slide2.default, { title: 'Walibi', image: '../../img/slider/walibi.jpg', link: 'https://www.tamtam.nl/werk/walibi-holland/' }),
					_react2.default.createElement(_Slide2.default, { title: 'Oxxio', image: '../../img/slider/oxxio.jpg', link: 'https://www.tamtam.nl/werk/oxxio/' }),
					_react2.default.createElement(_Slide2.default, { title: 'Florensis', image: '../../img/slider/florensis.jpg', link: 'https://www.tamtam.nl/werk/florensis/' })
				),
				_react2.default.createElement(
					'button',
					{ onClick: this.scrollTo.bind(this), className: 'scroll-down' },
					_react2.default.createElement(
						'svg',
						{ className: 'mouse', width: '22px', height: '34px', viewBox: '0 0 22 34', enableBackground: 'new 0 0 22 34', xmlSpace: 'preserve' },
						_react2.default.createElement('path', { fill: '#010101', d: 'M0,10.497C0,4.702,4.932,0,11,0c6.076,0,11,4.696,11,10.497v13.006C22,29.298,17.068,34,11,34\r C4.924,34,0,29.305,0,23.503V10.497z M2,10.497v13.006C2,28.2,6.029,32,11,32c4.96,0,9-3.805,9-8.497V10.497C20,5.8,15.971,2,11,2\r C6.04,2,2,5.804,2,10.497z M9,10.998C9,9.895,9.889,9,11,9c1.105,0,2,0.887,2,1.998v4.004c0.002,1.101-0.889,1.996-1.99,1.998\r c-0.003,0-0.006,0-0.01,0c-1.105,0-2-0.887-2-1.998V10.998z' })
					),
					_react2.default.createElement(
						'svg',
						{ className: 'arrows-down', width: '12.061px', height: '17px', viewBox: '0 0 12.061 17', enableBackground: 'new 0 0 12.061 17', xmlSpace: 'preserve' },
						_react2.default.createElement('path', { fill: '#010101', d: 'M7.018,7.322c0,0-0.526,0.678-0.986,0.678c-0.44,0-0.988-0.678-0.988-0.678l-0.01-0.01l-4.772-5.38\r c-0.348-0.441-0.348-1.162,0-1.602c0.349-0.44,0.918-0.44,1.267,0L6.03,4.835l4.503-4.505c0.35-0.44,0.918-0.44,1.267,0\r c0.348,0.44,0.348,1.16,0,1.601L7.027,7.312L7.018,7.322L7.018,7.322z M7.018,16.322c0,0-0.526,0.678-0.986,0.678\r c-0.44,0-0.988-0.678-0.988-0.678l-0.01-0.01l-4.772-5.381c-0.348-0.441-0.348-1.162,0-1.602c0.349-0.44,0.918-0.44,1.267,0\r l4.503,4.505l4.503-4.505c0.35-0.44,0.918-0.44,1.267,0c0.348,0.439,0.348,1.16,0,1.602l-4.772,5.381L7.018,16.322L7.018,16.322z' })
					)
				),
				_react2.default.createElement(
					'svg',
					{ className: 'chevron-down', width: '12.062px', height: '8px', viewBox: '0 0 12.062 8', enableBackground: 'new 0 0 12.062 8', xmlSpace: 'preserve' },
					_react2.default.createElement('path', { fill: '#FFFFFF', d: 'M5.043,7.322C5.043,7.322,5.57,8,6.029,8c0.441,0,0.988-0.678,0.988-0.678l0.01-0.01l4.772-5.38\r c0.349-0.441,0.349-1.162,0-1.602c-0.348-0.44-0.919-0.44-1.266,0L6.029,4.835L1.527,0.33c-0.35-0.44-0.918-0.44-1.266,0\r c-0.349,0.44-0.349,1.16,0,1.601l4.771,5.381L5.043,7.322' })
				)
			);
		}
	}]);

	return Slider;
}(_react2.default.Component);

exports.default = Slider;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Thumbs = exports.Carousel = undefined;

var _Carousel = __webpack_require__(104);

var _Carousel2 = _interopRequireDefault(_Carousel);

var _Thumbs = __webpack_require__(42);

var _Thumbs2 = _interopRequireDefault(_Thumbs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Carousel = _Carousel2.default;
exports.Thumbs = _Thumbs2.default;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(17);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = __webpack_require__(3);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _cssClasses = __webpack_require__(39);

var _cssClasses2 = _interopRequireDefault(_cssClasses);

var _CSSTranslate = __webpack_require__(40);

var _CSSTranslate2 = _interopRequireDefault(_CSSTranslate);

var _reactEasySwipe = __webpack_require__(41);

var _reactEasySwipe2 = _interopRequireDefault(_reactEasySwipe);

var _Thumbs = __webpack_require__(42);

var _Thumbs2 = _interopRequireDefault(_Thumbs);

var _customPropTypes = __webpack_require__(108);

var customPropTypes = _interopRequireWildcard(_customPropTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var noop = function noop() {};

var defaultStatusFormatter = function defaultStatusFormatter(current, total) {
    return current + ' of ' + total;
};

var Carousel = function (_Component) {
    _inherits(Carousel, _Component);

    function Carousel(props) {
        _classCallCheck(this, Carousel);

        var _this = _possibleConstructorReturn(this, (Carousel.__proto__ || Object.getPrototypeOf(Carousel)).call(this, props));

        _this.autoPlay = function () {
            if (!_this.props.autoPlay) {
                return;
            }

            clearTimeout(_this.timer);
            _this.timer = setTimeout(function () {
                _this.increment();
            }, _this.props.interval);
        };

        _this.clearAutoPlay = function () {
            if (!_this.props.autoPlay) {
                return;
            }

            clearTimeout(_this.timer);
        };

        _this.resetAutoPlay = function () {
            _this.clearAutoPlay();
            _this.autoPlay();
        };

        _this.stopOnHover = function () {
            _this.setState({ isMouseEntered: true });
            _this.clearAutoPlay();
        };

        _this.startOnLeave = function () {
            _this.setState({ isMouseEntered: false });
            _this.autoPlay();
        };

        _this.navigateWithKeyboard = function (e) {
            var axis = _this.props.axis;

            var isHorizontal = axis === 'horizontal';
            var keyNames = {
                ArrowUp: 38,
                ArrowRight: 39,
                ArrowDown: 40,
                ArrowLeft: 37
            };

            var nextKey = isHorizontal ? keyNames.ArrowRight : keyNames.ArrowDown;
            var prevKey = isHorizontal ? keyNames.ArrowLeft : keyNames.ArrowUp;

            if (nextKey === e.keyCode) {
                _this.increment();
            } else if (prevKey === e.keyCode) {
                _this.decrement();
            }
        };

        _this.updateSizes = function () {
            if (!_this.state.initialized) {
                return;
            }

            var isHorizontal = _this.props.axis === 'horizontal';
            var firstItem = _this.refs.item0;
            var itemSize = isHorizontal ? firstItem.clientWidth : firstItem.clientHeight;

            _this.setState({
                itemSize: itemSize,
                wrapperSize: isHorizontal ? itemSize * _this.props.children.length : itemSize
            });
        };

        _this.setMountState = function () {
            _this.setState({ hasMount: true });
            _this.updateSizes();
        };

        _this.handleClickItem = function (index, item) {
            if (_this.state.cancelClick) {
                _this.setState({
                    cancelClick: false
                });

                return;
            }

            _this.props.onClickItem(index, item);

            if (index !== _this.state.selectedItem) {
                _this.setState({
                    selectedItem: index
                });
            }
        };

        _this.handleOnChange = function (index, item) {
            _this.props.onChange(index, item);
        };

        _this.handleClickThumb = function (index, item) {
            _this.props.onClickThumb(index, item);

            _this.selectItem({
                selectedItem: index
            });
        };

        _this.onSwipeStart = function () {
            _this.setState({
                swiping: true
            });
            _this.clearAutoPlay();
        };

        _this.onSwipeEnd = function () {
            _this.resetPosition();
            _this.setState({
                swiping: false
            });
            _this.autoPlay();
        };

        _this.onSwipeMove = function (delta) {
            var isHorizontal = _this.props.axis === 'horizontal';

            var initialBoundry = 0;

            var currentPosition = _this.getPosition(_this.state.selectedItem);
            var finalBoundry = _this.getPosition(_this.props.children.length - 1);

            var axisDelta = isHorizontal ? delta.x : delta.y;
            var handledDelta = axisDelta;

            // prevent user from swiping left out of boundaries
            if (currentPosition === initialBoundry && axisDelta > 0) {
                handledDelta = 0;
            }

            // prevent user from swiping right out of boundaries
            if (currentPosition === finalBoundry && axisDelta < 0) {
                handledDelta = 0;
            }

            var position = currentPosition + 100 / (_this.state.itemSize / handledDelta) + '%';

            _this.setPosition(position);

            // allows scroll if the swipe was within the tolerance
            var hasMoved = Math.abs(axisDelta) > _this.props.swipeScrollTolerance;

            if (hasMoved && !_this.state.cancelClick) {
                _this.setState({
                    cancelClick: true
                });
            }

            return hasMoved;
        };

        _this.resetPosition = function () {
            var currentPosition = _this.getPosition(_this.state.selectedItem) + '%';
            _this.setPosition(currentPosition);
        };

        _this.setPosition = function (position) {
            var list = _reactDom2.default.findDOMNode(_this.refs.itemList);
            ['WebkitTransform', 'MozTransform', 'MsTransform', 'OTransform', 'transform', 'msTransform'].forEach(function (prop) {
                list.style[prop] = (0, _CSSTranslate2.default)(position, _this.props.axis);
            });
        };

        _this.decrement = function (positions) {
            _this.moveTo(_this.state.selectedItem - (typeof positions === 'Number' ? positions : 1));
        };

        _this.increment = function (positions) {
            _this.moveTo(_this.state.selectedItem + (typeof positions === 'Number' ? positions : 1));
        };

        _this.moveTo = function (position) {
            var lastPosition = _this.props.children.length - 1;

            if (position < 0) {
                position = _this.props.infiniteLoop ? lastPosition : 0;
            }

            if (position > lastPosition) {
                position = _this.props.infiniteLoop ? 0 : lastPosition;
            }

            _this.selectItem({
                // if it's not a slider, we don't need to set position here
                selectedItem: position
            });

            // don't reset auto play when stop on hover is enabled, doing so will trigger a call to auto play more than once
            // and will result in the interval function not being cleared correctly.
            if (_this.props.autoPlay && _this.state.isMouseEntered === false) {
                _this.resetAutoPlay();
            }
        };

        _this.changeItem = function (e) {
            var newIndex = e.target.value;

            _this.selectItem({
                selectedItem: newIndex
            });
        };

        _this.selectItem = function (state) {
            _this.setState(state);
            _this.handleOnChange(state.selectedItem, _this.props.children[state.selectedItem]);
        };

        _this.getInitialImage = function () {
            var selectedItem = _this.props.selectedItem;
            var item = _this.refs['item' + selectedItem];
            var images = item && item.getElementsByTagName('img');
            return images && images[selectedItem];
        };

        _this.getVariableImageHeight = function (position) {
            var item = _this.refs['item' + position];
            var images = item && item.getElementsByTagName('img');
            if (_this.state.hasMount && images.length > 0) {
                var image = images[0];

                if (!image.complete) {
                    // if the image is still loading, the size won't be available so we trigger a new render after it's done
                    var onImageLoad = function onImageLoad() {
                        _this.forceUpdate();
                        image.removeEventListener('load', onImageLoad);
                    };

                    image.addEventListener('load', onImageLoad);
                }

                var height = image.clientHeight;
                return height > 0 ? height : null;
            }

            return null;
        };

        _this.state = {
            initialized: false,
            selectedItem: props.selectedItem,
            hasMount: false,
            isMouseEntered: false
        };
        return _this;
    }

    _createClass(Carousel, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (!this.props.children) {
                return;
            }

            this.setupCarousel();
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.selectedItem !== this.state.selectedItem) {
                this.updateSizes();
                this.moveTo(nextProps.selectedItem);
            }

            if (nextProps.autoPlay !== this.props.autoPlay) {
                if (nextProps.autoPlay) {
                    this.setupAutoPlay();
                } else {
                    this.destroyAutoPlay();
                }
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps) {
            if (!prevProps.children && this.props.children && !this.state.initialized) {
                this.setupCarousel();
            }
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            this.destroyCarousel();
        }
    }, {
        key: 'setupCarousel',
        value: function setupCarousel() {
            this.bindEvents();

            if (this.props.autoPlay) {
                this.setupAutoPlay();
            }

            this.setState({
                initialized: true
            });

            var initialImage = this.getInitialImage();
            if (initialImage) {
                // if it's a carousel of images, we set the mount state after the first image is loaded
                initialImage.addEventListener('load', this.setMountState);
            } else {
                this.setMountState();
            }
        }
    }, {
        key: 'destroyCarousel',
        value: function destroyCarousel() {
            if (this.state.initialized) {
                this.unbindEvents();
                this.destroyAutoPlay();
            }
        }
    }, {
        key: 'setupAutoPlay',
        value: function setupAutoPlay() {
            this.autoPlay();
            var carouselWrapper = this.refs['carouselWrapper'];

            if (this.props.stopOnHover && carouselWrapper) {
                carouselWrapper.addEventListener('mouseenter', this.stopOnHover);
                carouselWrapper.addEventListener('mouseleave', this.startOnLeave);
            }
        }
    }, {
        key: 'destroyAutoPlay',
        value: function destroyAutoPlay() {
            this.clearAutoPlay();
            var carouselWrapper = this.refs['carouselWrapper'];

            if (this.props.stopOnHover && carouselWrapper) {
                carouselWrapper.removeEventListener('mouseenter', this.stopOnHover);
                carouselWrapper.removeEventListener('mouseleave', this.startOnLeave);
            }
        }
    }, {
        key: 'bindEvents',
        value: function bindEvents() {
            // as the widths are calculated, we need to resize
            // the carousel when the window is resized
            window.addEventListener("resize", this.updateSizes);
            // issue #2 - image loading smaller
            window.addEventListener("DOMContentLoaded", this.updateSizes);

            if (this.props.useKeyboardArrows) {
                document.addEventListener("keydown", this.navigateWithKeyboard);
            }
        }
    }, {
        key: 'unbindEvents',
        value: function unbindEvents() {
            // removing listeners
            window.removeEventListener("resize", this.updateSizes);
            window.removeEventListener("DOMContentLoaded", this.updateSizes);

            var initialImage = this.getInitialImage();
            if (initialImage) {
                initialImage.removeEventListener("load", this.setMountState);
            }

            if (this.props.useKeyboardArrows) {
                document.removeEventListener("keydown", this.navigateWithKeyboard);
            }
        }
    }, {
        key: 'getPosition',
        value: function getPosition(index) {
            if (this.props.centerMode && this.props.axis === 'horizontal') {
                var currentPosition = -index * this.props.centerSlidePercentage;
                var lastPosition = this.props.children.length - 1;

                if (index && index !== lastPosition) {
                    currentPosition += (100 - this.props.centerSlidePercentage) / 2;
                } else if (index === lastPosition) {
                    currentPosition += 100 - this.props.centerSlidePercentage;
                }

                return currentPosition;
            }

            return -index * 100;
        }
    }, {
        key: 'renderItems',
        value: function renderItems() {
            var _this2 = this;

            return _react2.default.Children.map(this.props.children, function (item, index) {
                var itemClass = _cssClasses2.default.ITEM(true, index === _this2.state.selectedItem);
                var slideProps = {
                    ref: 'item' + index,
                    key: 'itemKey' + index,
                    className: _cssClasses2.default.ITEM(true, index === _this2.state.selectedItem),
                    onClick: _this2.handleClickItem.bind(_this2, index, item)
                };

                if (_this2.props.centerMode && _this2.props.axis === 'horizontal') {
                    slideProps.style = {
                        minWidth: _this2.props.centerSlidePercentage + '%'
                    };
                }

                return _react2.default.createElement(
                    'li',
                    slideProps,
                    item
                );
            });
        }
    }, {
        key: 'renderControls',
        value: function renderControls() {
            var _this3 = this;

            if (!this.props.showIndicators) {
                return null;
            }

            return _react2.default.createElement(
                'ul',
                { className: 'control-dots' },
                _react2.default.Children.map(this.props.children, function (item, index) {
                    return _react2.default.createElement('li', { className: _cssClasses2.default.DOT(index === _this3.state.selectedItem), onClick: _this3.changeItem, value: index, key: index });
                })
            );
        }
    }, {
        key: 'renderStatus',
        value: function renderStatus() {
            if (!this.props.showStatus) {
                return null;
            }

            return _react2.default.createElement(
                'p',
                { className: 'carousel-status' },
                this.props.statusFormatter(this.state.selectedItem + 1, this.props.children.length)
            );
        }
    }, {
        key: 'renderThumbs',
        value: function renderThumbs() {
            if (!this.props.showThumbs || this.props.children.length === 0) {
                return null;
            }

            return _react2.default.createElement(
                _Thumbs2.default,
                { onSelectItem: this.handleClickThumb, selectedItem: this.state.selectedItem, transitionTime: this.props.transitionTime, thumbWidth: this.props.thumbWidth },
                this.props.children
            );
        }
    }, {
        key: 'render',
        value: function render() {
            if (!this.props.children || this.props.children.length === 0) {
                return null;
            }

            var itemsLength = this.props.children.length;

            var isHorizontal = this.props.axis === 'horizontal';

            var canShowArrows = this.props.showArrows && itemsLength > 1;

            // show left arrow?
            var hasPrev = canShowArrows && (this.state.selectedItem > 0 || this.props.infiniteLoop);
            // show right arrow
            var hasNext = canShowArrows && (this.state.selectedItem < itemsLength - 1 || this.props.infiniteLoop);
            // obj to hold the transformations and styles
            var itemListStyles = {};

            var currentPosition = this.getPosition(this.state.selectedItem);

            // if 3d is available, let's take advantage of the performance of transform
            var transformProp = (0, _CSSTranslate2.default)(currentPosition + '%', this.props.axis);

            var transitionTime = this.props.transitionTime + 'ms';

            itemListStyles = {
                'WebkitTransform': transformProp,
                'MozTransform': transformProp,
                'MsTransform': transformProp,
                'OTransform': transformProp,
                'transform': transformProp,
                'msTransform': transformProp
            };

            if (!this.state.swiping) {
                itemListStyles = _extends({}, itemListStyles, {
                    'WebkitTransitionDuration': transitionTime,
                    'MozTransitionDuration': transitionTime,
                    'MsTransitionDuration': transitionTime,
                    'OTransitionDuration': transitionTime,
                    'transitionDuration': transitionTime,
                    'msTransitionDuration': transitionTime
                });
            }

            var swiperProps = {
                selectedItem: this.state.selectedItem,
                className: _cssClasses2.default.SLIDER(true, this.state.swiping),
                onSwipeMove: this.onSwipeMove,
                onSwipeStart: this.onSwipeStart,
                onSwipeEnd: this.onSwipeEnd,
                style: itemListStyles,
                tolerance: this.props.swipeScrollTolerance,
                ref: 'itemList'
            };

            var containerStyles = {};

            if (isHorizontal) {
                swiperProps.onSwipeLeft = this.increment;
                swiperProps.onSwipeRight = this.decrement;

                if (this.props.dynamicHeight) {
                    var itemHeight = this.getVariableImageHeight(this.state.selectedItem);
                    swiperProps.style.height = itemHeight || 'auto';
                    containerStyles.height = itemHeight || 'auto';
                }
            } else {
                swiperProps.onSwipeUp = this.props.verticalSwipe === 'natural' ? this.increment : this.decrement;
                swiperProps.onSwipeDown = this.props.verticalSwipe === 'natural' ? this.decrement : this.increment;
                swiperProps.style.height = this.state.itemSize;
                containerStyles.height = this.state.itemSize;
            }

            return _react2.default.createElement(
                'div',
                { className: this.props.className, ref: 'carouselWrapper' },
                _react2.default.createElement(
                    'div',
                    { className: _cssClasses2.default.CAROUSEL(true), style: { width: this.props.width } },
                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_PREV(!hasPrev), onClick: this.decrement }),
                    _react2.default.createElement(
                        'div',
                        { className: _cssClasses2.default.WRAPPER(true, this.props.axis), style: containerStyles, ref: 'itemsWrapper' },
                        _react2.default.createElement(
                            _reactEasySwipe2.default,
                            _extends({ tagName: 'ul' }, swiperProps, { allowMouseEvents: this.props.emulateTouch }),
                            this.renderItems()
                        )
                    ),
                    _react2.default.createElement('button', { type: 'button', className: _cssClasses2.default.ARROW_NEXT(!hasNext), onClick: this.increment }),
                    this.renderControls(),
                    this.renderStatus()
                ),
                this.renderThumbs()
            );
        }
    }]);

    return Carousel;
}(_react.Component);

Carousel.displayName = 'Carousel';
Carousel.propTypes = {
    className: _propTypes2.default.string,
    children: _propTypes2.default.node,
    showArrows: _propTypes2.default.bool,
    showStatus: _propTypes2.default.bool,
    showIndicators: _propTypes2.default.bool,
    infiniteLoop: _propTypes2.default.bool,
    showThumbs: _propTypes2.default.bool,
    thumbWidth: _propTypes2.default.number,
    selectedItem: _propTypes2.default.number,
    onClickItem: _propTypes2.default.func.isRequired,
    onClickThumb: _propTypes2.default.func.isRequired,
    onChange: _propTypes2.default.func.isRequired,
    axis: _propTypes2.default.oneOf(['horizontal', 'vertical']),
    verticalSwipe: _propTypes2.default.oneOf(['natural', 'standard']),
    width: customPropTypes.unit,
    useKeyboardArrows: _propTypes2.default.bool,
    autoPlay: _propTypes2.default.bool,
    stopOnHover: _propTypes2.default.bool,
    interval: _propTypes2.default.number,
    transitionTime: _propTypes2.default.number,
    swipeScrollTolerance: _propTypes2.default.number,
    dynamicHeight: _propTypes2.default.bool,
    emulateTouch: _propTypes2.default.bool,
    statusFormatter: _propTypes2.default.func.isRequired,
    centerMode: _propTypes2.default.bool,
    centerSlidePercentage: _propTypes2.default.number
};
Carousel.defaultProps = {
    showIndicators: true,
    showArrows: true,
    showStatus: true,
    showThumbs: true,
    infiniteLoop: false,
    selectedItem: 0,
    axis: 'horizontal',
    verticalSwipe: 'standard',
    width: '100%',
    useKeyboardArrows: false,
    autoPlay: false,
    stopOnHover: true,
    interval: 3000,
    transitionTime: 350,
    swipeScrollTolerance: 5,
    dynamicHeight: false,
    emulateTouch: false,
    onClickItem: noop,
    onClickThumb: noop,
    onChange: noop,
    statusFormatter: defaultStatusFormatter,
    centerMode: false,
    centerSlidePercentage: 80
};
exports.default = Carousel;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(0), __webpack_require__(3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (typeof exports !== "undefined") {
    factory(exports, require('react'), require('prop-types'));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.react, global.propTypes);
    global.reactSwipe = mod.exports;
  }
})(this, function (exports, _react, _propTypes) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.setHasSupportToCaptureOption = setHasSupportToCaptureOption;

  var _react2 = _interopRequireDefault(_react);

  var _propTypes2 = _interopRequireDefault(_propTypes);

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      default: obj
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  function _possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }

  var supportsCaptureOption = false;
  function setHasSupportToCaptureOption(hasSupport) {
    supportsCaptureOption = hasSupport;
  }

  try {
    addEventListener("test", null, Object.defineProperty({}, 'capture', { get: function get() {
        setHasSupportToCaptureOption(true);
      } }));
  } catch (e) {}

  function getSafeEventHandlerOpts() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { capture: true };

    return supportsCaptureOption ? options : options.capture;
  }

  /**
   * [getPosition returns a position element that works for mouse or touch events]
   * @param  {[Event]} event [the received event]
   * @return {[Object]}      [x and y coords]
   */
  function getPosition(event) {
    if ('touches' in event) {
      var _event$touches$ = event.touches[0],
          pageX = _event$touches$.pageX,
          pageY = _event$touches$.pageY;

      return { x: pageX, y: pageY };
    }

    var screenX = event.screenX,
        screenY = event.screenY;

    return { x: screenX, y: screenY };
  }

  var ReactSwipe = function (_Component) {
    _inherits(ReactSwipe, _Component);

    function ReactSwipe() {
      var _ref;

      _classCallCheck(this, ReactSwipe);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = _possibleConstructorReturn(this, (_ref = ReactSwipe.__proto__ || Object.getPrototypeOf(ReactSwipe)).call.apply(_ref, [this].concat(args)));

      _this._handleSwipeStart = _this._handleSwipeStart.bind(_this);
      _this._handleSwipeMove = _this._handleSwipeMove.bind(_this);
      _this._handleSwipeEnd = _this._handleSwipeEnd.bind(_this);

      _this._onMouseDown = _this._onMouseDown.bind(_this);
      _this._onMouseMove = _this._onMouseMove.bind(_this);
      _this._onMouseUp = _this._onMouseUp.bind(_this);
      return _this;
    }

    _createClass(ReactSwipe, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        if (this.swiper) {
          this.swiper.addEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({
            capture: true,
            passive: false
          }));
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        if (this.swiper) {
          this.swiper.removeEventListener('touchmove', this._handleSwipeMove, getSafeEventHandlerOpts({
            capture: true,
            passive: false
          }));
        }
      }
    }, {
      key: '_onMouseDown',
      value: function _onMouseDown(event) {
        if (!this.props.allowMouseEvents) {
          return;
        }

        this.mouseDown = true;

        document.addEventListener('mouseup', this._onMouseUp);
        document.addEventListener('mousemove', this._onMouseMove);

        this._handleSwipeStart(event);
      }
    }, {
      key: '_onMouseMove',
      value: function _onMouseMove(event) {
        if (!this.mouseDown) {
          return;
        }

        this._handleSwipeMove(event);
      }
    }, {
      key: '_onMouseUp',
      value: function _onMouseUp(event) {
        this.mouseDown = false;

        document.removeEventListener('mouseup', this._onMouseUp);
        document.removeEventListener('mousemove', this._onMouseMove);

        this._handleSwipeEnd(event);
      }
    }, {
      key: '_handleSwipeStart',
      value: function _handleSwipeStart(event) {
        var _getPosition = getPosition(event),
            x = _getPosition.x,
            y = _getPosition.y;

        this.moveStart = { x: x, y: y };
        this.props.onSwipeStart(event);
      }
    }, {
      key: '_handleSwipeMove',
      value: function _handleSwipeMove(event) {
        var _getPosition2 = getPosition(event),
            x = _getPosition2.x,
            y = _getPosition2.y;

        var deltaX = x - this.moveStart.x;
        var deltaY = y - this.moveStart.y;
        this.moving = true;

        // handling the responsability of cancelling the scroll to
        // the component handling the event
        var shouldPreventDefault = this.props.onSwipeMove({
          x: deltaX,
          y: deltaY
        }, event);

        if (shouldPreventDefault) {
          event.preventDefault();
        }

        this.movePosition = { deltaX: deltaX, deltaY: deltaY };
      }
    }, {
      key: '_handleSwipeEnd',
      value: function _handleSwipeEnd(event) {
        this.props.onSwipeEnd(event);

        var tolerance = this.props.tolerance;


        if (this.moving) {
          if (this.movePosition.deltaX < -tolerance) {
            this.props.onSwipeLeft(1, event);
          } else if (this.movePosition.deltaX > tolerance) {
            this.props.onSwipeRight(1, event);
          }
          if (this.movePosition.deltaY < -tolerance) {
            this.props.onSwipeUp(1, event);
          } else if (this.movePosition.deltaY > tolerance) {
            this.props.onSwipeDown(1, event);
          }
        }

        this.moveStart = null;
        this.moving = false;
        this.movePosition = null;
      }
    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        return _react2.default.createElement(
          this.props.tagName,
          {
            ref: function ref(node) {
              return _this2.swiper = node;
            },
            onMouseDown: this._onMouseDown,
            onTouchStart: this._handleSwipeStart,
            onTouchEnd: this._handleSwipeEnd,
            className: this.props.className,
            style: this.props.style
          },
          this.props.children
        );
      }
    }]);

    return ReactSwipe;
  }(_react.Component);

  ReactSwipe.displayName = 'ReactSwipe';
  ReactSwipe.propTypes = {
    tagName: _propTypes2.default.string,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object,
    children: _propTypes2.default.node,
    allowMouseEvents: _propTypes2.default.bool,
    onSwipeUp: _propTypes2.default.func,
    onSwipeDown: _propTypes2.default.func,
    onSwipeLeft: _propTypes2.default.func,
    onSwipeRight: _propTypes2.default.func,
    onSwipeStart: _propTypes2.default.func,
    onSwipeMove: _propTypes2.default.func,
    onSwipeEnd: _propTypes2.default.func,
    tolerance: _propTypes2.default.number.isRequired
  };
  ReactSwipe.defaultProps = {
    tagName: 'div',
    allowMouseEvents: false,
    onSwipeUp: function onSwipeUp() {},
    onSwipeDown: function onSwipeDown() {},
    onSwipeLeft: function onSwipeLeft() {},
    onSwipeRight: function onSwipeRight() {},
    onSwipeStart: function onSwipeStart() {},
    onSwipeMove: function onSwipeMove() {},
    onSwipeEnd: function onSwipeEnd() {},

    tolerance: 0
  };
  exports.default = ReactSwipe;
});

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var outerWidth = exports.outerWidth = function outerWidth(el) {
	var width = el.offsetWidth;
	var style = getComputedStyle(el);

	width += parseInt(style.marginLeft) + parseInt(style.marginRight);
	return width;
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var unit = exports.unit = function unit(props, propName, componentName) {
    if (!/(pt|px|em|rem|vw|vh|%)$/.test(props[propName])) {
        return new Error('Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed. It needs to be a size unit like pt, px, em, rem, vw, %');
    }
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

(function() {
  'use strict';

  // desiredOffset - page offset to scroll to
  // speed - duration of the scroll per 1000px
  function __ANIMATE_SCROLL_TO(desiredOffset) {
    var userOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    if (desiredOffset instanceof HTMLElement) {
      if (userOptions.element && userOptions.element instanceof HTMLElement) {
        desiredOffset = (desiredOffset.getBoundingClientRect().top + userOptions.element.scrollTop)
          - userOptions.element.getBoundingClientRect().top;
      } else {
        var scrollTop = window.scrollY || document.documentElement.scrollTop;
        desiredOffset = scrollTop + desiredOffset.getBoundingClientRect().top;
      }
    }

    var options = {
      speed: 500,
      minDuration: 250,
      maxDuration: 1500,
      cancelOnUserAction: true,
      element: window,
      onComplete: undefined,
    };

    var optionsKeys = Object.keys(options);

    // Override default options
    for (var i = 0; i < optionsKeys.length; i++) {
      var key = optionsKeys[i];

      if (typeof userOptions[key] !== 'undefined') {
        options[key] = userOptions[key];
      }
    }

    options.isWindow = options.element === window;

    var initialScrollPosition = null;
    var maxScroll = null;

    if (options.isWindow) {
      // get cross browser scroll position
      initialScrollPosition = window.scrollY || document.documentElement.scrollTop;
      // cross browser document height minus window height
      maxScroll = Math.max(
        document.body.scrollHeight, document.documentElement.scrollHeight,
        document.body.offsetHeight, document.documentElement.offsetHeight,
        document.body.clientHeight, document.documentElement.clientHeight
      ) - window.innerHeight;
    } else {
      // DOM element
      initialScrollPosition = options.element.scrollTop;
      maxScroll = options.element.scrollHeight - options.element.clientHeight;
    }

    // If the scroll position is greater than maximum available scroll
    if (desiredOffset > maxScroll) {
      desiredOffset = maxScroll;
    }

    // Calculate diff to scroll
    var diff = desiredOffset - initialScrollPosition;

    // Do nothing if the page is already there
    if (diff === 0) {
      // Execute callback if there is any
      if (options.onComplete && typeof options.onComplete === 'function') {
        options.onComplete()
      }

      return;
    }

    // Calculate duration of the scroll
    var duration = Math.abs(Math.round((diff / 1000) * options.speed));

    // Set minimum and maximum duration
    if (duration < options.minDuration) {
      duration = options.minDuration;
    } else if (duration > options.maxDuration) {
      duration = options.maxDuration;
    }

    var startingTime = Date.now();

    // Request animation frame ID
    var requestID = null;

    // Method handler
    var handleUserEvent = null;

    if (options.cancelOnUserAction) {
      // Set handler to cancel scroll on user action
      handleUserEvent = function() {
        removeListeners();
        cancelAnimationFrame(requestID);
      };
      window.addEventListener('keydown', handleUserEvent);
      window.addEventListener('mousedown', handleUserEvent);
    } else {
      // Set handler to prevent user actions while scroll is active
      handleUserEvent = function(e) { e.preventDefault(); };
      window.addEventListener('scroll', handleUserEvent);
    }

    window.addEventListener('wheel', handleUserEvent);
    window.addEventListener('touchstart', handleUserEvent);

    var removeListeners = function () {
      window.removeEventListener('wheel', handleUserEvent);
      window.removeEventListener('touchstart', handleUserEvent);

      if (options.cancelOnUserAction) {
        window.removeEventListener('keydown', handleUserEvent);
        window.removeEventListener('mousedown', handleUserEvent);
      } else {
        window.removeEventListener('scroll', handleUserEvent);
      }
    };

    var step = function () {
      var timeDiff = Date.now() - startingTime;
      var t = (timeDiff / duration) - 1;
      var easing = t * t * t + 1;
      var scrollPosition = Math.round(initialScrollPosition + (diff * easing));

      if (timeDiff < duration && scrollPosition !== desiredOffset) {
        // If scroll didn't reach desired offset or time is not elapsed
        // Scroll to a new position
        // And request a new step

        if (options.isWindow) {
          options.element.scrollTo(0, scrollPosition);
        } else {
          options.element.scrollTop = scrollPosition;
        }

        requestID = requestAnimationFrame(step);
      } else {
        // If the time elapsed or we reached the desired offset
        // Set scroll to the desired offset (when rounding made it to be off a pixel or two)
        // Clear animation frame to be sure
        if (options.isWindow) {
          options.element.scrollTo(0, desiredOffset);
        } else {
          options.element.scrollTop = desiredOffset;
        }
        cancelAnimationFrame(requestID);

        // Remove listeners
        removeListeners();

        // Animation is complete, execute callback if there is any
        if (options.onComplete && typeof options.onComplete === 'function') {
          options.onComplete()
        }
      }
    };

    // Start animating scroll
    requestID = requestAnimationFrame(step);
  }

  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = __ANIMATE_SCROLL_TO;
      exports = module.exports;
    }
    exports.default = __ANIMATE_SCROLL_TO;
  } else if (window) {
    window.animateScrollTo = __ANIMATE_SCROLL_TO;
  }
}).call(this);


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Slide = function (_React$Component) {
	_inherits(Slide, _React$Component);

	function Slide() {
		_classCallCheck(this, Slide);

		return _possibleConstructorReturn(this, (Slide.__proto__ || Object.getPrototypeOf(Slide)).apply(this, arguments));
	}

	_createClass(Slide, [{
		key: 'triggerPrev',
		value: function triggerPrev() {
			document.querySelector('.control-prev').click();
		}
	}, {
		key: 'triggerNext',
		value: function triggerNext() {
			document.querySelector('.control-next').click();
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'article',
				{ className: 'slide', style: { backgroundImage: "url(" + this.props.image + ")" } },
				_react2.default.createElement(
					'div',
					{ className: 'overlay' },
					_react2.default.createElement(
						'div',
						{ className: 'slide-container' },
						_react2.default.createElement(
							'h1',
							null,
							' ',
							this.props.title,
							' '
						),
						_react2.default.createElement(
							'nav',
							null,
							_react2.default.createElement(
								'button',
								{ className: 'arrow', onClick: this.triggerPrev.bind(this) },
								_react2.default.createElement(
									'svg',
									{ width: '8px', height: '12.061px', viewBox: '0 0 8 12.061', enableBackground: 'new 0 0 8 12.061', xmlSpace: 'preserve' },
									_react2.default.createElement('path', { fill: '#FFFFFF', d: 'M0.678,7.018c0,0-0.678-0.527-0.678-0.987c0-0.44,0.678-0.988,0.678-0.988l0.01-0.01l5.381-4.772\r c0.44-0.348,1.162-0.348,1.602,0c0.439,0.348,0.439,0.918,0,1.266L3.165,6.03l4.505,4.503c0.439,0.35,0.439,0.918,0,1.267\r c-0.439,0.348-1.16,0.348-1.602,0L0.688,7.027L0.678,7.018' })
								)
							),
							_react2.default.createElement(
								'a',
								{ href: this.props.link, target: '_blank', className: 'radius-button' },
								'View case'
							),
							_react2.default.createElement(
								'button',
								{ className: 'arrow', onClick: this.triggerNext.bind(this) },
								_react2.default.createElement(
									'svg',
									{ width: '8px', height: '12.061px', viewBox: '0 0 8 12.061', enableBackground: 'new 0 0 8 12.061', xmlSpace: 'preserve' },
									_react2.default.createElement('path', { fill: '#FFFFFF', d: 'M7.322,7.018c0,0,0.678-0.527,0.678-0.987c0-0.44-0.678-0.988-0.678-0.988l-0.01-0.01L1.932,0.261\r c-0.44-0.348-1.162-0.348-1.602,0c-0.439,0.348-0.439,0.918,0,1.266L4.835,6.03L0.33,10.533c-0.439,0.35-0.439,0.918,0,1.267\r c0.439,0.348,1.16,0.348,1.602,0l5.381-4.773L7.322,7.018' })
								)
							)
						)
					)
				)
			);
		}
	}]);

	return Slide;
}(_react2.default.Component);

exports.default = Slide;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Intro = function (_React$Component) {
	_inherits(Intro, _React$Component);

	function Intro() {
		_classCallCheck(this, Intro);

		return _possibleConstructorReturn(this, (Intro.__proto__ || Object.getPrototypeOf(Intro)).apply(this, arguments));
	}

	_createClass(Intro, [{
		key: "render",
		value: function render() {
			return _react2.default.createElement(
				"section",
				{ className: "intro padding" },
				_react2.default.createElement(
					"article",
					{ className: "intro-content wrapper" },
					_react2.default.createElement(
						"h2",
						null,
						" We are Tam Tam "
					),
					_react2.default.createElement(
						"p",
						null,
						" Tam Tam is a full service digital agency focusing on Dutch Digital Service Design. We combine strategy, design, technology and interaction to make the digital interactions between company and customer valuable and memorable. We work for awesome brands with a team of 120 digitals from our office in Amsterdam. Making great work and having a blast doing it. That\u2019s what we believe in."
					)
				)
			);
		}
	}]);

	return Intro;
}(_react2.default.Component);

exports.default = Intro;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _axios = __webpack_require__(113);

var _axios2 = _interopRequireDefault(_axios);

var _Post = __webpack_require__(132);

var _Post2 = _interopRequireDefault(_Post);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Feed = function (_React$Component) {
	_inherits(Feed, _React$Component);

	function Feed() {
		_classCallCheck(this, Feed);

		var _this = _possibleConstructorReturn(this, (Feed.__proto__ || Object.getPrototypeOf(Feed)).call(this));

		_this.state = {
			feed: [{
				images: {
					standard_resolution: {
						url: null
					}
				},
				caption: {
					text: null
				}
			}],
			limitReached: false,
			getData: {
				accessToken: '300972848.78d0565.deded66c81874c5b95b70bf10067d12e',
				count: 6,
				userId: '562099325'
			},
			popup: {
				images: {
					standard_resolution: null
				},
				user: {
					username: null,
					profile_picture: null
				},
				caption: {
					text: null
				},
				likes: {
					count: null
				}
			},
			showPopup: false
		};
		return _this;
	}

	_createClass(Feed, [{
		key: 'componentWillMount',
		value: function componentWillMount() {
			var _this2 = this;

			var accessToken = this.state.getData.accessToken;
			var count = this.state.getData.count;
			var userId = this.state.getData.userId;

			_axios2.default.get('https://api.instagram.com/v1/users/' + userId + '/media/recent/?count=' + count + '&access_token=' + accessToken).then(function (response) {
				_this2.setState({ feed: response.data.data });
			}).catch(function (err) {
				alert(err);
			});
		}
	}, {
		key: 'loadPosts',
		value: function loadPosts(e) {
			var _this3 = this;

			var button = e.target;
			button.classList.add('loading');

			var max_id = this.state.feed[this.state.feed.length - 1].id;
			var accessToken = this.state.getData.accessToken;
			var count = this.state.getData.count;
			var userId = this.state.getData.userId;

			_axios2.default.get('https://api.instagram.com/v1/users/' + userId + '/media/recent/?count=' + count + '&max_id=' + max_id + '&access_token=' + accessToken).then(function (response) {
				var newData = response.data.data;
				var data = [].concat(_toConsumableArray(_this3.state.feed), _toConsumableArray(newData));

				_this3.setState({ feed: data });
				button.classList.remove('loading');

				if (_this3.state.feed.length == 18) {
					_this3.setState({ limitReached: true });
				}
			}).catch(function (err) {
				alert(err);
				button.classList.remove('loading');
			});
		}
	}, {
		key: 'hidePopup',
		value: function hidePopup() {
			this.setState({ showPopup: false });
		}
	}, {
		key: 'feedPopup',
		value: function feedPopup(id) {
			var _this4 = this;

			var feed = this.state.feed;
			var post = feed.filter(function (obj) {
				return obj.id == id;
			});
			this.setState({ popup: post[0], showPopup: true }, function () {
				console.log(_this4.state.popup);
			});
		}
	}, {
		key: 'render',
		value: function render() {
			var _this5 = this;

			var feed = this.state.feed.map(function (post, i) {
				return _react2.default.createElement(_Post2.default, { click: _this5.feedPopup.bind(_this5), key: i, id: post.id, image: post.images.standard_resolution.url, text: post.caption });
			});
			return _react2.default.createElement(
				'section',
				{ className: 'feed' },
				_react2.default.createElement(
					'div',
					{ className: 'padding' },
					_react2.default.createElement(
						'article',
						{ className: 'wrapper' },
						_react2.default.createElement(
							'h2',
							null,
							' Follow us on Instagram '
						),
						_react2.default.createElement(
							'h3',
							null,
							' @tamtamnl '
						),
						_react2.default.createElement(
							'section',
							{ className: 'feed-content' },
							feed
						),
						!this.state.limitReached ? _react2.default.createElement(
							'button',
							{ className: 'feed-button', onClick: this.loadPosts.bind(this) },
							' Load more '
						) : null
					)
				),
				this.state.showPopup ? _react2.default.createElement(
					'article',
					{ className: 'feed-popup' },
					_react2.default.createElement('div', { className: 'overlay', onClick: this.hidePopup.bind(this) }),
					_react2.default.createElement(
						'div',
						{ className: 'container' },
						_react2.default.createElement(
							'div',
							{ className: 'content' },
							_react2.default.createElement('section', { className: 'image', style: { backgroundImage: "url(" + this.state.popup.images.standard_resolution.url + ")" } }),
							_react2.default.createElement(
								'section',
								{ className: 'infobox' },
								_react2.default.createElement(
									'button',
									{ className: 'cross', onClick: this.hidePopup.bind(this) },
									_react2.default.createElement(
										'svg',
										{ viewBox: '0 0 23.335 23.335', 'enable-background': 'new 0 0 23.335 23.335', xmlSpace: 'preserve' },
										_react2.default.createElement('path', { d: 'M13.789,11.667l9.546,9.546l-2.122,2.122l-9.546-9.546l-9.546,9.546L0,21.213l9.546-9.546L0,2.121L2.121,0l9.546,9.546\r L21.213,0l2.122,2.121L13.789,11.667z' })
									)
								),
								_react2.default.createElement(
									'article',
									{ className: 'user' },
									_react2.default.createElement('img', { src: this.state.popup.user.profile_picture }),
									_react2.default.createElement(
										'span',
										{ className: 'username' },
										' ',
										this.state.popup.user.username,
										' '
									)
								),
								_react2.default.createElement(
									'article',
									{ className: 'text' },
									_react2.default.createElement(
										'span',
										null,
										this.state.popup.caption.text
									)
								),
								_react2.default.createElement(
									'article',
									{ className: 'likes' },
									_react2.default.createElement(
										'span',
										null,
										this.state.popup.likes.count,
										' likes'
									)
								)
							)
						)
					)
				) : null
			);
		}
	}]);

	return Feed;
}(_react2.default.Component);

exports.default = Feed;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(114);

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);
var bind = __webpack_require__(43);
var Axios = __webpack_require__(116);
var defaults = __webpack_require__(24);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(47);
axios.CancelToken = __webpack_require__(130);
axios.isCancel = __webpack_require__(46);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(131);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),
/* 115 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(24);
var utils = __webpack_require__(4);
var InterceptorManager = __webpack_require__(125);
var dispatchRequest = __webpack_require__(126);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(45);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);
var transformData = __webpack_require__(127);
var isCancel = __webpack_require__(46);
var defaults = __webpack_require__(24);
var isAbsoluteURL = __webpack_require__(128);
var combineURLs = __webpack_require__(129);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(4);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(47);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Feed = function (_React$Component) {
	_inherits(Feed, _React$Component);

	function Feed() {
		_classCallCheck(this, Feed);

		return _possibleConstructorReturn(this, (Feed.__proto__ || Object.getPrototypeOf(Feed)).apply(this, arguments));
	}

	_createClass(Feed, [{
		key: "render",
		value: function render() {
			return _react2.default.createElement(
				"article",
				{ className: "post", onClick: this.props.click.bind(this, this.props.id) },
				_react2.default.createElement("img", { src: this.props.image, alt: "" }),
				_react2.default.createElement(
					"section",
					{ className: "content" },
					_react2.default.createElement(
						"p",
						null,
						this.props.text ? this.props.text.text : null
					)
				)
			);
		}
	}]);

	return Feed;
}(_react2.default.Component);

exports.default = Feed;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _ContactForm = __webpack_require__(134);

var _ContactForm2 = _interopRequireDefault(_ContactForm);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Contact = function (_React$Component) {
	_inherits(Contact, _React$Component);

	function Contact() {
		_classCallCheck(this, Contact);

		return _possibleConstructorReturn(this, (Contact.__proto__ || Object.getPrototypeOf(Contact)).apply(this, arguments));
	}

	_createClass(Contact, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(_ContactForm2.default, null);
		}
	}]);

	return Contact;
}(_react2.default.Component);

exports.default = Contact;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ContactForm = function (_React$Component) {
	_inherits(ContactForm, _React$Component);

	function ContactForm() {
		_classCallCheck(this, ContactForm);

		var _this = _possibleConstructorReturn(this, (ContactForm.__proto__ || Object.getPrototypeOf(ContactForm)).call(this));

		_this.state = {
			validation: {
				email: false,
				firstname: false,
				lastname: false,
				message: false
			},
			message: {
				show: false,
				text: '',
				type: 'error'
			},
			error: {
				email: false,
				firstname: false,
				lastname: false,
				message: false
			},
			data: {
				email: '',
				firstname: '',
				lastname: '',
				message: ''
			}
		};
		return _this;
	}

	_createClass(ContactForm, [{
		key: 'checkField',
		value: function checkField(e) {
			var input = e.target.value;
			var name = e.target.name;

			if (name == 'email') {
				// Source: https://stackoverflow.com/questions/46155/how-can-you-validate-an-email-address-in-javascript
				var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

				if (re.test(input)) {
					this.validation(true, e);
				} else {
					this.validation(false, e);
				}
			} else {
				if (input) {
					this.validation(true, e);
				} else {
					this.validation(false, e);
				}
			}
		}
	}, {
		key: 'validation',
		value: function validation(valid, e) {
			var parent = e.target.parentElement;
			var name = e.target.name;
			var validation = this.state.validation;

			if (valid) {
				parent.classList.add('valid');
				validation[name] = true;
				this.setState({ validation: validation });
			} else {
				parent.classList.remove('valid');
				validation[name] = false;
				this.setState({ validation: validation });
			}
		}
	}, {
		key: 'submit',
		value: function submit(e) {
			e.preventDefault();
			var validation = this.state.validation;
			if (this.checkIfValid(validation)) {
				// Success
				this.setState({ message: {
						text: 'Thank you, we have received your message.',
						type: 'success',
						show: true
					} });

				this.refs.form.classList.add('hide');
			} else {
				// Error(s)
				this.setState({
					message: {
						text: 'Please complete the form and try again.',
						type: 'error',
						show: true
					},
					data: {
						email: this.refs.email.value,
						firstname: this.refs.firstname.value,
						lastname: this.refs.lastname.value,
						message: this.refs.message.value
					}
				});

				this.setState({ error: {
						email: !this.state.validation.email,
						firstname: !this.state.validation.firstname,
						lastname: !this.state.validation.lastname,
						message: !this.state.validation.message
					} });
			}
		}
	}, {
		key: 'checkIfValid',
		value: function checkIfValid(validation) {
			for (var o in validation) {
				if (!validation[o]) return false;
			}return true;
		}
	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'section',
				{ className: 'contact-form' },
				_react2.default.createElement(
					'div',
					{ className: 'padding wrapper-small' },
					_react2.default.createElement(
						'h1',
						null,
						' We would love to hear from you '
					),
					this.state.message.show ? _react2.default.createElement(
						'div',
						{ className: 'message' },
						_react2.default.createElement(
							'div',
							{ className: 'message-icon' },
							_react2.default.createElement('div', { className: 'icon ' + this.state.message.type })
						),
						_react2.default.createElement(
							'span',
							{ className: 'message-text' },
							' ',
							this.state.message.text,
							' '
						)
					) : null,
					_react2.default.createElement(
						'form',
						{ onSubmit: this.submit.bind(this), ref: 'form' },
						_react2.default.createElement(
							'div',
							{ className: 'form-container' },
							_react2.default.createElement(
								'div',
								{ className: 'field half' },
								_react2.default.createElement('input', { onChange: this.checkField.bind(this), name: 'firstname', ref: 'firstname', type: 'text', placeholder: 'First name' }),
								this.state.error.firstname ? _react2.default.createElement(
									'div',
									{ className: 'error-popup' },
									_react2.default.createElement('div', { className: 'triangle' }),
									_react2.default.createElement(
										'span',
										null,
										' We need your first name. '
									)
								) : null
							),
							_react2.default.createElement(
								'div',
								{ className: 'field half' },
								_react2.default.createElement('input', { onChange: this.checkField.bind(this), name: 'lastname', ref: 'lastname', type: 'text', placeholder: 'Last name' }),
								this.state.error.lastname ? _react2.default.createElement(
									'div',
									{ className: 'error-popup' },
									_react2.default.createElement('div', { className: 'triangle' }),
									_react2.default.createElement(
										'span',
										null,
										' We need your last name. '
									)
								) : null
							),
							_react2.default.createElement(
								'div',
								{ className: 'field half' },
								_react2.default.createElement('input', { onChange: this.checkField.bind(this), name: 'email', ref: 'email', type: 'text', placeholder: 'Your e-mail address' }),
								this.state.error.email ? _react2.default.createElement(
									'div',
									{ className: 'error-popup' },
									_react2.default.createElement('div', { className: 'triangle' }),
									_react2.default.createElement(
										'span',
										null,
										' Please use a valid e-mail address. '
									)
								) : null
							),
							_react2.default.createElement(
								'div',
								{ className: 'field half' },
								_react2.default.createElement('input', { onChange: this.checkField.bind(this), name: 'phonenumber', ref: 'phonenumber', type: 'text', placeholder: 'Your phone number (optional)' })
							),
							_react2.default.createElement(
								'div',
								{ className: 'field full' },
								_react2.default.createElement('textarea', { onChange: this.checkField.bind(this), name: 'message', ref: 'message', placeholder: 'Your message...' }),
								this.state.error.message ? _react2.default.createElement(
									'div',
									{ className: 'error-popup' },
									_react2.default.createElement('div', { className: 'triangle' }),
									_react2.default.createElement(
										'span',
										null,
										' Sorry, your message can\'t be empty. '
									)
								) : null
							)
						),
						_react2.default.createElement('input', { className: 'submit-button', type: 'submit', value: 'Send' })
					)
				)
			);
		}
	}]);

	return ContactForm;
}(_react2.default.Component);

exports.default = ContactForm;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var People = function (_React$Component) {
	_inherits(People, _React$Component);

	function People() {
		_classCallCheck(this, People);

		return _possibleConstructorReturn(this, (People.__proto__ || Object.getPrototypeOf(People)).apply(this, arguments));
	}

	_createClass(People, [{
		key: "render",
		value: function render() {
			return _react2.default.createElement(
				"section",
				{ className: "people" },
				_react2.default.createElement("img", { className: "cat", src: "http://gifimage.net/wp-content/uploads/2017/10/cat-typing-fast-gif-2.gif", alt: "Cat" })
			);
		}
	}]);

	return People;
}(_react2.default.Component);

exports.default = People;

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZDE1ODM5NDE1N2Q1ZmUyZDQxYjAiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0xvY2F0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0xvY2F0aW9uVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3ZhbHVlLWVxdWFsL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9ET01VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTGluay5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL2ltZy9mZWVkX2JnLmpwZyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2Nzc0NsYXNzZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9DU1NUcmFuc2xhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1lYXN5LXN3aXBlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2NvbXBvbmVudHMvVGh1bWJzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0Jyb3dzZXJSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTWVtb3J5Um91dGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUHJvbXB0LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1Byb21wdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N0YXRpY1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Td2l0Y2guanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy93aXRoUm91dGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vY3NzL21haW4uc2Nzcz9lYmUxIiwid2VicGFjazovLy8uL2Nzcy9tYWluLnNjc3MiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi91cmwvZXNjYXBlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vaW1nL2ljb25zL2xvYWRlci5naWYiLCJ3ZWJwYWNrOi8vLy4vaW1nL2ljb25zL2NoZWNrLWdyZWVuLnN2ZyIsIndlYnBhY2s6Ly8vLi9pbWcvaWNvbnMvY2hlY2std2hpdGUuc3ZnIiwid2VicGFjazovLy8uL2ltZy9pY29ucy9leGNsYW1hdGlvbi5zdmciLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qcyIsIndlYnBhY2s6Ly8vLi9qcy9wYWdlcy9MYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vanMvY29tcG9uZW50cy9IZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvY29tcG9uZW50cy9OYXYuanMiLCJ3ZWJwYWNrOi8vLy4vanMvY29tcG9uZW50cy9Gb290ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMvcGFnZXMvSG9tZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL1NsaWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvY29tcG9uZW50cy9DYXJvdXNlbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1lYXN5LXN3aXBlL2xpYi9yZWFjdC1zd2lwZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvbGliL2RpbWVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9jdXN0b21Qcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9hbmltYXRlZC1zY3JvbGwtdG8vYW5pbWF0ZWQtc2Nyb2xsLXRvLmpzIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvU2xpZGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMvY29tcG9uZW50cy9JbnRyby5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL0ZlZWQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL1Bvc3QuanMiLCJ3ZWJwYWNrOi8vLy4vanMvcGFnZXMvQ29udGFjdC5qcyIsIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL0NvbnRhY3RGb3JtLmpzIiwid2VicGFjazovLy8uL2pzL3BhZ2VzL1Blb3BsZS5qcyJdLCJuYW1lcyI6WyJyZW5kZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiTGF5b3V0IiwicHJvcHMiLCJjaGlsZHJlbiIsIkNvbXBvbmVudCIsIkhlYWRlciIsImhlYWRlciIsInF1ZXJ5U2VsZWN0b3IiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJyZW1vdmUiLCJtZW51Q29udHJvbGxlciIsImJpbmQiLCJjbG9zZU1lbnUiLCJOYXYiLCJGb290ZXIiLCJIb21lIiwiU2xpZGVyIiwic2Nyb2xsVG8iLCJTbGlkZSIsImNsaWNrIiwiYmFja2dyb3VuZEltYWdlIiwiaW1hZ2UiLCJ0aXRsZSIsInRyaWdnZXJQcmV2IiwibGluayIsInRyaWdnZXJOZXh0IiwiSW50cm8iLCJGZWVkIiwic3RhdGUiLCJmZWVkIiwiaW1hZ2VzIiwic3RhbmRhcmRfcmVzb2x1dGlvbiIsInVybCIsImNhcHRpb24iLCJ0ZXh0IiwibGltaXRSZWFjaGVkIiwiZ2V0RGF0YSIsImFjY2Vzc1Rva2VuIiwiY291bnQiLCJ1c2VySWQiLCJwb3B1cCIsInVzZXIiLCJ1c2VybmFtZSIsInByb2ZpbGVfcGljdHVyZSIsImxpa2VzIiwic2hvd1BvcHVwIiwiZ2V0IiwidGhlbiIsInJlc3BvbnNlIiwic2V0U3RhdGUiLCJkYXRhIiwiY2F0Y2giLCJlcnIiLCJhbGVydCIsImUiLCJidXR0b24iLCJ0YXJnZXQiLCJhZGQiLCJtYXhfaWQiLCJsZW5ndGgiLCJpZCIsIm5ld0RhdGEiLCJwb3N0IiwiZmlsdGVyIiwib2JqIiwiY29uc29sZSIsImxvZyIsIm1hcCIsImkiLCJmZWVkUG9wdXAiLCJsb2FkUG9zdHMiLCJoaWRlUG9wdXAiLCJDb250YWN0IiwiQ29udGFjdEZvcm0iLCJ2YWxpZGF0aW9uIiwiZW1haWwiLCJmaXJzdG5hbWUiLCJsYXN0bmFtZSIsIm1lc3NhZ2UiLCJzaG93IiwidHlwZSIsImVycm9yIiwiaW5wdXQiLCJ2YWx1ZSIsIm5hbWUiLCJyZSIsInRlc3QiLCJ2YWxpZCIsInBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJwcmV2ZW50RGVmYXVsdCIsImNoZWNrSWZWYWxpZCIsInJlZnMiLCJmb3JtIiwibyIsInN1Ym1pdCIsImNoZWNrRmllbGQiLCJQZW9wbGUiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7K0NDN0RBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMzREE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVC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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEU7Ozs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxFOzs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Qjs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0YsYUFBYTtBQUNuRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsNEZBQTRGLGVBQWU7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3REE7QUFDUTtBQUNSO0FBQ1E7QUFDUjtBQUNRO0FBQ1I7QUFDUTtB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eUI7Ozs7Ozs7QUNwWEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzsrQ0NWQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7QUNuTEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqQkE7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7OztBQ0pBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7OztBQ2xCQTs7OztBQUNBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUEsbUJBQVNBLE1BQVQsQ0FDQztBQUFBO0FBQUE7QUFDQztBQUFBO0FBQUE7QUFDQztBQUFBO0FBQUEsS0FBTyxXQUFQLEVBQWEsTUFBSyxHQUFsQixFQUFzQix5QkFBdEI7QUFBQTtBQUFBLEdBREQ7QUFFQztBQUFBO0FBQUEsS0FBTyxNQUFLLFVBQVosRUFBdUIsNEJBQXZCO0FBQUE7QUFBQSxHQUZEO0FBR0M7QUFBQTtBQUFBLEtBQU8sTUFBSyxTQUFaLEVBQXNCLDJCQUF0QjtBQUFBO0FBQUE7QUFIRDtBQURELENBREQsRUFRQ0MsU0FBU0MsY0FBVCxDQUF3QixLQUF4QixDQVJELEU7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhO0FBQ2IsY0FBYyw0REFBNEQsb0ZBQW9GLElBQUksMkRBQTJELDRIQUE0SCw2QkFBNkIsZ0JBQWdCO0FBQ3RZLE9BQU8scUJBQXFCLFNBQVMsZ0NBQWdDLGlDQUFpQywrQkFBK0Isa0JBQWtCLGFBQWEsZUFBZSxZQUFZLGtCQUFrQixnQ0FBZ0MsbUNBQW1DLG1FQUFtRSxtREFBbUQsb0NBQW9DO0FBQzlhLGtCQUFrQixhQUFhLGVBQWUsWUFBWSxrQkFBa0IsY0FBYyx3QkFBd0Isd0JBQXdCLGdCQUFnQixpQkFBaUIsMEJBQTBCLGtCQUFrQixhQUFhLGVBQWUsWUFBWSxrQkFBa0Isd0JBQXdCLGdCQUFnQixpQkFBaUIsb0NBQW9DLG9CQUFvQiw0QkFBNEIsT0FBTyxhQUFhLHNDQUFzQztBQUN4ZCxrQkFBa0IsVUFBVSxlQUFlLDRIQUE0SCx5QkFBeUIsc0JBQXNCLGFBQWEsdUJBQXVCLElBQUksd0JBQXdCLGFBQWEsNEVBQTRFLE9BQU8sd0RBQXdELGNBQWM7QUFDNWIsbUJBQW1CLE9BQU8sNEJBQTRCLDZDQUE2QyxZQUFZLEVBQUUsa0JBQWtCLG9CQUFvQixhQUFhLGNBQWMsV0FBVyxjQUFjLFNBQVMsWUFBWSxVQUFVLFNBQVMsT0FBTywrQ0FBK0MsY0FBYyxjQUFjLGlCQUFpQixZQUFZLGVBQWUsVUFBVTtBQUMzWCxvQkFBb0IsZUFBZSx5Q0FBeUMsU0FBUyxpQkFBaUIsZUFBZSxpQ0FBaUMsTUFBTSxpQ0FBaUMsa0NBQWtDLHlDQUF5QyxJQUFJLG1CQUFtQixnQ0FBZ0MsV0FBVyxLQUFLLE9BQU8sZUFBZSxjQUFjO0FBQ25YLGNBQWMsbUJBQW1CLHNDQUFzQywwRUFBMEUsOEJBQThCLFNBQVMsU0FBUyxnQkFBZ0IsOEVBQThFLGdCQUFnQjtBQUMvUyxrQkFBa0IsNkJBQTZCLHFDQUFxQywySUFBMkkscUVBQXFFLGFBQWEsc0JBQXNCLFNBQVMsNENBQTRDLGFBQWEscUJBQXFCO0FBQzlaLE9BQU8sVUFBVSxvQkFBb0Isb0JBQW9CLFNBQVMsZ0JBQWdCLFNBQVMseUJBQXlCLG9CQUFvQixtQkFBbUIscUJBQXFCLEtBQUssbUJBQW1CLGdEQUFnRCxxQkFBcUIsU0FBUyxrQ0FBa0MsU0FBUyxrQkFBa0IscUJBQXFCLFVBQVUsK0dBQStHLFVBQVU7QUFDM2UsMkJBQTJCLFlBQVksc0NBQXNDLDZCQUE2Qix5REFBeUQseUZBQXlGLHlCQUF5QixzQkFBc0IsYUFBYSxXQUFXLFlBQVksSUFBSSx3QkFBd0IsYUFBYSxPQUFPLHFEQUFxRCwyQkFBMkIscUJBQXFCLFNBQVMsU0FBUztBQUN0ZixzRkFBc0YsOEJBQThCLGtCQUFrQixVQUFVLFlBQVk7Ozs7Ozs7O0FDcEI1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGVBQWU7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLE9BQU87QUFDcEIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2I7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtFQUErRSxnRUFBZ0U7QUFDL0k7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7O0FDNTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCOzs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxFQUFFO0FBQ2YsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxFQUFFO0FBQ2YsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixzQkFBc0I7O0FBRXRCO0FBQ0Esa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsYUFBYTtBQUNiLGNBQWM7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGlCQUFpQixrQ0FBa0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQixFQUFFO0FBQ3JDLHlCQUF5Qix3QkFBd0IsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtLQUFrSyx5Q0FBeUM7QUFDM007QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtEQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx5Q0FBeUM7QUFDekMsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOE1BQThNO0FBQzlNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELG1CQUFtQjtBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGLGFBQWE7QUFDbkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGVBQWU7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtB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Q0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEtBQThLLFlBQVk7QUFDMUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1TEFBdUwsK0JBQStCO0FBQ3ROOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0pBQStKLGlCQUFpQjtBQUNoTCxPQUFPO0FBQ1AsK0pBQStKLGlCQUFpQix3REFBd0QsbUJBQW1CLGdCQUFnQiw4QkFBOEI7QUFDelM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwSUFBMEksbUJBQW1CLGdCQUFnQiw4QkFBOEI7QUFDM00sS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNU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Q0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQSxnRUFBZ0UsaUlBQWlJO0FB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O0FBQ0EsT0FBTyxFQUFFO0FBQ1QsR0FBRzs7QUFFSDtBQUNBLHVGQUF1Rjs7QUFFdkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxRUFBcUUsYUFBYTtBQUNsRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDBDQUEwQztBQUMxQywwQ0FBMEM7QUFDMUMsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QywwQ0FBMEM7QUFDMUMsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQSxDQUFDLEU7Ozs7Ozs7QUNsVEQ7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7Ozs7QUNYQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDVEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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TUFBSyxTQUFyRCxFQUErRCxLQUFJLFNBQW5FLEVBQTZFLGFBQVksaUJBQXpGLEdBREQ7QUFFRSxhQUFLaUIsS0FBTCxDQUFXcUQsS0FBWCxDQUFpQkgsT0FBakIsR0FDQTtBQUFBO0FBQUEsV0FBSyxXQUFVLGFBQWY7QUFDQyxnREFBSyxXQUFVLFVBQWYsR0FERDtBQUVDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFGRCxTQURBLEdBS0M7QUFQSDtBQS9CRCxPQUREO0FBMENDLCtDQUFPLFdBQVUsZUFBakIsRUFBaUMsTUFBSyxRQUF0QyxFQUErQyxPQUFNLE1BQXJEO0FBMUNEO0FBWEQ7QUFERCxJQUREO0FBNERBOzs7O0VBdkt1QyxnQkFBTTNFLFM7O2tCQUExQnNFLFc7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGckI7Ozs7Ozs7Ozs7OztJQUVxQndCLE07Ozs7Ozs7Ozs7OzJCQUNYO0FBQ1IsVUFDQztBQUFBO0FBQUEsTUFBUyxXQUFVLFFBQW5CO0FBQ0MsMkNBQUssV0FBVSxLQUFmLEVBQXFCLEtBQUksMEVBQXpCLEVBQW9HLEtBQUksS0FBeEc7QUFERCxJQUREO0FBS0E7Ozs7RUFQa0MsZ0JBQU05RixTOztrQkFBckI4RixNIiwiZmlsZSI6ImNsaWVudC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNDgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGQxNTgzOTQxNTdkNWZlMmQ0MWIwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvd2FybmluZy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIGlzQnVmZmVyID0gcmVxdWlyZSgnaXMtYnVmZmVyJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBhZGRMZWFkaW5nU2xhc2ggPSBleHBvcnRzLmFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59O1xuXG52YXIgc3RyaXBMZWFkaW5nU2xhc2ggPSBleHBvcnRzLnN0cmlwTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn07XG5cbnZhciBoYXNCYXNlbmFtZSA9IGV4cG9ydHMuaGFzQmFzZW5hbWUgPSBmdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhcXFxcL3xcXFxcP3wjfCQpJywgJ2knKS50ZXN0KHBhdGgpO1xufTtcblxudmFyIHN0cmlwQmFzZW5hbWUgPSBleHBvcnRzLnN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn07XG5cbnZhciBzdHJpcFRyYWlsaW5nU2xhc2ggPSBleHBvcnRzLnN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59O1xuXG52YXIgcGFyc2VQYXRoID0gZXhwb3J0cy5wYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBwYXRoIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbnZhciBjcmVhdGVQYXRoID0gZXhwb3J0cy5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG5cbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvUGF0aFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCB2YXIgYWRkTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBoYXNCYXNlbmFtZSA9IGZ1bmN0aW9uIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXggKyAnKFxcXFwvfFxcXFw/fCN8JCknLCAnaScpLnRlc3QocGF0aCk7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgcGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG5leHBvcnQgdmFyIGNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoLFxuICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cblxuICB2YXIgcGF0aCA9IHBhdGhuYW1lIHx8ICcvJztcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6ICc/JyArIHNlYXJjaDtcblxuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGggKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuXG4gIHJldHVybiBwYXRoO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9QYXRoVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IF9Ccm93c2VyUm91dGVyIGZyb20gJy4vQnJvd3NlclJvdXRlcic7XG5leHBvcnQgeyBfQnJvd3NlclJvdXRlciBhcyBCcm93c2VyUm91dGVyIH07XG5pbXBvcnQgX0hhc2hSb3V0ZXIgZnJvbSAnLi9IYXNoUm91dGVyJztcbmV4cG9ydCB7IF9IYXNoUm91dGVyIGFzIEhhc2hSb3V0ZXIgfTtcbmltcG9ydCBfTGluayBmcm9tICcuL0xpbmsnO1xuZXhwb3J0IHsgX0xpbmsgYXMgTGluayB9O1xuaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSAnLi9NZW1vcnlSb3V0ZXInO1xuZXhwb3J0IHsgX01lbW9yeVJvdXRlciBhcyBNZW1vcnlSb3V0ZXIgfTtcbmltcG9ydCBfTmF2TGluayBmcm9tICcuL05hdkxpbmsnO1xuZXhwb3J0IHsgX05hdkxpbmsgYXMgTmF2TGluayB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSAnLi9Qcm9tcHQnO1xuZXhwb3J0IHsgX1Byb21wdCBhcyBQcm9tcHQgfTtcbmltcG9ydCBfUmVkaXJlY3QgZnJvbSAnLi9SZWRpcmVjdCc7XG5leHBvcnQgeyBfUmVkaXJlY3QgYXMgUmVkaXJlY3QgfTtcbmltcG9ydCBfUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gJy4vUm91dGVyJztcbmV4cG9ydCB7IF9Sb3V0ZXIgYXMgUm91dGVyIH07XG5pbXBvcnQgX1N0YXRpY1JvdXRlciBmcm9tICcuL1N0YXRpY1JvdXRlcic7XG5leHBvcnQgeyBfU3RhdGljUm91dGVyIGFzIFN0YXRpY1JvdXRlciB9O1xuaW1wb3J0IF9Td2l0Y2ggZnJvbSAnLi9Td2l0Y2gnO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcbmV4cG9ydCB7IF9tYXRjaFBhdGggYXMgbWF0Y2hQYXRoIH07XG5pbXBvcnQgX3dpdGhSb3V0ZXIgZnJvbSAnLi93aXRoUm91dGVyJztcbmV4cG9ydCB7IF93aXRoUm91dGVyIGFzIHdpdGhSb3V0ZXIgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHJlc29sdmVQYXRobmFtZSBmcm9tICdyZXNvbHZlLXBhdGhuYW1lJztcbmltcG9ydCB2YWx1ZUVxdWFsIGZyb20gJ3ZhbHVlLWVxdWFsJztcbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcblxuZXhwb3J0IHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb24gPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSBwYXJzZVBhdGgocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gcmVzb2x2ZVBhdGhuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59O1xuXG5leHBvcnQgdmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmIHZhbHVlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0xvY2F0aW9uVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3Jlc29sdmVQYXRobmFtZSA9IHJlcXVpcmUoJ3Jlc29sdmUtcGF0aG5hbWUnKTtcblxudmFyIF9yZXNvbHZlUGF0aG5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVzb2x2ZVBhdGhuYW1lKTtcblxudmFyIF92YWx1ZUVxdWFsID0gcmVxdWlyZSgndmFsdWUtZXF1YWwnKTtcblxudmFyIF92YWx1ZUVxdWFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbHVlRXF1YWwpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGV4cG9ydHMuY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIGxvY2F0aW9uID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gVHdvLWFyZyBmb3JtOiBwdXNoKHBhdGgsIHN0YXRlKVxuICAgIGxvY2F0aW9uID0gKDAsIF9QYXRoVXRpbHMucGFyc2VQYXRoKShwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSAoMCwgX3Jlc29sdmVQYXRobmFtZTIuZGVmYXVsdCkobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn07XG5cbnZhciBsb2NhdGlvbnNBcmVFcXVhbCA9IGV4cG9ydHMubG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgKDAsIF92YWx1ZUVxdWFsMi5kZWZhdWx0KShhLnN0YXRlLCBiLnN0YXRlKTtcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvTG9jYXRpb25VdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIHZhciBzZXRQcm9tcHQgPSBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpO1xuXG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgYXBwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUm91dGVyIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHB1dHRpbmcgaGlzdG9yeSBvbiBjb250ZXh0LlxuICovXG5cbnZhciBSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLnN0YXRlID0ge1xuICAgICAgbWF0Y2g6IF90aGlzLmNvbXB1dGVNYXRjaChfdGhpcy5wcm9wcy5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lKVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgUm91dGVyLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjogX2V4dGVuZHMoe30sIHRoaXMuY29udGV4dC5yb3V0ZXIsIHtcbiAgICAgICAgaGlzdG9yeTogdGhpcy5wcm9wcy5oaXN0b3J5LFxuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLnByb3BzLmhpc3RvcnkubG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2g6IHRoaXMuc3RhdGUubWF0Y2hcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcHV0ZU1hdGNoID0gZnVuY3Rpb24gY29tcHV0ZU1hdGNoKHBhdGhuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6ICcvJyxcbiAgICAgIHVybDogJy8nLFxuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIGlzRXhhY3Q6IHBhdGhuYW1lID09PSAnLydcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuLFxuICAgICAgICBoaXN0b3J5ID0gX3Byb3BzLmhpc3Rvcnk7XG5cblxuICAgIGludmFyaWFudChjaGlsZHJlbiA9PSBudWxsIHx8IFJlYWN0LkNoaWxkcmVuLmNvdW50KGNoaWxkcmVuKSA9PT0gMSwgJ0EgPFJvdXRlcj4gbWF5IGhhdmUgb25seSBvbmUgY2hpbGQgZWxlbWVudCcpO1xuXG4gICAgLy8gRG8gdGhpcyBoZXJlIHNvIHdlIGNhbiBzZXRTdGF0ZSB3aGVuIGEgPFJlZGlyZWN0PiBjaGFuZ2VzIHRoZVxuICAgIC8vIGxvY2F0aW9uIGluIGNvbXBvbmVudFdpbGxNb3VudC4gVGhpcyBoYXBwZW5zIGUuZy4gd2hlbiBkb2luZ1xuICAgIC8vIHNlcnZlciByZW5kZXJpbmcgdXNpbmcgYSA8U3RhdGljUm91dGVyPi5cbiAgICB0aGlzLnVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgbWF0Y2g6IF90aGlzMi5jb21wdXRlTWF0Y2goaGlzdG9yeS5sb2NhdGlvbi5wYXRobmFtZSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyh0aGlzLnByb3BzLmhpc3RvcnkgPT09IG5leHRQcm9wcy5oaXN0b3J5LCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciBoaXN0b3J5PicpO1xuICB9O1xuXG4gIFJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVubGlzdGVuKCk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcblxuICAgIHJldHVybiBjaGlsZHJlbiA/IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Sb3V0ZXIucHJvcFR5cGVzID0ge1xuICBoaXN0b3J5OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufTtcblJvdXRlci5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdFxufTtcblJvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgcGF0aFRvUmVnZXhwIGZyb20gJ3BhdGgtdG8tcmVnZXhwJztcblxudmFyIHBhdHRlcm5DYWNoZSA9IHt9O1xudmFyIGNhY2hlTGltaXQgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50ID0gMDtcblxudmFyIGNvbXBpbGVQYXRoID0gZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgY2FjaGVLZXkgPSAnJyArIG9wdGlvbnMuZW5kICsgb3B0aW9ucy5zdHJpY3QgKyBvcHRpb25zLnNlbnNpdGl2ZTtcbiAgdmFyIGNhY2hlID0gcGF0dGVybkNhY2hlW2NhY2hlS2V5XSB8fCAocGF0dGVybkNhY2hlW2NhY2hlS2V5XSA9IHt9KTtcblxuICBpZiAoY2FjaGVbcGF0dGVybl0pIHJldHVybiBjYWNoZVtwYXR0ZXJuXTtcblxuICB2YXIga2V5cyA9IFtdO1xuICB2YXIgcmUgPSBwYXRoVG9SZWdleHAocGF0dGVybiwga2V5cywgb3B0aW9ucyk7XG4gIHZhciBjb21waWxlZFBhdHRlcm4gPSB7IHJlOiByZSwga2V5czoga2V5cyB9O1xuXG4gIGlmIChjYWNoZUNvdW50IDwgY2FjaGVMaW1pdCkge1xuICAgIGNhY2hlW3BhdHRlcm5dID0gY29tcGlsZWRQYXR0ZXJuO1xuICAgIGNhY2hlQ291bnQrKztcbiAgfVxuXG4gIHJldHVybiBjb21waWxlZFBhdHRlcm47XG59O1xuXG4vKipcbiAqIFB1YmxpYyBBUEkgZm9yIG1hdGNoaW5nIGEgVVJMIHBhdGhuYW1lIHRvIGEgcGF0aCBwYXR0ZXJuLlxuICovXG52YXIgbWF0Y2hQYXRoID0gZnVuY3Rpb24gbWF0Y2hQYXRoKHBhdGhuYW1lKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSBvcHRpb25zID0geyBwYXRoOiBvcHRpb25zIH07XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBhdGggPSBfb3B0aW9ucy5wYXRoLFxuICAgICAgcGF0aCA9IF9vcHRpb25zJHBhdGggPT09IHVuZGVmaW5lZCA/ICcvJyA6IF9vcHRpb25zJHBhdGgsXG4gICAgICBfb3B0aW9ucyRleGFjdCA9IF9vcHRpb25zLmV4YWN0LFxuICAgICAgZXhhY3QgPSBfb3B0aW9ucyRleGFjdCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyRleGFjdCxcbiAgICAgIF9vcHRpb25zJHN0cmljdCA9IF9vcHRpb25zLnN0cmljdCxcbiAgICAgIHN0cmljdCA9IF9vcHRpb25zJHN0cmljdCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfb3B0aW9ucyRzdHJpY3QsXG4gICAgICBfb3B0aW9ucyRzZW5zaXRpdmUgPSBfb3B0aW9ucy5zZW5zaXRpdmUsXG4gICAgICBzZW5zaXRpdmUgPSBfb3B0aW9ucyRzZW5zaXRpdmUgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkc2Vuc2l0aXZlO1xuXG4gIHZhciBfY29tcGlsZVBhdGggPSBjb21waWxlUGF0aChwYXRoLCB7IGVuZDogZXhhY3QsIHN0cmljdDogc3RyaWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9KSxcbiAgICAgIHJlID0gX2NvbXBpbGVQYXRoLnJlLFxuICAgICAga2V5cyA9IF9jb21waWxlUGF0aC5rZXlzO1xuXG4gIHZhciBtYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUpO1xuXG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIHZhciB1cmwgPSBtYXRjaFswXSxcbiAgICAgIHZhbHVlcyA9IG1hdGNoLnNsaWNlKDEpO1xuXG4gIHZhciBpc0V4YWN0ID0gcGF0aG5hbWUgPT09IHVybDtcblxuICBpZiAoZXhhY3QgJiYgIWlzRXhhY3QpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCwgLy8gdGhlIHBhdGggcGF0dGVybiB1c2VkIHRvIG1hdGNoXG4gICAgdXJsOiBwYXRoID09PSAnLycgJiYgdXJsID09PSAnJyA/ICcvJyA6IHVybCwgLy8gdGhlIG1hdGNoZWQgcG9ydGlvbiBvZiB0aGUgVVJMXG4gICAgaXNFeGFjdDogaXNFeGFjdCwgLy8gd2hldGhlciBvciBub3Qgd2UgbWF0Y2hlZCBleGFjdGx5XG4gICAgcGFyYW1zOiBrZXlzLnJlZHVjZShmdW5jdGlvbiAobWVtbywga2V5LCBpbmRleCkge1xuICAgICAgbWVtb1trZXkubmFtZV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBtYXRjaFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGguanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuXG52YXIgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgdmFyIHNldFByb21wdCA9IGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgd2FybmluZyhwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJyk7XG5cbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIHZhciBhcHBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uIGNhcHR1cmUodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHQoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xuXG4vKipcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXG4gKiBub3Qgc2FmZSB0byBjYWxsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaWYgdGhlcmUgaXMgbm90aGluZyBmb2N1c2VkLlxuICpcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxuICogeWV0IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHs/RE9NRG9jdW1lbnR9IGRvYyBEZWZhdWx0cyB0byBjdXJyZW50IGRvY3VtZW50LlxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jKSAvKj9ET01FbGVtZW50Ki97XG4gIGRvYyA9IGRvYyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBY3RpdmVFbGVtZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aG5hbWUpIHtcbiAgcmV0dXJuIHBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKClcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpIHtcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgfVxuXG4gIGxpc3QucG9wKCk7XG59XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgaGVhdmlseSBvbiBub2RlJ3MgdXJsLnBhcnNlXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUodG8pIHtcbiAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuXG4gIHZhciB0b1BhcnRzID0gdG8gJiYgdG8uc3BsaXQoJy8nKSB8fCBbXTtcbiAgdmFyIGZyb21QYXJ0cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLycpIHx8IFtdO1xuXG4gIHZhciBpc1RvQWJzID0gdG8gJiYgaXNBYnNvbHV0ZSh0byk7XG4gIHZhciBpc0Zyb21BYnMgPSBmcm9tICYmIGlzQWJzb2x1dGUoZnJvbSk7XG4gIHZhciBtdXN0RW5kQWJzID0gaXNUb0FicyB8fCBpc0Zyb21BYnM7XG5cbiAgaWYgKHRvICYmIGlzQWJzb2x1dGUodG8pKSB7XG4gICAgLy8gdG8gaXMgYWJzb2x1dGVcbiAgICBmcm9tUGFydHMgPSB0b1BhcnRzO1xuICB9IGVsc2UgaWYgKHRvUGFydHMubGVuZ3RoKSB7XG4gICAgLy8gdG8gaXMgcmVsYXRpdmUsIGRyb3AgdGhlIGZpbGVuYW1lXG4gICAgZnJvbVBhcnRzLnBvcCgpO1xuICAgIGZyb21QYXJ0cyA9IGZyb21QYXJ0cy5jb25jYXQodG9QYXJ0cyk7XG4gIH1cblxuICBpZiAoIWZyb21QYXJ0cy5sZW5ndGgpIHJldHVybiAnLyc7XG5cbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSB2b2lkIDA7XG4gIGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG4gICAgdmFyIGxhc3QgPSBmcm9tUGFydHNbZnJvbVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJyB8fCBsYXN0ID09PSAnJztcbiAgfSBlbHNlIHtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gIH1cblxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gZnJvbVBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IGZyb21QYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW11c3RFbmRBYnMpIGZvciAoOyB1cC0tOyB1cCkge1xuICAgIGZyb21QYXJ0cy51bnNoaWZ0KCcuLicpO1xuICB9aWYgKG11c3RFbmRBYnMgJiYgZnJvbVBhcnRzWzBdICE9PSAnJyAmJiAoIWZyb21QYXJ0c1swXSB8fCAhaXNBYnNvbHV0ZShmcm9tUGFydHNbMF0pKSkgZnJvbVBhcnRzLnVuc2hpZnQoJycpO1xuXG4gIHZhciByZXN1bHQgPSBmcm9tUGFydHMuam9pbignLycpO1xuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIHJlc3VsdC5zdWJzdHIoLTEpICE9PSAnLycpIHJlc3VsdCArPSAnLyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVzb2x2ZVBhdGhuYW1lO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZXNvbHZlLXBhdGhuYW1lL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIHZhbHVlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGFUeXBlID0gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpO1xuICB2YXIgYlR5cGUgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYVZhbHVlID0gYS52YWx1ZU9mKCk7XG4gICAgdmFyIGJWYWx1ZSA9IGIudmFsdWVPZigpO1xuXG4gICAgaWYgKGFWYWx1ZSAhPT0gYSB8fCBiVmFsdWUgIT09IGIpIHJldHVybiB2YWx1ZUVxdWFsKGFWYWx1ZSwgYlZhbHVlKTtcblxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZUVxdWFsO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGNhblVzZURPTSA9IGV4cG9ydHMuY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBleHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG52YXIgZ2V0Q29uZmlybWF0aW9uID0gZXhwb3J0cy5nZXRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xudmFyIHN1cHBvcnRzSGlzdG9yeSA9IGV4cG9ydHMuc3VwcG9ydHNIaXN0b3J5ID0gZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBicm93c2VyIGZpcmVzIHBvcHN0YXRlIG9uIGhhc2ggY2hhbmdlLlxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXG4gKi9cbnZhciBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZXhwb3J0cy5zdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xudmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZXhwb3J0cy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xudmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBleHBvcnRzLmlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5cbnZhciBpc01vZGlmaWVkRXZlbnQgPSBmdW5jdGlvbiBpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICEhKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQuc2hpZnRLZXkpO1xufTtcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcmVuZGVyaW5nIGEgaGlzdG9yeS1hd2FyZSA8YT4uXG4gKi9cblxudmFyIExpbmsgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTGluaywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTGluaygpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmspO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMub25DbGljaykgX3RoaXMucHJvcHMub25DbGljayhldmVudCk7XG5cbiAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCAmJiAvLyBvbkNsaWNrIHByZXZlbnRlZCBkZWZhdWx0XG4gICAgICBldmVudC5idXR0b24gPT09IDAgJiYgLy8gaWdub3JlIHJpZ2h0IGNsaWNrc1xuICAgICAgIV90aGlzLnByb3BzLnRhcmdldCAmJiAvLyBsZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAgICAgIWlzTW9kaWZpZWRFdmVudChldmVudCkgLy8gaWdub3JlIGNsaWNrcyB3aXRoIG1vZGlmaWVyIGtleXNcbiAgICAgICkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICB2YXIgaGlzdG9yeSA9IF90aGlzLmNvbnRleHQucm91dGVyLmhpc3Rvcnk7XG4gICAgICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgICAgIHJlcGxhY2UgPSBfdGhpcyRwcm9wcy5yZXBsYWNlLFxuICAgICAgICAgICAgICB0byA9IF90aGlzJHByb3BzLnRvO1xuXG5cbiAgICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlKHRvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlzdG9yeS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIExpbmsucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcmVwbGFjZSA9IF9wcm9wcy5yZXBsYWNlLFxuICAgICAgICB0byA9IF9wcm9wcy50byxcbiAgICAgICAgaW5uZXJSZWYgPSBfcHJvcHMuaW5uZXJSZWYsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydyZXBsYWNlJywgJ3RvJywgJ2lubmVyUmVmJ10pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICBpbnZhcmlhbnQodGhpcy5jb250ZXh0LnJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8TGluaz4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG5cbiAgICB2YXIgaHJlZiA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeS5jcmVhdGVIcmVmKHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB7IHBhdGhuYW1lOiB0byB9IDogdG8pO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2EnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgb25DbGljazogdGhpcy5oYW5kbGVDbGljaywgaHJlZjogaHJlZiwgcmVmOiBpbm5lclJlZiB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIExpbms7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkxpbmsucHJvcFR5cGVzID0ge1xuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgdGFyZ2V0OiBQcm9wVHlwZXMuc3RyaW5nLFxuICByZXBsYWNlOiBQcm9wVHlwZXMuYm9vbCxcbiAgdG86IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICBpbm5lclJlZjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKVxufTtcbkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICByZXBsYWNlOiBmYWxzZVxufTtcbkxpbmsuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHB1c2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByZXBsYWNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgY3JlYXRlSHJlZjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBMaW5rO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUm91dGUgZnJvbSAncmVhY3Qtcm91dGVyL2VzL1JvdXRlJztcblxuZXhwb3J0IGRlZmF1bHQgUm91dGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGUuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuXG52YXIgaXNFbXB0eUNoaWxkcmVuID0gZnVuY3Rpb24gaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHJldHVybiBSZWFjdC5DaGlsZHJlbi5jb3VudChjaGlsZHJlbikgPT09IDA7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIHNpbmdsZSBwYXRoIGFuZCByZW5kZXJpbmcuXG4gKi9cblxudmFyIFJvdXRlID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFJvdXRlLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBSb3V0ZSgpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIG1hdGNoOiBfdGhpcy5jb21wdXRlTWF0Y2goX3RoaXMucHJvcHMsIF90aGlzLmNvbnRleHQucm91dGVyKVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgUm91dGUucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiBfZXh0ZW5kcyh7fSwgdGhpcy5jb250ZXh0LnJvdXRlciwge1xuICAgICAgICByb3V0ZToge1xuICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHRoaXMuY29udGV4dC5yb3V0ZXIucm91dGUubG9jYXRpb24sXG4gICAgICAgICAgbWF0Y2g6IHRoaXMuc3RhdGUubWF0Y2hcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wdXRlTWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlTWF0Y2goX3JlZiwgcm91dGVyKSB7XG4gICAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgICAgcGF0aCA9IF9yZWYucGF0aCxcbiAgICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICAgIGV4YWN0ID0gX3JlZi5leGFjdCxcbiAgICAgICAgc2Vuc2l0aXZlID0gX3JlZi5zZW5zaXRpdmU7XG5cbiAgICBpZiAoY29tcHV0ZWRNYXRjaCkgcmV0dXJuIGNvbXB1dGVkTWF0Y2g7IC8vIDxTd2l0Y2g+IGFscmVhZHkgY29tcHV0ZWQgdGhlIG1hdGNoIGZvciB1c1xuXG4gICAgaW52YXJpYW50KHJvdXRlciwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGU+IG9yIHdpdGhSb3V0ZXIoKSBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIHZhciByb3V0ZSA9IHJvdXRlci5yb3V0ZTtcblxuICAgIHZhciBwYXRobmFtZSA9IChsb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbikucGF0aG5hbWU7XG5cbiAgICByZXR1cm4gcGF0aCA/IG1hdGNoUGF0aChwYXRobmFtZSwgeyBwYXRoOiBwYXRoLCBzdHJpY3Q6IHN0cmljdCwgZXhhY3Q6IGV4YWN0LCBzZW5zaXRpdmU6IHNlbnNpdGl2ZSB9KSA6IHJvdXRlLm1hdGNoO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMucmVuZGVyKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgY29tcG9uZW50PiBhbmQgPFJvdXRlIHJlbmRlcj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSByZW5kZXI+IHdpbGwgYmUgaWdub3JlZCcpO1xuXG4gICAgd2FybmluZyghKHRoaXMucHJvcHMuY29tcG9uZW50ICYmIHRoaXMucHJvcHMuY2hpbGRyZW4gJiYgIWlzRW1wdHlDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuKSksICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkJyk7XG5cbiAgICB3YXJuaW5nKCEodGhpcy5wcm9wcy5yZW5kZXIgJiYgdGhpcy5wcm9wcy5jaGlsZHJlbiAmJiAhaXNFbXB0eUNoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4pKSwgJ1lvdSBzaG91bGQgbm90IHVzZSA8Um91dGUgcmVuZGVyPiBhbmQgPFJvdXRlIGNoaWxkcmVuPiBpbiB0aGUgc2FtZSByb3V0ZTsgPFJvdXRlIGNoaWxkcmVuPiB3aWxsIGJlIGlnbm9yZWQnKTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgIHdhcm5pbmcoIShuZXh0UHJvcHMubG9jYXRpb24gJiYgIXRoaXMucHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8Um91dGU+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgbWF0Y2g6IHRoaXMuY29tcHV0ZU1hdGNoKG5leHRQcm9wcywgbmV4dENvbnRleHQucm91dGVyKVxuICAgIH0pO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIG1hdGNoID0gdGhpcy5zdGF0ZS5tYXRjaDtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudCA9IF9wcm9wcy5jb21wb25lbnQsXG4gICAgICAgIHJlbmRlciA9IF9wcm9wcy5yZW5kZXI7XG4gICAgdmFyIF9jb250ZXh0JHJvdXRlciA9IHRoaXMuY29udGV4dC5yb3V0ZXIsXG4gICAgICAgIGhpc3RvcnkgPSBfY29udGV4dCRyb3V0ZXIuaGlzdG9yeSxcbiAgICAgICAgcm91dGUgPSBfY29udGV4dCRyb3V0ZXIucm91dGUsXG4gICAgICAgIHN0YXRpY0NvbnRleHQgPSBfY29udGV4dCRyb3V0ZXIuc3RhdGljQ29udGV4dDtcblxuICAgIHZhciBsb2NhdGlvbiA9IHRoaXMucHJvcHMubG9jYXRpb24gfHwgcm91dGUubG9jYXRpb247XG4gICAgdmFyIHByb3BzID0geyBtYXRjaDogbWF0Y2gsIGxvY2F0aW9uOiBsb2NhdGlvbiwgaGlzdG9yeTogaGlzdG9yeSwgc3RhdGljQ29udGV4dDogc3RhdGljQ29udGV4dCB9O1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudCA/IC8vIGNvbXBvbmVudCBwcm9wIGdldHMgZmlyc3QgcHJpb3JpdHksIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gUmVhY3QuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSA6IG51bGwgOiByZW5kZXIgPyAvLyByZW5kZXIgcHJvcCBpcyBuZXh0LCBvbmx5IGNhbGxlZCBpZiB0aGVyZSdzIGEgbWF0Y2hcbiAgICBtYXRjaCA/IHJlbmRlcihwcm9wcykgOiBudWxsIDogY2hpbGRyZW4gPyAvLyBjaGlsZHJlbiBjb21lIGxhc3QsIGFsd2F5cyBjYWxsZWRcbiAgICB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihwcm9wcykgOiAhaXNFbXB0eUNoaWxkcmVuKGNoaWxkcmVuKSA/IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogbnVsbCA6IG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJvdXRlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Sb3V0ZS5wcm9wVHlwZXMgPSB7XG4gIGNvbXB1dGVkTWF0Y2g6IFByb3BUeXBlcy5vYmplY3QsIC8vIHByaXZhdGUsIGZyb20gPFN3aXRjaD5cbiAgcGF0aDogUHJvcFR5cGVzLnN0cmluZyxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzZW5zaXRpdmU6IFByb3BUeXBlcy5ib29sLFxuICBjb21wb25lbnQ6IFByb3BUeXBlcy5mdW5jLFxuICByZW5kZXI6IFByb3BUeXBlcy5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5ub2RlXSksXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGUuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9KVxufTtcblJvdXRlLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgdmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbmV4cG9ydCB2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLmFkZEV2ZW50TGlzdGVuZXIgPyBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciByZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA/IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG5leHBvcnQgdmFyIGdldENvbmZpcm1hdGlvbiA9IGZ1bmN0aW9uIGdldENvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICByZXR1cm4gY2FsbGJhY2sod2luZG93LmNvbmZpcm0obWVzc2FnZSkpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgaXMgc3VwcG9ydGVkLiBUYWtlbiBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvaGlzdG9yeS5qc1xuICogY2hhbmdlZCB0byBhdm9pZCBmYWxzZSBuZWdhdGl2ZXMgZm9yIFdpbmRvd3MgUGhvbmVzOiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzSGlzdG9yeSA9IGZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBmYWxzZSBpZiB1c2luZyBnbyhuKSB3aXRoIGhhc2ggaGlzdG9yeSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkLlxuICovXG5leHBvcnQgdmFyIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoID0gZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBwb3BzdGF0ZSBldmVudCBpcyBhbiBleHRyYW5lb3VzIFdlYktpdCBldmVudC5cbiAqIEFjY291bnRzIGZvciB0aGUgZmFjdCB0aGF0IENocm9tZSBvbiBpT1MgZmlyZXMgcmVhbCBwb3BzdGF0ZSBldmVudHNcbiAqIGNvbnRhaW5pbmcgdW5kZWZpbmVkIHN0YXRlIHdoZW4gcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlxuICovXG5leHBvcnQgdmFyIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQgPSBmdW5jdGlvbiBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5zdGF0ZSA9PT0gdW5kZWZpbmVkICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTE7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNFFBa1JYaHBaZ0FBU1VrcUFBZ0FBQUFCQUppQ0FnQUFBQUFBQUFBQUFBQUFBQUFBQVAvc0FCRkVkV05yZVFBQkFBUUFBQUE4QUFELzRRT1hhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMd0E4UDNod1lXTnJaWFFnWW1WbmFXNDlJdSs3dnlJZ2FXUTlJbGMxVFRCTmNFTmxhR2xJZW5KbFUzcE9WR042YTJNNVpDSS9QaUE4ZURwNGJYQnRaWFJoSUhodGJHNXpPbmc5SW1Ga2IySmxPbTV6T20xbGRHRXZJaUI0T25odGNIUnJQU0pCWkc5aVpTQllUVkFnUTI5eVpTQTFMak10WXpBeE1TQTJOaTR4TkRVMk5qRXNJREl3TVRJdk1ESXZNRFl0TVRRNk5UWTZNamNnSUNBZ0lDQWdJQ0krSUR4eVpHWTZVa1JHSUhodGJHNXpPbkprWmowaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1UazVPUzh3TWk4eU1pMXlaR1l0YzNsdWRHRjRMVzV6SXlJK0lEeHlaR1k2UkdWelkzSnBjSFJwYjI0Z2NtUm1PbUZpYjNWMFBTSWlJSGh0Ykc1ek9uaHRjRTFOUFNKb2RIUndPaTh2Ym5NdVlXUnZZbVV1WTI5dEwzaGhjQzh4TGpBdmJXMHZJaUI0Yld4dWN6cHpkRkpsWmowaWFIUjBjRG92TDI1ekxtRmtiMkpsTG1OdmJTOTRZWEF2TVM0d0wzTlVlWEJsTDFKbGMyOTFjbU5sVW1WbUl5SWdlRzFzYm5NNmVHMXdQU0pvZEhSd09pOHZibk11WVdSdlltVXVZMjl0TDNoaGNDOHhMakF2SWlCNGJXeHVjenBrWXowaWFIUjBjRG92TDNCMWNtd3ViM0puTDJSakwyVnNaVzFsYm5Sekx6RXVNUzhpSUhodGNFMU5Pa1J2WTNWdFpXNTBTVVE5SW5odGNDNWthV1E2TVRjM1FqSTBPREZHTnpjM01URkZOemsxUlRoRE9UVkRSVE5DUlVKRFFqRWlJSGh0Y0UxTk9rbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZNVGMzUWpJME9EQkdOemMzTVRGRk56azFSVGhET1RWRFJUTkNSVUpEUWpFaUlIaHRjRHBEY21WaGRHOXlWRzl2YkQwaVJIaFBJRTl3ZEdsamN5QlFjbThnT0NJK0lEeDRiWEJOVFRwRVpYSnBkbVZrUm5KdmJTQnpkRkpsWmpwcGJuTjBZVzVqWlVsRVBTSTVPRGhFTVRBeE1VVTFNMFUyUlVZMk5qaEZSRGN3T1VaQ01URXlPREJGUVNJZ2MzUlNaV1k2Wkc5amRXMWxiblJKUkQwaU9UZzRSREV3TVRGRk5UTkZOa1ZHTmpZNFJVUTNNRGxHUWpFeE1qZ3dSVUVpTHo0Z1BHUmpPblJwZEd4bFBpQThjbVJtT2tGc2RENGdQSEprWmpwc2FTQjRiV3c2YkdGdVp6MGllQzFrWldaaGRXeDBJajVUYm05M1pteGhhMlZ6UEM5eVpHWTZiR2srSUR3dmNtUm1Pa0ZzZEQ0Z1BDOWtZenAwYVhSc1pUNGdQQzl5WkdZNlJHVnpZM0pwY0hScGIyNCtJRHd2Y21SbU9sSkVSajRnUEM5NE9uaHRjRzFsZEdFK0lEdy9lSEJoWTJ0bGRDQmxibVE5SW5JaVB6Ny83UUJJVUdodmRHOXphRzl3SURNdU1BQTRRa2xOQkFRQUFBQUFBQThjQVZvQUF4c2xSeHdDQUFBQ0FBSUFPRUpKVFFRbEFBQUFBQUFRL09FZmljaTN5WGd2TkdJMEIxaDM2Ly91QUE1QlpHOWlaUUJrd0FBQUFBSC8yd0NFQUFZRUJBUUZCQVlGQlFZSkJnVUdDUXNJQmdZSUN3d0tDZ3NLQ2d3UURBd01EQXdNRUF3T0R4QVBEZ3dURXhRVUV4TWNHeHNiSEI4Zkh4OGZIeDhmSHg4QkJ3Y0hEUXdOR0JBUUdCb1ZFUlVhSHg4Zkh4OGZIeDhmSHg4Zkh4OGZIeDhmSHg4Zkh4OGZIeDhmSHg4Zkh4OGZIeDhmSHg4Zkh4OGZIeDhmSHg4ZkgvL0FBQkVJQTZZRmVBTUJFUUFDRVFFREVRSC94QUNRQUFBQ0F3RUJBUUFBQUFBQUFBQUFBQUFBQVFJREJBVUdCd0VCQVFFQkFRQUFBQUFBQUFBQUFBQUFBQUVDQXdRUUFBSUJBd01DQkFRRkFnVUVBZ0FDQ3dFQ0F3QVJCQ0V4RWtGUllTSVRCWEdCTWhTUm9iRkNJOEZTOE5IaFlnYnhNeVFWY29KRGtxSlROQ1d5d3RKakZuTkVFUUVCQVFBREFRQURBUUFBQUFBQUFBQUFBUkVoTVVFQ1VXRVNjZi9hQUF3REFRQUNFUU1SQUQ4QStwa0RwWGQ1Qy9kb0xVUUMxeUQrRkF5Ty93Q3RGRnowL0tpSGNYSDYwQ0hVZktnZHdEWWIwVXIvQUk5YUlZSklIZnFLQUo2ZEtBRnRMNzk2QmtuV3cyMStkQUVEVFRXZ0wvdG9IZXgyMzAvd2FBNjdiMENJK0grdEJJNm0rd0d1bEF2aHFSdFFQYy9IclJRVHNQbDhLSWR0VHZidlFIaFFGOVRZWHQwTkF6cDRVVTlMWDAwb0RiWFkvd0NkQTliR2dDUmJYOFJSRDhPMUZJTGJTaUhxQnA4S0ExdWJmS2drYmZMclJTRzRzTjZCbTFBdXUvem9IWVhOQXh2dFlIdlFGeDBvQWpyMTJ0UUEyc05xSUFmOGRxS2VsOXFCZ0wxb0dSb2Z6NjNvRVIwQnRhZ0NCMDJGQURlLzRHZ1pvQzNTZ1ZqMm9EVFUwRHQ0MEV0UGhRSURUK3RBemJhMmxBQ2dZK0cyOUFyYS93Q05xQmtEdDhLQU50aHVhQmNSZjlEMW9HQUNOYUNRMy9yUUdtOWhlZ1EvQ2dMTGI4cUFzdHZoUUdnL3hhZ2RqYnAvcFFBQTF0c2FBT3Q3OU42QjJHM2VnWCtMVUFMZDZCaTM0MEFWSHgxdHBRQUMwQnBlOWhicFFMVDVkNkJqcHB2MG9DdzZVQjEwMjYwQUF0QUFBZjBvR2JYNzBDNldvSGNhV29DOStsQUFmUHZRR21vR210QXlvNzBDdHNScU52Q2dZQTdhMENzTzFBRUFnRzJ3b0EydHAwL1NnQU5kVFFIVDQwRE50ZEwwQ3Ywb0M0N1h2MW9DL3dDSHdvRHkvUDhBS2dRR3RnUGhRUFEyOEQxb0hwYlRRVUNBR3Y1VUIrNisvZWdMRGFnUUdsaFFIeitONkFzTk5hQVA1VUFCWW1nUVViMm9INDYrSm9ENGJpZ1hmU2dRc08veDhLQm5ld29Ba1VCb0NmSFNnWjI4YUFzS0JFZE90QUgvQUFmR2dWdFNldldnZDlOdEtBMkdsQWhhK3UzalFHbTIxQXREdi9wUUdtLzUwQm9kZndvQzkvZ2FCV0czV2dPdXVuYWdEcHJRSUFYc2I2VUR2MkdsQWdCdjE3ZHFBSGoxMm9HYi9ocFFLMjlBOUxhMEVUdHYvd0JLQU9wMEcvNlVCYzlCcUtBdWFBRi9HOUFIcCtZb0k3K0hoUUcraCtkQTliNmRlbEFXdnRjZjFvRUFQbDJvQytuaFFERUNnTkw2SDUwRXIzRzJ2alFSRjlkaFFBSXRZYmJHZ0w5dHR0UDYwQWZ6SFNnVzRvSGY1QTBDdmVnZW5hMUFDNDMwSDQwREp0K3VsUUluUUhUVGMrRlVGL0Q0bWd3bTQrWGVnQUtJVnplL1h4b0pmTDRWUUU2OXZDb0FudDhqUVIrRkF3YjYzSjA2YVZReWRMVzFCMy9yUU1pMytOcUFPOXFBMVB4cUJDL2V4L1NxSDFzTitncUJqcDIyTkFBaSttMzUwQmZRbTNqUU80dWFCbmZlZ0wrRkE3ai9BRW9FVHFlOUF3UngwNjBCYy82MEFOU1B5b0dUWWkxamZZVVVYOE50cUlCZnNQOEFXaW5mVTZVUTc5K3AyNzBDQnNQMW9wbmF3Mm9oZ2FrNjI2MEIwMDNQU2dDZGRxS0xBYjdEODZCMjA4YUJHNHRjK05FU1JoYS8rdEZCNzBRLzhlTjZLTmh1YUFIdzhMMER0M0ZBdnlvSFkyb0hzZGZ4b0VkdjYwRHVTTC9pYUF2L0FKVUJhMzZVRHNPbS9XOUF6MXQrUGpRUlB3b0h0NGRxQjZqVGVnUGxwMHRRRnpiNS9sUVA0ZGFCNjN1YUI5TEVhMEM2MjN0dFFIWUEzN24rbEFhMytPdEFyaldnWU5BK20ydEFyNmJmS2dlbHUxcUJiNkRwUVNGNkJkYUI3LzYwREJIVFNnRDhkZWxCSHI4TmFCMnZwdlFNSFEzMHZRSTZqU2dkeitOQUE2MjNOQUhmc090QXgzdFFHKzlBZjQrVkFmOEFRMENQalFQcGVnWFMxQTc5L3dBYUF2Y2FkYUFKTzM1MEFiYjJvRnl2Zlc0N1VESDVmbFFNZm5RTHIzTkFXN1VBVHBmWWQ2QTVXRkFENDlLQXQxTzlBZUZBSHFLQXZyOGRxQS9LeDA2MER2M29Gb045UjJvRFlhNkNnQUxmNDYwQjhhQU56YTIzOWFCZGh0Mm9BbnB1UlFIWVVEM0ZBckFIWFUwQjBvQW1nWXRiWFVkS0F0UVJQWFhVVUM2RGNkdkNnTmRlOUFhbTNqUUZyMnRRTzVIeG9DMmw2QUowdjJvRVNSNFgvR2dDYi9PZ0NUdDBvRUwzK0ZBY1RwK0ZBWDA4ZkNnTGk0b0FDM3hvRHVUL0FJTkFqZS9oUUxYWHczb0dSNFVBTlFUUUIvUTBDUGhwM0ZBN0d3NmY1MEM4ZHFCR3dIK05hQUI2QStBTkF5Zmg0VUViMjAzb0FHNXZiYitsQTcvNTNvRHgvV2dEMjY5YUJhQys5QUVFNmlnV3Z6NjBCL2cwQjhOcUIyR3RBamNqeE8xQUFkaDg2QXYzUCtPMUFYMkIrWm9DKzFxQTIwdnRRS3h0cnFhQXNiZGpRSFMrNTJvRituU2drTGJEVC9LZ1Y3a2pYNG1nbDB1ZXY2MEVkejNvSGNML0FKVUdFMnVOdDlxQnJwdDhiMFFybnA4NkE2MjZVQnA4NkFOKzl4VkN2cnAzcUNRT3ZoMG9BVzJvQWo4YUFOL3l2NFZRQ3hBL09nWTYvcFFIVWpiVDhxZ1l0cGJwUUE3YjIwcWhEYjg5NmdtTmRlL1dnUk45aHQwb0hjN0FYb29CdCtHdDZCWDFvaVZqZlUyMG9FTktDWFhhNTc5cUJXdDA2VUQzMjY3L0FCb0VDTkJiNVVEK2Z5b3A2L09pQWZDaW1Sb0xmaFJEMS9LZ0xEZWdOamI4S0ExdjJORkcydldpSmFkUDlLQjZDNEF0UlM2K0pvZ3RxYjYwVSsxcUlMYWFhRTlUUlFOOVBuUUE4Zm5RTVh0UUEvQWRxQStlbmVnWVBqODZBMTNOQWFYMCtkQVdQWHZ1YUNWeGJzZkdnUTAzMW9IYnJlZ0RxYlVEOERwUUZqdlFMUzROL0MxQXhyMXVSUU1qdFFBNkEvbFFCMi9PZ0J0UUZ0VFliVUFCcnBRTTJ2b2REUUh4M29Ic0Iyb0VCcDRVRDVFV29GZlg0MERHdlg0VUJmV2dDeHNiNkh4b0dkcjcwQmI4NkFPZzhPbEFYdlFLKzFBOUJRSTlyMEJ0YnVUUUhoMjcwRDExNmVOQXI2K05BLzhBQTYwQnFkZjBvQUhjRFNnZndvRnJZZHU5QUQ4eFFGdHp2UUZoZjlLQjN2OEExdFFIV3hJNDlCUUppTmQvR2dZSUk4S0E2Zk9nUlB6L0FNcUJycU52alFCQUh3b0FqVDQwQjFOL3pvQzQ2OWRLQTBKNjBBQ0RidlFLMnZlZ2V4MEd1MUF0NkFOQTc2ZGoxb0VEUU1uU2dqNXIvd0JhQmdtMzlLQVhiYTFBQTlkNkJBaWdMN2dVQVB6SFdnTjcwREZ2alFSTnR1OUFBRFkwQmJYc2FCK1BiU2dOYi9wUUkrRzlBOUxYNzBDdHJwUUZ2bVA2MEMzNmVOQUU5L3dvRFU2allEYWdSR21sQWQ2QjBDTy82MEFkdTE2QVlXUGVnUXVUOEtCMlB4QjMrRkFYL0xyUUYvRFdnUjY2VUIwL3JRTFh3b0hwL2xRUmJ0ZWdld3Qxb0FnRzl1bEFIcnJRSTJ2dGM5cUFKNjdXb0Fray9uUUx0UUE3Zm5RRndCYjhhQmRhQXNOQitGQSt1cCtkQWgxOGV0QUUrWVVBRzJIK05hQjJPdzNvRVQwM3RRTFhVNzlOYUFJRnZINDBCYlh3N1VEMHZjL0lVQVNOeitBb0hjNzJOQXR0NzloUUhUdUJRWXlSNDJvaUlCdmMwRHY4N2RLQU51aG9FTzkvbnRRTWR6UUlhMjZqNFZROXRSc2R6VUR2dmZXZ05OdCt2K0RRSTIvRDhMVUVnTDcwQjF2NGFDZ0xDMnY0VURCN2JkcUFCMEhRVUI0R2dCY2ZwUlR0K0lvaHNRUWIwQzdkclVEdG9POUE3MjY2ZnJRR24rbEFEUzFBQzQveDBvR0NiRzM0OWFBT3cvS2dkdFAwRkFEUTBWSzJuYzBRaWJVRDdmbWVsQWhjWEcrbEF6NEMzZWdDRHkrSTJvSHZ0K0ZGRzIrL1NpSmZqNDBVanNkUGxSQWJnblNpbWR0N0dnTCtCOFJRQjBPbjRVQjAwL0NpR1AxMW9vditGQUU3R2dMOURyUU94K2ZlZ2ZYdDRVQnQ0OXhRSHhvSGJTZ0NOS0JqWHJRSStPNG9BYjIyTkFkcUJqZlUvS2dmeDZkS0JFNjliMERBc05UUUFCOGRLQkh3M29IZTQrTkFFNmFDZ1k2QTBENzBDdFFBL09nZTQzMDcwQ3ZiNFVCdmFnT2h1YUFPL3dEblFQVWRhQmtVQ05BYmRhQmpUV2dDTG41WHRSUjAyMXR0UkJvUi9XZ1Z5UGw4NkE2MnQ4NkFVRy9md29HQmZiYTFBVzAvMG9ENEg1VUMwSTFGNkNWLzlLQld0b051MUEvQTdHZ1dodFFDalc5QUczUTcwREdvOFRRR3c4VDg2QlVEOGFBSjBvRlFHbnpvQVhQOWU5QUEyK0hXZ1BDZ1pJdlFJNzI2ZGJVQmZ2b2Vvb0dQMTZVQ1A0MEFDQlFIVHhvQVh2UUt3LzYwQnZwUU1ramVnVnhwK2RBRzE5dmpRQkErUW9HQmMzMjdVQnBiV2dSQXYrWW9FTGE5K2xBOUFkYUEwdGExQXI5cUJtMXRQalFMWGZwUUdueUZBZEtCQTY2N1VCYjRVRG9FZHJHM3dvRUIzb0diNmQvMG9GYXdQYzcwQUwzRng4cUF2WWJkYUEzR3RBTnRwUUkzT20zaWFBc1NkT3RBRWkxQXZIcDBGQUcvZlhwUUhLNC95b0VkTnR1bEF5ZHRQaFFJYUMvVzNTZ0RvTzF0YUFIY2RhQU91djRVQWRxQld1QmMzb0EzNkcvalFHbno2OXFCSFltKzNXZ0xqcFFJalg0ai9GcUJqL0hlZ0xhYmIwQU5DS0FmY0cvNFVBQ1A2VUFiWDE2VUN1UG5RUFRRSDQwQWV0dFJRSUFiVURBQTBPdzZVQU5maDBGQUhmWFlhaWd4SFE2MjBvZ0piVWRmQ3FJN2pRYStOQXoxL1dnZGhxRDBOQU1kZmowb0FiN2E5NkI3NzlOeFVDMXRmdFFHdXdQbW9IZi9BS21nTEFiRFNnZXVwMDIzb0VMZzN0Y2YxcWhqY1grRjZBMk9uNFZGTW4vV2lHTFdQZWdOYUIyMHQ0MEFSZjVkNktpQjBvaG0xemI4S0JqWDQ5S0JnN2Y5UlFGK3Q5ZkdnQnI0WC9wUU1iNmROcUtkOU50dHpSRHVmOGJVQ056L0FLVVVYMXZ2M29KTCtORUc1L1NpaTUydDgrdEFHMzRmclFPeEcyd29ENWEwRG9GOC9nYUFCdmY4NzBFdkdnUk50YUIrRy84QWplZ0J0cFFQVFhyMkZBdE5BUlFNYjk2QXNmaUtBdWJIcUtCZ2pmdFFCRzJ2V2dsYTVvQzVzYlVBTmUydEF1bHJVQU8zUWZPZ1kxMTJvR05EOGFBMDEvTzFBQWRMMEIzb0dOZXUxQVVCYjVuclFGQXhiYWdaMzMxb0YvaTFBRTYydDhLQTZmcUtBUDhBZzBBVGUxK29vRFc5QTdDL1lpZ0Q4QU9vb0Y0ZGVsQXdkUlFGd1JyOHpRQjMrTkFmUFNnTnY2VUIrbEF3YUF0K0FvQUR1S0E2ZjBvQUUyMTJ2dlFGejF1TDlxQmFnZlBhZ0wzK1czaFFQYnBRRjlyK1B5b0gxN1VDQnQvalNnTGdDMzUwQnJhOUF4YS9qMHZRTCt0QUcxKy9jZGFBMkhhZ0QvcmVnVjcrTkE3RGJ4b0FrM3ZRRjc5alFMY0FVRHViandvSFlmS2dQNlVDSkkvV2daMm9GK2xBci82VUQxNzN0UUxZVzM4S0EwdVQwTkErTjFKNmR6UUIzL3JRQk91NU5BajhkS0I2RDUwQzBBL3FhQTJPL1NnTEFDL3lOQWlSYitsQkxZV29JbmUvUWRhQXViM29HZHUxdnpvRjNPMm05QXYwMm9EUW5yYWdZK2RxQlcwNmE3MENON2ZIclFNSFFkanZRQTEyNzBBUnNOdTlBaHVlbEFXMTdrYmQ2QmFhZzZFN21nVmpRUGJTZ1IwSjZXMytkQXp0b05qUUJ2ZlE2ait0QkUzdHBiNGlnT2cxc1JRUFMzNTI4S0JhV0pQVHBRTUh0UUp0dHRLQlhPdDlyYTBERnVwRnFBR290dWRiMm9FZjhDZ1J2Zlg1MERCc2Q3ZFBHZ0xBaXhvRllmTHBRQUZybSs5QURmOEFVMEFiYmcyNlVDMEs3YS81VUFmRFQvS2dZdDFPMjFCSGxmYlUwRHRwWWFtZ050UlFGN214b0dMOWZ3b0ViMjFHdlFVQjBGdCtueW9EVzR2OHhRWXpZbS80VUMwRnphNEhTcWhjckhmWHBRUzZiVzIwSXFCWHVlNG9IcGEvNjcxUUFlR2x0RFVDTnR0cW9kckhVazlSVUJweXR2OEFIYWdBZW5ROWFDVGFqdDNxaEhhMTlLQjI2YTM4ZWxRR3Q3ZEtBMzA2blFVQU5xS2VvMjE4S0lDUnVlbEZTNmVCNlVRZE50S0JFQWJENDBERjlPM2MwQmF4T3h2cDJvR2RPbHJVQjF0ZlRyUlFUcjRmMG9KYkR0NDBCMjhLQTIyb0R3L0tpSGF3L1h0YWlpNHRwWTY2ZUZFR3d2NDcwVXdBZHRlL3dvRGVnZlMzem9BV29BYi9BQUhXaUhmdjFvcCtPNG9FZFAxb0RRNm5ZOWFCbjlhQS9PZ05nQmUvYWdlK3Y0VUFiNmo4S0F1ZmpRSUh3L0Nna0wyb0hRRzQrRkFYNGo4NkFBMzFvQW5RWG9IcUI4cUEyMUZBd2JlQTcwQUxkTzM1MERGQXJkL21LQjJKTkFhVUMrV3RBOWJmR2dOLzhiVUJjL0tnZjUwQ09sQVgvd0FlRkFYL0FOS0I5cUFVNjBCMThmR2dlbHY2VUMxSnQzNzBENjI2MERPM3hvRVJwdnZRRmgxb0RVVzdiR2dMMjBvRDQ3ZUFvR0xnWE5BWEc5QWZuNFVCZlMzYWdEYTIvaGVnVnR2RGVnQjRmbFFNZUJvQWswQmZhZ2RoYS80M29GcU5lbldnZGgvclFBMDAyN1VCdHR2UUkzMy9BRG9DKzUvU2dOL0c5QWVQVHVLQTc2VUMyK2RBWDFzUGhRTWFmQWFVREpIRUNnUnVWdDJvSHFQaHB2UUlYdnFEM29DLzVVQnBidDRmQ2dOTkwwQUxkTnVsQkVudnJRQUpvR1RwZmFnQitKNjBENjBCUUxZSHQwb0RlMzYwQ0kzdlFINVVBTnIvQUtVRFU5ZSsxQXJqNGZuUUFQbXRZQ2dMamZjazcwQjV2aWFLZlNpRmJmOEFHZ0IrRjZCRTdVQ05qcjhxQTA2SHkwRDAydHZyUUk3L0FJVUJxZkNnQ1NEOGV0QXRQblFHdGozb0EySTBGQVhOKzEvd29Dd3RmOGFCVytPdTNoUUI2YWY2MEI0bWdWamJYcjNvRDVXSU5BckhYWDUwRFBFVUMwNjZEYWdEYnFiZHFCWE90dTFBNzY2L09nWElFbS9TZ0FPcDYwRDZXTzlBcm00QU91NW9BK09tbHFCRWEvclFGeWREK0hoUUJGeGJmd29DM0hwYWdaT20yaG9GYldnTEMzVzNoUUlnSC9PZ2Q5NkF1ZHQ5YUEwdnArTkFiN0hVL09nQ0w5S0RGZlR2ZmFnUitQd3FvWk45S2dRT2c2MEQxNzYzb0MxdE91MVVGenRmV2dldC9odlFPNXRicFFJWHVMVytOQUcyMXIvQ2dkcmdmclFGajE2VkE3Z0xxZmpRSElYSUgrRFFBM3NLQjJ1S0FHL3hvb0lGRVN0ZlRROUtBMTdiVUJwYlRiL09nTmovQUZvSHJZRyt0QVcvR2dMRGZRbjlLS0JRTy9LZ0JvZHZuZWlHM2dQdzdVVXRoYzdDZ2x2UUdsdHFCYWJiZHZuUVNIaU5mR2lDNU9tL2Y0MFU3NkNnVjcwREZyY3R2SGVnZHJuWDQzb0ZidDg2Qm4vRnFCbmF3NmZwUUxYNVVBVGExQWZyUVA0YjBCcmY0RzFBWC95b0pXUDRkS0I2SC9JMEMwQU56dlFCL1h0UU0vaDQ5S0FHdW0zaFFId29EYmJRZnJRTVdQdy9XZ2RoY2ZwUUsxcjIvQTBERjlMVUI4cUF0Ylc5eDFvR1RwNGQ2Q08veG9KYUVBOXFBb0FYdFFJQWRkS0I3M29EcnI4cUFQajhoUUd1MXRlbEErNEZBY3JyODZCN0hwYjhxS0ZQalJBUEg4S0JYdGVnZlQ4cjBEdC9sUUw5S0FJRndmbFFISWlnTDlxQXVRZE42QXZ0WWE5YUErSW9HTmliMEJZYjIrZEFFRGY4cUFBMC9TZ1c0dGVnZTFBWDZFNld0UUdsdGR4UUJOQWFYSDYvMW9IZlRYODlhQmJ0UUd1NW9Ba0hRZE42QlgwK2UxQWJrbWdQOENnQWFCamJ3R3hvRnJiVFNnQ1JvYjYwVTcvTWRLSURlL3cyRkFYb0ViOU5iZEtBdGJYYTFBcmtXb0VldEFhV1BZZHFCNjNvRHcrZmVnbHJmUS9oUUY5RDI2VUI0MENKdHJRRzNqNFVDMm9IZS9UNUNnT242MEFlNG9EYjUwRVRmdDExb0FiOTZCblRyUUlIVFhjOWZDZ2R4OFFkNkJHMnQ2QmE3ZVA2MEQ2RW0xRklIL1NpRFc1L0N4b0hld3NUUUt3SFg1VUJ0cCtsQWlUK05BRDg2QXRmcUtCRGJ3TkE5YjlhQ08vYmZhZ2VuVDRVRWRia2JlRkF5VGVnQWRBTGE5cUEzT3Y0V29GcGE5dnhvR2VuNVVDQUFKSDQwQmZyL3dCS0FzTGEwRVJ0cnVPbzJvR2RCdlFCMjhLQmJEOHIwQUFPbnpOQUcvOEFuMm9BQ3dIUzI5QS9EOHFCZHdkS0FOaWZBYUR3b0FkdW5oUUFGN2lnQUJiVFFEcFFMUUVDZ0wyOFRRTUcyblk3MEIzSGFneG5XMS84WHFvajEveHRVRElQK1ZBaUwrSHhxZ051ZzE3MEJwcVBFZm5RQTdhVUQ2OVBBVUR1Q0xXK042QUY3YkExQWdUY20zeXFodHJycVFOS2dha2REcDBOVU8vekZRTGNYdGZ3RkExQzZXQnQwb0hjNmFqV2dWcmE3ZUZBemZXZ2VtbitOYUFhZ1kwMkdsQVh2OHFBQnY4QUdpbU9YWFhUUTBRZ1JwUVBZYmFkNktkeVI0MFFEZmFpbjBKRkFiQTNvQUhiOHU5QWJucHJRRnVvK1ZFUytQd05GSVc2OVRRTzlyMEJwL2xRUDl2K05hQmswUVgwMC9BN1VVdGIzL09na0Qwb0J0TEQ1MEN0c1FmeG9Ici9BSzBEdVA4QUtnTk8xQTl2R2dOYUF0cnI4YUJrNmJhZDZCYmIwRDNINVVDQUhTOUF3UDhBclFPOWhyUUhTMTlxQUh4K05BYWcrTkE3anBRSFc1M29DL3k4S0IzNkg1ZkNnVzk3N1VBUnJiNTBEdWJnWDBIU2dBZCt2V2dEL1hhZ1hodlFQdDFKb0MydHVsQTlOajBvSDhxQkU3bTlBaWI5eFFTRmdOdDlxQS9jU05RYUJFSFRwUUg5T2xBOUwwQzFCNkR1YUJrYWIvT2dCdjRXb0RUcm9LQTVmNjBCOFB4b0VkN0Nna0xYNlVCc0xlUFdnTDJvQzUvMG9HZXBGQXU0MFBYdFFJLzQrZEEvRzk3Nm1nVjdhQzIrMUZGK25RVVJJYmE2RWIwQzMxb0FIZStuYWloanFSdFJDQklKUFU3VURJRi82VUFGMzYwQllENTk2QlgxSGU5QklIdjhLQldCTitsQXJkTDBBQU92NDBEdHBmUy9XZ0dzVGFnaWIydHVhQkcvV2dCYTEvekZBdWw2Qjk5cUJnYlcrTkFiYTBER3YrVkFYMDAyb0ZmYWdMSGUvaFFQcUtCZmtmQ2dOTnZ5b0Q0YmZHZ1AwRkFpdXUxeHZRQTEvQzlBWCtkOXFBM3VEOC9oUUFKMEg2VUFSMjdVQmJTeCtWQXJhYTZXb0FBMEFmeS9PZ05iMEFvdVRRSTZVQmEzdy9wUUIwditkQWZLZ1h5SHdvRVNiYTlEUU8xejRkYUJEdzZiMm9BblQ5VFFMYTFxQjZucmMwQWIwQ1BVMitGQVdzQ090QWEwQnBidjErSm9GZnRRSmpvTERmcFFPeDBvRHg2YTZVQ0g0MEFPbmVnRDQzOFJRUFcxdndvQTZhRDVVRVFTZDkrd29BNmFVQjRiMERIY2JEYWdXZy94dFFBMjE2YjlEUUhUYi9PZ0RmUy80VUN2MTExb01kcjJORUIwMDA3M3FobGp0WTFBcjMzMEZVSTJJQS9BMUJJQVcvUS81MVE5L0g4cWdRM29DNC8wcWgzOFBsOEtBK1BXZ1doSGg0VkJJQzQvV2dYeCtZOGFDVnlOUHowb0FFM04rbXRBRHgwRkEyTzVQNFVCY1gvVVVBRGExanZ0UlQ1VzY3ZGFBQi9PZ1lQVWEwQ0JQWGJ2UkVyRTZxUG5RRmo4UlFCdjV0dkdnTEcvNjBVeHFMWG9IZS9TaUdMN2kxRkd2ei96b0ZiVzEvR2dZMUduem9nMDEvS2lna0g1VUQ2MitWQWRQaDBvSldIZWdMSHd0UUhYNGRUUUdvLzZVQ1VFN2RmNlVEMStOQUMrMzRYb0pDMTk2QTBCMnZRTGJyUU1XRjlldEFBa2I3MER2MDZVQnF1dmFnQ1BuZWdQMU9odlFPOXdSdjFGQXh2cCtOQXVtOXIwQU5yOStsQS9oK1ArVkFBNzlUUUhTLzRVRDNHdEFpRC9BSjZVREZ1OUFqK045cUJpMXJmOWFBNmIydDFvQzM0ZDZBc1FiSHJRTUFDdzZkUlFIK1BsUU1rL0kwQ0czajJvR0RlMzUwQitWQXI2MlA0VUQwb0FkU2ZsUlRBSHlvaEVtMS9sUU1hZkFVQnVmSHJRS3grUGhRRnRkemZ2UUY5eitJb0JnYjJ2cHZRTWFtaWhnUWFJQjhOYUF2cmVnQ0xYM3RRSWZwUVNVajVVQ3VMSHQyb0ErTkErVndkTk5yaWdYVDViMEJvT3ZUZWdkN2svbFFBUGJUc0tBMjhhQld0dHA0MFUvalJDMStINTYwRDVNT3V0QXI2NjlOTFVVN2FYb2hEd29BbStoL0dnTlRmK3RBQVdHdHlhQUJGQVg4TGRxQjJQK2RCQTBCMCtOQWlQSFNnZC93RHBRU0czOVRRTWdEVHJRSTJIZTNXZ1F0MDZVQnZ0K0ZBOWVwK0ZBdmxyZWdWemUxQXpjVUJmOFRRTHIzdjArRkE3OXZ4RkFyRzlGTUViNjBRV0hXK25XZ1c0MXY4QTYwQ3ZvTGRLS0NMbjh6UUsrM2J2UVA4QUtpRVRxTDlQMW9IZTQrSFdpZ0d4djJvaUpZM1B4b0dSMHRRSVgrUGpRRjcvQU9kQUhVOXZHaWk0K1BTZ0xqL0tpQy81ZEtBMk9vb0lrOVB5b0dEMEh4b0ViM0F0K05BYWIvblFGZ2R4citsNkJmRFhXOVFCdC8wcWhBZ0hVYlVCcnVmbFFQY1c3MEMyMk45ZFRRSytuZnZRQjJzZW10NkIyUHk2VUJmOFJRQnRiK25TZ1B6UDRhVUNOclh0djNvRmNhYjZVREIyMG9BM0p0ZlMydEFNZEJRSWtmNWQ2Qm5XMm0ybDZCWEpOaWZOUVl0TitscXFHYmc5N0RRVkFocUxtMnZYdFZEUHc3VURKVzIyMjQveXFCQzI1M0d3QW9BNzJOOWVncWhqOUJRSFRwVUVqNGZnS0E2Ni9JMEMzMzBJN1VEc2JkcW9MbmxhM3hxS1lCK1A2VVF1dTJuYnBRTWJibmVnT1J2K3Q2QUl0YWdkemI4OUtBRi9oM05BK2h0MG9wYTdXc2Z6b2lRRitndWZsZWltU0YrSFdnQ2JhL2o0VVFCcmdpZ2QrNXZSU0pHditCUU1HOTdINGlnZXRyZEtBQTBBL1NnQjhLQjN0MW9HU1NmR2dpUnJwZWdZc0FiN2Yxb0hwcGY4YUNSMk5BaHB1YUF0NDYwRE5yL3FLQjZFZDZCVzZVREF0L3JRQUI2NzBEMDdYdlFCT25lZ0FQOEFNaWdOYUEvUHhvR0xkZXZlZ0FMVUQxSFdnRHR0dHZRSFQ5S0F1Zncyb0dmeS9NMEFhQkEzb0hRQk5qcDExb0dQaHBRSTlEUUJONkIzQVhYclFIOWFBOFR2M29IdmJXOUE3Zkx4OEtCSFc5QWVIYWdEb2ZqK2xBZkNnQ2ZIU2dBRHFSYTlBYVg4S0IzSHdvRHBwMzFvR1JvUHpvRHB0cjNvRU50ZGJIYWlpOWhyb1BDaUhjZFBsUUJ2dHZRSVgwTjZCMzdXdVAwcUFHdFVLd3Qwb3FYVFRRVUMvcDJvaFg2ZmpRUGExRkxTOUVNRzU4T2xBTmEzWHdGQVgxSFU5NkFDblM1Mm9GcUJlZ1kwT29IZWdldlg4YUFHNC9TZ0RwdFFJQWl4K2RBZnBmOEFXZ0RmWDQwQnB0c0tCM29GYlU5S0E2WG9BNmFkS0F2ZnBRQUZqMjZVQVIvbFFMY1VDSTM3MEJZOWZsUUhHNUd1bmVnbUFMWE9ob0YxMDA3VUFiOTZCRzF2Q2dmeDJOQWliNzc5NkJHOXQvblFPL2FnTmRUMW9BNkh2NG1nT2x1L1dnRGU1b0Q0OWQ2Q045ZFRwK3BvSGZTMzUrRkFocHBmNTBBRHJwUUY5UmFnZHRPOUZLK21uNDBCMjJ2Mm9oQzl1LzZVQjRVQmZUU2dWeDhhS1lHbDdVQ3RwWWpwUkFPOTZCV0lQalFCRnRmd29vc0FCdFJBU0QxcUJFQS9PcUEzc0wvaFFGOXU1TkFFRURmYldnUTdhMFVhL1B3b2hhZ2piV2dhdDBBR3UxRkJPdGh0UkFkQmZXMjFBaHQrRjZCZjUwQUFMYVcxMjZVRE43VUFQaDRYTkFiOTZCYVd1ZnhvRFU3RDRtZ1d0L0MzNDBBQVcrSFdnRmF4djNvRFhlZ0QxN2RLQS9LM2VnZDc2OTZERzFyYVVSQzUxMTA4YW9kOWI5VDFvQ3hJdDBvSGI0Zmgxb0RVanVhQUlQZS9XZ0NSc2UrbFFQcC9XcUQ4N2ZqUVMyT2gxcUE2YURUWVVDL3JRU0YrK3Y0VUR2dnByNFVDSkhqNFVCZlN3b0FiMnZ2dVRRU05yRDhpS0FzUjQzMXRSUnlOL0h3b0RYYnVhSU56Yy9sUlRCMTBvZ0oydHJmYzBCNVQvclJSMTBPdEF3ZE94b2gvME5GQUIyNlVBZDlOcUIyL0xhZ0FSUkRzUGpSU3ViOUJycFFNL0dnVnJIeG9IcjM4ZEtCK0JvQzIvd0N1OUE3R2dEdmI4ZmhRUHArbEFkYlVEQko2YTNvQysvWHgzb0dSMjB2K3RBamJUeG9KQW41MEN1VGZxTzlBN0g0VUVmbnBRU3R0Yy9LZ0w2ZkdnWTBGcUFCb0R4Nm52UVBYYTEreG9FUmZTZ1o3a2FkS0FGOVNONkEwMElvQUVYK05BWDZuZWdEZjQ5NkJnNmZPZ1owL1MxQWoyNjBEc2Y4QXBRQjErRkF0ZWxBRFErRzFBd1Qyb0JldHh0UUcxcjZVREEwb0VOOVBuUVB3L0cxQWROUGxRRnhiNWFEeG9vQk50UjBvZ0hTMmxGT3d1UnJ2OGFJZC93QWFDUEk5YUFKSFVXb0dTRHRyMm9GK3RGR3Q5cUlZUFVEVWRhQXYxSStWRkIwMS9FMFFYWS9FMEFCK0d4b0VLQjlqYjQyb290K2xFQTFvQVVCOE5yMERGdXU1b0VDT3V0QTliNjc5NkFJdUJiWHNhQldJK05BdjFvQVgvSGVnWVhyMEcxQURVMi9HZ1IyOGV0QTl2OWFLRGExN2ZBVVFFOTlCUUlEOHpRTURYYi9LZ1IwMUcvalFBMzA2ZGFBUFk5cUE2ZkRyUUhqMG9EWTlyOWFCMzhmQ2dqYzlxQTZlUFNpaXhvZzIzb0Q1NjBET20zNDBDdm9CK2RBZGJENG1nT25oUUlqYS9qUUdnRzM0MEJwcDM2L0NnTEcxdWxBdjBvSHVOVC9uUUZnRGMvSVVBRGZidFFINjlSUVIxMThhQU50T25RMEFiM0FGQTlPdnpvRTJ3dHIzb0MzalFJM29IOC82VUN0cmNiYmZDZ0xhV3R0MEcxQkUzT3BvSHVMaWdEeTYwQWR4UUsxeDRkT2xBTU5mOGJVQXVndHQ0MEJleEZ0dkNnWFVXb0dDZHVsNkJhL2pxYUJhMzNvR0IxdDhQblFEWCtZb3Bha2ZEWWQ2SUNEZlRmcUwwQUI4YmpjbWdBZGZ5b0FrYkRTMzUwQ0F2dDAvS2dMRHZjZm5RQTM3ZHFBSXZ0MnRRRnh1VGY0MEJwYmZmclFZOWREMEc5RUlqZWdBcDNHKzlqVkRHNDAxb0RVYi9qUUsrbW9Bc2QvRHJRUFMvWHh0dlFGdEIwRlFQcnZmd0ZVSWFqVGUrbDZCaS9hZ1kxL1VWQVgxdCtGQWNoMW9IdHZWRDcyMjY5YWdWN2JXSUg1VURESFMvd0E2QUEvQ2drQ0NCcnYvQUVvQUQ4YUtWN0g5YUllMisvUTBBT3Q5ZHFDVmlkZHFDUDhBaXhvb0g0RHBRTWJYb2lXdGdUcjhhS0IzdFFGeGEzVWIzb0ZlM3kxb0pkZkRwZWlHQ2RmeW9wQzE5UGxRUFMrLzQwQVRyb05xQjNGdEJ2dlFBSkc1K0lvSGEvaFFIeCtkQUczeC9wUUhUdzdVQmZRWEZBeDRmTCtsQUMxQkxXM2pwclFJOWh2UUZoL3JRTUhZSFh2UUdwOEtBNjIvQ2dZNjZpZ0w2K0ZBRHQxb0Q5YUIzN2ZoUUhMWVVCb0tCbnZ2YmFnTGtEUStOQVh0cmFnZEF2RzJ4L1dnRzJBNzY2MEQxdGEveE5BNzZiWEhhOUFiYVVBUWRodjJvRmZmdFFLNHVQQ2dkOVBqM29HTmQ2QUl2c1A4NkEvd2FCMzh2UWk5QXUrdndvQUM5L0RTZ2R1LzQwQ09tdEFkYUtZMVBoUkFkdjYwQnJzRFFHbXZlaWdnQy9ocjQwUXh0dHJRUklCK2RBeVRiVGJlNW9EdmJmclJUdnNmOGFVUXRiZm9hQU94ditWQWRkeDRVQlkvbHJSVHVQOEFIalJDQU5yNkhzYUtkNzdEVzlFSFQ5YUJYR3BvSGF3N2RxQkhmd29IeUhUNDBDSkpIaWFCMk8yL2hRTHFhQTEvNmRhQXNPbjRVQmZwYS9hZ2R0TG40VUJydmVnRDgvaFFLNUozdGZTKzFBZU5xQThPMUF3RHYxb0ZvRHArTkZESC9XaUdUcDNOQWdlKzFBejFJRkZJL0hTaUViRWVGQWNmQ2dPUStZMG9EWWFqNDBBYmdmcFFCdUxVQVJyYnAyb0Q5YUFCMjhhQTEvNjBDNlVVV0duaFJBVCtWQXYwb0dMYTlxQk4wMTFIU2dMVzB2WWRLQThEOE5hS0NkS0lRRkF0ZDZCai9TZ1dsdXdvSDF2MS9HZ2l4NmcwRDMwdDhxQlgrTkZJL1QvV2lINGQ2QjN0b2R5S0tSR2wrbHQ2SVJ0MXY0M29DL2pxS0E1V0d2YTM0MEN0MFBiU2dCb2RCODZCRUU5ZGVob3BnV09ob2hFRWl4NkMxQWVCR25XZ08zNlVBUjg3blEwQ3RxTmJEYWdPVnhmcDErTkFYdjhBNVVBZE5hQUJJSHdHMUFhZDcwQUFMVzZVQ3ZwcDA2MEQwb0E5eU5lMUFoYmx0ZStnK05CanZiNEhUU3FoZE8vUVVCZnh1ZXYrdEFYYS9qMU5BeHBxTnUxQTc2OXI5S2dZRnFvTkxrWC9BQm9DMm5TL2g0MUFmNCtWVU80L0hyNFZBYUVlRnFBdDRXRkFYT2wvblZCcmV4Tysvd0FxQUdvdHQ0Q29BVzJzYUNRdVRlMWovU2dYeU8xdTFGUzA0MkpPdEFhL0h3dFJEdGJiYnI0MEFSYWdXblRhaXBBN25yMm9EY1c2blNpRFErRkZGenFBTjl4UU1BWCtGQTk5anFOcUExL0RwUU8rbHlLQldGL2hzYUF2Yitnb0phbTlBZGJiRFRTZ0RhOXVuV2dEcC9qZWdOUlFPd0kxMW9Hdlk2Z1VCYlFucDJvQTZibWdMalQrdEF3Tyt4b0MzU2dZMDIwb0EzMFBlZ0xEOWFBRzJ2NVVEMEgrZEF0NkNRQnRwclFMUVVCdHIxNjBEMTZiVzBvQUFnYTdkS0FCMTN0YWdkamUxQWJmNTBCOEJvTnZqUlQ2VVFFamJwUUNtMUFIV3g3N1VBZHI5dHhRS3dBc1B5b0dQSHIwb0hZaTNlZ05meDFvRW9GL0hlZ1pGdmdLQ1Z0TDN2NGlnVmpmdDNvRGNmNTBVYnJ0WWRhSUNmOEFXZ1FCdDNvQzl2NjJvSGZUcDRtZ09vSFdnQ1FkcUIzdFlmamFnVjZBSGlONkF1T2hOQTl0YUFKdnR0MzJ2UUlYb0pXc1JmVHhvRGMvclFJRzN4b0RYdDRWQXd0OVFOOTcxUU1SMDN0UlVlK3hvaGdrZ2cyK1ZGQTBQK09sRUd3OGFBOFJwMEIrTkZBb2dIWHRRRndiWDFOQUQ4RFFNTmZyYS82MEVldW1uNjBERnZ3Mm9vTi84N2RxSUxqdDhLS1BEOGpwUkRJdHRwZWdQeW9GZlRXZ0RmdlFBL0EwRDB0ZlR4TkF0dGV0QWVIV2dMOWZDZ092eDc3MFVxSUxrZktpamtMNzZHZ0xrRDlhSWEzSjArTjZCR3gxTkF1MXZuUU1XMDZEcUtBMC9iZjQwQjRiRGNueG9DNDZmalFJOTcwRWdScU56NDBFUmNuOUtCa0VIU2dpUUw3Zk9nTk5qMTYwVWI2N0NpSGNiZGRxQldzZmh0UUxsYi9XZ2ZhK253b0Zld29FRC9rVFFIUzE5ZTVvRFRlaWdiai9BUFJvaEFEUysxQTl6b1BsUUpsTzUvQ2dMQzFBaUwvQWJtZ0d0KzdZZEtLR3VmOEFPaUkyUFVtMUJMVy82MEM0Nmc3anBRR214MDcwRVRiOE90QS9FMEVnUnFUdlFJazJON1dHbEFyallkYUJXSTEvRVVETnIyR3ZqUURYTnZ5b0k2bjVkNkJpZ1pKRkJIY252YjlLQjIvRHI4YUNQaURwMG9IZlc1TkFYN1VDMjF0cDNGQmtJMHFvamF3K1BhZ1oxSjcwRE50NytOQXIzMUErRjZDUU93ditOQWRSY1VCcnIxTlFCdGZYclZCdHNMbTFRTStHdjYwQURlMUE5S0FzTFc3VUJjQTI2aWdEdlJUQUh6b2g3MjdkS0EvcWZ5b3BnL2xSQWJtZ0FSYlNnYTZFOXVsQVcxdCtWQXd2aGErOUZMcjQ5YUJnRC9LZ0xtOTZCM3Y4OTZCcmYvU2dDZHpmV2dMZGYwb0dBZW0rOUFyWEpzYUNXdDZCVytQaFFQWWJVQmZyMDZFVUR1UEcrMUFkQVBsUUJQVUg0MEFHSk94b0gyN1VCWVcyK1JvQzVCditkQXliQ3gxdDhxQW9HTlJjYTBEME56K1ZBcjlBYmFiV29GLzBKb0pEL0FvR0FPTit2YWdSOFRRQUJ1TzNZMERGNkJtOWhlZ1JvQWNqcitGQXlMajlENFVEMjM2ZnBRRitnMUg0VUMwTzUwb0FHOXJuWG9EUU85eDJJM29DMm42MEJwWTYyNkR2UUZ2blFQV3c4TzlBSGY0MFV2Tjg2SVpBQjMvQ2dRUGFnWjE3L0tnZmFnVi9OUUM2L0R2UVBUVzFBV3R0cHBRTFhUdjBvSHZRSFVVREFKT3RBckc5aHYxSFdnQVJiWDVXb0MrLzZVVXpZaWlGdjhhQm5wZlkwQWIwQzFKdm9LZ0JvYi9qVlV5ZitsRUFZOTdVRDFPbTU3MEMwdmUzeEZBQVgxRzM0VUFEMDcwQzhlMjFCSTJ0OGZ3b3BXdDQyNjBRRWs3MER1TnRxQkhmOURRQTNON1g4YUFMQTZmS2dMZzdHNFBlaWwrbEVGeHYrQm9IYnY4QU1VQjB2UUJPNC9PaWpwdHJSQnViZDk2S1BqcFJCcHVkN1VBTmoxdUtBRnlCM3RRQS9QclFGd0FlM1NnUTBzRGFnUDhBQU5GTzJndnZSQ0hVMytOQVdIem9BYmI3MEFMbjRDZ0FRTEMydmVnWDQyMy9BQm9DeFBXMUF3ZGJDZ1Y3SHRmYWdWeWQvblFNa2szdjh4UUY3MjhPbEFhYmRUME5BYUVmRHJRSnVuNDBVcmY5VFJEMCtld3RRSGJ2L2xRUi93RGpRR3g4ZkNnZHhhb0VkKzQ2OUtvRHB0b2I5ZGFCRzRIdzN0VUQwdDNxcVFZRy9IZnBSQzNvb3NmbFJCdVJicFFMcmY4QU0wRHNEYTlBZ1NONkI5UUJ0dUtCYitQeG9wTi8xb2dzYlg2RGNVRWZuZndvSkMybW1sQVcwM05xQkEyR2cvR2dadGY5UENnQVJyMTdVQ3YwRkFnTnZ4b0MzVzN6b0EzN2JibWdBeDZiR2dOUmJTMnV0QWp0cHJRUFM1MnVQeW9FVFkyNm5TZ051NUhTZ3lFZE90VkNBdlliVzFvQWFXb0E4Z2JHd0cxcUJkZkhzS0JuYlhyUVNYamJYYnBVQmV4dWRlOVVGdCsvWDUwQU4vMTdWQTdhRzVvRU5kYjJQV3FKRDRiWCtCcUF2Ym9MMVF6Zlc1dDJxS1EzMzFvaHFCMytOQXpmcnBmYWdXbHhmYWdmNWR6dnRRTVh0dnZ2UUcxQTc2OStvdFJTSnZicjhONkNRMkZyZkNnWFhyL2pwUU85K212U2dCYlQ0MEQ2ZVBVVUJjbTJtM2VnQUw3L0FQU2dGSUhUYmZ2UVMxb0Z5RnRmd29HZGRiNjBDSGpwYzZVRXV0NzZkNkJDMndHdDZBQUlGelFTdWVtbXRBWEIvQ2dQNjBFcmkzNTBDNjNId29BRytnK1ZBeDNGQUFpK28vMW9ENG5lZ092YnFhQjY3OXU5QWEzdFFBMjBHb0dsQTc5dmhRTUhUNFVEK1A0MEM4MXJmaGFnWFQvT2dlOXVob0MrcEY5dWxBeGIvS2dDUGg0VUR2cGJ0dFFSb0hyY2FhL2pRUGIrbEF4YmY4cUJhMEJlOUFDOXY4NkF0Yy9yUUJCdFlkUHhvR0R2K2xBaitWOUtCM3VRZHI5TnFCRS9oYlNnWjhPdjlhQmRQaHBRUzBBMDZkYUFCMTc2YW1nUlBUdnZRTmRxZ05MN2FkS3FuY1gxMjhhSVIxL3JlZ05iZmthQXRwZnAwcUtOenRieHFvT3UyM1hyUU1udWRLS0FSY1c2RHJSQWRiZU5BZGUxL3dDbEEyRnJnL09nanB1YUEwdjhOS0JtM1E3MEJmWVVEc0N2dzJ0UlM2L3JRR3Z5b0Fpd3NlMUVJazc5OXFCMzh0dmxRQUhqYjQwQ0l2OEFyUUI3bWdCWWEvalFGaVQvQUZvR2JVQ0Z5TkRSUmZRNkVkeFJBT2gvS2dldStvdFJRTFh2MW9ndU56WTlhQXVQeG9IYjhldHFnamNWUTcyb0M1c0xpOUFnS0tMVzE4YldvZ3VkNkJYT3cxUFNnWTY3MzZDZ1J0MCtGcUJnM3QrbEF6OHlOalVFYkcxVUdsQVhPLzRVQzNOeWFCaTVJb0ZZSFQ4cUFGdmhlZ2Q3L0h0UUxXK3Y0MEJydHYwdlFBdC9qZWdRM0FBK1ZBOUQxMXFDUDYwQVR1S29OQ2RPdjZDZ0Qxc2FCYVVCYzN2K0ZBWE50UGlSUlIySnY4cUlDVHZmWHJRUnYwL0tnZGlmdzNvSFkyRi93NjBDNy9sL2xRSTYrQW9Hck1BZGQ2aW9qdHRmcGVxaDZIVzVIaDRVQzBPMjM5YUJIdGFnTDYwQjF0dlFCSUh3b0ZjYi9qODZBdWVsQVhKdUJvZnlvQzlqdmFnZkxUeDZpZ1hUdWFCQUMvVzNicFFQbHJwdDE3ZkdnTGdqWFR0UUZocmM2MEJyL3Azb0N4UDlhREd3SnQwdnJhcWlGeGMvbFFQV3hHOUF5YmduODZCRUhxT3UvZ2FnWU54YSs1cWhtMmxBV0k2bldnWTM4QnVLQk1BUnQ4S0I2ZzYvNCtOUUEzN2RhQmdMMHVEVkFiOU5qMXFDUzIxdnFUUlNPbW9KRkExL3dMVUQzSGpRQUd4M3ZwdlJCZnAxNzBEQXZmOEFTOUZJZkdnWjhCcHNhQlc3ZmhRU3VOaUwrRkE3bnJ0UUxUWUg1N2FVRXRkS0JpK3hPOUFoWWJiWG9Ba0dnWS93YUI2VzMxb0YxUFczU2dsWUcxdndvRWR3RjBQajRVRHVScCtWQUVhOUtCaTNYOGFBTnIvcmVnZHhleC9LZ1d2eUd0QTE3N2RxQU4rbTRvRFRicDQwRHNkdXQ3bWdMNjlqMjZVQitYaUtBN2kzaFFBMjhOckdnQ2RTTjZBdjMwdlFQY1VENjJ0YWdZSkg2VUFEZTNjNlVDdjNzUlFNQWY1VUIvZzJvQTM2Q2dOQU8vOEFTZ05iV29IcCtHbGpRTUhlL1dnTGpVOWFBTzE2S092eW9BQVhIZWlBM0Y3alhyYWdBRDhBS0JrcVRjQzFxQkQ0NjBBQnByUUZpTlB4b0dCb1QwNitGQUN4Tmh0UUZ0ZHJmR2dCcWYwTkFkZjZVQnNSUVNJMDJvSVdPMUJLMWlMblNpbmNFYlhIZWdRTjlPMnRFQjI3ZGFBb0FteDF2NDlhZ0QwRzFVTzl0cUtWK25ZMFFFMlA2K0ZBN0MyaCtGQWRUZmFnTmhSU0Z6c0JlMUVINjBEQUZqUUd4c2ZtS0tSQk8zK2RSQmY4S29BZnpvQWY0LzZVQWIyMW9GMTE2VUJlL3dEUzlBVzEyK0FvQUVXdHVlM3dvcGt0dWVvMW9BRzFyZGUxRVNMWEZCSFRVZmxRQnNkTDZVQWI3YmRTS0tCMTYwUXlma2ZDaWdjbEpQNDBRYTIxRkFpTmV0NkIzdWFLUitCb2dGdjgrbEFyRy84QWcwVUEyOFBHaUdCYmJXZ0RjNy9oUUx4SFR0UU05ZXhvRWI3Zmg4S0FCdlFMWHRZLzUwREd1bEFDM1dnRGUvaHVhS1IwMHVMNzk3MENzMm5lZ0NCZnc4YUlBU0I0SDhLQTN0Mi9XZ0w4aHQwb0RVRGZlZ2lUb0RRTzFybi9BQmFnTnZ4K1ZBaWJIdzJvQTN0YjhEL1dnVittdW5hZ0wyTnV0QTc2QzIvWTBVWDB0dlJDQTMvS2dSNmVGRk1OcVBIV2dSMThmR2lHQjFIU2dYYzMyMm9FVHI0ZEwwQmMvQURTZ1owQTJvcGROYUlMTUJjMk50clVFUVFUb2ZpYUJyZS82MFVqNGI5QlJDdmJmZnJRSy9VYUU3VUFDVDhLQmp4L0NnRHBmODZCOVBqUUszK2RBWHVQODZBdDQwQ3ViMjJ2UVNMRUxib2VuU2d4TitCMk5WQzY2RFNnZlNnRHJZVzI2Q2dSdmFnQjExdUJRU1hlNEZxQTM2NjlhQ1IzMTZhMnFCRFUzSHhvQUwwNi9sK05BeHZxYmtIU2dEYTl0KzlBd0RlMXo4UlFLd3RiUW5XZ05RRDBvR05kOXFCMjEyM3RZbnZRQjNHMWpRTWpRSHIrVkFVVWhiYzBFdjZlSFNnVnJuVFhxQlFTQUJvQTJ1TnYxb0RYeHVhQ1E4UGhRSDVIcmFnUU9uYTFBL0FuNDBEdUxIcU5qYWdOTGtlUGFnQjF2dlFQNTM3MEMvY0xDZ1kyMytONkIrWDhmeW9DNStab0R0UVB4b0FrMnQzNlVER2lqd29EZS9lZ1d1NUY2QjhqdlFNdG9EL2k5QUFDM2ozb0FiK0cxQXV2aDB0NFVERFdvSGErdXdvQUE5VGFnRGNiL2hRRjlMZHFCZzlkKzFBWEh6Sm9DKy9XOUF3U0xYR2xBWC90K1pvQzJoRy82V29BRzVBN1VCb2RPbTFBOUJRTTZhNzlMVUN1TmJkTktBdUtCZ2krbmVnWlBjL0dpb2tuVHVQMG9nQUcvV2drMWdOL2dLQkRiOUJRSW5xYUNRT2xqUUt4MHY4QXJSVEkxOGV0RUJKTy93QXJiVUNCRmlPOUFHeEcvd0Qxb0pYc08vajJvRFMxeFFHNTAyN1VBU1RwcDRVQ3NRVDJvcDNPNTI2MFFyalc0djhBNDBvQTJ0NDlhS2xhM1Q1aWlGcC9XOVFGaC9qOWFvTGZuUU1hRUVmaFFMcnZ2dFFBTzNmdlFBdjQ2YW1pbWRSL1U3MFFoL3BSUnlQSzIxQXpvYmRQQ2dWckMvNTBDTyt2em9oNjMvclJUOERSQ0s2RWRCc1RSUzIrZWxFSFRRZkNnQnFkZjhBVUJyMDF2UU94dHB2UUg0NjBBTjdmdXRwUVBhM2FnUjNJdGE5QVhKb0Eyc2JkS0JhMkIzb0d0Ny81MERKL0h2VUMyMDdEU3FIMUZ1dlNvQXJhMS9sZWdpYkFkL0FWUTdIZjhhZ043QTlOcW9XcDEySTJOQXlSdGNmS2dWOUxkNkF0dGZYdlFBR2hHbEFyZmo0MEQ2YVVEQjBCTzlGUjAvNjBRRHR2MEJxQXZycHA0MENPbjZpcUgwdlJTSnNSUkNzTDYvNVVBVG9UcnZ2UUg2Zm5RTFFmRTZVRWh0NEdnWEU3ZGV0QWY1MENONy9EYWdMazZDaWdIWC9HMUVKdDlkTDBDSjNHdEFIYmFnVERXMUFXNzZuYTlBYjN2djMvQUVvQWl4N0g5S0JkYi9qUUEvRCt0QXpmcnRRSzNZNjlhQStkN2ZoYWdXdlE2bWdmZ051MUZKcjlkTGRhSWkyLzYwQXgzNlVBTERUclFPOTlPOUFialU5TEFVQU9uLzhBQ0tBTy9oMG9DMnczdCtkQUFpNS9TZ2lScitWQks5bDhOcURFMTl0aGJyclZRWDYvcHJhZ1h6K05BL3o4YUI3L0FPTmFBTysxdTFBd2ZFYStGQUFhN2JkS0JHOS9oMnFLZXQvajBxb1kxR2w5S0F1Ym0rdFFQemZoMUZBWHZhKzI1b3BqVFczeEZFSTc2R2dsYTNjMFVyMlBqM29oMzF1ZGU5QXg0ajVtaWdYT3Q2QmJqL0Y2Qmc5cm0rbEF3ZTIrd29FQi93QktJa0NQaDRVRHVEUlQzTy96b0R3MEhXZ1EwMDM2MEIrZmpRUzQ3VzI3VUFwTmhRSFRTZ2Z3MG9EYlRYeEZBYWEwQnJiZWdCcnZ2MDhhQ1JKNkg0VUN0Mi9PZ2tEYmI1M29JNjN2K0ZCS3gvQ2dXOWdLQmkrZ29DMytsQWRSZWdaQXYwb0FmaFFCOFJwUVN0ZjlUNFVDSi8xTkE5YmJhMENOcjMzMnZRTUhYVzE5cUFQWS9qUUlYRnRmR2drUm9ML0dnWXR0YjhLQkhiZjVVQllhYmQ5TnFBMW9BL0RRMEQ1SHJRTW0rd3RlZ1JPaHQrRkFiSHRmdlFGN2lna0Q0YVVVdFNEZnBSQzJQeTJvR3cwL3JRSUVrMjNQK1ZBenQ0ait0QTlqcjhhS0FRVGMwUXJMMC9HZ2Z3Tjc2MEFOTzFBWDZpZ2V2NDBFZWw5NkJuVFdnTmJmclFIY0QvSHdvSHVMOTZCQTZqcjhhQjYyQXNQQ2dMYVdHbmMwQ3NML0FBM29IcWJtOXIwQVFiMFU3YmRiMENCMXQyb2cxM092YWluM0kwcUlWOWZodlFBR2x4VkJwMzA3MERHZ3Rlb0VOanBWQUNRUjErTkZQUTBDMHZiclVRejBCNzYwQ08zNDBWRUhmYXFpUU9uYjQ5S0I5UGh0UUsydDZLQjMzUFEwRHVMRHZSQVNiNy9PZ1Z0TkRyMTBvSTY3MUE5eWUzYmFnWUJPdjRWUXR0emJwNDBEMnRyNDBETzk5S0tSWWRUZnRSQVNSYnYxb0YwdnZVQmV3UFNnTDNQY2pyNDFRWDAwM29vNURmdnRSREpPZ0ZpS2dqNGR1dFZUMTN0OEFmR2lBMnNOeDQwQ0kxK05BcjI2YlVFdC9sUUlHK2w5L3dBcUJhRHB0K2xGTUd3TmhyM29pTnorTzE2QjJCSDYwQ0pGdjhxQUFOaC9XZ1J0cU42QTF0cnQwb282YTMxNlVRYnJ2UlM4T3ZhaUE2bit0Qks0SUhTMVFCNDdEVWlxSURZMzYwQU51bEE3OGI5eFFSdmJUL1dnTmRkS2lrZjlLcURqMzBGRkdvTjlxSWQvTHZlZ1d0N0Q4YUEvUFdnUU9scmFmMEZBWEZBamFnWkMzMTI2Mm9FUjBCdlFLeHNhQmpmWHJRQjdYMm9EamJYK3RBcjdqY1VBNHZRTVhJRnFBc051dlczZWdWN2IwR1JoWS9wVlF0QVBoUUJPbDczSGhRRnU5QTdzTlYrZEFpMXp1Yi9DZ2QvbjJvRC9BQWFnWkY5ZXAwSHdxZ0IwNzBCZjhhQXZicGFvR05Mai9wUVBTKysvYWdZN0Q1MFV0QnBwNGdVUUc5aFltM1lVRWg4TnZDZ0NUZlQ1OTZBQk94NjlLS2R5YjBDMUduZWdQaHJRUFc5QXgyR3Z4b0FYRGRoMThhQmkvZTM1MEQxSGJUY1VCZnFQejdDZ05LQmdYT3YrTFVEMCtOQVgyNzJvRFU2VzBvRHpkTit0QUUydVB3b0YzL0NnZDlOZGFDUTAyT2xxQTA3Nm44VFFBT2x0N2JtZ093R3RBQWtqYlRwM29KRFRwUUEwTzFBZkhydGVnQnJwMG9GZlVjcUF0cmFnZDl1NW9IcmJ2K2hvSDAyMTcwQ3NiMlBlNG9KcUFOUG5RSWtYdFlXb0YrT3RBVzAvV2dPMzlhQmdtZ0FUdFFHdnk2VUVsQTNOQXUzYWdDYi9BTlJRRnpvRDBvRHQwb0h1UGh0YWdMQzRINFVBTERla0R1QU5iV29HSHVMSGFnUk9nL1Npa2Q5ZnpvaDZXRnhwUUZ0UGp1QlJUL3dLSVFKMnZZN0dnTGdIdjNvRDRmRTlLQVhYNDlUUVBTM2EzV2dOT2h1ZXRBWDZEUVVDWGZUZWdOUVBEd29IZStoUHlvbzZYNlVRanZjRGY4YUI2ZFJydHZRSDY5dWw2QXRmd3Z1YUtQem9nSklzYmZLaWk1My9BQU5BSFR4MDJHOUVNbTR1TGVGcWlnNmRQalJBQ050dkdnV3QvQzlBQUE3ZE5Lb1owRmgwNkNnTmJqdDBxQTFJTjZvZHdvc1I4RFJTMTF0dWQ2SUNUY0JRZmo0MUFiRWVIUTBCWURRRzJ2WGVxR2JDdy9TZ05yRHJVVkd4K0JGVkRVNjdYMDBORkEwT3BJMDB2UkJjYmRPbFFBSXY0OUtxa0xYMDJvZ3VUdlVENWVONzc2VlZJV3YyNzBCYjVtaUEvR3hvSkcydzE3MFZHMzREODZJRDIwcUIyM3FoQnRkZHFBSGg4UUQyRlJRMi93Q29xb05lby82VVVDM3lvQVhPbHRlbEVSdnIzRkZTdHkwdmZ2YW9oV0YrMUFYMTBHbldxRjJQYnRRQUdualJSb1JwOGFJVnpwZWdQOER2UUJBRnlQblFGN0xyK05RSWI2SHhxcUNCODk2SU9nUDVVQ3ZjYWFDZ0YxMjM2VUFCZS9qUU94b0lBanFOT3dvQUFYUCtEUU02YjBFVGU1TjlEUU1nYmZqUUFJNkdvQUMrMVVSSjEyMTYwVkxRblU2MFFnUjAwb0VkdkdnQUc2YjBESzliYmJIZWdXb3RmYy8wb0M0SU5yRHdIZWlqYTNjbmVpRHNkZGFCSFk3Z2I2MENGN1g2MERJNmRSUUJIZnJRQkcrdW8zK1ZCSFcrNW9KQTllbStsQWdSMTNvRXdGdTFxREsxOVBEcFZSRzR2NERyUUExMS9DZ1kxK045QnRRQTBHdjRVQUFkYUIzTjk3VzZVQzF0NDBFallmSHBRQTE4ZkNnT3R2eUZBeUJ5Mm9DOXRMNmpyVUROdE9vL0txSld0cmJUK3RRUklCdU91NE5BeGZmcHRiYWdkN2IvQUlVVVhHOXV0QTdiN0VpZ2dlKzFCTFFucjhLQXVia2ZsNDBEMTJPdmowb0pBVVFkU1Iyb29BRzl0VDg2Qm0zejcwQ3ZkZDl0alFQVVdvSGJUdFFBM3VOQjBGQTduUWcyb0FiRzRJTkFFa201MTZVRWJYOEJ2UVB4L3dDbEFDMmg2amI0VUV0dkR0UUIzb0M1NzBENWY5S0JzU2ZnTmdLQU5nMzZVQVQwM29BWHY0VUFUL2w4NkFBM0d0QTdhMm9DK25YU2dlbWx0cUNRdmJ4RkJIYWdZR3VnMEc5QVhIK090RkszK25oUkVpZmxiK3RBdW1sQXhwY0hmcUtBTnIwRXRBQlFCYlN4R3R0RFFMVW45YUFBQUkxOFRRRnRmR2dBZGI5YjNvSGJyK05BaHNQeTYwRDEyL0NnQnNOTDlxQmpVNjBDNmZuNFVEdC9qL0tnTk9tdEFyNlc3ZGFCbi9yUUlYN2ZHZ1kxNjBCYnIvclFNZ2JqUWR0OTZCRUcyK2xBRTl2eG9DOS9sUU1DK3Uvd29GYjhSK2xBYVdIV2lwV3VOdHRUMW9oWHVkaDRVQVRRQm9DeE9oMHZyUlFiM3QrUm9nSk45L2dhZ1BoditsVlFCYmI4cWlBRTJGdnk3VlErblMzYW9FUWJucU5oUUw0YmlnbHJld0Z6MkZBV0FORkxTK205VkV0YmZDZ1RiVzI4S0FCSU8xQWliNkhRbjg2Z2Q2cWw0WDhhSVlKdmNhRHFLQUovSFlHbUJMNDlOcUtaSnNiZkszV2dYWFhVZFRSQnZRSDZqcFVVN20vaDFGRUlqcHFLQ1F2WVgrRlVCRjcyNkRXb0Z5dWQrbTlBRGJVNjk2b0xhOGdhQ09oT2x5ZXRBN205dHI3MEFTZmhSVHYxR3hvaEEyMjB0dlFSdnRRTzF0Um9PbEFEdmFnRGYvU2dOenRlZ0FDUWZ3N1dvQWRUdlJTL1B2MG9nSlhVRStHbFFGbDJHdDk2cWdiZ0RyMW9oZk8ydEFiSDQvbFFKdGRlbXdvQzk5TmJudlFGL0RVMEFOUlFNbjhCdlJTWWo0LzQzb2hXNjlhQUJzYjdqcGVnQ1NiWFBoYWdCM1B6b0VSMXZhZ1ZqYlRTKzlBSGUrMnZTZ0NEb2FBTmdORFlEZWdXdnozb0diVy9PMUF0ZC84QUd0QWNpZHRhQlh1UEdnTDdnZE5MQ2daNVh2MEZBbUcydmlhQ09ueS9yUU1IeTMvTTBBYjIxdWUxQVdKMk56dlFCdjExdCtkQUEyMU94Mm9DK3VtaDNIYWdWenQwNjBEMnRRTGtiM3Y4S0FJMjYrSm9GY1gwNy9sUVl5Q2V1dFZBZkhwUUY5Q2R6MzJvQTZpMit1dEE5dmtkUWFCalM0NlVEYTJvRy9YNDBDMUd1OXhwM3RRRzRJL09nQWJYL1NvSkhYWDUrTlVLeDhPMTZpbUJkZGQrMVZCcUxFL0tvSmNqc2RRTlJRUjAyL0ExUTF1VGM5T3RRU0J1ZFRhLytMVVVIWHBRSUUvT2dZc2RDUG5RTWRmQ2dBQmM2V29BSHVmR2dsYlVYNi9yUUsydmJ3b0dQQVVDdm9mbFFTRmhyUUIyMlB3b0grVkFYMDdDZ05MMEFiNmR0NzBEdjBIVVVFZEwwRHRmNGpwUU1hOVBBMEFQQTdVRHZyZmFnWjRpMnRBSGErMWpyUVBrTis0MU5BRzE5S0JiNmZuUVBiL1dnUEFVQU8xeGY4cUNROGFBb0RXMXFBMTZVQmNXMTdkYUE4YUFCb0dOTk56MUZBRUMzajBvQzF6c1BqUVM3NjBDQXVUWVdvQnRCNGZqUUdvTytsQUc5dGZsUVBadC9sUUd1MzRVQWVuNFdvQUE3WDIyb0JRQWJIcCt0QXoxdDBvQlRiUzlBYjloYWdpYmFlRzFBeDQ2VUR2YlFHZ05PdlNnWnRieEgwai9BRm9BRWczMkk2MEIxMS9HZ1BodlFHNC9yUUJKdmVnTGp0UUs1K0hqUVN2cnJRQjBKNzN2UlNGeWJiZDZCbTI0dnB1S0lqcVFiVUVpRzFGQWFmOEFXZ05BUVB4dlJTNUFudCt0RU1DKzlGTW5YYjhkcUlWOWZ6b29JNkUvaHRSQnAydFVERmgwdjNxcWlvMEY5TmFpSkM0YnNOaDNvbzAxMDMzcW9BUWR0dHZHaWtiV0ZSQVJ2ZS9qUUIvT2dPdHdMMjM3VlErUFQ4VFVBT2hGdkNxRmZUWDhLaW1BZWxVQnQ4ZS9qVUNPNDdWVUcveDcwQnBwMDdWRkFLa2tmalZRMnRiUWIvblVFZkNxR0xkcUtDMWlPL1NnT21vMG9INC9uUUltaUN3Mi93Q3RRQk9uK1lxZ0dsK3Y5S0JFRFhlZ0RlMXUzUTBDOGJmR2dZUCtEVUNHMzlLb1oyMytOQWorZEFYMzduVUNnVnJuNDBEMCtQWGFnVnpvRnQxc0tLZTlFSmdDVHZmVFR4b0JXdDAzb0EyMUovNjBBVHJ0cDJvR2RENGRLQ0xkN2IwQU8zNTBEVXFMZFQxb0UzNjdBVUN2YTF0KzlBdDdkZTlxQjMxL1NnRHhJTnZ3NlVFYjdkajNvQWFXUFFtZ0xudHFPdEFYUHp0ZWdRSkkvV2dMamJ2UUJJTmdUY2lnUjEwN2Q2QXRjYWFnVUR2ODc3MEMwMkc5QWp2WW5YcFFMeEd4L1dnWU93NjlhQlgwb0Q1MEFSWUd4K1ZBaVNiMkY2QmpmYlNnTngxMTJvRU5HTnp0b0tBMUF1ZFBFMEIrM1Q4NkF1YitOQkw0NzlxRENUcHZ0cFZSRWtYR29OQkt3dGNiMERKUFhicjhxQStOQWE3VUJhOWg4NkJrbi9yUUJ2MTEvd0JhZ0xBQzk3MjYwQmZ4OHRyWG9BYWtiOXFLa0JyMXZWUVdGK3ZqVUFkckhxYmErRkF4dFFLd3ZwcmJ2MW9KYWsvcFJUdWRxQmRMN2Q2QjJ2di9BSXRRTW9RUENnQnZRTWY5YUE2SHYzb0FYSnNkenNLQjMzRjlhQjdBRHBSQWROckdpZ1d2YmJwUUZ4WWEyb0h5MzIxL09nTDMvd0FxQm5VNjdDZ0FMLzFvQ3dIeDY5YUExN1hOQWpiL0FCdFFNRWRCUU8xNzlDTnFBdHFPMUE3RDUwRHNkOU5lMzlhQkhmNDdHZ0J2cWQrdEJJalh3Mm9FUjhxQmdDdzZIZndvSHI4S0E2ZnJRSTcwQnJiYmJhZ2Uvd0EveG9EUzVvR0wyb0gxMitBb0M0QzN0cmVnUXYwb0dEUUdvMi9LZ1YrblR0UVBTZ2Q5NzBDdjEzb0dOaCtkQWpiZTlCTGwxSTFOQXRlMUFyZ1dPOUJJNm0vUWEwQmI5ZHFCV0liYXhvSHAzMm9EL0ErTkFYdnYwNlVBU0NCMzYwQzF2dGZ4TkFFMkk4S0IzQjM2VUQzQTErTkFhOU5UM0ZBWE5ySDhLQTQ5UnNOK3RGTUE3Zk1paUEyNi9sdlFLNDI3Zm5RQnVMZGYxb0hmeTlkT2xBQW5ycC9XZ0IrbjRVQndzb0owL09pbzdtaUpHZ0NTM2oyb0Q4TFVDN2RxQmkrOXRhZ0NSc2ROZWxVQjNKNlZBeFlBNjlhb1RiMkc5UUc1R3Y0ZjBvbzZlSjZVUXdiM3VMOXZqVkN2cjNQV2lnQzl2d29nb0R3dDhxZ0NlbDlxQUcrMVZUM1BoL1dvZ0lQd3ZRUk5nYjdkS0tOdm5WREF2cURZZDZpSGRiMzJGVlMxTy9YZWlHQ0wzN0RhZ1REVVcxdnZVVXRlMjIxVkQwNkhwdFFJalRiWHZRQTcvd0RXaW1TTFh2UkJjR3dQNVVVRS9MODZJUU94MjcwQUxXMDM2VUN2MTNBL1dpcEFHMmdOaDE3VkFqdnFQa0txQUVFVzJvSTlMMzA4S0FGOWdOLzFvQWdqNWRSUU1YQnRlZ0NmTm9OTDYzcUNOK240Q3FEWDhEZWdZSFhXM2FnUVArRDNvSHFEL25RSyttbXZoUUdnc0NOS0NOemY0YlVEME5GTDRWRUhXOTdYN1ZRaWRiZm5RQkkzNjBBRGMzNjlhQVlDK255SHhvQzJvc0wrSCtsQWJiYWRUUUY3RFViZjFvb0p1Q2Z4K1ZFSzRBNmEwQllXRjllMVFMcHFmbFZBYUEwN1dIYWdWeHFldmVpa1NMVzdVUVcwdjErTkFBbmE1OEwwVWROOTZJQVJlOXRxQkhXNXVSZlM5QUFpNHQwMm9KY2pZQWkxQWhlMzlhQmN0Z2RyVUJzUitYeG9EOTNpUmUxQXl6YUM5N2JrYjBHTnZEUzJwK0ZWRWJXMjY3MEVnOXhad0QxdlFLMXZBOVRVREo4YlgvU3FHYjI2QTk2QTQzT20zeHVCUU1ycDQ5NmdUWCtlMUFhMzExMW9EcnFCcDFxaVZ4cDI3VUNKMThSVURzQWROdE42QnRvUjIyOGFBSXVOdE9sRklBZE5QQWJYb0pBYWJtL1dnQ0R2K2RBNzZXMm9nQnNhQmwySTFOL0dpaTNmZnBRTVhCNjY5T2xBcjY3MEQ2NldORVBXK28wTkZNMkl1TnFCYmRkTzlBR3gxMkE2MEQ4TGE5S0E3RGVnZHgvU2dGdHFOajBvR0xnNmRhQXQxMjhhQUhTK2wrdEF6YTVGdE80b0FiazMxNm5wUUw5TDBEMTIwdjNvSHJ2Y1hGQWgwRzlCSTY2ZFJRSTdlUFdnQ1QzMG9IL1dnTnI5NkI3ZjFOQS9IcFFJZ2czSjA2K05BL3pQY1VCYzlONkFCNmIyb0R1YmZHZ0wyNmJkNkEwSThmOEFPZ2RySFUwQnBxZm5RQkdsQUQvclFPNHNMN1VEMTY3RFkwQ0IwdlFBK1k3VUV0TmRLQ0pPdmhRTzNhZ1JGK2xyMEJxTmZHMUJJWEpzTkQwb0VRYjNiZnNhQUYvbjI2VUQ2MnRRRmdPdWgzb0FXSS9wUUJCdG9QalFBQTIvT2dkd1A2VVV0OVRSREJOKzFBYTYzL0NnTk5Uc2RxQkFpeHRxMUFibS9qMW9EcVJ0UUJON1hOQklXMTExRlFBK2tHMmdHdEFNTk5EYndxZzBKdGJ4SnFCYjFWTWtYNjN0UkFMNy9oUUlnYjBBZHREcCtCb29OaGJvRFJBQnFmNlZGT3grWFcxRUszeS9TcURTNC9PaWk1MFBqUVBVQWo4K3RBV3RvZTlBYW5ZNlhxSUJiWFRhcXA2Ny9sUkViRC9NbWdDZkMvaFFHM3oydFFTQjE4QlJRYmFkUDhxSVIvUHI4S2dSQXZZOXRhQitYWWE2Vy9HcXBkYUllbDdxTmV0Rk1FQzUvU29oQy9XcXAzMEZyYjllMVFJRzVKNDdWVURBZ2svMXFLWExhcWdHdng3MEQwRytsK3RGSXRiVGJxS0lBTkIrditsRkIzN1dvaFc3YWRhQjZEclFSc05iYTBEdnRmdnBSUnIyOGZDaUMxanFiVUFkYkMxckNnQ1QwNmRLQlhGdFRZMzBGQUcraHZyUUFHdHpzQitkRkYyQU91aDJvaU5qY1cxNzBWSWkzYW9oWDZXcXFqNERUc0tBM3QwMXQzTlJEQkorZlhyVkF2YmJ3b3BFTnkvb2FJUjI4TzlBeVQxMThPdEFybTM5YUFPbzcvR2dWMTMvQUZvQWc5dmhRTVgzTkFpZXA3YVc2VUFTU1FBUEVhVVVBWHVML0VVUWllbmpRUjNOdFFhQmFiZGFCay9oMG9FTlZKNmJVQ045UnQ4S0I3RzJ4b0dPOUF2aDg2QUpQN3Z3TkFYUFNnTC9BSWphZ05EcnY0VUNPb3Yxb0VTTGtibWdkNzZmUHd0UUxXOXR1M2pRWnQvalJDSTZkdHIxUkVXM0Izb0plVzJ1OUFXQjMyUDQwQU9saCtOQXdEYTlBWEpGam9LQUl2OEFvTGVGQkxvYmIrTkF3YkhVYjdDb0YxQi82YTFRV0h6Qm9DK3YrTDBFZ05iSDVWQXRMOVRRRnRmODZDV3Z6OEtLWUd3SUk2MFFqK25XZ1l1RDRVVXo5UHdvRFUzL0FNV29BTUwvQUoyb0FhMjZVQU80NjBFMnVRRDJvSS9LM1lVREl0cVArbEFnYkxwdlFNZm5RUGExQTdDK255b0FpMS96Qm9IY2o5YUEzTit2NlVEMHRjVUJjRVVBQnVCK2RBcmZoUVBwcitGQWE3am9OdTlBd05yMEFkVHBvRHFLQXZ0cFFGdSs0NjBFdENOUjRHZ1d0NzMyb0hwZTFBV3NibTFocmU5QXZsOHFCMmExK2xBQWFiLzZVRDB2Yjg2QTMyRnFBdDQvRzlBWCtmalFLLzhBblFTMzNvR3ZXMWdCM29GMm9Eb094NjBEUGJyUUJZVzhhQXVUcmZTZ0JZblEvaFFPL2hxUlFLMm90b1NLQjNPM2JXOUFXdjAwTkZBTnY4cUlEcUxrMytKb0h0MTBGQUd4dHBRTTJHdTNlZ0JiWFVlRnFCZGZ5b0g0RWZHZ1crMi9VMERGNzZDMm1sQXIyK0ZBOWRqUUszYjVVQUxXK08xQTlTZjg2Qkh0MU92alFCWHJyUU81SGJiZWdRdGJ4TkFhMjhmR29IZTRzZnhxZ0Z4ci9vS0tMNjYvZ2FJRG9UK0ZBQWk5aitGRkFKdWJiMFF6dlliVkFiQzNmVmJVQnlQK2RBcmFYMnZzS3FnSFM1MHFJQ1B3OEtxbUxEYzZkNmdlblRmYWlFVHFiL2hSU1A0ZU5WQm9QR3d2YW9walhVWFB4cWhXSnYzb2dIV3c2VUR1VDhLS0R1UitlMUF6cWZHaUkrRjlEcFFQdDJvQVgrRkFyYTM2MERGOStsRkx0MU5FRnhieC9XaW5ZZE5PNG9oRTMzRmpRRmowb0dMQUNvSTdFWHNCVkVpQ2JmZ0tLTkJwUkNQVUVhOVJRQXNQRHBmdFVFVDRmRVZWUGJTMS9HaUEzRy9XZ0xqYjUwQ0d0KzJ4b0gwRmlOUnVLZ1JJSXNUOE85VlFia0czV29ndHJwK0ZVSWIvQUFQNVZBN2Q5ejAvenFoTTFyYVVCeVBhOXRxQkg2dGFCYVgzMW9BbTNTaWxZMi9yUkRGcjYvRGJ0UlFPMXIzb2cveHBRSnpZM05BdGJrOUtDUkY5ZmxRSURYV2dOVGJXZ1J2VUN0cjF0VkR1QU56ZWdDZHJmT2dpZC9IZWdMbnRyVUVUdnZ2cWZoVkRPbmdhQU91b1BnUENnUzhkZjhHZ0JZM0dwdFFMYlhwUVB3NlVBUm9TRGZzYUJkYlgrZEExK0YvRHhvQTZrNlcwb0VMbS93QVBsYWdMK0ZBYjk2QU8xOUtESVQ4VGFnV2gxT3QvR3FpT3YrdEJJV3RyUVA0ZlRRRjlDT3Q5ZGFCM0E2V3ZRSEsveHFCMjdENWlxQVh2b092WDlhZ09nNjZiOXFCZy9FSDRVVXlCZTE5YUJFanBlL2hSRFc5eUQxNm1nZHhjOGR1bnhvRm9OQVBqUVNINDZVVXhvVHJyMG9nTnVueDhhS0xYQjMwb0VOTCtGQklFY2Izc2ZDZ0xhNmEyL0NnQUxIYTNlOUE3Nlg3VUJjWHYzMXRRUFQvS2dWeWJkdkdnZXBYV2dQbnZRUFVHM1hwUU5oOHFBMnY0OUtCZzYrRzFBdXR4dHA4NkJ0WWZyZWdCb0w2NjdXb0dMVUMySTc5NkNRL3dLQkh4QnQrZEFXQi9xS0JqcGZib0tBQUh3TkF3TGkzVy93QTZBdUJ0K0ZBRHZmNTBBQ0wvQU5hQmtqcDFvQVgvQUEwb0FrMzhPMUFHOTdEYy9uUU1HeHNhQXRlMTlCME5BRW0rL1hyUUhTdzJvR1ZPK3RqUUxYYnB0ZnJRT3kydnBwUUF1UmY4ZmpRQXVPdHFCaTE5UnBRSTN2MFB4MG9DK2w3MFVkcUllbGhwclFGcmRhQXVkZ05PMUZGejExb2lWLzNDMXZ5b0ZyOGROYUJzVDJzYUJBOWZHZ1pJL0dpalM0djEzdnBSQVc3NmpvRFVVWDEwTjZxRllXb0dMV3QxNlhvRi9pKzlBK3Qvem9HYjdIU2lvamZUcU90RU8yL2NVREIyTng4YUtHWWtXdjhBUHdvaGZMeDNxQXR2MHFnSnZ1YldxQmk5clcwN1ZRRFc5OWozb0Zwb05yOXFBMHZyOHFBNkhTK2x2aFVVOURwcUwxUWlkTjdDaUhmUWY0MG9wYTdWRVM1WHQ0YlZWSFhmVHRSQzAzT2xBRGEyeC9Pb0M1MnFpVzR1S2dqYlcreFB5b0RrTkxiOWFvQmYvV2daRnpwdFFNQWVOdTlRTFEzdHByVlVDMTlSeXY4QWpRTzQ2YWVCb0V3L0R3b2dBMDBOQVdHZ0oxNjNxQmVBTnh2VkNKN2VGQWRLQmpxZEFMMERJSUhlb0lnM092eXFpVnROL2tLQlhIWFk3VUFOYmE2ZU5GRmp2djhBNDdVUUVuNDk2QTNKUGJhZ2liRWFhSHRSVC9icC9yUkNVNjJId05BRzQrQjNvQzlqNFVESEhqZGIzUFNnUkhYWWFhVURJSnVkZ08xRkxyMUhoUkMydmM3ZGFCM0Z2SGJUdFFBc1RxZjhHb0VUb1JyWVZRaURwdFlVRHRjMjZVQVZ1UENnVmlBZkVhZktvQnJDeEd2VzNXcXBhRTZHL3dBS0lYbXYzSFk3VUVnRjc3alNpb2dEcHJRTURRMjAxdFJDTFgzNmIrRkF1UjZkNkExMTExTkFHM2ZUWW40MUFBTHhiWGJwNGZHcUYrN3czdlFQcGJxYUJkTDdkcUJYRy9mclJVVHZwUkFTTndmbmFnQ1NkQitWQURyZWdSM3VQblFHdDlkZW1sQUFnanNPdEFOeDNHcC9BVUFXb0RvTEhVN2diMEQyRi95b0VHdTN3MlBXZ1J2MTZkcUF1ZGh0MG9GcWJEOFFhRE44alZSSFMrMmxBRVczTzlCTHJxTGVGQUEzMjZINFVBVFkzTzQ2VkE3M0YveHFoQ3dPaC9BZEtDUXQxSGhidlFGZ1FQRHIwb0FYSjhlMUF3Mmx1eDNvQzQwdnRVVUhmbGExRVM4VG9kcUJBWFBjVVU3VzBGaUxVUWRCMzZpZ0wzSjZVVklFNjdEd29BbTV0dDNvRFRqNDBDNjlxQjY4ckdnWThhQUxBbnY0VUQxdjQzb0dOamZRZHpRR2w5UHdOQStlaDEwTzRvRmNXK1hTZ0FDUDlLQ1pOd0J1QUtBVTdqclFJMkYvenRRRmlQOEFLZ1pZRWl3dGJlZ1Z0TGR2NjBFaGJlZ05ML2xRRituNVVEM0EzTnFBdmM5cjBCWUFhMEJwYTRPbEFiZjArRkFEcUJ0UUJOdE54M29IdVBHM1NnUTIzMThLQ1YvRFRyUUJOci9uYndvQTc5cUE1YjBCMzErVkF3QWRlblFHZ0QzOEtDU3VWRnRxQXZwcFFMVTc3RHJRTWs4UnRhOXFBQUpGaC9nMFV5QWRLSVJ0WWJnL0RwUlN0MTB0UkQrSjI3VUFkOTl2NjBBR0hocjNvSHRhL1dnQittOUFiQzNiZWdRdnZRU1B4MDdVVWhZR2lBaHZoUUEyNlVCYm9SZWdaNzBFUjJ2Y21pbnJ0MDZHaUdibTNUcUJRQzduUzUzb0IyTzlGTWQrMUVMVUEwQlk3ZHV0Rkg1ZU5FRisrdmVnWXQyMUF1YUJhL0MvZWdrdHJlTzlBQUVBMitkQkhwZWlpK20xN1ZFRmoxcXFEcnBidzFvR2R2RS9qVUN1ZjlLSUw2ZGgyb0M0RzlWVEdodmJTb0M1QThlMVZDSHcxcUNXbTlxb1p0YTE5TzFRUjFBMTJ2M3FnT3VuZWlpaUMvOEFvS0JhMnNkN2IxQXlHMTArQm9wazZWVUs5eHRhZ1lVYTYyb3AzMHR0NDBSR3gyT29IVHBVQmE5eDA3MEQzUGdlM2hWVkVrZjZtaUhZamJlZ090cUFKWHBleHNiMFU3bi9BRE5FSysvZjhhQXViV3RwVUM1RTdiOTZLTEcxK3A3MVVHMXh2ZnJSU043a2ZuUkR1RC9XZ1Y3Nlczb0dQSHRyUUs0dHI4Z0tCZUk2YjBERGJBYUU5YUFON2JYRyt0QUhUeHZRS3g2NzBDMHY0MEFiL0Nvb1BHM2lLSUNlblFiVlEwdmUxOTlLZ2ZpMytMVUN1Q2ZIcUtvUkZ0cUNKTmhSVE5yZjBxSWpiVzUxcWdON2o4NkE2MjFvRVQvMW9IYTROaG9hQmRUYnJRSFMrOUFFSFcyMjlBcm0rdzA2R2dRNVhIWVVVOU52d29oRW4vU2dEYmpmV2dSTnlkZGZEdFFHaC9vS0JhbTloNDYwRDFzT2wrOUJFV0lzYmtkQWFnQWRleDdWUWFnNml4b0RTK253dFFMUy9ZRGJxYjBVL2dkQ2FJWnRiVzU4S0JFMjZiLzFvSHRwZTVvRXVvdnZhZ3lNZGQ3QzlWQ0orQjYzb0hZYkEzTjZCMkhIZTl1dldnWFQvSHpvRFQvTVVFN0FEYlhTZ2lUNXQ5OTdWQVczN1g2MVF6dCtOcUFCQTErVkE5YjZyWWpyVUVnVnRyMTJvcUcydnk4TmFDUU9sdTIxVkQyR20rOVJScmJ4b0hZL09nQnRxTktCMzZrZktnTDY5NkJzQUJmcjFvQ3hPKzNVVUFHK2ZhZ05kd2RQeW9KQWkxeDExb0FFWDArVkE3YjZiVUMzTjlyMEQ4ZjIwQVNCWW5XZ2FnSGZZOVI0VUVyYTNIeW9FTFcrUFR2UUZqMW9DL2xHK3ZhZ0wvUHFSUUFPcG9HUjE2MEJjMitXMUE5RHR2ME85QTduNWRhQlhGaDFvSGU0L3JRSlFiNjZIYlNnTDk5UGhRTzIzYmVnZjlkYUFHL2orZDZBSW9BSC9XZ2QrKzlBTVFCb1RmZTlBS2JrblluZWdENDc3WE5BRTZYb0N3MzZVRHY1YkhZVUJlNC9PZ092aVJRQkorcjkxQklQYlRwK2xBRml3SHp0UUxjN2EwQ0lQeTZpZ2xiNVhvRU52RytscUEvS2dkanJZL0dnZmlSYWdXdmI1ZUZGTHc2VVJLeG9FTkR0b05hQVp1dHJVQUxuWHQxb3FWKysvaFFGL2tSdjFvaU8xdTlBK2w2S2xleHZhd1BqUkViajVWQWFrVzY5cXFtQ0FCNDdVUXhwMHRRSzJ4MlBRZUZBS1FMNjY5S0F1YmlnZWg2Nm5lMUFYQk9tL1dpbzhqK0ZCTUhsdm9lL1UwUkhsYzZkTktnVjlkU1RmclZFdW45S0JYdnYvclJUdnBhd3RzYWlFTi9BYVZRVzgxaCtOUUJQV3FBQVd0L2k5UUh5MG9DK2h0VlU3NmVIV2lHZHZ5dlVFU2Q2b2RyK0o2ZEtBTnRyZkdnTG53cUEwL0dxQytuK09sQWEyN0FWQVgyMXRjVlZNSHkyL09vQWxqdjIwK0ZVSTY3Q29ndnNldEFBaTNlMUZHdTJsNnFEcGY4QU9vRVQxTlVCc1Q4ZjFvcDZXSDQwQUdJc2JYdlJBU2I2R29DeElKK2Z5b0ZiYTlBRWdiL0txRmNnN1VVQVhKdFVRNzY2NmRxcWpTM2Z3b0VScDVSK0ZSQWJuZlR2NFVFZmgwcWhrM29Eb1RyZnZRRi9OUlFkZ2Ywb2hhV0IzSW9Bay8xb0ZZL0QvSFdnTmRpUGxRU0owL3BRUkIvd2UxUUJKWThyaS9RRFM5VlVkU1JwcjJORU0yQkE2OWZoVUJ5OFBDMVVGeGY0YlVBUWJnbmZvYUNOemZTZ2JNU2I2WC9QNTBEQU5pVHQzdFFMVDhONkNKUGhwUUZqY2VGUUFPdmIvV3FFTnFCZ2cvSDlhQlgxL1dpbGJUdGZhMVFMWTlpYUlkejhSVkMxSFhRNzBDdDMrUm9GYnFkdkNnZGp1ZmxhZ1dscmFXRkFEWFRZMEJZRUR3MitWQS9FSDQwQzZpK3g2MEJvVFlqZmFnUEVmOUtDaXdLM0dscUlnYjMwL0dxQWFkZHZsUUIxL3BRRzQ4RDhxQUlJQTEzM0ZBN2RoYy9oVUFBYmVIZnRWREl1dEF2SGUzZW9vN0R2K3RFUzYrTkZDaTVHbEVGaGZ4SGFpbUZ0cjg5YUJrYWEvblFBMU50cUJrRzJtM2h0cFFGci9HZ0xFRVdvR2VuVHNCM29FTC9FZDZCOHVsN0FkYUFHdW5iV2dtQmV4YmJ2YWdSQXZwUUF0OHFCa20yOTc2MENGK2xCSzJ0cUEwNzdVREFPaG9HQnA4YUFKQTFIYWdZSElhbTF0alFLOXpwZngrTkFXMElHaHRRSWZuUVNQUzI5dGZHZ0IwNmRhQXQ4ZjBvRVZzUmZmcFFTL3IyNzBEMDA2SHJRS3d0cjBvSDh0T2xBMWF4MDI4YUNUS0FMOWUxRlFOcmJhVVExWFhiZitsQUFXRjdrL0NnTG5XM1h2UUY3aldnZXB2WW5TZ0JiVUc5aCt0QWJBWCtSb0EzMnY0M29wbTF3ZW5UNDBCWWI3MFFXMVA4QWpTZ1BscFFIRnJEVHhvQUhUNGEwRXl5OXIwRWRSZm9kL2hSVDA3NzlhSVBMY2diVUJZajViRTlLQTh0cjlLQXViY2QxdmY1L0dnWDY5RFFIUUMyMjJ1dFFUNlhKMHFxaVRwNGpyUkFDZjlhQTN1QlFQa2JDMm53NzBCcllIYWdWOWV4RkJJQVdzVHJRSThkUDBvQWpYdjBvcGkvUzVvQWcyc1FkTmhVUWh2M3FnTjl0K2xBN1h2cnIyb0ErRkFyamlMYjBCMEhmdFFGdXBvRFc5QU1MVURGeU52blFCMEoxdWFCZzZiN1VDR3Z4N1ZOQnFCcWQ5YlVCMjMrTlVPMWpVQzF0cHYycWdCMS9LaWpyOExVUUQ4dnlxQjhRT3Z6b0RVVlZCT2x5UGhVUXR0aDhxb05LQ1RFbncwcUF2WUhTL3dBS29SMDAwUGo0VkFyYWI3VlF5YkN3MG9vdnA0alkxRUFQUWRkYXFpM1kxQXJqNUh0VkI0OXRxaURXMmgrVkZNWHZyYWlEVGNHeDdVRVJZa0UvbjNvR1RmV3c4Q0tLYWk0ditkQXlMQW5lM1hmU3FJTWRMMzNvR1RZRFR4MThhSVhVZEJ2UVBrYkVmNHZRRnlQNjBCMnZyNFVVcnQwMHRSQ1hyM29BaTJ4R3ZRVUN2dWR4MW9vSk4vQTBRZGUxQStuNVZGTDVYMTBxb0QxdHFDTkRRR3BBdi9yVUFkckVENVVVZ0RjWC9FVlFtdjAxSFh0UkNQY0NnZlQ0ZEtCWEZ0TlFmeG9IcWVtdldvcFgwOEJSQjRhbnRWQ3VlOUFkUnBwUUIzNzloMG9GcGI5QlFCQTBQem9Ba2k5cUFHOSt2ajBvRnJleG9BN2FhOXlLQkU2ZUpvb0pGemM3MFFnQmZUUTlhQkcybHp0ODZBMEdsci8xb0hmY2tYTkJFbTE5TDBCYzJ0YTN3MU5Bd0Q0YVVDMjExTnFCZ2FXUFhyUUkzb0FhK0hZMEIxSCtMMEQ2ZGp1VC9TZ3lXQUhodWFxSTYvOEExN2ZHZ0wvaFFPNTFINDlLQjN0Zlg0K0hqUUFPbitOYWdkN2tEclZEWGZ3RkZGL3c2MUVPdytYOWFLQnIwc2FJQ2ROL3dxaEFrRTIzb0Fsdi93Q29VRTdEZjgrMVFJdHJhK28vSFdpbUFDTjlQem9KMkoxdlFSdHBlNDhLQVBpS0lkKzQ2MEFiNjYwVVg3MnQvbFFTdFFISTJzTmoxb0FqUUcydEFFNjdmS2dlblc5QXVXbW12alFNRFc5dmxRU3ZZYWpXOUFYT3dOaFFLOXRLQjMxTmp0UUt5L0x2UUJPbDdlRkJQcGEzeThhQkFFYm41VURKK0k4S0FHL1MzK2RBYVhBSjI2MEFRQnQ4cUNWcjNCL0tnZHdkTlRRSzU2VUNKNzZYMW9Ea1I4NkExNmJiVURYVThmeHRRTXJZOGVtK3RBY2diQzIyOUFEaitQVTBENUFmNVVDQk45Ymp2UU1jYmp0MG9HZERZN2Q2QldOdTU2VURCSFVDZ1lGdGZHZ2FGYmViV2dSSVB3b0krSTBIalFQZlMxNkI3Q2dpTGRCb1JSVTdBQVdPdmpSQU5UY1VFaXloUU8rM1dnamNIeTBCeEZBaVQxTzlBQzNTeDhLQm05cjJCRjZBTnJudDJvSGY4YUJhZHRLQjZkckUwVVh0cDBvaGtXMTJ0YTFBaU5MWDMzRkZHMUFNRnNCdmZlZ05RZDlLSUwzM056Mk85UlRCRnJXTkVJWDAwdDhLb1l0YnFXMjhLQmZPNS9Lb28vcDJxb09ueDMrTkE5aHYrRkFDMTllbXdIalFESC9TOVFOZGRMMjhCUVJOcjI2OTZxblk4YjdqdlVDdTE3N1ZSTWVZYW1vaEFBNzZDaWpZWDB1YXFJazJxQVBqL2xRU05yYTcxUWVVZUY5NmdWaDN2ZnBWQjg3NjBVOUxkNmdOdGV0RUJKNmIwVWFYMzBQNWZHcUEyWHBwZlFVUXYzZnJhZ0w5ejRHOUFBdDMvS2dMZE56UlJ0ZnFPMUVQallYSUhoVUMwc0RzM1hwcFZVSGY1MFFFWDhhQkE2alM5QUUzTkFhblFmQ3hxQjdibndxaGhyYmJtb0VUMEJ0UUJVY2Q5cUJhazIvZDBvQW5TMjNmeHFnSjF0K2xBWDdmQTBDMVBUcHY0VVVDKzNRMFFkTmRMRFdnVnplL2Z0UU1uNEMzZW9FTGFEdFZBTDlmRzVvQysxemZ3OEtBdVJZYlhvQTJ2NENnVnp0MFBUNDBVRmlQOGRLQjNicHJSRWJhVzZqdFFIZnNOL25RTzE5ZXdvSWJiRFkwRWhwdHVhZ1IzcWhkZXArRlFNZy81M3FxUUJKMTJvZ0lPMXJDMUZJbnFkS0lCWWFDZ2xkUWROZW56cUJXMEZ0dkdxSWtkdmpRSTNDanFSdFFNbGVoQnZyMm9FYkczWDQwRVNiMzhOcUFVOUFhQjZiWDA3MUFpYkhYYXFEUUEwQjI3OTZCQTllbmFnR0pOZ0JwZmFnWTN0MXZ2UUdtMTl0eFFJRW13dmNVQmNuL0FEb0FXLzYwR1JyZHFxRmY0L1B0UU8ybjZDZ0FRRHJyUURiRS9qUVBVNmFFZHFBc0JmdzYwQUNRTk42QnFDVzBBM29KSFJ2SHFlbFFIdzEvUGVnV3AxNmJVVXdiZjUwQnNOYUlZWFh2M29xTmpheFB3b0pDL2EzeG9IY2FBYTlxQjMxSGgzb0dGSTZHZ1FKQnZlNU5FSFcxcmYwb28xdCtRb0hianIzNlVFbElKc2VuYWdHdURmY2RMMEFBTGJlUGVnTkFmQTdVRDAvek5BN2IzMXRRSG0rZEF3U2VsQkVBWHR2UU02SGZRVUVyZU8ydytQYWdZSGNVQ3VWTzNtb0M1dlFHbmY1MERBSkJDOWQvbFFJRWdrVUJjWEY5ZTVvSkFnYi9BQnRRTVdGQWJiMEN0cDVxQkhmUS9PMUJMYlM5QUR3b0MvYzNvQUhyMEd0dTlBMk53TzRvRDUyTzE2QmFHMzQwRDNIajFvSkZtTnJkTzlBRFUzdlFHbXR0ZjlLQkVFRGpwUU1kUjE2Q2dkeVJiODZDT2x0clVFZ3BPOUZHNTdXb2hIZlFVQWRmbG9hQmtkenZRSFhmZnBRRi9uZnBRQU90aWIvQ2dMNjJGQUVBYW5md29IYmNIUVVCMU5ocUJRTWtuV3cxNkRhZ2plMXdmK3RBWHNiaTFCSzVPcFB3TkFybS93QWV0QVhKMTI3ZktnUDB0UU96YlcxcUJYc2R0dWxVQnZmOUJRUHBhaWdFRnIyb2hrRFMyM2pRTFFkYmdEZW9GYy9qL2pXcURjYTFCSytnMkZ0RGFnTGpjYVgzb3BIeC9HcWhpM2Jhb0EyM3RwUlNBRy9YdFZRRW0yblNnTGl3dnY4QW5RQUJPMjRvcCtKSnVkelFBMXZRSVh2WTN0UkVxQmRMbmJ2UUdndGZYcnJRQTVFMzY5QlFBSFVENDBDSko4TDZHaW1lMjU2ZjYwRERINS8wcUlEYTl0amI0MFVpQ2V1aDNQalFBdDJHbFZCZlhVZkcxUlRCRiszYXFBbmNBNmFFMUVMa092VGFnUHo2aXFwOGJBbnIwb2hhamJYcWFnWUI3WHRWVXJhMzZVUWFBMko2YVZBR1JqcHYzTkZMbFpUdHJvTFVCNERwc2Y4QVNxZ0F1YmJtL3dBS0FJRnJXL3dLQXZhL2JxVFFHcmVhMis1RkZMVFMreHFBc1JwZTQ2ZDZBMUlPbTJsVkFBYjJ0ZlRVZEtpa2I5dGUxRUZ1K3ZoVkQvZGNYRjlLQlhIeDF0UUcrMisxcUtDT214NitORUt4Ry9TaWczdmZTaUFhbXhzTzNlb0VmeDdWUXhwMlB3b0VRTGFqNTNvQTdIOWFCaDJIMDBFZVhtMUdob0Q4aDBvRnRib0tCM3VMVytGUVJ0YitsVU8raDZBYmp4cUtqc3hOdmdmalZSSUFrYkVBN2ZLb0lrQUhlcUMybGhiL0FCMW9Jc1JiVTI4YURNK1pFSldnNUQxYlhBb0svYnBwWkkyWnlDZVJBMXZvTzlBWlh1S1J3eVN4ZnllbG80R2xxRFJCSnpRTWV1dEZXQmROdkUrRkVCQXQ0VUNzTmVsOUtBTmh0dURhZ0JiWDlSUUpoWTc2VzdVRDZiWG9DK21nb0M5N2RQMG9FZHJXdGJjOWFCbXd1ZngveW9GOE90QmtMYTc3ZEJWUklFZnVvSUMzZXc2MzcwRWhlM2ozb0M5dmgyb0dkZjhBSFNnZGlkclVESUlHK25hZ2lmMS9Xb0pEWGI4dTRxZzFON2FrMEJZWDEzdG9hQUJKRitvcUFGNy9BS2lxR0NSYnFiMUZGN205L0h0UVNBK0pQV2lFQjNPbjlhQ1FCM0p0UlFCWTc3YjJvZ1d3TnVualFINW53b290cnFScm9UUVMxRkFHMnV2WFFVQnBjZHRxQTBGN2ZsdFFOUnVkeDRVRWh4dnhQVDlUUUsrdEFXM1ArRFFNYjY2ZkNna1JhM2VnRGJ1TGVGQWdUY0g4NkNWN0N4b0ZZZkFVQ0l0L2xRR3ZhZ2ZJL0NnZWxyOU85QVd1TlBpVFFPeHQrVkE3ZVh2NDBDdmE1UDUwQWJkTnoxb0QvR3RBOU5ML0FDSGhRTUMxclVCZlVEcDBvQW0zWGZwNFVBQUxrZHVwb0RhZ0R2MkhVMER2cHQ4NkF1T3V0Rks1dllXNzYwUkxheEZCRzQxdGVnTHJidDh0S0JqVFRTZ09tdXBKb0dia1hKT3V4b0RiVytsK3RBeXd0cDhhS1dwRnoxM1BqUkRGenQrTkFyYTJHOUEyQURXRnZsdFFCNVc2ZkRyUUlEVGUzVFdnZTV0ZTlGSFFXOGFJU2thOURRU0YrOXVsRkJHdFJDVTlEVkV0QmUrdjZVQUw5TmZEZWdOUnRSUW9zTlI4QlJCWWdrQytuUTFBRzNVOUtvVnhiWWlpbmNFZnJlaUVMMzFBSW9KYm0vVTBDSGliV3FCV3Q4UlZEQzZIdHNhQVBnTktnRG9UYlQvT3FvL1dnTDllKzlRTzY5YmkvUVZVRzVHaEZoK1ZBQldJSkdvRzkvR2dOYkMvYWdRTnI2NjBFZ1RiU29JWDFKK1ZCTGtOdjhmQ3FwSFc0N2Q5S0lZSGxzUEc0b0ZyZXcwdFFHdlQ1ZzBEQU92WHg3VkF0TGp0VkFUYS9lZ2U1dDFxQUtrSGZhcW9IYnJSQUFDU0R0UlNzUjRHZ2tPSkdnczNXb0VXRnJqWFRicFZRZGUybEF0djhYMHFDVE5jQ3gwUFFVQzVEWHR0clFMcmErK2xWVDI4TEhXZ1JKRnJVUWE5cm50UU81QnZ2NDBDTzU2VVVlVzJ1L2FvQTZhanAwb2hrV29GYlE3Z1ZRdFQwb0E3alNpbGExeDA2Zk9nZTF0TDloUUp0dFA5YUlCdGZmc0tLQTFyaStob0ZjYUd3OEtJWTc3L0FKYTBBZFJRTmVGdk50UUxsMitWNkNKMXYwQW9BRUhiOGFnYkMzZit0QkhTKzJyYjFRRUFFQ2lrUmE0L0xyUkFUMnZjVVVqb2ZqYTlFTWthOU5xQUIxMnYyN1VVaWJ0ZlFIcmFpQWl3dUJicnBRSTZYMDEvcFFTdVNOLzhxQ1BRMERzdHdiMjhkNkRsZS9NaTRMOHBPQnYvQUJtOWlXR3cwNzBoWER5c243ck54Q2l0NnZwcS9Ic3dQSUhUNEVVUnI5bHk4ajdtZUJsUUl6dExIeDBJQjFzdzN2ZWl4anpNaVlZYzRVTkdKNWlIRFdGZ1JjZmphaVIyL2IvY0l6RUZPeWhWTDkySXZSWFNWZ1YxTmlldEJJRHgzL1NnamEydHhyM29EWHYrZEFpRGNhYjlhQjNOdC9BbWdremtBa0FEUzJnb0kyRnR2OHFCQTMvcGVnZTF2RGFnQ1I4UGpRSzJtMUJrTnVWeCtkVU1teTJHL3dDZEVJcVJzTnFCMzExRjdkS0IzMU9saGZhZ2V6YWkvaFFCRnpmZnJRRzF1NS9DZ1IzN1VFcmkyMWo4S0NJSkJ2YWdtVGZjQVcwb0VRQ0xqUURwUU80dGI4cWdRN2dhYjZHaW5heDEzb0pBaTE5dkdnTEVFbTlBci80RkJJSC9BRi95b0M1TjdhRTkrbEF3U090QXdyRTI3ZERSRElzZGRTTktLUU5qcWRMMEJwYnBRQzkvd29KQWkydEFya0VlTkF5ZGgrbEJJcU9PaDMvQ2dXMTZBNVh0dWV0dTFBMUIyb0FpMnZXZ1hLNU45NkIrSjErSGhRQTExM29HZDc5OWhRTGZiYzk2Q1IvNjNvRVQ4ZHFBdURwUU8rdHI2MERBTnFBSTBGdnlvSG9WdHBwM29FYlhJdGVnWUhRVUJ2MVB3b0VCditkQkt3T3cxOEtBT3d1TmFBL3dLQUJGdGR0NkJDOTc2MzcwRXQ5OWhSVEo3YURzZTFFQld4c1R2MFBTb0Z1UDZWUWdMRVg2MERCMTIwSm9KbGxLK1hTZ1Z0cjZXMStWQWlhQU81b0RhOXV1bEFBZEtBMTBHNEgwMEQwc09wNlVBcElzUnAzNjNvby95dUtCMjh2YlNnUTB0YTkvem9nSUZ5UHdvSGUydGhiYWdWK25TaXBBWEIzc05hQ056ZSt4b2gzSkhmcWFBTGZLaXBHeC93QTZJUkp0ZlQ0MEN0dnI4YUtaR2dKK21nUUErb2FXSDYxRU1DMituOWFvWjNGdTN4b0VRRGJlb3BXc1BIclZENWVXd3RiZW9BRHJ2VkFUcGUzNTBRYUErUGVnTCtXMjRXOS9qVVV3U0R2MDNORVMwNjNBNjJxaE1wQXZ0ZmFvcUZpTlB4TlZFd0RzUmEvV2lsMFBnS0lDUUwzRkJFM3ZxS0JxYmZqUU1HOTc3YjBDSFlmS29HUVIwMThhcWxjZmdOeC9XaURRZU85QklXdHI4elVBV0pxaUlOMkl0djhBbFFUdjJ2dlVFRFlBbTlVTzNUWDUxQXIySTJ2MHFnSnMxdndvSFliai9yVUN2ZlhYNDBCM3ZxS0FzUUxpcW9KSFRVZU5FQlcxcjNzZHFnZkplbjQxUXJmTTBBZmhRSWE5S0IzMHZhb0hjWDAxUGFnam9XMU50S0F0cmZ0VlVlWmhhOTdVUWhwcWRpTkxVQU5oMm9KZVhqdHI0VkJIYjRWUURZMjNPb29wSFRXMjFFQTBCNmVGQWRqdjJ0UUEzUGJ0UU1MYTNnYUtqYlc5OVIrRkVJYU5wdDFvSkxxZE51aDYwVXJrSDRHK2xBcmFrOTliMFFyYkE3ZDZCNjc5S0JMZmNpMXZ5b0ZxYjIyb0RTMmcxN1VCYTl1cDhLQkV0YlU2YjFGRnZINFdxb2V3dit2ZW9BaTJ2VVZSRWthQ2d4KzY0TWVaaHZGSU9RK3NjZENDT3hvbGNqQjlza2doTVp5R0x3eGl6amNNU1NOOTdEVFdtR3VmZzR2dWErODM5VDA0M0tsbkEvN29Hclh2MTcwcXhIM0ZzY0dYR2pzekdabmtWbTFQSWVYVGMyYnBSSXNoOTFUR3djWU1uR1VNR2xERGU0dWVOcWthMTZqRW1Fc1N1QVFyQU1MNkd4MTFxb3VCR2xBMk9sZ0QrZ29BNjlMRHRRUjE1YUhUYWdmUy93Q2RCTFE5S0NMZUc1MW9GWURRZHJmT2dMZFIyb0VwME8rMUE5Kzl2Q2d6SFFmR3FpSUdsKzlBRS9Md29KWHVmaFFIUW44VFFGeFk5dXBvSTMwOGI2VUR2K1BVVURHbHUxQkp0ZFRwYmVnUkFBMDI2Q2dCY2IvbFFBdmZjL0NnZGhhMzUwVTdDM2NkS2dMZ1cxc0xVRWxXN2FuVHBRT3dGNzZrNy9DZ2l4UDRkYUI5TnZnYUlCZTUzSjdVRE43NmFFZktpbnJlaUMvZlkwVUE2OTZCMjBKdFFIVDRhM29HQ1JyZlhld29EbHY0OWVsNkJYUHdIVzFCTUZyV3ZiclFSL1h3Mm9KZVcxeGZ4b0VUNC81MEVyOUxmRHdvRUJycjFvSld1ZE4rOUFhMitHMUJFdFlIOWFCNlh2cmJ3b0pYRnRxQmdjbE56dDFvRmRlOUFqcGJ2MW9IY2p3SFRyUUFQbTcrQW9DNFB3N1VESklBQi9DZ1l0YlhRN0VlRkFhZ2RUcDEwb0dxM1czYWdMZkszV2dWenI0OWFCMzB0YTVvRjE4S0I3RWEzdlFHaHZlL3dvSGNjdGR0cUJIY0VmNC9HZ0JheEovRHdvR1RmWWFub0tCL25hZ1hJZ2o4NktMOTk5cUlZMDMzb0M5ejI4S0JkUjQ3MEFMaTk2QjN2ZXd2NFVBUUFMVURJNGdIdnFCUUw0YUdnTmZENFVEUEUvU1NLQUF2c05hQUJPdlMvU2lnYUM0MjZYMDFvaGttK3AxNjBDYmxjQ2dkN2pVYlVDNjYyT3U5QXdidHI4NkFOellucDJvb3QvZ1VSSmZqcFFSTysyd29DNUpHbW5ZVUR0WTZmS2daSUFBdDhUVVZFRVczMW9obTNheHR0VkR1UDJuUWJqeG9BZ0VHZ1Z0ZVBXZ1JHcDN0UU5TQ1BqMXFDWkMyMHZSVVdZOWQrdEVML3JWVTczMC9HaUVCWTBBTGtEWFE5YUFHdHllKzUzTkFBa05mZjQwREIvMW9FdTkrdEZPNVAxSFNpRFRVMzBxQ08zUzQzSnFoM0l2b0RiWVZGTUtMZENkN1VRaWJiZGV0VUFKQTczRkZPeHZiUTIzSW9ndmZiNEh4cUtSQTQ3Mkk2ZDZBODIxeGZhOUFHcWgvbWFpa2JmRzFVR3Q3VkFIYzZiOUtJUjdmclZVQzI0M05FU0JXMnYxZHFCZE5CNDNvcEhwMUZFTWxyZVBYNFVDQU8yM2VnQmE5dnpvQWtrNkczVzFBdVMyMTNvRU52SHFEUU1FNkhhaXBjdkxxZk4wdFVSQTNPbzE4UENxcGdxYmdnM0d3cUlBUUIvamVxcEVHOWhVUXROUDhhMVFFV05BOVFMMzA3OURVQ0xXSXRvUlZDRnlBTjZCbXhJSk9wb0FjZ0xnMzZVQzdhV0pvbzdmbUtJTmRqOERRSzFpZGQ5YkdnVEMyMWlCUUlEWFhYeG9EUTIxc05iVUFkQmFpalhZL2xVUUE2Ny9NMVFhWHRyOFRRTGpjMEdQM0hPanc0akk1MEFKNGpyNFVIbmYvQVBJbFhJTDQ4VE1jZ0F0eUJzbkFibTNUV2c2bUxteFNzWldDZmM4QlpMNjh4ZlFmR2c4aDc3bTRjODVXS0dWTWtGeVpvaDVoL2RjOWVQaFNrUjluT1NZSkVZSElMSjZVQWF3SUY5ZDlxZzkxN1ZFWU1PTkpINVNBV1lrN2VIeXFqY0w3Z2pYci9sUUZ0ZGRhQjNKMlArbEJFY3QveW9BM0kxTnpRUHk2WDM2MENCTjlQbGZVVUNJSTM2bmVnZHowK1ZBaU5iL0lBMEFQRWo1VUdXNjdNZHhWUWlSdXY1K05BYVd0YmJvYUJpNDNOalFTMitGQWlSZjlLQXRhM2FnQWRMYTY5S2dkaHYwL0NpcFdIVGJmOEtxRnJmYlMxQklFaTUyTkFnTEh3M3RVRDh1NC9DZ2JMY2NocGJ2UlViRGNmTVVReFlBWDIydlJUdmFnQ1JiWGVnTG4vRzlBeGU5K3ZTaUpBQzErdEFoZlFIOEtLTlRyZlhyUU1FQzU2N1VFajJHbmZyUVJDMzEyNlVEc0w5ejF2UVBpZnA2OTloUUduK3RBVzF2ZlEwQmJxRHIxdlFQcnRjQWIwQURRTWtmNjBENDZhYjlLQTE2YVVBV3Z2djNvRnVMZmxRU0NrblFhR2dDTEh2YWdSMTYvSTBFdHRyVUVkamY4S0JnaS9qMG9HUVB4M29BblMzNDBDTmlRRHYxRkJMYjQ5S0NRQ2dFYmo0MEFRUUxnMEViZk9nT1J2Mk5BZGIzdjNvSHBmWGVnRkY3QWFIZWdkdXQ5ajBvRVFkZGJXb0dkeWUzNFVEUUVzQnY0ZGFCR3cvSGJyUVNVanJxS0NPbHplOXQ2QjJ2cHBRU2YwOUFtNDMrTkFFRGlMV0lvRUxiazc3MFVDM1hhaURZOWRPdEFXM090RlNVRzkrMUFFZzZHM3hvaGJuVC9BQmFnWXVMalRhZ1NpMXlmblFGMU9pajVWRkluWFVYUFdxaGdIcHFScjhxS1lGeUJ1UnNLSU5DVGZhZ1JON250UUJMV094RjdWQklNQWQ5ZTFBbU91L2hWREExc2RmQ2dRQnRjYjMvR2dPSkhsUFhidlVVYldJUHhxb2ZKbUF2cmJyUUkydmNiRGFnTC9uMW9BWDFBSTdtaWdYTjdmNEZFQjdiZGhRQUl0dGZUUzlCSmJLYkhyVUF6M3ZicFRCRWFuWFVuWTBVNzZmUGFxaGdrbXhJSGpVRVNiNzZqb0tvQ1RwMjhhS2Q3ajlUUkJjQVd2Y2Q2QkFkT25laW5mWmZIUVZFUGxZNmJuUWlxR2hIVWY2MUZJMytOcjBRN1hXNDI3ZHFvWEUvQzFRUnRycHJidlZESHdIZ2FCYW5yUlVpckFiSDQwRVJ2K1ZpS2dZSHlxb0FUZitwb29KSUovTWY1VUJlOUVGaUJjZE5DYUtWeVI4YWlFYm1xQzR2cjEyTkZPMWdMRzlFQUpKNzBCYTRJMkg2MENZYkRlK3crRkZNSnIzRzRGUUd1cDZXdHJWUWlialRwUlMwdUNOcUlQOEM5QXlkejI2OUtnT0pPdmJxS0JhMi9PcUEyRi9Ib085QWdiSDQ5YWdlKy93Q1ZVSTlldHQrbEFBa2Ywb0ZwY1gwdlFCT3RyYmR1dEEvRysvYWdRdWVscUtEY1hIYWdSOE5hSU5TVDExNjFGQnZvZnpxb2o1U2Yxb0pGZ1ZGcjNvcUpKdGJlMVJEQTYvbFZDdHRSUWI5TmU5cUNJTFd0K1ZFTWVOQXRkOXozb09aN3RsdENBc3NIcVkwZ0t2SUJmaWZFZHFKWGpZQm1aUHU4YUtEOXJBTGlBRU1sbTNKNDJLZ2p2UTExcE1MMUpsaHh5RzRMZU1yYm5ZNkUzK0dnTkJ5RkdhTXVTRkVUaEFQSTRlN0FYdVZidXBxVlZIczJUbjVHYk1NZUpXa04yODF3c2FEUUc1MzFvUFZZT1pHTWhjWkhhV1NQU1VnR3hKR3V2WFdxTy91Tk5DZWxCSWs5VHAxOFJRQTI4YUJha0FYb0FBRHBwcHBRU3NlWGorSDYwRVNlZ05BeVJiUmRkK1ZCQWtqd0ZBZ2RmcStWQWJYN1dvS0NQbjJOVkVlUFhmclFJVzhiRFdna0xFajh6UVNKc0tCRVhIaDNvQWZUZlkwQ3NMLzBvSnExaGJlMjVxS0xqdjhBaFZCZTI5aFJFcmtBZ2ZuUVJKOGxoc1Axb0dSMkZoVVUxdmZUcnJhcWg2blU3SHFCVUJ0Y2dlRmpyUlRJQUY3M0c1TkVITHY4cUtXbDdVREY5ci9HZ2tSWS93Q0wwRDQyK3I4cUJmMDI4YUE0alk3OTZCalVHKzUyTkJaenVMV0I4YUNKMTZiMEVRTDc5ZWxBK3cvVHRRSExRZ0M5QWVZNjlEMm9KS0JZNjJ2MW9BZmdlL1MxQUxwYTI5QUZlcG9DdzIwSm9BQzk3L0cxQVdPdmh2ZWdrb3ZvTnFBVTdBN2JpZ0NEZmZ4b0FHNCtWeDN0UUZocUwyN0NnV3ZVNjBEN0U2RGI1MEVnQWI2ZlBwUUpRYUIzMzEvclFBdnIwUGhRQWJYV2dadHVOZXR1OUFqeDdXOEtCMnQ0VzFCb0hxNDJ1ZkdnUUcyMUFkYlhvQTNPblNna2ljdEw2OWFCN0UyME5CRyt4M3Ywb0dEY2RQQ2dENGkvU2lnbGp1TnRLSWtSZGRnYjBFZWg3ZEtBdlkvR2ltVHBlM2hiclJDdWZoMG9MRXRiVTNOQk93M1B6cUN1VFlFSFg0VzJvSWhpTk9sVUY3NzZqdlFHdTRvQWRoc2FLWUJCL1NpQzNsMy9BT3RGQkd0dE8rOUE3alp2ODZBRnJnVzI2VVEyTi9FYkNnaUJycG9SUVB5MlVqY0RXM2VnZWhGK282aWdXdlEySFdnVGNqdjhSUU1EOCsyOUFIVFFmblFHL3dEVzFBeVBsL2xRUkFvcGp4b0pBV0o3OXIxRVEwdjNBNlZSSWovQjFxQkU3ZUZVQXZjWDI3ZGFCZ0VtMzVWQVdOdmh1S1FCQkduUTFRZ1RjZHFBMU5pZmpRQk8xejhhQUd4N0dvb3VDYUlaUEk3V29JL3JRU0RBblVXc0tvbVg1QUt0Z0FONmdoeUJvRU9uVCt0VVBwb04rdEFhNzdkYjlxQUphMmgwdmMxRkFPdDZJQU55ZnhvRUJjNy9BQU5GR2grTlZCcjhCMjZpZ2x5SUZyNkRwOGFLUXNMZzFBQWdDMWgrdFZBTmFBWWNTTmIrSW9JblRhZ2U0QnNSY2JtaWl4dHZmeEZSQUNSc2JmNVZWSy81N21pQzR1YjdHZ05mdzBGQUJyWEkxSFk2MFVtSko1SDZ1OUErVFc3V3FJV2gvd0F1OUFFRHBwZlkxUWlPbzYwQmNXQnZvS0tOOWFpRWVJMTI4S29OT28xRkFIZmZhZ09SSUdtbXUxQTdraTkvblFSdG9hS0w2Z2Q2QXRwWWJEZW9FRHJ0YnVhb0d1VG9Qa0tJWGVvQ3h2cnQzcWdzTytuZWlqaVQvanZSQzFGclgxMG9HUnNEMDJ0UUx3b0FrZ0FBYWJHZ2lRT04yMjIxdFFlZDkzZkZoazRQam1OTDNEeDZCZzMxQTJxb2hqUERpSkRrd0JwY1lLeWNScXdGOVNLaXZKZThER2ptbG5oNVJ4Skw5SXVRNU91cEhRVXBIYXhZUGNoZ1BsNDdvc2VRaS9TQXhWUm9lblVkS0N2RHpNdURONUlUS2poaEcvRXFTOWdBcEIvYUtFZXdpeTQxa0VFajN5Q2dZZ2ZoZWcxV3ZwODZDVmxCMDFOQkVhQ2dWejMrbWdkN2s2bWdWK3UxQWlTVGZiL1dnZDcyRkJHMXI5Ky9oUU03YjZXb0tDQmE1RnFxSUZyQTdlTkFEYXgvU2drUDkzK0RRR2xqcmY4QTBvR3E2NmtlQW9GeDEzdWVud29IYm9LQVd4MzBIZ0tCRHRlNG9HYmpRaS9ZMUZHdmY1ZGpSRWxaZGJpL2lPbFVLNUpzTkw3MUZTSFR1TzFFQk9sdTNlZ2FqcnNQR2dRb0pFQS9MZS9TaW5ZZUZ1OUJHeHYzditsQXlUcjJ0clFUdWZqMm9JZ20rOWgwNjBCNFgyM29IZXhGQklOWW5UOE5xQlgwOHZYdFFGaWRkeU90QXo0YTNvRnlJUFk5NkIzTngwb0pGVkZyRzk5ZEtDTGR5YkRwUVMrV3RCSHQzb0pBYTJPbmhRU1plS2p3M29JaTUwb0hxZEQvQUswQWREY0cvZlNnZm1MZVkyN21nUkkzN2pTL2VnWUJKc054UUkzR3crTkJJRzF1M1NnRjVFVzZkajJvQU5xYmFId29HQ0xuanIwb0FIb1RidUJ2UUsydXZUcWFDUTJzRG9hQnFBZDZDTit4OEtBVzY2YTMydlFNRWEyRnJVREIwR3UrdXZoUU5tRyszU2dSVXJvTitoRzlBaGUxdHZHZ1lKdDRmMW9HUWR0ejRVQW9KTzl2RGFnUHh2UUZqYXh1QU42QlhGcmZrS0JtL3dCVlFLK3RCTFE3bjRWUWR1OUJKU2YzSFg4VFFKZFRxMWhVQ3ZyZTN3cWg2QStCMzhhQU43M0ZBeGJqcnBRUi93QUVVRWd0OWZ3b3FJR3ZoZldpR050S0JtMjF2aWFCRWRPdmVnTDk5RFFOYm5YZWlsZlhYUTBRV1A4QXJRTXVwQUZ0QlJTSnQ4YjcwUTF2Zlhwb1BqVUJ4TjlkdjZWUUcxKzQzMUg2MEVScmMwRXRMZUg1MEFRYjY5ZGFBR3ZRYmExQXVSL0FXSGpSVWl1bjZEcFZRRFE2Nmc5ZTFRQjQ2OGR1bmMwVXc1M0p2YmY1VlVKamMyK2RBdGI5U2V0RlNhL01DKzIzWDVVUkR3dHIxb3FYZ2RRUlVDQTEvd0FYb2dGeHNkdHJkcXVBTit0aU5xQStJMTZtZ0xYR3YrQlFCRnpmL0ZxaWdqdHJWQ0pBMDZkZkNvaWRnQmNHM2lhcWl4dmI1NlVSRTZXN21nU2drV29xUlpyMzN2OEFwVVJFbnFkL3lxaGdqNFVDOGZDL2pRTUJqMDFHNHFCQVhOenA0K05VU0h4K05GSStBMzcwQzMxdlJEQkFJRnlWb3BHM0xUNTBRRWkzUWQ2QkVFYmZLZ1l0YlhVbWdOTFdvQWtmaFVWR3cyR2xWQjFBNkRyUVNBNWROUitGQTJ1ZW1uU29xSEVtMm9XcWlJM3NmbVJRTlFMNmIxRk1sYmpTOS95b2hFZ1cwMS9wVlV6WXJiVy85S0lRSFFEZnJVQmRRTGZ1NmtIU2dWK3ZUcmVxRnlzZE5odFFNYWpVYStOUUllTlVCdmJ3T2xSUzZENDZWVUJzQnY4QWpVVUFENStGVkFHRmpwZm9UVVVsWWczdlk5cXFEbGMzT2xxS0NRYnIxb2lJSkhjbnFLQUZ0Yi81M3ZRWk16Mi9HbmlzVUJrOFNiV29ZNU9aQ21LMGFJdWpFckhFRFlCbkZ0aDBORXh5WnNQQzl2ZDhPYUpXeVdReXhDeDRNQmM3NmkrOUREOXJseVk0R2t4aGRwRTVxQ1F3anNiQUVmT2lyOEgyN0t5ODZPWnBJMndsWWtxb3VlUStxdzZVcEd2MzMzSEd3czNEZm12cnFTcFFtMzhiRFhYd29UdDEwellQdGx5R05vbUFJSjdIYWcwcElIVU1ENVNlbldnZXh2YlRjVUMxdlkzTkJGMkFVa200M0kyb00ySDdoRmxCK0d5SGliNzNGQnJ1RGNBSFhhMUFyanB2ME5BeWQvTHJ0UUt3MDF2OGFET2IydDBxb2lCdVJ0M29HR0lCR3R0ckRhZ0RxMmdzVDNOQXlGM08vZWdldjdiV0EzOERRSUh6YW41MUE5ZGlCZjQ3aXFGYnFiaTJ4b0pBQzJtZzdWRkZ6YnQxSXFnRmpiWHgxb2c2VzA3aW9KQWdna2lxb3NSNFgycUFCRjlEK05FTUVtaWcydHJyMnRRTzQxL0tpSkxyY2RCUUxVandQYWltTlJjN1VFZExqb2U5Qks0STBQei9BRm9CU05ML0FDRkJJa2FIb1JwUUluVHJwMC95b0RXKzEvSHNLQjN1dW05QTdqU3hONkFZTFlXTi9HZ2ZIVFdnRzBHZytWQWFFZGJuOUtDVEtnNjNIU2dnZDlOTzFCTGtUMTFvSHFSdlFMdnJyNDBEUGZXZ1BOYlhTMjVvQUU5ZTJob0dDQ1BqMW9EUWFkYUEwK0hXOUFhdHNkeFFTRnRqdjNvRlpldDZBdmR2RHVhQ1FYYy9pS0JXQnZicG9BZDZBT253RzlBYVdHdHlkN1VBRHIvbFFCWWR6YmU5QVg4YUtOeHJSRFBZYVVCeTB0UUdwMjBCM29BWHNiYmRhQ1EyMCtkcUFJSEcvUzlBcmtEdXZhZ0xuYm9PK3RBeGM3L2dLQXVlbjRVQWVKWGZmcDNvRVI0M29KRWkrMm5hZ2pjM3ZRU0JGdFBtS0JhOU51dndvSFkzMDJvb0JzZDlEUU1sUUJZM1BYd29pSUlKN252NDBBQ2IvQ2dBTGtrRzFqclJVaWJNRGEzVzFFTGZVQzVvSmNsMk4rZjlQR2dSSzIwTmoxb0M3ZnRPbzdlTkF3VzVXUDUwQXpIa08vUTBFYjZqditsQkxVang4S2dPUnNBZnA2MVF6WnZwL09vSTJ0djAwcWhnYW13NmZDZ0NMbiszWFNpbFk2Qzk2SWZLeThSK2RGUkk2M3QwdFFUMUlBNkg5YUE1QzFyRzRIU2lGNXR0cUJDKzNUdFFNV3Q4YVVNV0FGdCtvb0UyNEtncUIwcUtXcDdlRlZEMDIzSnFLS29DOXdOTktJQTJ0dTNTb0JpQ3RyZkdxSmVZeGs2ZVhTZ2liWE51bTk2QmdnamJRZGFpa2JFYW40MERDTmZRRW1xaFhmY2JuYSs5QXcxLzhoVUM2Z25XcUhaU0wyK1ZBdWxoMG9BMzNORkJJMzY5VFJDUC9TaWkrdW12aDJvZ3VkNmdOVHJlL0dpZ2EzL05xcUhwYjQ3R2dDdGlOYjZYb0ZZRTY3SHRSUnhGRUs0RnRMa2ZuUUZnTy9hZ0RhMXZHOUZLMnhINTBROWJVQUNCdUtLa1NCNC81MEVTZGJBYjBSRWE2OUtBSy9DNG9DNUFPdjhBZzFGSGh2ZXFnREM0VVd1TzFRQklzQnRyK05VUjZhZktnQmZ4QUpvbzVhSFN4b2hrZytOdXZqUlFRUnIzM29nYXdHOTdtZ2gxdDMxOEtBdUNiRFR4b29ONzIyTkVNQWQ3SDhxQ0pGdW1nb0Y4TmZHZ0FMYmFtMTdVREo2R2dqeVlkZEQxRzlCeGZlODNNd1pJc2lNZXJqbHVNcWYyZzd0ZndvYTg3bDVNdVZtL2NKa2xPQkRxcXBkd29OeGZ2YndvTTJaNzhjbkxrTTZNMHNDaGNRZ1dKTGZVMm5Ud29hMmY4Yzl1elpvVExqekhsTmYxUkpveWkvN2g0MEhmR1BIN1VqdVpReHRmMDcyc3Q3RTJvUEhlOXdaR1JsbkxreW84ekc1WEdLcDRnWEgwc1JxYkRXaEhwWm1sZkNoeFdJVkpWVlJ4QkoxMkFIWUNrSGZnVGhFcTMyQUh5RkJjYlg3ZHIwRVRlKyt0QnpQZXM5c1BITWl4bVRXeHR1S0R6LzhBeC8zaklrT2MweFBOV1gwN2kxcjZBVlBSNmIyMlhJbHgwa25ObmE5N2JWUnNEQWEva2FBdU8ydTk2QXZyY2FHZ3ptOXIzdDM4YXFJa2tlSVBlZ0YyMytZNjBET3hQV2dZTyt0dW9vRUFQOVIwb0dEMC9XZ2RySGJYWTBBUWFCZ0MxK3UxcUFJMDIzNjBDRnRlL2FnZDk3bTN6b0pIUzF0UGpRQUpzZEFMOTZpaXhQVFRvUEdnUEx0K05CSWpvTzN4cWhBYTYvT29pUURBNm53b29DNzMyNlVBRFkzdmFnTmRQelBZMER1TDdHNTJJb0ZmWWpXZ1o3ay9HZ2tEUUFzQmErL1dnTmJIOGFBR2h2MS96b0FXNmFYb0o4cmJpNTZkcUF1ekMrK3RBZ0xYL3dBYVVESXR4c2JnaTROQkcrdHUxQkxwNEQrdEFBTnJmd0ZBckVqYjVVRTFJdWI2anBRUnVSdDhxQTFPbXBvR3luWS82VUFkTi9DZ2xjZ0EyMm9GYS9UNDNOQWNsR25YdnZRTHJmOEFLZ1pPd3ZmdFFBSStlMStsQUFtM3pvSGNYSGJyM29BRWpXZ1FJdWVRdlFTOGR4NFVBYkQ0N2tVQUFmaDFvSmNnT2gxb0kzMVBRR2dkdEwzMzZVRWxCM09sQU5ZR3gwSFVVQzFzU1JwZmMwQjlRTmg0bTFBd2JYSGZ2UUlEWFMvZ2FCSHNONkFBc2JudUtDVnp2NDZmQ2dOalFGaGUrL2MwQWRONkIvdDBHNTArVkFnVGZTZ0wzdHJvRFJURmo0RWJtaUd5MjQvUFdnUUl1RDBvRHd0OFQwb0hZTmErOXU5RkFGckhmb0JSQWRUZnVkNkJhRzFBeGNFQTBCOEtCc2ZOMCtWQWdCYTl4ZjhBV2daNDY2V2FnWEVFNmcrSW9HcEF1UjhPOUFYN2thOWFCZ2dIZlViMEFXSEludjM4YUJEWHlqVVdvQTJOdWxBdExmcFFUS2diRUUyMW9xQUcydGpSQjNKL3pvRmEzK1pvSGUrbDl0QlFNZE93L1NnYmNibTIxQXVSK0FIV2dhc0RwZmJTb0N5NjN2dFFJMnVPbzdWUWpydjE3VUJ5QjFvSGNqd1BVMUFqZmo0OUtxbnAxMjZmSHhvZ0g1ZGFBOHpDMUZJanZlMUVHb085clZBQWtiSFhhcUdUcFk5S0EzK0hoUlI0blkwUXV4dDBvQ3dORkYrdmJwVVFFQWtqOEtvTGtpNTYwQnJzVDhlMUFyRTBVRW0yZ29nQkZpZHJmbWFCblRZM3FBSUlDMzN0OGFxbHFkUUxnYi9DaUJpMTcyMThLQUJ2c0xEd29wZmwzTkVLL1dnWU9nMS9HaWk0K045L2pSQjFGaDhkS0JIa05DZmxVVUE2WHRyMDdWVVIxNjdkYUNWaGMydnIwOEtnamEzeDNxaVFQVFlIVzFBckMvejYxQWFqVVZRaWJlSFMxQkd4TzIyOUZNRWh1VnI3YjBSRUVFMjcwRFlrYUhwMXFLaVBqOFJWUWVBTndEdlVWTVdCMU52RWk5RWN6M2xNOW9WYkRjcVVQSjdBRzY5ckh2VktmdCtWTU1aWk1tNnUybHpvZDdVRzRFRzV2dU5hQkRlM3oxb0tjbjBmUllTZ0ZDdm1CN1VIaS9kSU1TTVJOajViSEdacnhvVkJLa2Yyc2JYQm9qUkY3ZDdmalk4YytRNWxMK1lSaTNLUmgvU2cwNDN2R0tzUisxWllVTGN2VDJhd0FCK2Q5QlJXTDNEM3VlUnpPeUs0a1F4eHhOOVkxMkpIZWc1bU9ZNTVJNFZJVlZ2emJqeFlCamNDdzY5TDBIUm05d2JGbmlYMXJTY2d0Mk5tQ0RUUzlLUjdDQ1pTQUFiM0Z4MTA3MEZnWUhycjFHOUJqOTFueUlNWXZCYmwxdUwvQUpVSFB6SWw5eXhZK0V4amxJdXBHdTNoUXJ6ZU43Qm1ZK2JLVkhERk9zak9ReEpHb051MU1UWG9aZmRMKzF5bUdSRnlvVURNRUlaUVRvQmVpdWw3WGsrdmpJek1IYTFtWWJYNjBHelhmdjBvR0JmNmRMYm40MEZMT0dBc0xhVlVWazJONytGQklLUi9sUU1zQWI3OURRSm12OE5MR2dmSWQvamFnWUFKc08zWGE5QVh0cDFPOUFmcWV2U2dldGpyK05BV0ZyN0h0MG9BRytoMG9IY0RsY1hKb0Eyc0xIVHBRTURXMm1uV29CVHIzdDJvcVRtOWpwNFVFYjJxb1lPbmhmVHhxQ1lKc0NPbTlGUnVMOHVoL0tpQVh2OEFEdUtLZkk4dHQ2QTVFYTMyNlc3MEVnRGE5OUxiR2dpTGRkVFFTMk9nMTcwQmNqZjRqNFVESDBqeDBONkF2M0FvQzl6OGY2VUF4N0Q0MEJ0MHQ4YUJqcCt2aFFCc0RhM3pvQWttMmxBQVhIK2RBOWUydmpRU3VCdU52a1JRSzVBK05Bd1ZEZjdSMEZCSlNEUVBlK2w3YTBFVzQyNVgxdm9PMUF1VEFnL0sxQXpyYlRlZ1JOOWJVQU5TUHdOQkxXNEcvYWdWdHIvTTBEM042QS9FMm9BQTlQd29FTFh2K05BeXhHcC93S0JrMzNvSkMxdGRCM29GcGE5N0VIU2dXdHJYdVNkYUI2LzVqdFFNTlliL0FBRkFpQVNQem9FVzEvVC9BRG9IeXNMRGEvd29IZXcxMm9HN1hBSU51aG9JM0ozR3ZTZ2x5L0VVRGNEUnI3MEM4VDlXMUFqZTlqcVJvVFFNRTcrRkJJRUFYM29JaTJvTzVvQUFtOUJQaFllRkF0U3ZoNDBDSjAwQW9HQmI0VUNCc2JEYnIzb0dkTmV2VHRRQlpUYTNRV2EzZWlpNHR2YzNvaVJGN2RXL0sxRlFKSU50amVpRHhJb0h1TlFQRHdvRVFkL3pxQmp1TitocWhFN0RwUUsrbEJJYWJqUTk2QjZFM3ZwMytGQXI2a2Q2QTBPK2hvQWR6dDJvR0ZZaTUyRzFxQXRZOWowb0FuVUMxdkh2UUhXNG9Gb1BHNCtHbEF1MUJKaUxDdzE4YUJEcHB2UUFOanZwM29Ba25XZ05ocnQyN0dnTDZqVFVpZ1BHMzQwRWxRRmJqY0hiL0tnaWRiRFFmRDlhQUY3L0FORFFQUzFqcjBId3FLbmUybGdlOXFxSXRjblRTZ1IxQXQxMHQwRkJFL2hiZWdrdmM2MEVpQ0Z2cHFOUU9ueG9JYW53cUNRMjFIWFExUkd4SjhPbXRGSzQvcGFpRHFDTisrMUFjaVRyditkQTJOOWpjZDZDSUthM3ZhMUF5T25UZWdRQjFzdXAxQjhLS1lKQnYxOGFJRFlqKzM5RFFBT2h0OGJVVUUzdDBKMS9Db2hEUUVqNWRxcWpYOEJxUlJFYlgrVzVvR2JiRGFnQUxYMW9GY1gxdlFNMkd4dWVwb3BBWE85cm5UdFVEUDBCcjliY2FxRnJjWEp0L1NpbHZzZHFJWUhTNUZ1cG9vT3cvd0FhMUFyc2Q2Qkc1MVkvNjBRWDJCMEExQXFxWjQ3RFh3b2lPK3R0UnRRUkpON0FmSHZRREhTeEdoL3BRRmlQMG9wM09sdEJRVTVITVFzVU5tdG9LSTRlUkk3U1JKTElJc2RmTTlqWmliNkQ4YUVkdUp3VkZ0UnVEUVdNMXgrbEJ4dmZIV1NOb0Zaa250ZExmdUEzQTcwU3ZONVUwY1dFc09mR0pqSGQ0bEE0cnIrMGpVaWlxNE10TWt4dkxHc1VRWWhXQkxNZ0l2cGZlb01udU9WaXdTbGNYK2VOd3BHVXdLaTQ4cDh2US9PcVJES2toSWlXS1F2S2pPdHBBVkJ1TGtrL3RPdWxCc3hsVkFqRUdOSlA1RzRIbUZzTnVSMS9HZzNpTDJISm1aOG9FbUUzajUzRndCcWFHT3BqNWVCOXc4V0xMeWxZY1VVRTZCUUQ4cURwKzNZMDBhTzhwSEpuTGI5NkVZL2Z6engvU0RsZVc3RHBSSG1mWHo0c2pIWEhrOWJKaU51QVQ5cDB0djFwaTY2ZnVmdThpaG9raEw1QmhZTXBCQXVMSGZhaVZ5Qmk1OE9ETkFrSytsa0tIZnFiQVhJdnBjMExYZC80cEpiRVdFSTRWZFF6QzE2SzlGY20xQUFHK20zYWd6UGJpTkFMYWFWVUlFLzZVRXVZdmNucHZRQmJXMzRVQnJmd1BXZ05DUnI0QTBESGJUeG9KYWs3MjhOdkNnaUFGN2tiVUV2MDYzb0pHMXJFWE5RUXRycC9uVlV4cm9OQlJCZSt2UWJYb0dMYUMxcmQ2aXBhNkM0RnROT3RBQWpqYTI5VkJ4WWVGdkNvRGZyOEtLYWtLUENpQ3h1VDBvcGtiOU5LQmdEYnIrR3RBaitmVzlBQWthQTMrWGFnYTNKL09nZWgydU5ONkJXN2JEZWdsMFA1MENHcDAyR3hOQXlmejZlRkFyOS84WG9KV0ZoYi9TZ2VvMDN2UVI4Ti9qUU85K3Z3b0N4QnR1U1BqUUZyQy9XZ2tDcE55ZFQxTkF2MDdVRHRzU2ZoNFVCeUZ5ZHFCa2tHd085QWdlL1NnQ3dQUzF2blFTSjF2NFVBQWdIaitROGFBQzNQNlVEQzdnV0ZBamZxTjl2RzFBQTBEdXZLMzQzb0VTZGV0QUEzR3Y0MERLMitCMkZBVzAxK1ZBSGJYYmU5RlA4QVVDaUJ0K3grTkE5TGI2K1BhZ1F0djA2V29HYjMwR25TZ1ZqcXBPL2VvSmNMamJYcWFCc1RhMXhlMjFVSWJEOVJRTTdXRzFBbEJKMUF2UVNYalkzTnV3STBvRUNOYmk1N1VWSFlnOUtJa0RZOXh2UUFzZWx6ZWdrRnNDV3VPM3hvSThqY2FkS0NYTWxMZHV0QXVRNDNKMjBvQWZVYkd3N21nZW84dDZCRWE5ZE42QXVvdDNINENpbGJiNDM4S0lkcmZEdlFNRzJuUTBFZUozMW9Ed0cxRlM4dkhRM1BiclJCZGlwR3c3VVVDM1UySGZ4b2c1RHQ4elVVaHByVlE3bDI4TzNhZ1FKQjBHMUF3d2E5OS9DZ05CdmZTZ0R2c2FCbFNvN2VGOUtBREhqYm9kNktTalczUTBRTWUzNDFBRFFVQ0k3MkcyZzYxUTlDZE5QNlVDdnh2MUFvR1dKT3V0cUFGN250c0tCaGJzRkdwTzFGSmh1Q2RSdlFPTms1K2NYQjdHZ1J1YitORUd0dkRyOEtLUUdwUFE5VHBSRDJYWTBBRDRiZktvR2JFM1VmRHdvcGFqcGNtcWhYRkFlQk5CSUw1ZVY5OXhSVVFiYTZEL09vaVhOenVhb2lTU2RkNktCYnAzL1dvaE5jMzAwUDlLS2U0dGNBWDdhMVVKcmtpKyt3K0ZBYWFqcmJlZ2t5bFJvZWx4UVIxNmErRkFYQjVYdjRXNzBVWDBJdnRSRFBRZk9nTkd0K2R1MUF2M0hTK2xGSGhhaUhiYzN2YmVvSXRiVHc3VlFEZllFZHFCRWRPMjFBRlNOYmpUcFFINmRxQnFvSTIrQm9HQ2dCdmUvU29wQzkvTFlkdWxVUWJ2NDYxRUJ1QVIycWlXaEZ0ZGZoVVZBOVRhL1NxaVZ4OHR0ZTlBdGV1bmFnV2wrL2owb0FzQW9BR28wOEtDSkl1ZHJVQWJEYmJ0ME5BcmdlSGpRTGJVL25RY1gzYjJ2QnlWa2hXUXBrL3dEY0ZqWnZ3N0doak43SG1OQ21SQzBqUytrd1ZBNXVkZWw2SzcwVHVWQllhMFJpeXJaSVBHeW1Kdkt6YWVhZzQyZEZQOXJMSE1zY2pHN093c1pMZHU5cUpXZjNyRkVPTERrWWQ0Y3BZMUlVamtnQUZ6Y2RMZU5DM0hBeWZjRU9LOFU4RDhuWHlLTmVicWZNN2YyaSt2alVhVS9keXJNT0U0bWwwVlZUNkdVV3VwVzI0T2xDUFl4NW50YzJNNVNCbG5DZnl4RzRObVBFaTN4cEtsZWY5K00wTW9na2xabU5pcVdzb1VYVTJiNFZTZHV6L3dBWGp4QkJFb3VaU0M1YVRWdERhcEN4Nm9DMXUxVUtTTkhIRndDUEdneVN4NDJOL0tpaGJheUd3dVIzK1ZCejVQYS9icHNxUEplUm41czNFY2p4dnh2VFNSQ0wzTENmSU9GRkdCSENiaGoyR3VsTk1XZTFlNlBsWkRSckVxcEhmVUc0MzAyb2tkcmU1NjBVeXhOcms2YlVHYzZrVzY2VlVJMjZnNjlhQkErSHlOQklONEEzL0tnTEtEcWR4cFkzTkFXN2FnVURVMjFPd29Dd3QydDBOQVhJSGpRTmR0ZGFCNjJ1UGplb0ZmeTJKMjFBb0FiK1BlcUdiZkdvR05CZnJ2VkQ1WHVMV3ZVVWFrOXU5RVN1ZjhyMFVpTkxrL09nQVNScnQrZEF4ZlVrZkNnbGNId29Jc1QxT3RBV3ZvZXRCSlFOTFhvSlhGcmx2bFJBR0Y5Ti93QTZLSDErQW9GcllhZkdnWXVCb2VYUVVBUURwWTNvRVQwMk45VFFUaktBYTZqcFFSTjl4UURBN1VBdW54b0pIdGUvK1ZBSGJYcDA4S0JpNTAvT2diQUE2L3Q2VUNzd0Z6dDM3Mm9FVDA3VUQzdDBJb0dWdU5ldmowb0V0K1ZpTkQwb0hlK2cvd0JhQnNwQUEwOGFCQm1BTjl6UUhMb1JyMW9KY1R1ZEFkalFKYmJBYmJVQjhqUUhYZTNXMUF1cEFvSktXdG9OdDdVVklDeTZIWHJSQVZ0cURjVUVEdmZTMjFoUU1rWHQrRnFBdllhZktnWXZ2dGVnbkhia2I3MENrWU0xeDE2VUV1ZHg4ZEtCQVhON1cwNlVDWWJEcjM4YUIySkZqcXc2MEFHWFVsZkFVQXozWWQ5cUNKMC8wb0FXK1ZBN0cvWUNnWVlnbTN5b0pPek9CYzNQWWJDZ2hmcjE4S0JqanUyL1MxQUVqY2JiaWdYWHY0VUU3TFlBa0R2OEtLWHdQNDBRYWR2K3RBd3c0a214SjBvSWpRV1B5b0o4dmo0SGFpb2k0MUg0VVF3NElIUTdYb0ZjamFnWjAwT3gxdFJTMHQrbEFhZkE5VFFTOHJiQ3c3M29nRE1Gc0xENWEwQ0JZQTk2QUhqOGFCTVNkZXA3MERGeHZ0K1ZCSmlPSTF0VVZIb0NlbmFxZ043Z2pVZmxRUjYzNjBFeGIvV2lrZkEvSHRSREMvT2dSQkYvRGVnUnRiVzkrZ29BY1JiUTN2cjQzb0EydFlIVHYxb0RXMjNXZ0xpNXVmaGFnTDY5VDNvQWdhMjJPdHFCZ0M0RGFkdW9vb0pYbWJFOXhwVUVRTmJmbjhhb255UEhnUjVScUtnUnRhNDY5OXZoUkF3N25hcUVDTGNldEE5eGMwVXREcjJvaEhmYmJyNFVEQTE4T25qVVV0L2oycW9ZMDBCQXR2OEE5S0JxVkEyMUd2aFFJbmxyWVVBTFh1MTdVVVgySUpJMW9pSUg0K0c5QTdFalhlOUF0ZUpPZzc5UHdvQUEyMEduU2lnVzZhRS9uUUZ4cHBxZExDaUE2YWJIcWFLZDc2MzJHbitWRVI1RHZRTzNsdU54L25SUVN1bStuZnhvaU8vWFh3b0M5eHQ4Q2FDYXR4MUlQSHJyVVVpd2E1RzNTcUllQjY3VUV1TERValFqUW1vRnVML2wzcW9SWUVhanJmeG9BRVcvM0Npb2tEbFpiMi9Xb0RXMnV0K25XcWdGeVNBZEtBUGwwMCtWQWphdzJ2MDcwQUNCODZDTEEzQjdiVURZMjY2SDhhRG0rNCszUlRTTGsrWU1nSWJqOVRBOU5LRGpTaUpKdkx5aXYvSUlWRy9nL3dBYUd1cmhaazhqdXJnS3FnV1BpZWxCWkxBODdYS2xCY0cvZWc0L3VrRWVQSzBzWkpkaFoxUFVIZWd3eDVEUnR4WWtST2YzWHRZaXdGQnlQZFpVZHBKbkE5T1VuMGxCSE51T24wallVRkgyZU5GRzVsVUxLRGVJTG9XWmhvQUxIeWp3b05JbXlwV2p4MUJiSXR5WjJjaVM3QWNiVzZEdFdXazhxRldtYys2Sy9xc2xvK1YrSWtCMVk2OXRxcksvMjZXSEQ5MGo0bHVSS3gyMTRubUwvcFRWZTVTUkFBU3dBNlhxaTNsNVNiNzlldEVjdktud1RJejN2TW80MjZhOUtEeldkUG5RdEdvVjNFY3EzQXZ4RjIrbjhEU2txZVMwTXVSSWtrTDQ3U1JubklQSVZPdGxCMnFDai9pUHUrS2svd0Jpa3ZxazZlWlNyQWdEUy9YNDBWN29Ob094cWc1cXQ3bmo0bWlLU0IvbHJwVlJIWC9HMUExREZTUjB0ZndvSkt1bDlMQWEyMG9EZllVQmMySkZBYURmOEtCbTMrWm9FT3gydnFUUVdBZVVFZ2E5QjRWQWlUL3JRUjdhNkhyVkUxZmpZVzBJMW9EUzk3V0J2YzBDNjloMCtOUlR1ZE5QbFJERnV2V2diTnJyYlR0UVJ0MVB5RkF4YjhiK05CSUhjVzM2VVV1V3RFTUc1dWFLWjQ5Q2RkenRRTkFUYnczTkFqOGRLQTVXb0pYSkEydDNvRnIwdmExQkxiZWdRQXQ0MERiUmI5T29vRUJxYi9HZ1lJSk50Kzk2QjZFZHZDZ1FKdjE3Q2dmVFNnTCtPbEFYOGRLQjJOaWU1Mm9FYmdtNDZiVUQ0Nlgzb0hlM1czYS9TZ0NTVDJvSHJ0YWdqeTZBZGQrdEE3MzBvR3RqZlM5QXlMRzUvT2dSTEVYL0FBb0pCQm9RUWVsQU1DQnJRQXR0c0IrTkFtTytuWVhvR3R4ZnAvamFnT1JZRHdvQzV0dllHZ2VwMjFQUVVBYmFiL09nYmFqNGZyUUxiNTcwQ3ZmYlFkZmpRU3Z2cDV2RHBRSVdQeTJvSGUzVStIeG9CeVMxaWIwQ0IwMCtSb0d0aVQwdHRRT3crVkFjZEJZMjYyb0JReEdteDFvQys5QXRkeCtsQTdtMWhRQkFJMDMvQU1xQmh0TFcrSm9HTmJYdFFGZ0R0Y1VFU1QydDRkS0JzQ2RiYWZqUUY3Z0E2S1B4b0Ryb2FDY2dOd1crcTFGUkpPeEZpQnY0MENBc3Q5ZkdpR2U0M0cvaFJSZTRINjBRK0k3OGp2Yi9BQ29JNjIxNlVCZlhmWHJRU0RXSnVMaTJsQWN5eHVlK3RBclhGeHFlMUZQcGF4dDB2NDFFR3V3MEhqVlZHdzZmSzlFTTZFMzB2UVBsZlRZZUExTkF3RUI4d1BnUjNvcGNyc0dJMDZpZ05TZEFiZkdnUnZiVHBSRWxiOCtsRlNQRTM4YUlyWUc0NmVKb0dRT043aS9ZVUNCMzB2OEFyUUkydjhOKzFCTFFpMzQ5cUJobUM4ZW5oYS80MFVoYlcrOUVSR2h1UGxSVDVXSUpGK2xxSUJhNUI2VVVhNzlCUkRHdHorZEFnQnkxMXRyUU1sTEFyK1kveXFLV3QrTjlDZDZxRFc0RnRlMUFFRmI5S0FZZGdlL3pvQWszdHRSUlkyR3c4YlVRZ051ZzcwRXJrQ3gxdlFIbHZjNmdqWWFVRVNCYTR1QWRLaWtBeEhlcWdPdHU1b0hzU09KQThkelFNQUhZYTlSUUlDNS8yK0ZCRmpZbWdkaHhzTmU5RkxrTnlMRHJSQVRvUjBxQTZXMk50Nm9DQmJiK3RBa0hVMERQRTlkcUNPdWdHNHZyMG9wa2tXdC9sUVI1SDRYMkJvaWZUWFR0ZWdnUjIyb0VUZHROcUJteHRhNTZWQUxhNDVhSHI4cW9HNDh0Q1NPaDYwVXJXMXY4UlJFVzJHeDB1YUFKdHJiL0FEb3BjN0h1S0lkd1V2Y0E5dXBOQkUySTFGNkFKUGI4S0RpelhHVk1reWdCbDhndGJrZkUwR0NTU1QxRmlhOGRqb3BPL3dBNkNQOEE3Zk5na2RHSE5yZ3JZMzAyb0pIS1QzQ3l1T013SjVnYjhSUVpNaVdXTEZJTUt5NDczOU1zRGEvKzREV2c0Y1N5cGxKZnoyTFhIMURpZXhQYWhxV1ZqeVpVcUk2U3RFb0pnOU1qMUExdHRUOUdsU2tjL3dCVElSamtObHQ1WEhHTlZIcWNob1BqWTcwVmYvN3pCbmZnNkY1SnhZTk5zbzAzdjNPMU5NYWt5RWtSa2phRThWRHRJZENIdiswNzBSb3djLzNHUlk0aWtyQVBkQ3gvYWRRTGpwZmFpdmRRbVF3Z05aWDQ2aStnTlZISXlQYWNzU3laRWtvYU5tRE9nRnRGMXFveGU1ZStZOGtBeDQxS3pCMWFMVHFHRzlSZUZEeGU5NUdVY1dZSk1HUG5mOXEvT2lkdDN0SC9BQTNBd3BmV1VFeVhMWDdFNjBXUFJDNmdpOUJ4ZmZNbHpDVlFYNEVjbnZvTDBSMDIxTzFyL09xRVNkN2JmT2dsdVJZMEM4TDYwRDJGaC9wUUF2c0Jmd29KQmREZjhLZ0NOeDRmQ3FDeDB0cjExcUJnOVQ4L0NxSWkrZ1B5cUJFa2tDK3RVVFUyc2IxRldYTy9mZTI5VkVBZGREdjA2MUZTNDNXNUdwMXVOYUlWOVBFZERSUVRmYTNqUUZ1bTFBN0xidDNvQUhYK2xBN2dqeS9PZ1M3K0hXZ2xwZS9UOHFDZk5ncDQ2WDYwRU80Nkg5YUIyQU50RHJRTVVBUmIrdEEwdmZhMTlLQUxDOWlOUHhvQVdMYUVmR2dCcG9DQ0tBTnY4eFFNOGJBMzgzYnBhZ0FOUnBwZlhXZ1orRy9XZ1ZnTEhmclFNYmdEYmNtZ2ZOYjM2WDFGQWFYMzZXdGJlZ21PSUdtdjlLQ1BFOWgzK1ZBdEFkRFFQWFQvQUtVRHV0amJjMEN1Yjl2OUtCZ3RhZ1l0dnYyb0FuVDg2QUZ3Zmgyb0d6aGphM1hXZ2QxSThLQkJkcmE5NzBDSStkQTlMRUQ4YUFOZ0FkLzg2Qm8zRmpjWEZCSzRacmpUNDBFTlFiZFJxUlFBWWs2alR2UUJ0YXdCdWU5QVcwRnhvZTlCSmJYMTdmSzlBdVFCQnRlMjlBaHI4NkJuYlFpM1UwQmV4c05SM0hTZ0FTTktCK045VFFNR3kydDhUUURNdC84QWIwb0FONVFMV0lONzlhQk1lcDF2MW9KSndERG1OUERlZ0RxVFkzRjlLQ1FJSFQ1MEExZ0NPOUJIWVhOd1QrRnFCcWJXMDhMYmlnUkE2VUFiZHZqUU1kYmsrQTNvQVh2cjFvSDFOamEvYWdMQysvbXNMLzVVRWRkYmJVRTcyUE1IWDg2Z2hyZTUzTlVNL2g0VUFSWlJwb2R2bFFMY20zNGVOQTczMy9HZ1l0YjhxQld1d0hmOWFLYkE3RVdKNzBRRXJhdzM4UDBvcU54YTF0ZTlFTmlUcGJTMmdvR3RqdGJhMnUxQU1lbS9jZEtBQkE3NjlLQS9iY2FIdFFBY3FRd3Rlb3BzQVNMSGZjQ3FpSnYrUFdnVndkdE85cUJuVHhHbWxBeU5TUnNOZ2FCRW5lKy9XZ1cvWW54b0dvRnQ3SHJRSzJsQVdOZ2QrcG9wM0d1djRVUUE2amU5N2ZLZ1JzYjZhSGFnUnZiV2dmZ2V0QXhlNC94clFTTFdCVmg1cjN1ZHpRUXVML2w0VUJ5dUxBYTkrbjRVQmZ6ZU4rdEF5UllDeHZyY25hZ1ZqZmZlaXBYQVd3dmM3MEViV1A2M29nZlE2R3c3aWdWeWIzMHRRQnNkcjIvR2drTjlhQkJ5cDh1aC93QWRLZ2pJeEpKT25jMVFyc1I4S0NWME51aDY2VkJFSG9SWVVVMkE3SHdQeHFva2JXRnV1akhwVUViWHRhL2NWUkU2Nm0xajE2VUMxQUhRSGVnWXViOWFCWFArVnU5QksxK3VvMTc2VVV0ZE5CYWlGcVRwY2Q2S1I1RFViZzN1S0FKQitKMW9pSXViaTErbEFhMkYvd0FLQlhQVVVCYy9DZ1pGeUxiVUI4TktDT25YNVVCeElGemJlZ29tamprRm1IaUNlOUI1djMyTStyNnR1UVBsRmpRWW9jTm5qTE9uQUczR3gwSm9KU1BJaDlISGEwbkhWV3NEOEFhREk4MDRCaE1wVW44TFh2WTJvS1dEdEswUythUUtER3FyMTYrRkZaODZEZzBYM3lUQ05sQVFwWVhIYmtiYWlvampaelljMGFMaFNTc2hOakpNUm9RU1AyL1RiU2l3OFAxTVNJbktSTXgwQTRteFplUk5ybXcxK2VsU0xlVzBZeXVpWkVVa3BsYS9yQVdCQk9sdVBZMVlWNlBGOXB6SU1YMW55amVJQ1FCVjFKSTZzZDZyT3RHRDc5bkJpODJNM3BNcEtzekM1Q20yMURYb1Z6SVRqaVNWZ2lNTDNib0tEaSs2Uyt5b1RKSTF6b1U0QVgxNmp2VFV4MUljckFpeHVVUlVLb3VRTi9uU1ZWMkJtUjVjUWxRRUM1QXY0R2d2WmdnUDRBR2c4TC95TDNXRWU1cENnNVNxMzBzVHhJdGMySFdsSTltU2ZuYmFxaVBFWDdIb2FpcERVYTJ2MnFvTDJ1ZTlBOU5EdjJvR0tBRGJEcHZRU0RBWHZxZHhRR3ZmVTlhQjZBM08zOUtCa0RjQ3dPdzNxQ0lYemFrVUVpb0duNjBVZ1QrUHpOVkQzMS9DZ2tENWJkdjBxS0xIY2Y1MEViNitPMmxWQXhQYzNvSkFtd0IvUGVnWkZ1dTlSVW5LajZldlFVRUxFYWIwRTFDWEFZN0RwUUxTOWhyYjlLQ1NxRGJUU2dYRWpZWEEzUHhvQzVQaUR2UU1mVDhhQjZnRUhVOTZCYTN2UVNPaDIvQWZuYWdURlFkTlNQRGFnQmJjYTkvalFPNUdndDN0UUlXTGFYUGNEU2dadDBOQUVYSDVVQUFSNCtGQTcyN0UzMjdVRHVEYTNYcDJvSmNmaGJ2UUs5amZyMW9FU08xenZmd29EUWpYL0ZxQUlHdDlEMCtOQUE2NmQvcW9KTXdKdU4rd0g5YUJhL2owK0ZBSGV3MG9GZXgveDBvSmkxeC9qV2dSMzAxRzlCWWpBcnFmbFFMdllXb0l0WUcydHU5QXJtMm5hZ2tCZmJhMUFycmZYNVVET2x2eW9KSnRmcDRkcUJOY2kxOVJRUnRxUnQ4YUNWOUxEWUh5amVnTGkxdXU5NkE4cE56clFIRzQyMDcwRFhqNWIzMk90QS9uWWpZZDZBNUxzZW5UYWdSQU9vK0ZxQlcxc1Z2WWZsUU1kZGR0d2FBTnJqdHVRS0E2QWVPdEJKV0EwUDRDZ05iNjBERzlqdnY0VUNHOTIzNmRxQjNETWRkZjhiVUNOdm4wb0VUMDN2cVQvU2drU3JhRVdQVzIxQUtQN3R6dFFNQzZuVFh3b0Z5ODJ1dllDZ2tRcFcrNXY5TlJVRGU5cjYxVUd0N0hydC9sUVQ0amlTVDhxZ0hDSFVBZy9qUVJON2ducUtvT0lHM1NnWUFEYTNQY1ZGUG1oVTZXUFExVVFKMDEzT210QTdFRlJiWHAzb284dGliSHc4S0lrR0FGcitJb0lnajRlQXFCblQvNURjR3FwVVFyR2daVWQ5KzFCTWNrVXNWQkhjaW9xc0hYOHhWUXlCZTRQNFVVbDEvMW9pUmNsZUoxSUduU2lvM1lnNmVXaUdRQnR0YmVnQ0J4OERxQlFJQTMxR25XMUFEb2VteDhhQjZXOGU1b3BYWmpmdFJFZ1U0V3NlWjYwRVQxNzBVQ3dzTGE3SHRSRWdQcUIzRkFpYjloOGFCRWFnWHYydFFBUTdFZk9pZ0M1R3RpZHpRU0l1VHhIZ2JiZm5RVm53b2gyUGUvVzlCTjJJc04rdjhBZzBFTkwzMkZBaG9TTGIwQUxBRFh5OTZDVzJ3M0ZGQ3FEcWRMNlhxQVpWR25MZnZvQlFRM04rdmJwYXFndWJEVzF0YUtRdVJjWDQwUTcvTTIyb0RrUmJUWDhxQmFrRVgwTzl1dEZPMnB1QmM3WC8wb0Y4LzhxaUFlV3g3N1ZRL3ExMUxIdC9wUVJKNkhlZ0FBZkE5NkJqbFk2NmZyUUkzdU9JMjNvcEVlRmlCUUxXOTlkZWdvZ0lPeE5pTzlCRmphL2VnWkdnTzN4b0Z5STJxS2R6Ym9OS3FJbGp0WUcvV2lrdzEvcFJGR1ZNSVlESllub0FLRHpYdVhLWmtLSVJyY2dtMWovclJIUE5uRGVwS0FWYnlnbmp0OE42TGlZbWlnSVkyYVZSNVhJdmNuNDlLQ3VQRGprUnA1K1NKWXNGVGkyL3owb09kTGZHbGVXRElzbkc0Vmo1L0tiMkpIZndxQ3FTVEh5dVN0TzZUQW43YU4xWnViY2JuZ3dCMjhSUVlFKzNFTFNaWmNQQ3c5UlkwdmEyM20wVzlCQ0xtY2VlU0RMSDJMYStqTUxNZVJ1b052RDVVVjE4Zk1lR0F6Q0FEYlVBdHp0cVM0MTJwZzZPVi95T2FUMitPS05QVXlEbzZJclh0NEw4S1JISGdXRkx5RnBIa210R0JjMkd0OVIzTkJ1OTl5dmRQdGhHa1FkU3BBaklQcUFkUVJ0VkdQQmloZkNrYktQM0VzYWdQSTkxNGpvcUQvQUcxSXRhTWJMa2d5WkduVXZHcTJBWnRXSHlGRTE2djJETmhsaTlPSzNGQUN4WFlNMnRxUlZudk1IdUVvQzRyY0w2czVQYnRWWmNITmh3MVdJTkVtWG1pNGNydUN4R3B0UlhyWDMwcW9WOXJhV09vM29IYnYrTkF6cGUyMzZVQzZIb0IwOFRRU0pJMDBzQmFnTi9udlFJM0hTL2hRTUZyN2ZFVUUrV2gwK1ZBQVhJdDhhQ1JIRW5vZC9sVVZFdDA2OURWUWdkUDZpb0M1dllIVC9HOVVTRnJrYUR4NjFGQUlOQTlSdnJjVlVMNDM4YUNRRi84QTVBYlZCTHNOZTFGSzRIZXhvZ04rWDZDaWcydGMva0tBc2IrSTYwRWdUME9nMm9BRnRibmZYNDBEdGVnQ2Z4OEtBR21tNW9KQitJMUduYnBRSzUzL0FBb0VTYjNJNjYwQUMzd05xQm9RRHRjYVVEYmNXR2hvRU5kRHYwb0Mvd0RuUVM2M3RidFFGd1FQRS9PZ091aCtGNkNRYnk3YVVDK3ExeitGQWwxRnpZWDM3MEVpcmNlWjBGQXR6WWk1NzBFblN4c0xXRzl1MUFya0czUVVWS3g0N2c5QlJFYkRxZkg1VUFPSllXMHVPdEF6Y1hONzl6UUxyY2QrbEF3RHR2UVRQUDREdlFSQnVOZFBqUUxVQUhwMUZCSU1PblhhZ0F0OVRZV0h3b0ZvQ2I3SHZRUGxjTmZhMXY4QUFvQUVXMUkyb0EzMTVmT2dXZ0FQeUJvR0NMRU1OZjFvRzI0QTY5RFFISnJXdlliMERBNGpmZjhBQ2dMN2cvQzlBckMzeC9DZ2t0MUIyMTAxb0VHWWFBOWV0QUZTZGJYdnRRRjdHNm01M3ZhZ1hLNStOQklNUmV3SEUwQmErNDFPb05BQWE4U2JIdlFCRnV0NzJ2YWdaOGxpUHhvSHBZOVBFMEVkTm12Ym9mR2diY2JnZ2EwQmYrNFhJMlBhZ0YwTjdVQzZEdjFGQStsdjFvcGkvd0NIVHRSQXhQVTdVQmNXQnR0UUxVNy9BT2xBOU9wdjI3MFV1LzZVREp2YSs5RUxVQ3cvZCtkQWNibnRwL2o1MER2WUVBNjI2MEF3TnV1MUFGdVEyQXNMVVV0YmIzRzlxQmdlTzQzRkVNZVlBYmZDZ0Nvc2RhQlgzb3BFM0EvT3gzb2hXTnZBOWFCaGlUZStwMHZRSTJGaGJjMFVXTjk3M0dsRVN1QWJna2o4S0FKSk9vME5BaVFQblFMVWVGK2xCSlMydHRkTkJRSytuajNvRUNPVnhxYUIzdC9TZ0N4STh4MjYwQy9UcUtCY2plNTFKM29IZnI0YlVERjZBQnVkZWxBWEJPdjVVQ0xXUGNWQXV0ajExcWd2cDhLQ3hGdllrNkFiQ2lvc0JhdzZkS0lqYTUwMThhQmNiZkh0UUlqcjBPd29IYzlOTzFSVW1ZN0d4SCtkVVE1RTJBTi9oUkJxVDQrTkF3TDN0cFFCWnJXNmZoUUc2OGIvQUEwb0VwL0RyUU02alhjNkVDaW8yOGZMdlJCdWY2VUJkdDlpUGxRSEpyZzMxNm54b0ZlM3lvRG1ML3FLQkEzK05Bait0Qkkydm9iN2EwQVZ1ZE9uYWdnYlh0K1B3b0FIb0JjZU5BQUhrZnk3MFVyaTNFNmp2UkVXc090N2JIK3RBYURTNG9LTXFCSlY4L2xDNjZhVUhFeWNmRmxaNFRMWnJYdVYxK1JvamhTNGN2QzVYa2lIUnIzNjlBT3RGS1JFY3JFbk15ay9TemFXdGZyUVk1TTVvbVZJNDJCQkhFaTBpc1FkYnIyb0lRVDRzdU82TVRGTi9kYlg2dGtKMCtJcUNFT1Rpd3pYV0tReFNFcHlqZXhSeG9ycVd1VHBjc0tDV1FxeDVFaXhaUzVJa1FXa1VNQUdCMzg0c1c3MEkyelljZVBpL3dEalFCaGxvdk1zcXN0dDlPVm1zdlMxV002VWFlMXI3YzBpbDVNbmszTlpHc2hVRzMwM0h4cU5PUi8vQUpOSkRrckhvczRCU0tWbUpBUW14WmgvZFJjWFprUkp4cFo4aVdlR1VGZ290ejRxZnBCWHVhSkZydUNqU0RKZU94OU1RU01TNVVtNFcrNThUUlNsSUVhd3ZLb2prdUVKdlpMSGx4RnJrL0NpU3RQdWNVaGRaWmNrQk9Pbkd5a3FRTDBHci9qT1NzTXBhTmhKRTMrNGMxdWRPUUZGWGY4QUovZTUxUm9jV1V4TWJLSjcyVlhKMk4vQ3FrY3YvajAzdStObHloWTFuWU1QVW1PdkxUOU90VEYxOUJiYnVmR3RNcTdhK0ZCTUZmblFQY0FEZWdDVzVhNm1nUk54djhSMm9KckdTcGJwdlFMVGNYdFFTQXNOTlNlbzNvRVFCYTQrWCtkQVhON2JkcUNaYlFnZ1g3NzFCQTZXdWQrditkVVMxSUdvSXRRQVArbFJScDJOdHFJWTBYWC9BQmVxR0JjNkd3NjNvR2ZFNkRlZ1Z0Tk9tdHFCZ2pzYm5vYWdWMjExMTdpaW1PZzdhVUVoYjhOQVA2MFF5Q1NCZldpbnRwcGNiMENKYlMvU2dsMHR1ZW5hZ2lUcFkvbFFJYjdmS2dMV050N2R1MUJKYkUzdmVnQ0RiWHZRUDVVQ0Z2eDNvR2RyZkRVZGFBMCtmUUdna09KNldON2s3aTFBbU5tMHRZVURHK3dIYzBDTmh1Yms3MEFwWFcrNUg1MEVoeDBCL3dBQ2diMnY0VUFGQkZ1dEFCU0JvYmRxQUx0YjRiVUFiNkUySjhLQkZmQzNiV2dZTkF0YjY3VURMTmJlMUF3Tk43SHdvSHlLNkFYN0VVQTdzMjUxMjBvRWJpMzUwQzdqOWFCampieG9EbHJidHQzb0dTUGxRQTAzdGVnQ05TUXRoZmJ3b0ZyWVg2VURBdC9TOUFmMTJvSGZTMXRQNjBEQUsvVU5UK2xBWEduVWJnVUJZRzF0eCtWQVd2UU8yZ3Z0MzhhQkU5dHpRV0pZaTViY2Iyb0lEczIxQUJkZERwMW9HZTFyZUZBcjJHdlRidlFOZFRjNzlBZTlBNUR5WTZEdDVkcUNIRzVBdm9LQ2EzQTIvSFdnaVR2ZnIrVkJJMkEwUHdvRUxIdjhlbEJKUVNiYVg4YUtCWWIvQUkwUXVWeURhZ0RZaTQydFFGMjIydHJSVFZiZzY2ZGJHaUV4TjdFM3QrVkExTnliV0IvcFFORFpodDQrTkFTcUEvbFB5b0k2Zkx3N1VEdDF0cDBBb0Q0YmRLS0R5WFRVWDZVUkc1R2x2aUtLWU9tdWdHM3hvaVZ3QWJqeEI2VUVTd3VOTFcxTnV0QVhQSzUyRkFYMEhoUUs0M0d4RnlhQU45ZmtmblFPNUZpUHdvR3dQMU5iWHFLQmhRd3VBYjl2QVVFU05EWTZkOXFBQkFON0R4RkJFa0UzOE5SUU1FbjZqYzBBeXNMNmFkL0NnTEEzQjNGQXJnSGUrdEFFNjNHM1VlTkZHdWwvdzZVUks0dUFOanZRQkMzRnR6b1RRUkduanhvR0NEOGFCc0xXSUlOKzFBclhGOXgyRkF0Q05CcWU5QXJYRitvK1ZBckMrKy9YdFJVdzUyRkVIMUVBL2pSUWRWdFlIeG9pSzlOYlgxN1VVRzk5NytGRU8xeGNDOXpwUUJWZUlzYm5yNFVFU1JZV29KRlJjNjNBb0ZheHVOZTFBdFRxUjhLQm0xeU5nZW4rVkFpQUNMSFcrb29FeDFHbHpSU05yWHZjOWVsRVNqSVk3MnZzYUJNUnlJQnVMOWV0RkRFWEJDNkNpRVFiangyNm1nUk92d29BRlFOZEtBSXNOdEtDTmdUMUZ0NkIrWURTMXRoOEtCZmhlZ2lkQnRydFFQaVNMald3MTdVQnBmWFQ4NkJINnI3K0ZCRTJ2K2VsQkNRQXFWSjBiUTIzb1BPZTllMlN4bFpJTHVyWFhpZTUwMzZYcW80U1l1WkFvOVlsQ0NBRnZja0RTL0VWTVhWT2JOUEVaSE01QmpJRFNnWHZ5MDBJOEtFWW9ZVnlIbFRIYmxNQXpCbGJqb2c1RmdLZ3pSVDVQQXh1WS9RWWNRNVhpcUtOYnNUcXBacUsxUXNIWkJKamw0SUJkbzJzakZtM1VIZlh3NlVGM0hLbXlROFJHUExIZjAwUUU4Ri90dHJlcWd5NC9kc0NOOG5KaTROa0VlaTl6ZTk3Z0ZEYmplbUdvcGpaSHVKeWNwRURTWFd3alUyYXdzeEY5ckdvZE1qUzRrYUFLcmljb09YS01DSVBjZzYvVWZsUXNEWWVQR24zRXNRZU1GQXJseXJLQ0xnS29PbDZHdWxoZ3BpRnBKRms1S1hlSWpoSWhIMDhycWJnZzZXb3JOa0NPS1pESTBja2NCNGlhSkNPUXRmVnYzRWpyUkNka3lKa1pJaWNmbGFKVy83akZ0RFlBbXlpZzFZSC9IMHlNc3o0YzdRdWpjaXJDM3k3bWxXVjNCZ1k4K1VNYWEvcUN6TzVBSjA2QS9HcWp1NFh0ZUhoci9DZ0JPdCtwdnZRWHM1dUJhcWlGL21ldCt0QXdEcU9uVzlBOUQwMm9DeFA0YVVBTGZoc0tDd09BQmZhKzFyMEVHTnlkUDZVRFV0cFllUHpOQk5RV0d1L2VnaVZzeHNkdXZTZ0xlYTF3VDBvQ3lnais0Zk9nbFlrRTl2bFVVZ2I5TnFDVnlCZTk3aTFBaHl1U05iN2VGVkVneEhtMk8xUUJLM045ZjZVVTFZM3NON1d2L1NxaDZhalFFVkZJRWE2YjdrZEtBTmpxTnJhMFE3allhZUZGTlFTUHkrZEFHNEl1YUJnbnI4cjBFaUNOZHVvK0ZCQml4T3U5QklFRlFMNkE2WDNvRisyOXhwdUtCQzN3RkJJbGdOclcyb0FYSU50ZXRBd2JlSjZlRkFqY3NiYTJGQTdBazYzUFNnQUQrR3BvSG9HL1NnbXEzR29vRUVKSnQwM29DM0kzUGJlZ0FiRzE5dnpOQkY5V0lzQmFnbEhkaUFMWDZFNldvSnh5QkNWSnVEcnBRUklCTzJ0QWdCMzBQZWdrT09tbGdkL2hRSXQ1Z1FMazdpZ0FMYUhydFFBVTIyK05BWHVPbW5XZ1paVGZqb090QWxPdHp0Mm9HU0MybTNXK3RxQUsrWFFnOURRQnNMZE85QUFHNEhTZ0NTRHB0UlJyOEtJc0xEamUxdE54MThhQ0JKSFczaFFOU1AzYmQ2QmtuYTE2Q080OEw2VURzTlRjVUNPZzFPblh2UVNISW9DZExuZWdiaXhzZk44S0JYWXFBYmtYK1ZCRWIydFlVRTc2WHZ1TFdvcUlzQ1B5b2l4WW1KS2picTNoUVFKc1RjM29xUUlOckMzZTlBSGlScDg2SVhtMjJ2dU9sQTA1YVdIeTJGQkxtZUc5d05MZEwwRUZ1VGJmdlFTVlRiOUtBMEpGdW0zd29Hb0lGLzhmS2dRNXNRR08rZytWRkdtbzZuL0FCb0tJTFh2cHFON2RxQld2cDEzMW9KQmR5ZGhRTFRZblRyUUlzUnNMYTZVRXR0VTBPNTcwQ0xNVHlOaWV0NkI2MzVBYWR1bEFya25XL2lSUU5RM2E1NldwUk41RmNXS2NXUFc5eFVWWGZYOGpWUTdrRVgzRzFBanFUMG9Hb0czNFVVeUI4aCtWQkFhQUVkTlRSREo1YmJucFFBME5pTmFLUU5yWG9pWlBJZEF0L3pxQ043Rzl0T2dxcVRFVzhmeW9oRHQwNlVFbHNOeGNkNkI4SDlQbVI1VHNhS2llUTJ2ZnRSQmEzbUxlR245YUJXRjdXMXZRQVU2a2l3RkE5cjMwRkFybXd2MTF0UUszajEyb3BpNUc1djRiVVF5TFdOOU9vb0V1NVBUd29BWEpKRnpwOEtDZklFV0ZoYlhrZEtpbzhldTVOVkVmM2RyMEVsSkJPM20wMW9wYzJVVzI3VVFyZ3JwOERRQ2xkanFMN1VBTEFra2VOQk1qbUMxd3AvdC9TZ2d3QXZjYWp2UUd4QTc3R2dDYmFiMjB2UUs5OUxkZCt0QXVWenJRTTJ0cHZRUko4RGZ4b0Y4dW1uejYwRWdRcEJ2Y2tEUTBVeTNtdDAySFNpSWRTT25XZ0NiblRwMzMvS2dYTHIrbEFHZ05iMzNIYnhvRGxlNXRxZERRSzJ4SHpvSGJ5NkN4N0NnRHhLaTQ4dzJvSUFkdCt0QUEyR3hKMk5BRnZnUENpbzZIVzN4b2gzM0hlZ2lXNmpjYjBHYkl5TVlSdVc0bFUzQlBhZzREZTdlMk1vbmpVOGdMaTJwN0VVMHh4UGNzaGZjWWhFc3ZHTG1Tbk1jVkJPbDJBM0FvT2RnUVBHMDhnRWNrQzJZUHh0eEY3Y2lTUnBjVkJia3llMytuNnlQa1pPWGxYL2pjY1VTMmd2MGJ3dFJXejJ2RkFBeUpVamh1T0RBTHpKSjNLaGp5dnBSS3l6bklneTFPQVhpUVhZU3F0eWJmMi9EclNrUTlmSWtqbGt6SGxuK25pMHI3RTNLMFZmN1ptWldOSUFzUWRFUUZpUEtDRHZwMW9saWozaktjS2tiUmZhK3BkNGxjamlibjZ4YlViVVdNV09HU0FUdnd4c2QxWUdVTGVSaXAra01lLzZVS3Rubm1rWVR2TUo0bDlOV1lnb3loUUxnQWVWcUM2WEx4SlpneUV4UWdha1dVc0xhSGpyeHVkNkppakVPUThqNUJRc2lkV0pMQW5xQ0tEYkg3aFBBcklxaEJJZjVPR3JEL3dDM1NxTzE3RjkzRFo1VVlpUWhmWGt1Qjh2alVWNm9TZ3JydjIycW9nMWhmUW5wVlJINS9MNFVFZ0xpNW9IKzNmNDBDUVcxRkJMVGZyMDExRkFCK2hCOFBDZ0JZZmo4YUJrOWV1NVBqUVNGdHo4QlFSRno4RDAvcFFNZE5OS0E4MjEvblFTdGJmVWRxaWtMMzAzNzFVTzdkVDhPb3ZVVTduZnAyRlZBVGJUODZpamxwclluODdVRWlDUURhMTlqMW9oV1VFMk4vRHhvb0ZpdCtsQXdwMkEyNzBCZnNELzA3VURCL0h0L1dnWmZTMXRiVUMvTVVFOWxGN0h0UUlzT291QitOQXJnaTJ0K2xBQzNVYWRHb0pXNzdkTFVCYzN0K3RCSlNRTERwMm9FYldEZGI3VUJwY2FFOWFBdUFOZm5RTmkxZ2RsNlVFZXcydjBvTEZrWUphMzQwQzVNUnVSZnJRTG9MZmpRTzE5U2ZqM29FVk43aSt1MUJMMDlMRmgzdFFSdHI1dmpRU0o3SFMzWC9TZ1F0YlRYd29BYjYwRDAxdjhBNTBBRDQvR2drQU5iM29BbmF3MC9XZ1dvRitOQXJrNm52b0JRVDQySU43OHU5QkhYYi9IeG9IYStnRnI5L2hRTFVHMjRIYWdrb08vNURyUUkzSGg4YUFPdzFzUGhRUHk3dHIvbDhhQXN1dmZ0MG9HZVIwQTBvQ3g2bmVnYW9TYmRmSHdvSWtXYlhiU2dtRlVEZmxmYlhZMEVSY200MDMxb0ZxZHJudU9nb0pkYk5xUU5MZU5BV0JHbTNXZ0JlK20zYWdmSTJJQi9DZ2p1TmZsNDBERnR0ajBvR0xXL3BRQjFPbXcvR2dDZGpzZHFnbFlkTmJmMXFnMEhTL1kwQ0RjZGIzTjlLQksxajV0alFNTjI2VUM2N21nbDV0eCtJb0MrZzduZWdUTnlZRzF2QlJRV0lraFlXQkFPdmhSVVdKTnhjYUdpRUNMK2ErMmgvU2dmSUViYmJXNjBBUmY0ZDZCWDJIU2dMalliZGFBNU1OanIxb3BEdjEyb0RXOXU5RU1BbmMyK05BTFlONWpiODZDUVRrQ2ZHZ1d1bzJIYWdoYXhOQXdkUEViZHFDVnVXOXRldldnaTJtcTZkYi8xcUJibTU2VlErUkJzTnY4QU9nUjczb0d2S3gydWFCVzVBdCswbTN6b0dXWUxicDBvQWdqUTBFUnZZalR0NGlnbFpiQzl3ZXBvSmVtN0RudUwwQ2J6RUVBRHdGQkJ1OS9uUVN1ZWxqYzN0Mm9KS0FMc043YUNncll0b0NmaUtCRVdKVWpVYWtVREhJR3dKRng1bE5Bd2RlbW10QWNqc0FOOXFpa3hQU3g2RHZWUWFYdWJINFVBOWg5TzNjMENMRTN2dDJvQ3hMQWpRMzJvRHdzTDlxQ1NLcHZ5Tm12WVcxRnFpb2tXSkY3OXpWUUZSYTQwdisyZ2FXSnNSNGFVRVQzb0VEZlhwMjcvQURvR0NPViszU2dPL1hjQzlCQTMyNmdXUGhSVXVCdGNXdDI2MFFsVmlTQnIzMG9wV0hhL2hSQnFEc2ZDaW53OHZMdjNvSXRlK3UvWTBBaTg5UTMwanJwdFFTdGNnZGZDaUltNXZiNTJvRHpBZ2JVQ05pdHpmbGUxdC9uUUlFcXdZSGI4YURGN2huQ0NKWkZjQTh3Q0Qxb3JuWlh2cUJROERxMFlZaDJPNHQxSGhRUjl0OXd6TXIzU1Vsd2NlTzRDS2RUZTFqK0ZFZDNtZ3NvQUIyK05CaDkza2xUQ1o0NUJHNmtjU1JvZkQ1MEs4bmtIT3lvTW1kSEFibUI2VGJXWVd1QjhhR3VKblR6YytFU3NIaUFXUk9RMFlEWFJmeHFLcnhwSjVaSTQrQWtsa0hGcGVRVUN3dFlBNlhGQ2xMajUwazdSd3M4U2dsWjNjZ3h5V0JabEorRkE0VGpRUU9va2xlSGlFOWVNbFVScjJRWGJxT3FpaUZIRmFNeXlUbkhpWThZaEl2SjVXMnZkVFphTGlUNUtnUDhBeXMvRWNwMUxOWWpZalRhM1lVRkdZSWMyT1A3Zk5CZTFsTS84YTNBMUEzdnRRUWduRWhiRVZUSEduRkhrVzdCaW91Q0MzMDZucFFhYy93RGl3WVpNdU5aMWpVaFViZE5iK2EzN3ZqUVRpOXo5dGx3VlhtUXJndjhBYnQ1Z2hQUmI5OXIxTk1ZcE1uSFNLS0NSUFE1K2NGVzVCbUowQkg3YkR0VkdyMjlaWlhhQVJwa09wSmprR2pFOGJCYlUwYmx6Y2oyc1BCSkdIYVlEbFllWWFhRFhlMUUxWEJON0xFcm1lVnk1SUtCTkVKT29COGFERm1UZTYrdW4vbFBOSExjNDhVWjh3Y2JjaDRVWFZrdi9BQ3IzTEZ5SWttWmx5SkV0SEhia2cwc2VSNzZWREgwNXQ5TlJ0clcyVWVsOUxIYTI5QXdSZTRGeWZ3b0EzdnJ1TzNXZ2pmVys5OWFDZHV6YTBEMXZicnRVQVZPdzM2QzlVQ2tBbS84QWp3b0prQzM2MEFWNi9NbWdSNDlEY1VBR3ViRFQ4S0IvbCtSdFFISFU5QjM4S0JNUnYvaTFGVEgwazdXR2c2bWlFVkp1ZTI5UlNHM2J2MW9KZ20ycHNOTEh0UVNDb0JjL01pZ1RsYitYVzJ3b0VDU1FlKzlCSzQzR2cyb0RRYmtFRVhvRVIzdlFDdGJYcitWQTdra1dKMW9KY3REcUxkTktBT3cwMTYwQmJwcmFnZWx0ZWhvRURhMXpyUVQ1M09nK05BRndSNDM2Q2dZY0FXdHYzb0VEeTBzTDMxb0RVRFRYeC9wUUpSclk2SGVna1JjQTMyMlBTZ2ZBa2p2YnJRSUd4RkJJZ2RQK3RCRW5TNDJvR1dKSVBiVDVVRFVNM1lkdGRhQmFCZkhxS0JFaTIvekZBZ1N0d1NDS0NRQkl2UUFVOVRxZWxBdzRWdGZNTzIxRk1qVHNmR2lHeFRZZzZBRGpmODZDRmpmYXgvTTBEVWkyOXU1TkF5UEo1UnB0NDBFVGU5cjZkUlFXUjhUZFNEZTJsQkVnaTRCNlVEYTE3OGlSdVRRQkk0MkJvRmEyMjFCSkVETi9hT3ZLZ1Y3YUx0UUZ3UDhBS2dtV1d3L3U3MUJBRmIzT3Y1YS9PcUdwR29HZzdkYUI2Z2tIOEtCK1VkUGxRQjRFYUcvZnRRSUcxK3ZTZ1J1RHIwb0R6RWVHNXRRU1lDMmhvRWR0TmVsQXdCYlRUeDhhQmRkQmJ1RFFNMnRjSFU5UENnYVhJc2RLQmxyWHNmbFFSMXZmZi9PZ1c1dGZlZ21WS0c0Ti9qdFFObzJWUXh0WTdXTnpSVVQrTkVOMjdIUTl4UVJOZ2RiNjJvSkI1TndiZExVQ0oxREFraHVwb0RVRFU2alVVQ1k2MzMxb0xBd050YlZCRmdMMzZWVkxYVWpZQ2lHRnViRFhUNFVCdzhOVDBvQTl4djQwQzNzT3BvQWl4OGRybWdkK0o1S2ZFZ2JVRGVYa3dQR3cyTnFCTUJ1dS9hZ0FiRTMrWkZBemJTOXZqUUt3QnZmcm9UUUhIa1dJSUFHcEpxS2lmMHFva0ZKRndOTzE5S0JFWE4veG9GcGZhL1p2OUtCOWJIZWdicnhJdHFUMm9JcllYQnY4YUNiMnRwMHRRUTVOcUxtM2J2UU5Tb091bzdYb0lrWDFBL0NnUVlpNDBOQk1NcTNCWHpIWTMyb0VUMHRZOVdOQU1EMzVYM0hmNDBDdUQ0bmExQTJEQ3dZV0pGeHBRUkZ3UWRiYjBBeE81MHYwb0RpTDJJMDZkL3lvQmxzQnI1dXRBanBjWC9yUVRSQ1J6dGNMb1FUYmVnaVBxOHVsL3dBS0JYc2Y4cUNmazFPb29JRzF6YnJRQUo2VzA2bWlrdTl3TEU5S0laNDdEYnFLQktkUWJBL0dnTGk5K25UU2daWW02alcvWHJwVUNRTnRiUzlVV05HeWdrTjh1NHFDazZuU3d0cGFxSDAxSnVOcUJpdzY2SHYwb3FCQUd3NjZrMFF5dDdjUU5Sb0IvV2dseWpBQ2tFTU90QkEydnJRUjduYWdDTEFIYS9XZ1REWGY0VUhIOTA5aGl5a0xLV1dVYXBaajlXOXhWU3g1M085bnlzZUNKWkpYZU81V1NKckEzSTM1RGVvcVgvSE1zNHZxWWtIRjUxWUFjanFWdmE5N2Eyb08zOXhsTjdvanVBa0l1Z0hVazdFMEZQOEF5TEtmN2RmVGxVZ0c1UUhVa1VIbFdIdURoa1NVUDl3ZktpblZiNkFIeHFHc09RSklQNXBXZE1xTzNNL1dwSjBzOXVwdFJVaDdqbFBueHRMQ3FKZTVMMmdzQUxFRnJOcFVGMkw3d2tLNUR2QkVabWQxZ244ejJCMlh0ODZxS01mMmozR1JKcEdLL3dEcjlXZG5ZcW81YUZnVDErVkZaVkdQaTNETDl4ZXplcGNjZExqVUhwYWduNnptUzBQR0lNU0ZtdFlrSDQrRkVOZmFjekY5VjQ4ZFpWdXA1VHFBdm04MmpkTDcxUm1obkFrQzVxU2VqeVprMXNMMnNiRWZHb3FPUk5Nek9KWm5mRFg2WjFVaTdFY2x2NC9HZ1M0aWxFYmdzejNIa0Y3ZExEVHcxcURjM3RpNU1qUXZreENNbitLQ01IMUZQVFQ1V0ZVVkdNWThpcmtST1pXRjdtNElZZlZjYWFqZWdveVRJOGtUWTJXSmwxTFFzRzhuWUZtMHVmQ2c2czZsWUlHOVlGZlBLSWdGSUVvOG9ISGUzeG9rWURpWkM1RHh3NURCcGlGa2tOZ2VURFd3UG00MFYwNS9ZY0tIRGtrek12N25JaFVMRlpRT04rb0ZFZlE5TGc3MjArVmFRZWErbGdldzdkNkFEV0MwRHZjNzc3MEFmeDYzb0h5MEJ2OEFocmU5UU5nVGE1SDQxUWxBdHJleG9HV093RjEvT2dDNEtrSFFDZ2ZLMXVuU2dWOVIzOEtCMklCR3dCL09nQWRmMDcwRXRPMitoOGJVQUdGeVFOLzFxS0xzRnNCcjNxaWRyWEY3VkFnTmJEVmgwb2d0cjIzT3UxRkJQUy9sb0h5dnFUNFdGQTdHeFBTZ2tTdC9OZTlxQ0JJNlg0OURRQU96RDhONkI4ZExuWHJRTVgzNjYyb0FYSTdlRkJJYkE3ZUZBQngwMm9EbGZVWHY4YUFLaTF3YjlLQkFmaGVnZkpoYnFPbEEySkdsaDNOQXRHTmliZHpiV2dDYmpVMjdXb0haYjM2ZHFDUWJZWG9IZlU2M1A1VUVSYmUxKzFBd2JXT3dHdEFBZ2kxOWV0QXlUYTFya0hUdFFBc1NSMzJ0UUt4NzZkZkNnTkFkTmFDUUdubDI3YlVDQU85ejQwREszMzE4S0NMRFMvU2drTlRmZWdCMzZmanBRRytscmZDZ1pOeUNSOFIzb0dsdFJleDdkNkJjV3Y4QURzYUJHeE8vaVQ0MERVdDRqeG9HeWpRcnQrWHpvSkFIcDN1TzlBeUw2RGUyOUFNbHRPb0ZqMm9JZm1Sc0tDUXVBYjJ2dmZ4b0lhZ2krMjkrOUJJYTdXdVRRTXJZM1BYZWdZQk4vSGY1YTBFV3ZjMkZ1dEEwVm11QjhiVUJ1MjlBWEdsenJzVDNvQnJjUWIvSWRhQjhSMDI2VURJdUxkdC9qUlUrVjBBdGUyMUVSYTZrWEdyZlNhQk1iQ3gySFdnYU93UEs0STIvMG9BNzNLK1U5QlJTNUd4dDhQOEFyUU1hMllpd3Y5WFNpR1FkL3AwMEZBcjZkTEg4S0FWMXVBMm82OTZCTVFXdUI1YjdYMW9BWDYvSWlnTFdJQjJIU2lwRUtOamNXNlVFVDRIVC9PaUZxeTcvQU5LQ1owR20rL3k3MEN1ZUlBSXNkeC9uUUxpUmJ2MG9HVGZ6YlgwdjNvR2hJVytwNzI2VUNKSnZjQy9lZ1Z1bzdiVVV4dmZlMUVTVkM5eUJwMkc5QkU4Um9UNXUzU2lwS3dDbTUwSFNpRnkyRmhwc2ZqUUc0SHhvR2JFR3gwRzlBaVdDZ0hZOWU0b0YrMjUwNlVEYVFOYTloWWJpaW9BbGI5K2xFTzl6ZHRmRHNLQUp2My9yUUlhTnI4NkIyODJ4djJvRzdzYkU3OVRRUkpCRzJvb0dHc2xndnozTkFpTDZIUzIxQWNiS0RhM2I1VUMwTzJsQk1GaUFBTG5YeWp0UVY2cjQ2L2hRTWEvL0FDRkFCaGZYVUE2aWdiWEowUHd0UUlBblhvS0JuZ0JkU2VRM0FvcGFzMm1wTkVJM1BhKzFxQTFOaDAzQW9KTXhGd3V0OXdLQ0Y5TnV0QTF0WWdiNzhxQ1BKaVQrRkJMVWFhWG9GY2k1dVJiU2dBVk9oRnU1K05BdGJqanYwb0Mrb3Y4QUEwRDRtMTliOURRTXlNRkszMDhSUVFZazduWGVnQWUrb0ZGQktrZ3JvUDYwUUVianArVkJDeDZYdjBzYUtrb1lOcCtGRUpsdGU0dDhhQUw2RWZqM05CSFU3NjBFam8xaU54K1hoUVFhNUhqdlFERHIwb09mbSt1d2RlSUtxT1VjakFIemRxRmVMbmtuRXNrSVJaakJwRzhLbFN6bTJybGQ3VUk1N1p2dUNpVm55SGpURkpBUlFXWnRkZGRyZ0hYd3FLMVlmdUV6WXdlT2FKSlJ5V0ZTb2NrS3R5U1IxTzE2SlRXR2JLa2orcUdYanpuWm5WVjRqWnJEcWFESExKZ3haTTBHUThscGh3SHBua0J5MnNwOHBvckU4Q1J3aFkxZWFRWGtiaWI2QVcvQUdnc3hYeklrUVRZOFVTQitVYUVrU01XQUZ5TDZpZzNTTERNd2pNL3JEVXZISGZRblQ2VHBlZ3BYMjJhS1JveWdHT1Fwa0Z5ZVNqY1hJL0dnaTZaRHlKQ2theXhXdEV2Q3pYTi8zaXFqVkJpZ1Nlazd0anRrWFY0UzNNaTJubURFVzhLQ1VPR3JBeFJxaGFUK01ST2J0cWRiRzFoclFjeWIyd3dlcXNrb1dTRmlaSWw4M0p3ZU55ZGlMVkJaaVk4RWVPclloTXNYTXRQSXF1am8ycTJzMjRvclBrSjZtU2tVcnZBRkY0M2wvaVVxR3NWRFhKb0Y2Y3loNW9ZM1pBVEl6dVNWQ25vVHJvZmpRVngrcGtOTkxPMW80WERnSTNMMHdkbEh4R3RCZmgrNHhaSjlSTVBualIyOVRLR3JBc2ZLWktEb2U0eSszR1MySkJJSkZXelNTNk1wMEpOaGNHaVltUmpIQ2o5Tml4bmYweS9Hd0lGeVdSdWw3VVY5Q08ydW5hdE1vM051dzdkNkFVNmtDZ2Q3MzZmQWJlTkFBa0NnbW9WdVIwdU85QWhxZmgxb0E4aDRHK3RBeDVqcWJIdlFKaU5PdldnWnVRT1RYc05CUUFKdnBwME9sQUVtNXRieG9HTkJmcjNvSGY1RHhvSmpYUWREdFFCS0FrWHY4S2lscDhxcUZxRzA2N1VVd043N0dvQzMvVGVnbllBWE8vN2JVQTRzTEhmb0Ixb0VGTit3b0RjOWJiVUQwNURvTnFDVFdCc0RkUjFvRXQ5Q0JjN0VVQW9GOWIyMi9HZ2Q5ZmhRTFErTkFDOUF5Yi9oclFGdGQ3andvR1FDTzQ3VUJvTEFENDNvSkhVR3dzZHZqUUlFQUVBWE8xQTcySTBzQlFCTmliRzVvRVNkQ1Q0VUVneEhTKzFBaVJ5OE90L0NnbFljajV2TGI1MEVXQUowT2gyb0phQWJXSjJQYWdQOW8xb29MR3dHbTEvSDhhSWpjYjJ2UU8xemJVVUUxSVhYcmZVWDNvQmlISk4vR2dXM3hvSmVUc2ZDZ1FiVHYvbFFERTM1RFQvYlFLMndHL1lVRnFoR0hGYmcvdW9LL0x5c2RGNmRhQmk1MFhXM1UwRFlOc05RZE5hQTh3VTlMSFU5cUJLelg4T3ZlZ2t6K1c1NzJOQVdCRngxb0FIUzJoMDYwREtnaTkrU2pid29FZUhFZHpRQTJCdnB1QjF0UU0zSjh0N2RmQTBFTk94UGE5Qk1FV3NkRGJVM29GYTZudFFGaGJleE5CSml2ZlVDdy96b0VsckVEVW5iNDBBRDBHMUJNYTZkNkNKQk5nVG9mbmFnR0NnRGpzTlIzb0FLM3lIWHBRQkp0K29vQzY5VFk5NkFCRnhmUlIzMm9BblhlOXZ4b0N3SjFOeDBvR0FRMmxqMDcwREVUTXBib09tMUZDbTk5TE4wb0lrYTZYTnYxb2hFSFFDZ1lHaHZlMUErSUZ0UlltMUFYNmczL3BSVVNORCtRb2hpM0VtL3lvQTMxL3dLQTVFZjZVRWhhd0JXNS91K05RRHF5bXhGdTlWVFl4Z0FJRGUycE8xRUwxbkFzQ2FDSTg1TjlMYTNOQTJVRGJTZ1JHZzhkTmY2VUFTZGdOaDIxb0pJNEZpTlc3ZExVRVNWSjYrSm9GMXVldEFBa0Rmd29KQUhqc05OQ2FDTERVZnJRTWFEWFdnUXYzMzF0NDBCYmZXOXRhQkE2RzFBVzF2c2U5QklLUXdJNjlLQ2JBRUMydHFDdlVuNDYwQVVrQXZZNjBDNXNyWEhsL1dnTDNOOUNPMUFLTEtUL2pXZ09KRGEvVUJyZWdMMzE2My9BQk5BQmp5MEdvMC8wb0dDd3VvSThiaTlBTVZXM0VtM1gvQW9FdkhrTGk0NjIzSW9wa1hmUUczWTBSRzUwQkczU2dUVzArRzFBeXZFWE4vR2dpQUwzYllkcUI4M0pGemNqYTlBRUVBMzJPNG9GcGZjcU4vaFFPL0U4VVlsVDRXMm9GMHNldTlBeWVnMXR2UVFKQU85L2pRSW44UlFJRzE3NitIZWdrRk5yaTNoMC9LZ1d2NDcwVU0zSWk5cmRMYWZqUkNVNk1EMS9XZ2tTdHR6eXRyUVE1WHQrbldnQ1RmVzJtNG9BSHBlL3dBYUJzb09sdHZ4b00rUk9Zb1drVlM5dnFBNjBLNCtSN3RISzRnTTZ4RjdrVzFOZ05RNE8xNkhiaCs0UVBGSzZJOGJRaFJ3bFltNm5hMWx0ZWc1bnVlTm1RWThzOFpFeGNjSlFGS3BmWUVqWmphb09Gd3hNZG41SzBreU5kbEFaSTFEYVdXMmw3ZFRSUnc5REdpWGpLV2xCSXRjSkkzUUU3MkIyb2phc1VjaUJCR1B1T0JBdnk1RWtDeFlOOUk3ZkNpcjR2YmZjL3R1S2F1c2FoSkN1cEkrcE5CcjhhSWpqcG1UZTR5TGw1VU1ib3lyeElIcWNiZlRyMUZGUE1pUVpraXlBbzZSOGdnNHFRQ0wzWTMrZE1KUmo1Y0U1TVRPem8xa1M3ZVhUWDhLRHFMN29ZTUJveUlpaDhxdnFIWGpvTGQ2STUwcmg1Z3JYQmtBTjVCeTY3bGhSWFFhYk9pZ2x4bWVOSWxSaEk4WTVjbElCM0hRMFNxWTRwc3FKUWtVS1J4eEQxbVFjTytwQnYwb3FySmdmSXhFandZcFpjaHRHbEhhOXZONCtKb2pFY1dPSm1pbldTYzQvSW8vcUtWVnh2dmU5ajBGUlVHUHFlM2NENlQ0M0lzakllTXJjeHN3R3ZFVzYxUlJGaHJqS0Nrc0plUWVuSkRIZTludGZVMnRwNDBGWlgyOW5HSzhheFIyTm83eUJTeE50R0ZoYS9laGhTd2U1cGlSTkZsUXhJUy9LUGtXWm1YVUJsMXNiYVVIUXhNb3lZcXZrWktRa0VJL0ZnUnFOMUhRVkZmVFN6VzhLMndYd056dGFnWFRhZ2xld0pCMTM4YUJobXNTZGJkOXFBRGFXT2hHbytOQklBalh2b2FBdngyM09tbTlBY3JEVDVpZ0xYQk93b0psQ29CT3A3OVI0VUNXM0lnL0sxQVgzTnRMN2VOQUUzRjl2em9EekVlYlVVRWxKQjIxSFNvRVdCMUJzYW9mSFhXZ2xZYWc3bWdaVzY3a2diVkZSMXRvTC9yUUhYUVgvcFFBWTNHbTlCSU1iYmRLQjJIS3h1UDZVQ1lqUzE3WDA3VUFCdmNiMEJieCtkQkpiMnNEcFFCRnlQMW9CZ1JvZE8vaWFCOHJIVVhHM3dvR3dRNjI0L21LQVlvTGNTUUJyODZCQTJKc1NML3BRVFFLeDgzMVc3VURJSWF3MHR2UVJZMlVpL1g4YUFVOUxmNDhhQTYrSjZVRXVJSzhpYkFhRTlxQ0ZyYkRUY0dna0ZJRjdqOHFCSFhhZ21oSUY3WDczb0EzVmJHL0Z0N1VDVFc5L3dBQjFvSmVvZUpVS05Ub2V0QkRXNTMwb0pJZHUxQkxpeEhodHBhZ2pkci9BSmZLZ0NUZlg0VUM2azYvMG9KV1pmcTM2VUUwSUJ1dzVXMHRRTGllUEkzc2ZsUUFGZ1QwMkZCRnRDYmZUUU5iVzJvTEhkQ25Ialk5RFFRM1VDOXorVkF1K25TNG9DeEFHdnhGQUE5L3hvR1RjZ0FlSUFvSkdTNEF0OEdvRllYc0RvZXRBTUxBRWJHZ2taQ2RSb2ZEU2dqMFA0NlVEUEFwcHYyb0VBZTVzUHlOQTdnanVUUVQvajQrVUhrUjFHbnlvcUZoYmZVN2ZPaUdEdjFINTBEWUFhQTJPbjUwQ1VHL2Z0cjBvR1NMNzI2WG9FZENMNmpyUUsrdW92MW9KRHB4RndiaWluNlpONy9HaUVCcGJxS0EwdVFkUitmem9KS1dXM1Q0ZHFnVnZ6NzcxUStPbkxwMjYwVkFBMzAwUGVpSGNnaTNUOWFLYk9iOHI2bnI0MFFJeWE4Z1FQRHZRTXN2SFRUKzAwRVF3SUlJOGI5YUF1RzIyL09nQXB2dDJ0UUdwSUEzdnZRSyt1cDBvR0dIN2p2cDNvRUR2MW9KcVFiSzNldzhLS0NvTEVLYm5wYWlGY0tiV3Ywc2VsQUJRMTdtMXQ3MEVWdUxsVHI0VURCVUtSYXc3blcxQkhYVUNndGp0MUdwNlVFR0Z2QVh0UUFRRTJVM29HSEtOMEpJdFFJQWpYcC9qU2dlaEZ3TEVmMW9JM0F2WWFIeG9DNStSNlVBUW9RTmYvNjBEUWk5dGlOYjFGUGZyZXFpSnNEb2I5NkFWOVJjblhZVUVXc1NUK0hlMUF5dzZDeHNLQmczMEd1bndvRnJyZTJndlk3VUFDTDJKc08vYWlnTlpyMnZjNjMyb2dkbVlrMnQxOHUxRlIwdnRZRHBSRmpGTCtVY2ROZXV2eG9FQWREY2tlTkFQR0NiQWJqdlFWN0E5YjlmaFFTSDdnUmMwQ3UzYlUrRkFsUFUvaFFLMStvdDJQOEFwUVN1M0gvYURRSzV1UUJhKzlCRm1MR3gxdFFBdHk4NXNCUVNBWGUvdzdVQ1kzSjArUTJvSW5meTYwQXBJdGV4SFk5YUF1RHBiVS9rS0NKVWJFM1h1S0FOdmlUMU85QTlMMjM3bWdURGY0NjBFVGM2SHAxb0ZlLzlLQmtNRFk3ZmpRSG00M3RiNTZVSEk5Mzl1d2lyek10NDdFeUt1N0dxbGNGL2E4Q1dHRUxKeVlsbFZuWW9UZnY4S2hZcWthYkhLUVN5bVZJeVBJb0FiMHdQTXdEYWJuU29xaUgyR0hJa2tVeXBqaU1sSW5uYTVkZDdBRCt0VVovZGZhL3Q0bFIxOWJHZnllYTkwWGZrcHZwYmVtSnJrbEpNTmcwYmlReCtVVE14WWxCcUxqYW8wN2VMNzgwNkdGeUpIQUJNY0doRnhwZGlMVVRITnlJL1ZtTXFLVm5Za1RGaHlCdWJYdU90VVpwSVlPTUxNR0Vra2hqYVdSVHN2WlR0VVYwWWJza2R3a1dFTHBFQWJzQmU5OUI5VGVOQm5nOXZVNURmUStoc1pIdUVIOTFxRFhqek5FWHg0RWphT1hRaHJIemRlTGRxQ2MvdUhwUS9hcW5xRlJ4ZTVLOFNPNDZpZ3hlcEdFTXpvWXBMK2VRbGdDU2JqYlRhaHFvZTVUWWlUUmdLOFdTQURHdTRXOXdlWGVvcm5aY09aTTBzK0JBL0ZJd3M3b3ZHTlZZNnZ4UGZ2VlIwUGI1bWl4a0o5RElaWXdPVWtpc2JsZFFFR3BzYWkxVGtHWEpSWlZnV0JsdVhaQmRXQUdtbDlRS3FPcGorOFFZc2NXUE43YXMwc3FYZ255QUR4SU5qNWJXdDFGUXpWcTRQdGM4TFpXVk5HazRjbVJrQUduZ3V4clROdU9ETWtaZGxEREZqakJLUDZZUE1tekFlYmFwV28rdGNTUnhQWHFSV21VTnRUOVA5YUFPcElHbllEYldnTlIrbmVna0QwUFNnWTE2Yi93QktCcUI4QjQwRFlMZnltdzdtb0Y4Qjg2b2RnTERyMVBUV2drQWRiMytmaFFQY1hBMjNOdTFBcmEzN2FtZ1Y5UjI4S0NZUGE5anBhb0Z5dGEyaHFoRmlYdmFvSkt6YkRRaldnWnVkVHZSU0owRmpwK0ZBd3pMWURyOHFBdWRyYTcvR2dOZmdCL2dVRXRySDh1bEFDN1dHdHlUUU5pTDZhNjc3VUF1OXRxQUpHdmFnbUEvQm1YUWRlOUJHNTFCM29DeEJHdC82VUMwMHYwb0pjdktScGNVQ0pKdDF0b0JRSGZwK2RBd3pDMWo4VGVnWkozNmZyUVN0ZjZlZzYwRWVPOTlLQjhXdDVkUjFvR2JXTjlHR2dGdEtCTHI0RHAvbFFTakZ6WWtXRzlBRUFDd0Y3YkUwQXJFNmQrZ29CdGR2blFMVWFEVHc2MEVndHpwWUQ4S0NPZ052MW9KQWtYVUc0dlFIbDZueWczOGFBNURYcGMwQUYvSHI0MEJmeWpYL0FFdFFLOXRhQmhRRHJwY2JpZ2xjV0d2eW9CMEtnQTIxL1dnU2drZ0FYYStnNjBEQXNTYlh0dU8xQTNJUEZ1VnlkK2dGQWVYa0J0YmMwQ0pQSzIvUVVEQzIzdDg5OUtCRlFEOGRxQmxTRGZwYjRVQXR1UkJiWG9lbEFOeEFBQkJvQU1lNDBGdGVsQWxPbDlManA4YUNSRmlPL1dnUTVBZUlvSjczSjIvR2dXbS8rTktCeUcvdzF0cnQzdFFDRlZZOGh5QjI2VVUvQTlUUkNzQm8yaDN0UVJHaHZmWHBlZ254djRmRGFnUkJHcE55UlFIQ3d1UnB0ZWdWZ1BIdFFUNWtFZjIrTkJFTnYyOEtDUStuY0MzVHJRRnlEcHBmcWFDVitRQllDeDYvQ2dnQ1cxL09nZkE5VGJUcWU5QkxrcFR1UnNEMm9JQzJnT3c3YjBDSlc5cmlnWUp0WUc1UGZhMUF5cEd0ckViMm9xTEFBRGY1MFJKV1cydDlObW9FVmJRbmM3R2dZNWFzVHR1YUNQUTIwb0pJVTNKUHdvSk95VzBOeDA2YTBFRkpBQkcvaHVLQUpJSkpIMWRmSHZRRGtYUEc0SGpRQ2E2WHNDYUJIUmo4ZjhXb3BkTC9BRHZSRWk5N0xxUUJwUlE1V3dDN2dYTkVKSDROZlFnYkVpOUFqK2RBY2lOTnZEdlFNQUUzM0E2WG9vdnJjajVHaUJpR0pJOHR0aGYrdEJHeDZHOUJLeEM4aUxnOWIwRWRiM08zaFFNRTYzQVBRMFUwVWx0QWIrRkVLOWlWT2w5TCtOQUlRQWJtNFAwanhGQkVFRnRSdnZhZ20vbTRpd0J0YlEzb0lBRW05OXZ6b0FnNy9NNlVBeDZIZWdlL2dQSHdvRGNhMERGZ08zaFFKbkozSHcrRkJIa2JIOURRTFU2Zm50UVNibmU1TitoMW9vSVBFZHpzVFJFU1NOQnNma2FCRWdqUVd0MW9MRlZTQXhhM2VvcURXRzIxOTZxSTdDNEZ6M29FQ1FBZHY4NkNXbjd0dTNqUlViRFVBM3ZzUEdpSldCMDQzUFMxQkprWWI2ZHFDc2FpMXplZ3Jra0NSdTRGeUJlM3dvT1ZEN3o2cm9JeWJsanlRL1VCUWRWWFk2MzMzb0pFa200MTcwQ043bTUrQm9FcEJQbTY5dHFDSkNnRVgrSW9NZnUwNWp3Wkd1dmxGL01iZkNxbGVEazl4a0t6UlpDRGh5TWlFZ3UwUjIxWmRMVkZaWVZ4MmxYTGQ1WENnaU1PSElmVzE5ZE9ONmczcm40VHRBa01yTkFiQnJyY29kMzRmM1ZSRDNDV2Y3aE1aWlBVV2E2Uk13QkJ2WTNaZGR4cGFpUkNlYmpJa1UwY2ZCMlplSVczbUdnRnVsRlpJc0taakpENm9hQldBYmhaQjVMa0tXdHZlaHJaN0hJWmM1a256RXdUTHB4VWVUeXJaUVFCeHVhaFYrVkRIOXFZMGxFak01OVdPTUVhcnBjM0c3ZHhRMW5jNE1VYnh4czhaU3hDbnplYzZFZUh4b01hTG5SWlhwcXFFc3BrZTdjckwwdmUzU2cyWUdJV2dHYVpFYUZDUklyNmNmRzlCbnp6RklQVWdSYkUrY1hZL251ZkdnelR0bWlDQVpDcmRMOGR2VEtqc28xK1pvcW1MSisyT1FGamp5WTdFc1Rvd2F3SktnOXFETGkrN2taVERXWVNoWER6bHVCSS91SFVXRmhVVnRiMjJTWEorNmQ0c2I3aDJaZlJXeW90Z1ZCQkdpMzhhcVJyZjJ1U0RnOGhpWkdZeUdaRjA1ZEYzMjhLR280bVVJdmNJcFhsR1JFbGlVSVBJQW5XMTlBb29ZaDdnK2JsNVM1T09zVW91VldNYXBxYldPdEtTS0NHR1VEbFkvb1RvUUF2N0FvRnJnRytwTkVmVlhZOE5RSzBpdS9sQTFzTnIwRWdwR3AyT2xBN0FCZ04rcG9FRnRZVURBRzUzc2Q2Q2F0cDNBMm9Gc2Q5UlFCSjZtNEEwTkFMYlJUMTYwRXk1QTRnVzhUUUxub2RMOWoxRkFFNmZWdDFvSjZFazZDM2ZyUURNZFFHdUxhQ29wY3IvSG9SUURYM1lhbTM1VURCS200MzdkNkE1RS9QYWdDRG9QbmFxSHBxUi9qNDFFSytvdnA0VVU5TGFqZnJSREZtdmMyN0NpcGZTTGthSFMrMUFYVTJGcmQ2QmhBU1FwOFFPOUJFNjZEcDE4S0NSZDdXdVFCOHFCTVRldzBIZWdRMTAzQjNvSHFMWEhYU2daSkEySGM5NkFXNEFvSFlnajlEcFFBc1NmSHdvSktTcHRhK2xxQktkQ2VYRzJwb0FPUzF5Ym5yUVMxMTZudnRRSXI1ZTRIU2dXbHJnSDQwRFh1TjdVREJGKzk5QUtBQnR0dnRlZ2RoMU54MHR2UVJhMTlOTzVvR1NMZC85S0JBZGI3NmVOQkpiYkRYOHFCbTFqY25rZExVQUZEYXNlS3IxdDE3VUM2WG9IY2c2Yjk2QkJyYWpRMEUyVGpiVTY5YUJkd05BZFI4cUJEVTMwQjZkcUIrYTl6MDJOQXhjTHZyUUppb0ZyZkZ1bEZDMzNQVHJSQ3V3MTJvSkxiUzR2WVgrZEFHMWdCUVBmY25UWVVDdVBpUWIyMm9wZ242ZDduNTBRYWtrQUM1Ti93b0N5M3NSWStIalFQa1NPTnFDTitKK09oUHhvTEVCdDM2V3FCcUZ1UjBxaFNnQURUWHdvSXJvU0NmbmJXaXBBTnY5S3JvVFJDYzNZbmIvT2dpU3BPcHRyMW9KSm9SZStuZnRRU1ppemFpM2hSUVd1UVgxNkE5YUNJUGdOUlJFbmM4ZUpBRnQrOUJEcGFnZDloZlMzWHZRT3hJTjZBQ25qWnZLQ2FBNkhUUzl0YUIzdUxXMjYwQ1BRRFFydlFMcWFDWEZlSlBMNGFVRWtLaHRScFFNekMvbDBHeDhSUVFOdDlDVHNBYUFib0F0amJlZ1JKdUFkalFLOXRLS2Y2aWdBVHNQbUtJYkVsZHRSdTFBZ0RxUVFBZXRBaWIvR2dOaGMzdDBOQllSNWVWdFRRVmthNjdEcFFKU0xBNms5NkNRQlBnTzlBNVBTQS9qSko2NlVGZDlkdDlLQ1JBNkQ0OTZCWEY5VHBRU3VMV0F0MytGQkhVNmJpKzNTaW1iaGRUb2RUUkNVQzI5QkpoYSt0d2R2blFMaWxoMGExNkIyUDdkeUtCZVllY0MxdExnNzNvb3NPcDJvaUlhd0I2NjNvSkVrTG9CNG5yclFMelc4UDdhQkRsWTIwdHNhQTlYcVRjMjY3MEN2b1QrVkJMNmhjNk4wQTJJb3AzNmJXMnYzb2hIVHIxb0lsZGJpZ1hsdjNQNFVCYmt3Njk2Q1FiUzFnZExFbldnT1J1UzF5S0JHUUcxRlJLazdtMzZVUXdWQ252MG9HV0c5dHRxQ0dnME8xQkpqeDIyN052UVI1QzJseDN2UUlLZW56b3AySTFCc2U5RVk4MzNTTEVhTVRBcXNodDZ1bkZUNG1pcjFma29ZYWc2ZytGRVU1dVFZSWpKeDVMKzdTNXRRY0tmT3c0Wnc4QzhaSmdRR085NzZVSGE5dW5aNFZMa01kYjIrTkJyZHYxb0MyMm1uV2dpd0FKQThvQjNOQlhPaGVKb3grNFd2UWVWOTJ4TStEakVXT1ZHUE1BZGJhV3NmQzlWSzVNVU9QTG1GOHFGNHdFS3NxTllYMkExNkR0VUlyR1hqUXhTWXQ1Rmx1ekprV0FqQ3JxVjEyMDFORlo0cHNPTExNMk9weXcxMFVyNVFodHVvN2EwSFI5dW14SGsrN0hxR1pWQ0hIWkFPTEhUVHRRUzl3aFpKV2xqUkVuWmJra2hyTVJiaTE2REg3ZlBnNHVQTkhrdXFaRG5uRUdWaW9rVWVaYjdHKzlCeFpHSXpHZWViMUFpK29GR25FdDVnRUZ0VFVHbFBlMnh1Y1JQRXQ5UmNYWUVudnByM29JelRTWkNwSkdVQTUyRVpIMVdGaUQ0MFdKSjkyTXNRWk1Vc3NFWnNjWWtLVlU2L1VMOWFnclk0T3pSRDFIYy93OHp6QkIxSkIyRkZqVWNsc2EwVVFEVE9vSzVFWklrQU9qS3k5clVUdHlEeDV4c0NaTWwySUNXSUNnQTZHOXRiVlIyZmJQWklzeHZVbWtSSVRkSGE1VjdqVWNoZllXN1VpVlZtWU9EQVdobWpDMmk1d1NNQ2ViS1NWRVY3YU5TckhJTWs2R0hIREZYYzhwRWEvbURmU2lnZEtEdVlDbGNSOFhNbVdGWUNUT2p0WVhJdXRyZmtLRlpjUVlNYzArSm5vNitrQ1dsWGpJZUoxSElYMk54dFVLMVlkb0lSS2NRckdvS3hTSFFBazJ1UGpWVEdob2ZiaERlYkpSNVhJRXlnaDJVdHBxUmUveW9QZkhZaG04YmVOYVJYdUxEL1Nnc2pVa1hMV08zalFEc3Q5TnRoUUJVZzZpM2NtZ1pOd090dWxBYzJzUitJRkFsNm5Zalh2UU8vY2tFYm1nZlMxdm5RQUZ4ZXh0M29vdnByZmx2UkR2Y2o0MERzTGVGN1ZBeWJuWFVVVVgwdmZZVlVDOXpxT2xRTVh2citkRk1Kcjg5cUNSV3gxT3ZTMnRCSFRlOW12dFFPeWthYUhiV2dtV0RkQnAxSFdnTEwzMUg0WG9FRHB2cnI4S0JzdmxCMCtXOTZDS2cyMyttZ05CdmU5NkNSMU9nQW9BM0F0MDBvQWR3Zm1LQTU5ZENLQXVQNjBFZ1FCcmF4RzRvQXRmYjVYb0dscjN2WWpjOUtBSzhpZGJuWVc2MEM0TWJrZmpRQUZ0N1gveHJRWEFyYlVhbWdyTEFYQkhoZnJRTFcyMXdPMjFCSURZWEFGcm0rbEE3M0FVZDlUM29GeHN3SFcrMjFBalliRy93b0pCYmdFM0MvM1dvRjB0YnBiWFdnYThkUTIvUTBDQk8vYmFnWkZyMzN2clFITFUzL0NnWUhJanFOclVCS0RmZS9mNDBDVWFjdEIySGpRQUp2YTl6UVR1dkhyNDBFQlltMjlCTUVnNmI2N1VFa0tXMUY3MFZBQUZnZjIzK2RCWnhmamZRYStYYmVnZ1ZiVmp1ZHpRR2dIaWRDZkUwUTEra20zSTZXb3BoU2ZsMzhhSWlRQVRwOHQ5cUFBQjNzUDhkS0JrK2JUdnVONkNRUWhyZlNkemVna3h2MStOQkVSZ2s3QWRMMERRZ0lCeUJ2ZlQ0VUNWenVSclVBN2tuL2IwcWc0ZzN0cWUxQTJRS0FOR1ltOTczRnFCWHV1cEZ4MDhQOUtCQS9qMEpvR29JMTYvNTBETGFFblZqMUhhZ0FUdGI1NzZVRElMS0NOVUI3Ylg3OTZCQU1iRTNJSStKRkF0RitIUTBFM1EySGpxQ092eW9xT291TDc5ZWxFSWtuYzNHNEZBMkJzRHVQeitkQll4Q2dHOXVXaEZyMEZZSzZhYVVCY2FrNkcydmphZ1YyT29vSmNuN25VYUhwUlRHcDU3amF3b2lWa0lOeHAxcUtxVm1CdXRVUFUydjlXOStsUkNVWE5qcGZRbXFMMUNHeDVXSjB0VVZVZXV0d2R4MXFvaVJZOTF1S0I4N0E2MkJPdHFDVmpZdUhBWmZ4TjZLcnNiZzc2N1VSWVpCdzMvQVByVUVXTE1RTDJ2b1BoVkVkTGkvanJRU0lXNTQzNDBDRFdPbHoyb0VCeWJVNy9qUlVtQUJJVTNCMk5FTGx2Zlh2UURYR2hPK3BOQkh6YVc2Q2drd1lHemI5QlFNRUtiV3VLQnNVMEl2YzcrRkZRUEFudnIxb2hHOTl5M1pmaFJVbDF1QnR2UkFlSUp2b2Q5QlFSc3RoWUhsM29HR0s5UExzUlFQVUtGT3ZqNFVFQ0xFbnZ0UUY3alFXMHZRSElYQlVBZHhyYWdYSzU4TjdkQUJRU0cxQWliYi9oUUJWaFlrZklkYUJhblRjOUIxb0k3YURTK3BGQll5dXEzdHBhL2pyUUFJQUJKMzNOQkVBRzE5dkR0UUJRRGJsM0Iyb0luaU5RZXV2U2dBNUoxRmp1YUJsRk56ZTRINTBFZGJlQkdwb0luOE5LQ1hxRzl6WTZiVUF4SVVYR2phcmZ0UWNQL0FKRGd4U1k1azFaUzRNaUVjbDQ5VGJ3b09oaU9QdDBLazI0aTErMXRLSzRtYjc4WTV3c28valhra28vYXg2YTBSUkpKRmt6S3lrY0YxTVJzQUxBSDVYb0wvYU1vcGtsU25FU2k1QTAxR20zd29SNkxsWWFuL3BRSXVlNCtOQkQ3ckhFWkpiUWJuY1VBc2l5V0tHNE9vTkJHUUx3SmNLTlBxUFNnOG43M2pxMldzNnl3eDI4M0pnYkFqOWJpZzg0c0dGN2huaUdlZjBvM0hLVUFrYXRvR3VCb0cvdG9PMmZib2NXSDFJNDQ4aUtOdUt5SjlSQk52TjAwb2pzUGlaTVRRelkyRmNnV2tBS3NDQ0wzWWZHaW81MHZ0SWpsbm54M2hsVmRGZFR4TERhMXVwb2p5R2ZORm0rNC9jVG1HR0tFZyttaUhSVHUxcitZcnRVV01lWmtZc0UzcU14eVlzamtTUkVWSzhOVlZENDBHVEliRmFSTWwybGFTUmc2eEJneDQyMVBVNkdsV05vbmk1cXFvRXkrSUN1NHV2RTNQTmJiWG9Zbzl1ek1yTXl2VmtrdEZ5SHJROENGTExlNStIR29vOXp5WW9ra2VHYU9ZdXlzeU1EL0FDQTZoZGZOWUhzZWxWQzl0eThzNDVtbWpJU1F1RGxKWm5MQWYyM0REVHZVaTFuanpNcUovVW1reUpJMnVTSEFZL3lIY3FmMW9QUysyNVdCSGlIN2lQZ3lzUFZubEFEcXhGMVd3TjJEZkRTcXpXVDNmM0RBblZDaEU2STRWanF5MkdwVy93QU8xQ1I1ZklseFh6UFhoYmlHY0dNT1RlTlVQbEpIYW8wNjA3M3dZdWNzVjJZQVNMbzBpMjBJSDA3L0FENzBHYUtOSkk1bzBNcEJjZ3pIaHFMWE90dE5kdTlCcGFmQXhZUFVobW1NMGdzc2I4akd2VHpkN2RxRG5IS25seVZhT2RZR0JJZjAwNFdLN0l3R200b2RQdEJKc1FkZTkrdGJZRjlpT283ZjUwQ0Y5eGNpZ2xvRHFTbzZYMW9KQm1LMnZaZTFCWXlXRmhyYnBRVmEydVRZNzJOQXh4SXN3dDF0UVNHdW5XZ0ZKWFVmQWcwQjVyMnZmcUI0MUZOa0lZRTlSdFZDMEd4MkZRQTdBRS9uVlJLemxkTmZHb3BxR3NiMkhRVURHbjRXb0JXNUU2N2Q5Nm9rNktHM3VPKzlRSTJHdkxUdlFJZ1h2MjIrZEF3ZS9TZ2twVzFqdjB2MW9Ja2tuUVdJL3dBQ2dtUUFtbHVWOWowNzBFU1NSdDh0cUFJTzlyS2FCMkExSHl2clFUUjdHd29KU0FzZkRhM2hRSlYwSS9BOU5LQ0p0ZmE5QkVFRTBFZ1FMZERzZjlhQUE4d0ZCTFJlbitkNkJEVHgrUGVnbUFTYmJYb0V3Q250OEtCQW5XeHY0ZEtCYVh2c085QllyYUhYVS9uUUlNaFcxaGZ2UUhxRUFuZWdWL0tRZFExQXplNDAwM0I4S0IrcTRYankwSXNRS0EvdDNIalFCRzRGQUtvUFd3UFUwRFo5QllnaStnb0ZmelhzTzlCSU1BcDB2MHYzb0hjQmJiMzNQd29JM0JGejIrVkFHMmcvNldvSGJhM3k3VUF3dnJyYjhxQTB2cHRRTUVpNHVMRGMwQUMxOXRBTnFCbTl2ODZBQlpnRjZkK2xCRmhxYjZuYWdtcWl4SlBFMjA4VFFKUGhxTnJVQ0k3ZE56UUErbTl0ZkRhZ3NEZ2k1MzIwdFFRWWdzYmVZZENkRFFUQld3dU5kN2Y2MEI2bXZ4L1NnaUxqWGY4QVNnWmEvd0MyM2hRSzF6cFFOVFlYR29Hd29IL0lRTzF0UVBDZ2p2OEFLZ1hHeHRlL2hRV29GNjZFL3VvcEc0L3I0Mm9pSUE0SHphRHA4YUthNmdnTmJ0Mm9DeEZqK0I3MFJJRWtoU2JnYjBFalpXQXZicmNVRlpiUWo4ZTVvRnF0anNQeW9IeTB2ZlR0UVB5TVNTeDBHbEF0U1R1VDJvRFFlVmhZL3BRVERBRWVXL1FBN1VDc2pFalVkaDQ5cUJCN0xhMm82MENMTWRTYjBEUjFGL0tDVzZtZ0ZBSlBJK1VhaSsxQXRONytPbTFGSy9VMFF4eTE3MENGcm13MXZxYUI4YjNKMEkzQjNvRU9PbTRQNWZHZ0JicjhoUUJJSUF0dDFvQmp5STBBUDVVRXVKdGNXWVcxdDBvSWhpTkFiQnR4UUFBNVdIVGFnWUNBOFh2eU94RkE3YldPdmZwUVE4M2NpZ0dZc0w2NmFHOUJJa3Rib1JwcHBSU0NraTR1V3ZiU2lCdVI2MzB2ZWdsZFFwdXR6cFkwRmZFWDAyb0diOXZuUUZ0QnJhK3RBTUY0cTF5YjMzMm9JaHRQNmRLQmx5Vi9LZ2toSjBOOWRiN205QWliNmtiVURkMWF4dFludHRRVjdyY2E5TDBEVmpjRUFIdzFvQUhjM3NQeW9FR0JKTnY4cUI4cnRmVDRmMW9HMzA2VzAzNkdnclk5ZE5QNjBEK2Z3b0VkRHRhZ1lzQWJqVy95dFFKaVcwSnNCUUZsTmhmVHFLQjZiamVnTlNPVjc5RDNvSUZyM0h6TkJGWkZZbFFkVjBQaGVna0Z1Q1FMMjFOQVhKMytWQmk5endteW9DRWRrZFJweE5nZkEwSEh5cDU0NEV4SjVmdDQzVGlKQnVDT253cUs4K2M3SVZzaVhJZ011SUxXbFVnY3Vpa2dlSW9pV0ZuTThiK2tSNWp3YTYyMUl2dlZIVDl1emtnQ3ltTy9xbFU1blRWUlkySm9PNGZlTUZPRE81Q3lEa0N3SUZ1OSsxQmtYMzBUWmtzRVNsNDQxSjlSQnlXOUJ5aG1Sc1BTamNlak5LQTBaYTVKT3B1TnhlaVBSNEU4VW1NanhFR01YVlNOaUYwb3FLWitMbFNOampVV3Z2Mk8zZWc0L3VuL0FCazV6dUR4Q2FyRXBObEd1NUhlaVlyeC9ZY0NEaGpTTHpLQUdWeGNDNE9sKzlqUlZudS9wd1lyNHVNd2ppWWN3UllLYm5ZandvbDRReFArWWUzd1F5UlNIajZDaThndVFUdHFScHJSWEV6L0FIMkxMU2Q0cnpPN0I3RWxWakFQMVcvdTdVSEN5b00xWjFsbFl5cEtWa2xJODBnR3R2bDNGUlpXWDBpMmJGQk5QSlBGZmdoMUxKRmE1QitGNkRyUSsyZWhLdjhBQVlUR0dVenJ5Y3lBRzUxdlpUNENpYWI1a0RRTXdpRWJRMmRGZXdiajQ5WHVkbEZGYzZiM2Q1V2p4Wm1YMW9TQkhJaWxaT0JOeXAwRjkrdFJjWCs2dEhGTzhXUEM2eXFWanVxaXdWckd3TGRhVkl3NDhpR1I4bExCVWF4amM4bTdEaXR1bEZ0ZWh4c2lPZVNNUVR0blN6TDZiWWtnVUFxbXVqZnROVm11VG01ZWZJSm9Uai9hTVR6a2NnRWNka1BJamVpeHo4c0RDYzRtVGlGWjNzNnpLMW96RzF1TFdGK205dXRSWlZrZU1QdFdnWU1GbmxIT2FKUVJHRklJc2JYUGUxQ3ArMzQ2eEFwaDVBWXpGbGNhTklBeEttL0ljVkREWFNpVnJmMmxzR0NOSlJ3WkYwYmFOd2gyWGZ6ZDcxY1A2MUZtOWxreFpzY1hCWWhuU1JReElBMDg0Ti9xNlZER0gyd1JxekdXSTVXRjZuS1RJQ0JaeHBiaXFzVGNVeGJYMlYwNDNGeGZ3MS9HdHNJZ24vUHZRTzl4YzcyMm9CYmZ1MHQyb0o4Zkx5QTE3MENON1h2ODZBTmpxZExVQjQ2NldzVFFDZEwyN0dnbmNGVDFJMnY0VkJFSFhUWFQ4dkNxTFVKSTExdlVVNUkrT3JmL0FKZXRBdWEyVUE4VzZrQzFBSFVhSDRVRUFiYmcrQm9MTHF3MzE3MENLVzE3MVVJWEI3OU5haXBNUmZ6QWkrdHFDSThOL3dCS0NaSTBOcUJNcDFBMjN0YWdGdVRwdU5MMERzQnZyUU1BQmZxMjZkNkJHNU5nTmJVQU5OdEIyb0p4a2pVRWZQOEF5b0dkZHo4K2xBYWREb1RRSzFya2FqWW0xQWhZV3Z0cGFnWElFZVVhSGFnWTB0WTYwRExDMmh2MTFvQUVXMDMyb0pLeHVlOUE3anJRSW5TOXZsUUNzTGkvMGlnU2dFM3Y1UnRRTXNSY0N3SFcrNG9BbmZzT2xBSU5yL2lLQ3krNjhiOWp0cFJTYmhZVzY3MFFjaWJhL0M5QXdRZFR0dnBRUjJJSTJ2UURNV2E5dGFCMkdscjNPNG9BTGUrbHhiY1VCYlcyOTlxS2x5WUhheHRxYUlGNGZ1SDlLQkFueEk3VURGL2sxdnlvSkhVM3RwYlUrRkJIaWIyMjdXMG9CVzRuUWZPZ1pKSk9oK0ZBRmdDQVJyMW9FM0s1dm9UUVNON0Mrd29CYitueTJGN1gvd0FxQ0lKMG9IeUE2L0tnRkY5cUNUTU9JdU51bzYwRVM1SUNuWWFnSHNhQmdYdDF2dHBVRXk1NEJXT2cySGMxUkc5L2oyK05BaWJDOXZuUU93dHZxQmZTaW1nTndMK05BRVdjZnUwL3dLSWxkTGtkS0FZZ0pjRzV2c2Q2QldCMHZ5SkcrMXZDZ2lDdlViVUV0TkRiUTlLQkVkTDdkS0I4aGJUUys5QktNS2Jna1dBNjBFU1RmUWZWcDQwQVE3S0dQMDdYb0lENDdkS0NZSUJ1QmI0VURGdU56cFk2MEJZWDBPdS95b0hHdzExMEd3b0NRRFIxMUI4TlBoUVZqanZmVWI5cUNYRGlCNDYwQVYxQ20ydXgyb0dCNXdDM0VYNjZpZ1d4SUgvNXFBZjB5UnB4c1B4TlFTVlJ4TEczYTVxaEM1VzROZ0tDU0FNQ0dQbk5CRnh3MEk4eTdqL09nUVQ5MTlUK2RBbUJHNDA4S0JLYkVFMlB4Mm9MMmFPd0lIbUcvajRVRkJ1MTdiYjI3VUJvU0FUdlFXTW5GL0tlVmh2Mm9JTXh2Yzdub0tBSllyOFA2MEVMM08ydlhzYUJrM08xNzlmaFFUVjFzRksyUDl3T3RCQWtFanczb0pFOFNDRDVocU91bEFsYms1dWJEY2s5NktRTnRMZjUyb2hycWRScGF3dlFJRFEzR2gwdjJJNjBBUEVFK1BXMUEyaDRlVzRKUFVlTkFNSkVPbzRrZGFBRnlOeFlhazk2QmJyY0czOXEwRVNUYTloNDBBRDg3N2pyUUFJM0kzT2xBTTE5U0I4T2xBaVd0ZmEzYWdPbS93QS9qUURlVUJyYjdmR2dpU0xmbWFDZkh5aHQxSXRjOTZDRzN3OGFBdVNMYS9BVURBY1gwUGlPMUJFWEoxMkg0MEFkd1JvQlFWWlVvaWo5VXFTdHdMZkdnNXNIdVVBbGxPdkl5QlRmYTRIVDhLSnJwUVpDeWk0M0g5ZGFLdWpVY3JjU2V0aFFSWWdDMytCUWNEL2tjVVplUHlzSm10d2xYOXBHMXFKcnlEUG00ODZ4VDNpQllrOFhQbUpPaGNOMG9yYkRtcEtKR2FNTEViRmdEWk9TaXlueTYwR2FETXhValpaRU5qY294SkJ1cHR4QzYxQmJITkxrRldDUEpFTENTUGNJaDBISHFiYWlnMFl6NVVlVlBPM2t3bVc3c0JvVHNDdmozb01rbU5HODhiZXVNcFFuSlFQN3I3QWpXd3FqcFlQL0FDRE1peEc0SkhHSWJncWRSYmRkdHIxQmp3YzNMbW1iM0JJUE9ySDFRbWdzZGVXdTRwcTVHdkovNURQbVNuSFFDRlJ4TWM5OVZKMlp2RHdvaVUvdnMyTmhQQXllcFBJcExUVzBManJWUld2L0FDUEh5ZmIxWElnV0hMWlA0YnFTUzE3YWp0VWl1RTJTSkl5bVJpU0RFYVFmZVBGeFZsZGJnZVVhV0c5QnpzOUlGeUJqd0hqei9rTXJvYitYYmJvZXRxVlkwRTQwODBjazBneG9HdHpaSGJncE9nZGVXdXRya1hvU0tuZ2l3TW02eUsvcjhtbGtpa3VyUmh2eHV3b096TDdwOXpqREVpTHBqVEliNkM2M1BsSS9RMDFMSEx4Y2lDTVNSWk16Q0dNMlFSZ2NtSXVBcDVDMWhlaW81MmRHOFVVbjJhbkpEZ1BNd0JMYVdVdVBoUXdKR3VWTkpKbU94bVJRNlc4aGMzdHd1TGNkdHhVSXRpWi9kRmVOWTRzZHczTXV4TEVzVjQ3OWFwMDVMUlJvWFVRc3Q3R2R5UXl1TmdVQTgzSWtWRmFQY01jRlV6SWM2ZEE0Vm1qbnVZMnNiZ2o5b0E3R2hFdmFzd1NnTm1TQkhpWUNLV0pWZU94SnVYVTcrRkN0T1g3dHdia3VLZlc1Z25KRGNWRnR1SVg2YUlpL3A1LzhzVXBrejNReUlJaHdDRWJsN2FXb3F6TnovZE1tQ1AybDVJaXZJU2VweUNrcnRjMnZmZWpNbktIMk1iNHBHRGxBc29LemgxczQ0RzFoWWVaVHZjMWNYVnVUandKaVRTcE8zMzU3aXdBdHY4YUp5K2xBa2p3L090SWV0N2ZnS0JBRzE5dTlCYXFhYTdIYWdiTXRyTFFWbSt4MjdmMG9waXdPMXlLSW12bkpON2RiVUNieTJXL2xBMEE2VkZJRFRlMTloVkVyVzZrRHQycUJycWIzMS9RMEEwaGF3dnFPdEF3YmFrZE5CUUsraEFGeGY1aXFDNUpIN2UxOXFnbnRwYS9qNCtGQWhmNmJnQzlWQzQzTnRkRDg2Q1Zyazk5dVJxQnEzYzdhVVVhVzhhQmdtMXIyQjNvSW05d0JwYmFnT1J2cVQ0Q2dtaXMxN0hmdnJRQjhwQUJ1ZHIvNVVDR210d2U5QXhxMm9zUERhZ3NKc0xqVHhvSTNzYUNYSUVHMis1MW9LMnVibm9hQThwYXcwNmY1MERJSGZYdFFBME8zdytWQWFGVDFQUVVCdU5PbEJJWHRhM1NnWFVuY2ZwUVNGK2c4QUwvMG9EeWdXUDFkOXFCTHViN25hL1Nnc0tCbExYMjZIc2ZDZ0J4QTBKMDhLQ0J1eE52Q2dCNGIwRmpFRWtnWDFHdEJGaWRsdUZPaEZBbEhROWVsQkpnVnNkajM2MFV6S05MNi9FVVFpZk5jRXFLQ1FMRFFmNjBFTGszOEQwb0pteStZNjMvS2dWK2cwSnRRQzZYRjZCS2JYMXZycWZqUU02M094Mm9HQXJBa25VYkw0ZkdnanJxYjdiMEVsVG0zQmQvQ2drNnNqV0k4dzYrRkZJS3BVa3NRT2dvaEtMZ0RwUUY3R3piR2dpQWI2ZFJhZ2tvRjlhQUl1d0hUclFNOG0xSURYTkFjM0dsN2E2anFSUlUwWk9CVzEyMXRSRVdKc2IvNjFGQU54WTdFYitGVkJxQnQ1VHNUdlFISzJvNy9BQW9KdXdMRWpRWDJQVDUwRUFDYlhvSGZTeDNHdC9DZ0xHM1Q0OUtBVUUzSTdhMEFBTyszanVLQ1dsd0RvTmRhQUtnblE2MjNOQk1LUWx6cUJwYWlxMlkzNGpiYTlFUkI3YWo4NkNYQmpwMUdnb0pGWHNMaXd0YjVpZ1FLN3R2UVIwRGJYSjZVRWdDYjJHb29BTlpyZ0Eyb0ZJVHl1TkxuYnRRUGt5NmFoaFFHcEd1dXR6ZnhvR29VRUUzdmZ6S08zZTlSU010aTVHemR4K2xWRUI4QVIwb0psd2RMV0FHdldnZkEyQlkyRENnam9EWS9LMm10QWcyaEZocjFORlRaaUZVMnNMYWEwUkcvZi9Bb0ZkdW5YWWQ2Q1RPd2JpUmEyaG9Ja2tBNmtYMEk4S0FWdWdHdDk2Qm40WDhEdFFLK3Y1VUFTMWdwL0tnaXRnVGNYWG9QR2dscC9Yd0pvRUNCZlM5cUJFZzMyMTYwRHZkZktOQWZuUUlhV3ViOXhRSXNkRHFlMUZXUnN4OG9VRm1GaDhmQ2lJblFrZHRQQzlBQzNIbGJUKzZna2Jtd1VYQjJVN2lnZzRZV0JPbzhlbEZIRWxUMkg5YUlMRUQ0NkdnU1dEaTQwNjNGQXJHeElGZ056UVN1RkJWaGM5QjAxb0l1ZVY3Yi93Q1ZBQmlCOE85QUVxUnFMVzdiMEVXdU45alFNOTc5S0FhUm04dDlCc0RRU2lCWmdTT1Z0QURvRFFKdEdJNjloMG9JM0oxTGFnNzBDSkhsQThiandvR3ZBMnVkZXRoMG9PVjd4bFNSZ3hwWmc0c3Q5TGQ5ZWxDdlBRWnE4ZnQwSUpUUlpWMEpZZlV4SjhOQlJIYXdNc3F3VTZjN0VLYmdnVzYwVjJVWWdpMjlCSjVuS2thYTdnQ2c0djhBeVFYd1ZIcUxHUXdZQnV2RTNvUEwrOEdHUVJTd242VklrVkQ1d1NOaXgvQVVHSEtYN2tCTVpSaHRqZ0dSWlc4M0U2cXhPbDcrQXFLd1BZZ3puSEJrbFlLdVQ2Z1pBZGl3WCt0QjBNYlBtaTFkVEJNM2xRcTFoSUxXdUNRZkxRYS9WOXdtZTBLU01IUzA4UnNEc2JNb082K0lvT1A3amtPc2NTTEFJc25HOVFFT2VKWmxJT29YdzZVTVlrNGdZeExORTdrUHhOdUJPLzdkVFlHb2ExeEpsdERKbFlrcXlSSzVlS0NON01iQTM4bitlOVUxVWtrZnBxK1hJNGlqUmVNWU5wQTRKSkJ2WVd1ZDZHTnVMN2hrUzRmT0YxQ3lXRVVUY1F5OGZxNVhQNlVpV01Nb3pEbUU1Yi94Ukt3OWFKZ05SMHNkQ2FLNk1CaFdWNUZtSlNVQlhpY2NIdjE4cEpCRnFJcjl3RHlCSVlJUkM3K1pWQlBNNldXNy90QkhTaXNjTWZJL2FacktpVzlLV0JSZmtxN0Rsb05DTnFDV1RoWU1ETVRrS1dSdUtaS3FQT1F2SGp3YStpOTZEUEpIbWpKaWFDVlBVNXB5a2tOK1dnNGhnTk5BS0RzZitnelhpVDNITHlGZ2pMM3VxazgrUitvSHZSTjV4VmxjSk1rUTQ3TXpNaGptUEFjanBiemRQaGFpcy91ZVBJdU5IajNsKzUxRWlFQ3lyYnk4U1B6b1JpeDhkUmZtVmlXM0tRRzVBNGk0K2RGU3lwb2N5Q0dMQ3dZaXpzUStRSElGbFlBWFU2TFliVm5RSDI1aEFJSnVNTFk4dm1XSWNrODNtQUxjaXJWUnJ6L2JmU2dEUk92cVpFWkJNVEx4dGJSV1haZHFKSzVrV2NCLzQvR1JadlRBUjVDRWl1b3V0L1UzRnZ4bzByd0h5a1ZHaGtpRWtnWWNva0JKMlhnRGM2YTMyb2llWkJseEkwTVAyNk9saExJNTRPUXVvVW5xTDYycW90OW85NEdHRWVaT1UxL01RT1NpK3UzdzFxRmpWbmU5WWVSbXpJaitzck1Dclc0c1FiRTNYVGtLdEkrcE4wTngyRmFaQVlXMTFIZWdCb3ZnZWdvSmh6WUM5OUxrZHFDRnpiYXgzRkF4ZnJ2UU95MytIZmNnMEVoZmNYSFMvYzBVdXV1M1RwUkRqR3BKRnR0OTZCczFqb2RONktSYmNEVGtkYmIwUUkxamNIWGVpcEFtL1k5cUJnQzF1aDZEd3FBdGJiZnRRSUVqL09nZHV2ZjhhcUpBclkzRmlPdmhVQzNhdy9MUTBVMkpOaTJsdGdLQUorWGUvZWdMaTVGOVJ2UU1NTFdPdDZCQVgwMEIzSW9KZ2pwY2VOQkU4U0xudm9hQTZpeHZmUW1nbGR0TEc1b0orWmh5WS9MclFRdVR2dDBGQTJ0eXV2WHBRUFh2WU5vZmhRQlhqdFkwQ0JISG9QbFFTVkdaU1FRQU56dFFSWGtkamZ0MG9HYkEydGEvVzk2Q1NIeU5ycDArTkFmTFR3b0VFUEhsYS9lZ1c1djE2MERJSDQ3bWdBV1B3L3JRU1VoallteFBVK0ZBMVlsYkRXM1g0MFVBRUFFL1QzM29nTWcvYUxtL3lvQWFuYTlGTjJGK0kwSXRSQVdZNzZHZ1hIdnNUUUF0b0JjZzZFbitsQmJ4dUxrMnRvRGVnZ1VVRFUwVWdOZDl0VFJBZVFKNi9IV2dqZHJEUzlBd3pXSzdhN0NnbHFUNGZsUUZyNkFVQ0kwNmduOWU5Qkt4REEzczNjNlg4YUFQSmpjbmM5NkEwdm9kZHZqUVRGckVFNms2Z0Q5S0N2ajRkZEJ2UVdPR1FsUjlYaFFRc0xoUU5lcE85QTJXMWw3NjBFMlllVUVqUWROcWlvZ2FnZzJQVHJwVlEyYm13dG9kckR4cUtpUlkyN1h2VlFjdEFHMTdXb0N4Tjc2RFkwRENnblJyMzB2UURMYlE2bmE5QllvWWc2WFBXMUJBc3V0NzdiOUtCSXhYb0QzdnRRUzVnZEJxTFdBNitORkFJQzh0dGJjYUlUV3ZycVRxYUIzQTN2NGs3M29GekIzT3AyK1ZBZ2JMY2pYdjRVREZnVDI2RTBGL0VGZFJlK3hvSUd5Z05vUmZZM3RRVm5RZ2pyMEZBY2hvYitZSGFpcE5HVUNra2E2Nkc5RVZrbjUwRmlKZXdzYmZ1OFBHZ1RjQTVDa2tkTDZVQ1VpOWlkKy85S0JxR09uZWdBeE55ZGI5ZmhRSzIxaU90Qk1oT0Y3bmwxRkJCMkFzQnNCcjExb0dMc2JtOWwwb0ZwZjlLQStuY2JiMENGeHJmVUhTZ1pOemNuWHIwUHlvQXFSWS93Qng2VURrNEg2TGFXK2RBRmdSWlZJNnRwcmZ3OEtDS3RZaS9YZS94b0xDRnZkUVFoNzBDa0szOG9PbTMrZEJXTDNBL0dna0VCNjdVRVNiTHRZSGNkNkFQRzRQK3RBRVdKdWRMYi8wb0Zyc05SdlFTVUFuc2ZDZ2lkTndOYUJ0eHZyZjVVQ0JOaUxlRkJKZHZNU0RiVFgrbEZBWVdDZ2N2MW9oaEZJSjVjV1VmVHRmdlFSTGNnU1NCdGE5QXRDTERmb2FBMFhmVXRwWTlEUVIxQjFHdlh0UVQvakJYZmJYVGFncjBGdExmMStWQmp6ODU0T0FUWWc3QzVKSGdhQ25DOXhlWlkya0I1VE0zcGpzRjcwTmROSkkxUTMzSTBvSTJJME9wRzNXZ1JZYVd2cHY4KzFCTGtXMUZoM29JOHJiN2IyN1VBUm9MRHByUUxVQWdEcnFkNkRqZTVZemlSM0Qvd0FZSEszVUhwVlJ4SkpoOXlqUnhBbEZzb0J0eUpOMjFxSzI0c2l5TXB5TjJZTXV1M2dmQVVIVDl2OEFkRW5kb3dHSnZ1Mm5FRC9PZzZJWTIwMW9LTXpHaXlJdlRrQUlPMmxCNVAzZUU0ZVVvS0IxZlJsUDBzRHZRMXk4dHNlWEpPVXNCV09FTDZac0hJSzZhOHVnNmlnNTJGSE5KN29zNUNUUnQwVUNNc3piR3gwQStGUlVmY0pqa1phNHNjSVY4YTZyS1h1cWY3UWRONkVVUDdoN3pIbEtzOGpCVWlLS3E2c2lBY3VIbXR1YUNxR0dlRytURXFQSEtPU0pZczROL05lL2pRMXNnV0NPT1VaQUJsYXdXYjFBQ0N3ODF3Tjc5ZGFGZEhEWDIvS1VCWFRCR1B5QnlSeUp0dXBWTEN3L1dpVmg5MWhpTTBBZ0gzVDh1VU9TeC9pWlFDUE11NE42TEdQR3lQY3NGUkpGQWd4cGJqSTlVSzRKQjFDRXFkaFRCM0U5MXhHeFlWVEFBQ1g0bDdNT1IxYmJTaUp5UWZkSW4zVVlFWTh4ZFI1Z0NkdmxWVFZXZmovWiswdGxTS3dITGpDVUt0NWgxYS9tR25Tb3V1ZEludCtVRWt6bUVUdTVjaFR4OHUvbFVDdzErZFJWdnZBaXdNV0g3WEhrOWE0UlpaRkgwdnJaZ1IxR3RDS2NYM21TSnBzY0g3UElZQlppOFJKc29zR1VnRTYzcHBqTGYzRlVRNU9UNm1NemNZVkpkdENiWDlFVVdyTVQzUDdIS2hCV1FSamxhWkxGejAwVnVvN0doMjA1MlhsNU1rYnlTTktqZzhIc3F0WWFhZ0hRL0dxakpuUGdQR1pTNm9VV3dSMEtsN2FNZjdkTzlRWXZjTWpKZ09OS2twOUdaUFJEeERnNGppN3FCNWpyYS9XalE5cG1tbGw0ZTIyeVpKRll6R1pMM0s2M1FhV3RRcTJRNWtFZ09YeVJHMVdYaHhacjIwS25UZllHaUllOWVyaUpFc21SNm5xMmthQnVMdUFkVUxPTGpicFFuYW5NeXMwR0hMQ1JLWkc1QjRDR1Uyc05CcCtGQjE4bkN6ZmRJMkNMOXpJNmdseHdUWGV3QnNCWUNxbFpNLzJQTGdKdEZLekJHbEllTUlxb29zZU1sN3RhOVFsam1MREhORXJZOG1wc1pJaGJtekRiNUNpdnR5MnRyZlhyNDF0a3JuWW5RNzI2MFFYdWRPbS9lZ2xjY1FMMzhmNlVETCtYanBwdWQ3MEJjbGUyOXpRRitwb0hjMnRVVklFR3c0MjAzNmZHZ1JQamUvWHZRUzh0eDE3MkczaFFEa0hicFZBcUZ0RkZ6K0ZSQVZzMWlmaUtvVi9Oc0JiYzFGUzVIcDAvSDVVRFZrWFQ5ZWhvSGNhV0cydmhWQ2RnZXY0VkFYSUYrMUFLUU5RTDlCOGFDVjliQzNhKzFBclhPdTErbEJJaTlyQXFEMTZVQ3NScGUrblNnTlJZay9WdnJ2UUhTdzFKMFBqUU1yNDJ2UU1NUWQ5YmEyb0RtZW8rTkFnVHIwdHVLQjhsSnVCK0ZBeWZHL2pRVFczSGZYdFFJOHdvdllBN0FiMEVBV2EzK0RRU3Q1VHJaZTNqUUJhK2cyb0YwNmVGQklhaXcrVkE3TUZ1dytkQkZiYlh0MjhhQmxnYmttM1VDMjlGTlN1b0Z6ODZJWUJOemEvYzBCd1lXQlUrYjZiVUI2amNXVy9sL3JRSFFXN1VBdkpiSHJ0cCt0RlNGenFTRC9sUkUyS2FGUllXMm9JdVZ0dnFhQVZ0bE9uUzVvSmdXc0RzZGo0VUFYMDdudzZVRlIzN2k5cUJxekN5bXlqcGVnWUpzTkxBZnJRUFU2RFcvVVVETnlwdWJkeFFEc0NDVkZyQzIrOUF1VEUzYlliRHBRQVlkTnVuK2xCSmdseHhKMTN2UVF1QmNXdjRVRFB3K1hhZ2FzVjFHNDI4UGhRSElNUUh2YSsvaFFKMjgybW83R2dCYnR2L0FJTkJZeHVRYmEwRlEwUHkzb3FhN0R0dGZ4b2dOdVFHeG9GNWIyTzFBN0FNUnFSOGR4UlNCM04vcE8zeG9pYmJiVzhPOTZBNWppQURlK2hIVFR2UVJCdWJEcjFvR3dKdVF1blg1VURYYSsrbTFBMUFGN2p4RkFyaFR5dGZ3TkE1WFVpd1hpZXQrdEFnTHJZQWIzN1VCSWJ2Y0FMNGJpOUFMZlFkOXFDVE1kcm05dHFpb2h5Q0wvRUdxaEVXczFycit0QXdmUHk0QWc3QTNGQkU2RTIwL3BRU0FCMEExN1VEUjNqYmtEWnRnZC9sUlJxZVJiNnY2MFFXSEM5dGI2TjhhQVVLRFpyNmIyMm9FRFlqcUFiMm9HaitZMzFIVzlCRWszdjg3ZGFBUEc1QU5odjNvR29GN0hmZndOQWFFOFY2blFIU2dHRjcyMFVibWdheHNRQ292eVBsdDFvRnhJWmxBODE3V0hlZ0JaVnNUcWREcFFCTjlWTzI0T210QXJqVzVOK254b0lrMzhlOUJZZ0lUbDBKdHZRUllHNTZhMENRdGZ5Mm9CbWZrTGFpZ0xDdzF0M05BaGNFSGNkdTlCSmxBODR2cU5iOUtCTXpHMTlDQmExclVDOG8zL3dLQ2NaVzVON0tCMUdwdjRVRUxnMkJiVFhmcFFNTW9Yam9mSHRRUlk5ZDZDYXVpc2ZLUW8yQjFORlJMR3h0cU5MM29FNUhRYU5hNEhXaUlralcxL0NnUllrOGlOZHlUUVdLNjhiWHNlaDZVRUxkT1Z6MUhoUVZ5ekpFak01OHFpOXpRY0wzSElPU0NJcENraEk5R1FENkdPbklYM0Z0NnFLdmFNYVNPZDVIa2N4WTdOeEVoSTVGd0w2ZkRhaEc3Tzl3YmdQVFA4QlpWWXFkZGRRQlF0YWpuTEhGRTAza2FRaFF1MXVSMHFLMkRWZVYva0tCWEhiL0FLMEV4NXIyRnROcjBFQ1NEcHRzZkdnWE04Q25MUTlPbC9HZ3labU5ESW9kNURIeThoSy91djBvbGpsdmhZV1BsUVFwOWNkeWlEb2lqcjhhS3d1T1pma1NUR3hXTVdHclh1UHlvSisyeVRSU3Q1eXhrSjlTOWpvZGJxUlFkM0NuOVdGUmU1Q2k1OGFEQjcxNzMvNjZlTUdNdEVkR1BXNTJHdEJtOTJNbWJqeGxZMzlLd014UXFYVUh3b1BQdmtMTW9lZkdLNGQyMExlWTI2N2NnMUtJWmtPT3hXVEVWWStTbGk4dkc2c0NDQ0xkZkVWTVZabGUwajNKY1Bpd3lJVlh6elFoRllGdjI4VzRzeEhlaU9aUGcrcGx5WUVzTWtmcEFxUVpyYy85emN0ejIxb2Fvam5IdGtDUlRHZjFSY3V5QUVBRVdDL2hRYkJOajVXQ0k1TWRzZ0JiUUJSb3Q5bXNONm9NajJUeTIrN0l5d2dZd3kzc0ZJM3ZmUnIxQlZreDQrSkNucHhpTUcwaHpBM0loblBGZ28wMzMxMm9xREpsdGx0bW8vclkwU0ZPTWpnVGFpM3FXSGw0L25SUEJOUGlZclJKT2tza3FjTGNDQUFyZGJFOVQwM3BWaC8rL2xTZDRJNUg0cWJDYTJwWTdBaTF0YmRhRmlqS3o4ak15RTlDTXBJZzVXVmlwNUVFVzR0NWI5YmloaktrZWJNcVRaREVMeDFmWm1rdm9HSFVjZXRGVTVRZVRJYm1yR0dQZFBVY3RHNU5pZk45UUFGU2pyWThlTG40L3FSeWNzaER4YVJneW5UU3dQN2hTSXlPSk1kSTVNbFdEeHMxbWpHL0hVTUpQQTFUVmJPOFNFU3RITWtoODl5V1pUOVFzOXRUclFFd3hvY3VHU2FGTWhCdEdqK213UEc0SksvNHZVVlAzREVrbjlJSk9pbWNGMWhJOU43RVd0NWgxL1dnendZY3JZamVxR1NJR3lIaWRPSjJFZzc3QWRLb1dIN2JqSEdlYm45bXlNVEVnYytyeFk3bmE5dTlRYTVZczJmRVpFbGFZZVZMUHhhNEoxNU1kUnIxcW9lSERnU1E4TWlOVFByR2tTbTZuam9GdVAxcVFyRGtaVWNFc0t4UVJ3emNXVjRpcElRYkxhK3BhM2VoRjZKaVR4cDZXRmxIM01nbVJKSk9NVDJHbXB0WTliVVZRM3ZHYkUwYzBrYno4b3lBN3NXQ0cxdktUMVU2VVFSc3F1aHgyQVpTUzdYVUtpMnUzbk91dSsxREgyRmlvMEd2enJiSVVYRjliZDl4UUFIbDczcUtZWUFHMnY4QXBWUUxxTmRyMEQ2bmYvUHRSVFhRN1h0clkwUTFVTVRyNEFiVkZNRWJqY2REVlJFMnZjWC9BSzYwRFZsQkJJdmJwMG9HT1RFdUJvTDMrZFJUMkcvNGIzcW9TL1ZydHZSVXJhYVc4ZTVOUUhJazNPbHFBSmF3ditOQllZbUJzZmlmblFSWkY1Y2hwNEhlZ2pmcGUrdHdLQ2FxTFhPcEczK2RBWGJUU2dTMzZiMVJJY2hvU1RmWmFnUVVLdk8vV3dIVVVBR0pXMmcxM29IcWIyMEY2QjZFRFhVOUtBNEhVN2pxYUFKN2RQMW9KYUtOdFJ1RFFSc2JjcjZVRDhxN2dYTzE2Qjc3VzhTTmhRTWpjQWE5S0FWeUpCeFA5RFFFaHVUMjNORlRVUkZSMElCdmYrbEVSNmdYMTZhYVVFZ3R6ZmZ2UUp3UmRTTGlnVzJoTkFjUi9qdlFLeHY0OU9sQlBYdm9lbTFBeThoSGFnSWJsdFNBUnFDZTFBbllzYldBMTBJM29vQk9xbjVINFVSSGMvcWU5QTkyUGgxb0xBckJyTUR2dHRSU1lHNEhVbTlBRWxXdHFDT3BvZ0JZNmovQm9FUU5kL2pRR3R6YnAxb3BqVWI5cUlrd1lDL0cxKzFBdVFJMnZydlFJRW5UcHVSUU5iYkU2R2dZK2xyYmRhQUFGK0xrL0JSYzBDdUExamZUdFFTU3hPbndvR1ZXOTdGRVB6T2xBbWQ3QkJzTmUyOUFnVlVnRzdFSHpEclFEOGIrVUVMKzBIb0tDU205N2dhNkEzT2xGTFFyMDVkVFJDc2JYdFFQV3c1WHZ0ci9BRW9DMWpxRDQwRmpzekc3QUFiRzNZVVZBS1hZMkJOcmtmQ2lBQUFFWHYzdDJvQ01HK3BzYlhQd29CUWR6c05iMERzYkFBR3czdFFOVzFOejhmQ2daRmpaVHVkS0NKc1NGMkEwdU5hQWF3QjZuYTlxQTVNVGNpNjl6UUFhNXNCNDJvRmNocjJJRzlBaWRMblVEYWdtUVNBZEFlMUFjYkJXQkhiL0FBS0tGSzNQTy84QXR0UUx5MzVFWEc5dTlFUGtMM3RxUHBvQTNzZXgxUDhBbFFKUnFDeC9wUU1xd05qOFJidFFNazJGeUxqWStOQkc3Y3U5dS9XZ1hUZmJhZ0J0djhLQ1RyWTJKdmJlMjN5b0VYRjlOTDFBY3JOeXY4Nm9WL0tScGM3WG9MQklRbkcxamEvSWIwRlY5U0w2anJRTWtpMytOYUE1WEY3a252MHRRSzVBRjlhQXN3SURialgvQUNvQWsvajI3MEM4M2U5OUtBdHZmOUtDUUl1TGp0WS82VURiUTZuNTJ0UUlNRk8rbzFGQkpwWForVDZrNjZiVUVDOXlBZmwvclFOVURqZ1BySjBQUTJvSTJIWGZjMEJvRkJ2cWQ2QVlveWdxdkd3c1RmYzk2QmViajJPNVA2VURZZ2pwYzl2MG9JWEJiYlNnbjRibWdpVHA5V2gxMTdpZ1laVFlBV1A1VUVUdlk3ZGFEbSs3NWJRY1FwSUFaYkVDNGEvVHdvbXRVTXFUNDRkZ0NyQzU3V29ybjVwZ3hURXlqbEV6R3lBWEk4UmJjVlVVZit3OVoyT0lna0FzQ05QcDZzTCtGUWFadnRva0dSd0tDd3VDT2czdjAwb3JqU1pabHlITXpNaXlXKzNjYW50ZGlLSTc4VWtlUGhoMUpsQ2ZVdzF2M05GUTl2OEFjRGtPNjJQRlNMTWRqeTFzS0RkMW9KOHRMQUFuclFWdWVLczlyMjFJNzBITXovZEErRzhJVlRPcDhpRFJ0VHBhZzgzTlA3aXN0a2JoSWJyL0FDYXN6UHBZZkNnMVlzZVFVSTRFU1JSOGl2TlRia2JGci9LaUxCQThKc29LdU5sRnlWL0NnV043aGtZekxHdzhwSkpKRnR0eDg2S2Z1bVpEbTN4eXljbWJrckFGbVlkZ2VsQnc4VWU0Um1JbHl5OGVMY1g0RThqYXpxQ0w4YlZNTksxbmVPV0tWUkxkZldBYmx5SFVsdjJrYjJxalJQOEFkcWtXTUlZMVNZWDlSMXRyZTNsWDl0OXFESy90K1ZOTkU4c25wWk1ZL2hZRUN3R3RnZWxnTktnM3RIRmlZc1dTWUV5WndQTktxRlpRRDlSYzNzekNyQ3VaTjlwblNSek9vUXl1OGdVZWQySUl2ekp0eDAyRlJYZW1nOXVYMlNBWThMdEZKcW5BMktucnR0VmlEQS80MzdaNkgzRXVROGprTXdMamtTRkZyV090cUdPZmxqQlltSmtpQnQ1QisxdGRDZjZVRk0vdHhWMlJRSUlaQ0pBWWJjQXlhZU5DTWNzTWVkbVJqSXhSUGpvM2xVTVVjaE4rUjN2V1dtcWJIZ2huNHpJSVlWYlJUY3RZN0tYVy9JQ3FtdVZrKzdMQm12SC9BQlplT0pBc3J1aDRzTFdDcndBYmlMZEttbUllNCs3ZzVaT1FNWjcvQUVxa1pWemNhYTdEamF3b3JKQkhEUEM1YkpuREdKbWlpYlJRV2J6QldQMUMyMUJzaWt3OFRDTUZtYVVhNDZSa3JacmFNN0FtNVBVVlVVKzFaTThjT1E1TWpDUnJ6UXVxbUlJQ0xtNVBJbG0wTlJhdXk4L0dreFpZSW9Jc1hJa0hMZ2prSUdHd1ZEZjl2ZWd4WnNlWGp3UlQ1a2JDTzNPT1JWWmdXdGJiNlJwc1JWUm14MnpjajBwbExTTFBjQ05oNmpKKzBBOGp0MXFOT25pUVN3VEhEVlVTWU9TRUxNNVZtQUF2YnJlaWVOZVY3V01ZSmc1TUN4NVlOak1nTEM3blVYMXZWU0hrNDBhUW1MRi9neUZmaXp5YTZyb1FHRnhSR1BCOWx6TWxqa3hONmhRRml1aFVzTnlnNzBYV2FmRmVOMmxuWjRveWJ4emFPUVRyZHUveXFMRWtreS9jRmFOSkRlQldrVjJETWJBL3ZzM2xDNzdVUml5U3J4RS9jUXh2SFlqRlFOeUJ2YmxxUDNibWlzMlJseGpBYkZXS015Rmc3ekxHZlU3K1UzNjdiVU01ZmNINDZYMnZjVnRnVzZIOUtDSXNiOWlhQXVUdmJ0K0ZBMFZpeHZ2UVdnY20xMTZWRk5nQXBBT2gySCt0VVFYdmEvejYxQk5ZMkl1ZSs5QU11OXRiOXRLQ0ZpdEJKamMySnVUK05BK1BsdmJiVDQxUVdKSU4vd0F1bFFNczF4MDZVRWh4SkE4UGxRSWtYdU5hQ2ZxTllnYWpjK0hqUVJKTjlmbDQwRDBBK201UFU5elFBdU9ud3ZRU0pKdWR2OHFDTnRyNzlhQnV0cldONzYyM29BZUZyRFlVQUxYMUcrNG9HV0piUW0zWHdvSnR4NGdMZXczdUtCY2dScHIvQUowRWVURTZENTBEMTYvbnRlZ3NMS1ZzMi9nS0JXVUM5L2tlOUFnRk51RnpmY1VFdWFzRkZ0dnFOQWdvSUw2bm9MVUNPdHJiNzNvQTJJQXR0MW9KQlZCdHkySHlvSlhPdHRyZnJRUnYzdjhBMW9FTGtnTHIvanBRTXFBTkw4aitGQTdqa1NUZHRxQmdrM3Q4L2xRUzVPQnhHeDFOQlhZZ0JtSGw2amFna1FkVGV3R3g2MEFMdUxrMk93RnRQalFNSmZVQy9jMFVnQWRSY244aFJGZ21VRFVjbU83ZGFDRjJEY3R6ZS84QTBvQm5MRFVDL3dEZDFKTkFYTjdrMnNOUGhSVTRRYkVMYmJyL0FFb0lrNmtsYmdHaUFPdHhZZU92aFFUWmcyblhzZHFDQ3FUcGV3T3dvTFBUWWJiVUVBakVIUW0zV2dWaGJsK0E3MERKYTNKUmJ1UnRRSys5Nzh1OXhhZ2tHSUJQUTcyM29CV2ExOTcvQU9ONkFiVVhEWHYwN1VCWXFmRzFBbWF6YlhBMG9KMi9pNVhIYmVnU2xTQjBOdFNmMG9GZlEySGdEUVRhVm10Yy9Ub0xiZklVQzVlYTdhamFnQzF6ZjlLQ1htVUVLTEhZL0NnU0U4N2JrNlVFbUFDOURSVUxwcGNiYkgvT2lFRGE1SDUrTkJJRlEzSWkvY0dnTkNCMEpQNlVCYTN4M3Q0MEVyNjZYc2JFMFZGcmJFM0owQTdmR2lBRmlRRCszYmFnazBqQUc2ajQwRUF4dCtwb0d5NkFycnk2ZGFDTmpZRTdHZ3RWUVFxTWZQZlM5QkJnUTJtdXZ6b0N6S2JrWDhQR2dHWUZ1cHZ1ZDZBc0FxbS9YYnJRSlNiSCswVURIQW56blE5UlFOUmJlOXUvV2drcWM3RlRaaHZRQmhBVS93QndOMnYyb0tsdWJBNmkrZ0ZBOWlRQmJ1S0JFZ1dJb0hhNTE2Yjk2QStuVWVOQUl4VjdxTmJiSFVmTVVDT3ZqZWdYRTMwTmpRU3RaYkhjNzBBTGJmamZUOGFDSnRheDZYdWFCcjlOckF0ZlZqMm9IYXdGOXVsLzBvSWl3MUg0MERzeFlLTG40MERzeTNQMGc2ZDlxQmhpQWRCWWkydEJFa0JTU1RmOUtDTzlya2JmNHZRTUc1MzhvMFB3b0FoTFdGN2pVZGFCTTRPeEl2cllVQnJiL2FkTC9DZ2VtbHg4L0NnaGV4dU52R2dZMTZlSXQvV2dhbFFPbC9oME5BMVVLT2pXMUFOQUlQVVlxZEw3ZkNneSs0UmtRT3FzRVpoeFZqM1B4b1Z3R09maFlzdjNGbGhHaUM1SjQyMHZieG9pWHRXS3F3eENWZ1ZaandqWWtrRnR3cG9xY1dNSTVwVlJCWmVVYU1wQzZHMmpEcWZHcWpSUEpiR01KdkxJZ0l0cmE5dFJwVVZ3cFdhVXhlb0NxNldrSnR4NG5rRkkvclFhNGM3SUdOOXhqeGs0OExNa28zNVhOMllmQVZVYU1ISUUrWGoraElXaFVGbUJGallqVHdJcUs3d0lGaGIvQUFhQUREZS80MERreTRGS3gySEsyb3Yzb1BPZTRMTTJjWFdNQllpZUVuL3lHcDEwb2ltT04zeEhkaUpaWUR4Wld0eVFkU0Q4TzFGY3RJWVE4RThrcGpXNU1scm5rb1BoMG9PcGllNHlKRXlSUk5Pbkt6T1FiY2IySHcrZEZSZkhqbGtNOGtyS29hM2xHb1ArN3BhaU9VczR4c2xHa2IxWTJmMUJJcEo0SUFSYnkzMU5CWDd0bWwyaGtBTW1JRlBxdEdvREsxN3FBM2UzZWlZcGk5NHljWnZVU0pwSW5IRXh5Z3RhK21ualVWTGtYamZJbWtmbWhDd0dTOXl4L2EzVGl0VVovVU0wbnBNOThwRzRSdUxpNDdud0FxVWpiSm01ZUtKTWVST1Y5R2tEY2s1YkVBMjFxa1VTWUs0K05JY2VRVEdaaHltVkxIWHRhOTZpMTBzVDNHZkg5dldHSnZQSGZ5MkdwYTJ2R3FqSkZsNDd6R0laRERKQ0VlVzZxaFkvU2FnejhWeEpPV1pJMHp4c2lzempTeEI0a0EyMEZWR1dYM1NKOHhVaS9oakl1Z1ZpUXpBay9UL3UzdFVheFhMbUNYaklIOVNVTUNuVGJlL3dxTElzUHVMNWJERkRDOW1aZ1JwcHJ1YWFtTWsvdG1NZlV5REpJWWtONGxMQmRXUGxZRVVGT1I2OHpKaEdZdmpOZVJvZ29ESTJ3K3J6RTlkNkxFNElZNXBGWDFYUVg0R0Z5RlFFYWNodlpXN1VIZjhBL1RlMXlZc0tSWlVYM0NGbmxqZGVGei9ZamkvWHZWVFhDek1QSmhua1hMTUpqaElPL3dESTl6dWVPajJvSGp4NFdTN0pJcUtHY3RGYTNFZEFQTWRxaXBIQVgxSHduY1N6cEplR0dOZ3lBazJIbHZZL0tpZnRsenZiL2VNU05oSkg5dkloZG1LYUx4M0JOaVJmclRGMWt3ZmRKWUFaSW92VWtrQVl1YkFteHZjMi9TaTE2Ti9kUGNzOUd5WkkwZUJPS2h4b0NUcmNxTlFlOVZuTVhZR084am4wdlRhUXFXWTZnWDZnQTlxRlptbk1DeWtjbHlYQjlQMHh4Mk51VzFqZWlPTmx3VDVNVEY1QzZNUVhGN0VBZUIyb3FsSUU5WStwSUVsdmZoYmtwdnA1aXAwMDcxS3NkTDNML2pPVU1MSG14MTlXT1ppRE9wVUtUYTNIbWVscUV2TExrZjhBSHltUERQSFA2T1FqZW1uSDZnUi9jZkFVU3ZycXhnangvS3Rzb3RwcG9SMzZWQXQrbzhQQzFVUGlkTDJOQk1wYnFMMEIxQTJBb0IyQlVYR25mcFVVd1NBZXR1Z29KTEl0amZWajlQYXFFR0J2Y1VBQXhZQlJxZGg0VkJFeG5sYnJRVDRtMWpyYnhvRUJ0NGphZ0RZbmUvYzBEdnB2NEFVQXFFdGJXNTZWUXlMTmI4ZjhDb0JYQThEMm9KS1FGdUJkdkhhZ2pmVTZVRWdTUmNhK0ZxQ1RFQTlCMG9JaTE3dHFLQ1FLZzJVY2hiUW5TOUJBL2o0VUUxSUREbDVsTzRHbEJKbVVzYmVVZnRvSWJhN2pYZWdhdFp0cm53b0FBWHNkL0Nnc2ozSkd0dHZDZ2J1dDlGdDRDZ2g1U3RoZSs0b0JBb0cxL3dEYlFET0dBWGp4MTNvRFRRMnYrbEFBcTMxWHR2ZWdscHJmUVhvSmN1R2cxdnRmZWdSMXVCY2dmaUtDUGF3MzJGQkppUjVUMDJvQUxmcjhQalFBZVRqeC9adWFBVWNqditYU2dibllFM3RwZldnanFBU0tCOFJZRUEvcFFUWm1YNkRwMXR0UlM1alpkTzQzMUZFQVlIVzF1MUEyc1JZRDRtKzlCRlNWdlk2N1hvSHk0bTVBNmIwRDY2RHlrK1dnWTMyMHRleG9FMWdMQWpYVzlCTUQrM3Axb3FKY2cyWTNORVdMTlpXMDhvb0lDVWkrbHI3bTUvU2dlbTlnT1d3UFNpb2tkRHFMNldORURhWEg2YTBBQVY4TDZnMEUxSU5sMkc1QzczSFdnT0JBMUkxUHpvRUNlVndkUjJvcGczWGE3RTZ0MXRRTlZCWFM0TjdndC9sUkVMQWkvSzNIV3gvU2lwQjVDT1Z2S2RCcFJEVWdIVVdzUHpvQVdLam9ONzBCNXlRTCtBK0ZBQzl6dmE5aUJ2UVJCSXZwZSs5QXl4QUF0Y0hZVUFTQ05EOGZqUUMyNDNBQTJzS0NlOXlScHN2YWdqb0ZJb0FOb1NiRDRVRDVBblUvMTBvQUVHNmo2U2UydEExWGllUkkwL2FldEJKMThnZmNONDYwRmZJV3RiNWYwb0M1dmNnYW42UnRRREhXNDZlRzN5b0JHczNJYjlPb1B4b0c5Z3hKdGZwYmFnUlpuQmJYeTdVQzFBdmIvS2dEdWIvbFFTZmdRQ04vM0NnVnIzTkJJUGV4SkpBM0ZBK1FCOGdOanRmZjhxQ0xNVG94SjcwRUQrZlMzalFTWFFxVDI2NmlnQ2VxN0hmclFGd1FTVDhLQU50Z0tCRUhVMk85Z1JRR29OcUNZdHNCWTBGaXFwSTB1QnYwb0syVTNQRVhHOXZEdFFSZnpIbWkyLzJqcFFRVVd2M0ZCSUVrZ2RqcGVnV3diV3hOckE5YUJXWWtEYnh2Yjg2QmpUVGRlZ29EMUJjOHV2OEFnVUQ0T3k4aG9sOXpRU2JuNmYwMzNISWJHM2FneFNac0pnWm8yRHZjZ0o0cnVLQ1dMbFJ6QlR1VkhtQU94SXZRYVNVUmhkZkVpMnB2UVJqSEpyRzJwMHZ0UVdQSVN2RUFhYVg4S0NrM3VPTmpmZWd1Z1o3RXFnSVZkUnZvYUNvbTV1YkVkYUJhRUczVGFnaWVsalkwSE85OTVqRjlRbGp3SXRHT3B2cFFyRGs1MGN1UEhBRWVTZDdEaElBRnN1OTI3MEtNYkR6SWNRU1l5SVpYc3pzN0FxdGpjbFQwMG9tS3ZjWElCblY3eStVa3BZbFJheE9sRlJPVERMSDY0allvaEtzVUxLNE5yQnFJd1p2MmNaZEpGZC9VK3NzYklRTkQzTkIwc1daSjhKc2ZHY0RncWg0eWJCVnRzZXhvcTVjMGNrOUZGQTVLamthTWJhTXFqK3RCcDl6OTNod0ZITFZpQ1ZCMnQ0bWdvbjkveGtiMGtibk1DaEtnWHNyQzkvaGFndys1U3laR1h5eGRYQVVjYjIrZEJBRlpvL1RsbGIxT1I1UnNmb0lYOXcrRkVab0VpTVNyR3BqS01Ga1ptdmM5Q3QvME5GVlptRDZjbnBKL0lFSFBqeEpZZFNOOUxVUkdRd1l1VHdpbmRsNExxTHBzQm9ScnRlaXMyZG5GU1Zna2NPQUdhSWtFRlEydXVsQWxpTFl3eVlsV0tReWNCYVRrNUZyMk1YWHk5YWdpWEVmT0dISUhtZlFOZERiOTNMeHFpc3EwcUttUmxTckF2SVM4UUZVTUNiYjZtOUJDQjJqRHBPOGJZODFwQ1RyYTJsMVlkKzFSVFRISGxEeVNOeExGaEdvNW9wSUtsV09qWHFvMWZhMnh3NlpERkFHQ3JJb0JGejNYWm02MEdiRjl5bHdBWXNXQlpBNFZXbDJaRk81VzV0dFVVMmx5SXNoWjhaUXNVWjFhUlFUeWI5cCtOREhQbm15SXZkVEk3K2hEbWtOQ3gxVm0wREhUdHNLQ0RaMldGeUlGbDlXT0Z5aUxZeUtTTnp5b05BbG5seDhrdkhHRld6T3lxb1lIYzhlVmp2VUdPS0tXUXlGK0t0SWx3dWlhazduNVVFV1dQMFRrQUtrc1JBVWtneGdyZTNIVzU4YjBVbzh2RWFRelNRbDR3RlloWDRpNEZ5NVk2ZDlLRlcrN3grM3lZSzUwZVJOQks1ajlLRjBEWDNJUE1hMnQzb0k1VWdsaGptbHlSRzBmRlRhUGpHTmpkdUhidFJLNlh0dnUyS29pWU5IUGsySXlWa1VlbWY3ZUJCM3RxYXNwWXdHWEtpOXhXWUxISmNFdVNmS3Eydnh1TzFEeHp6S29Fay9sakxzUThCVWdoVHJ5VW1vc1J4L2RUaFpNV1JoSkpreXFDem9UWUJiL0FOeWFnMEdlZVo4K2U2SDBlWXV5RmpadXBCQW9qYkRpKzBsV01VVXVQZE9mRng2c1pmWUZRdm1YYnJSV2dGaE1ENmZDSjI5Tnhjamd3Ri9wSkh4MW9tcUJOa25JZG9aQ2pLZFNqSFVIVHkycWpiQy91RVU2eUlqVENIUUNSU05ON0ZUdUtLdEI5UExacEJHbnEydWdCQUFKdllyZWlNbnVQMjBlWEhqWXJJY3lRQlJLekw2U2hyK0ZnMVNrVjJtKzFkVEpLWm96ZGNaTHVQOEFjMnBzQWZoUmExZTFUaVk4SllINXJHQW9WeHpaNzJ1bzJKSk5COVBKYTNVQTF0aFZjbXc2algvS2d1aUVWanorUjIxb0VDRkk3ZGFLbEs2c0J3MjdVUkZiRWE5ZjhhMEF6TUJZbnlydFFTVndvdVJjMzJxS1dyQWtDd0ZWRW1VS3Fra0cvWTBVcmdyWVh1TmZDb0dHVyt1cE5CTGxaUUxhOWFvaUdZamZRN1c2VkErUTFBdi9BRnFva3BRRFFrMjB2YW9wTlpSY0hYclFOaGRlVzF1bEFyRDkydmgvclFOU2RpTjl5ZW5oUU1mdDZGaDBvRUFTZGREMHY0VUFiVzIxMXZRUzVBamEyblRXZ253c0w2OXJtZ2hjS1NMYlVFbERFazIwMm9HRUlJRzl0KzFBaUFUcHY0MERLRkRZN25jVUViRWJiYldOQTdrYlhBL09nQXBPM3pvTEZzQmV3L3gxb0lGZ05mOEFyUUYxUDZBV29KamdWOHplYnQwdFFSS2dhVUEzWWRPbitsQkpRNEJaVkpIY2RxQkxJUWREYnBmcFFNc2JlWVh0b09tdmVnV2dYWFU5YjBBR1ltdytBdFFXTWVSMkNqdDM4YUJPeDVDN2N0QUJidFFPN3lFSVQ4elFJOHJGU2JCVDlQalFLNUFzQ1NiNmcvbFFPMWdiSFFiOXIwQ0FiZGRSZTkrMUJJYUFNUllOc1QxdFFQbWRSWVd2cDhhQmJLVFkyQnVMZC9HZ0RkaUFkL0dnVHFWWWc2OWpRU3VTb1RVRTdrLzUwQ1lXMFBXZ3NqYnAvZG9LQ3Rqcm9MVzYwRTBVY1NHNmFnZDZCQWtpM2M5cUtDZkx3MDN2ZWdTaXcxRyt4Mk5FU0JGN0FiOUJSUUZ1TDdrM1B3b2dMV09ndGFnYVBmUW14YmRqUVNISWppRkhnM1dnaWREeC9IOUtDSjVBRFhUOHFBMTRrMkZqc1Q0VVZKVDVCclk5aHJRSXFRMmdzTmdhSWtPVmlRTnREODZDSkxOWURVbWloQys0UG1CdVArdEJPd1lFMzYydCt1dEVKbFcxeHZlM0hmNDBWSWVwd0JOaWwvRGVpRXRqR2RCdm9UdlFJbGd1aElGOUtBdWJFSHJRQ2prUUJhNUkvd0FhMEQ0NjI2N2ZPZ1pCVStBb0lsMnZ0NGY5YUJoWFkzQTFPNG9DNE9uWHYyOEtCRzE3RFVEVzRvRnkxN0h2UVNYbFlsYmdEUnJVQ1lFbTk3clFDc29VaDF1U1BJYjdIclFXaEFkaDVkd2VwK1ZCQno4cmRld29JT0R5M3QxdlFYRlNGQWJSZ0wyL1NvcXAzWmpxTnJiZjFxb2tDQ0xFK2IrdEJFa2drQTZiYVVEQ0Zqb0xXN1VENUZDMnYvMUgrdEJFa0hiWWFVQ0pCQTdkYitOQXkxeURzbzA3bWdYTTN2OEFUWWFYMm9GeXRlMngzRkFjaURZYjlxQ2FTTmZlZ3M1c1d2cHAwb0szdUwyT20rOUJIa0xFblUvbmFnRWNxUTJuSWJEcFFEaGl4UFFtMSttdlNnbXZwR01oaHFEb1J2UVFWVk8xamMyc1RRUmNXTnJXWVVCekkwMTRucDBvSXRKWmdPVmgrMmc0MlJFa01yVHFlUVppT0lGN0U3blNoVzdGZUNOMWlUVjJITm1GQnNia2I2MzJONkE1VzJzYmEzb0hKSzBoQlliYUN3dFFSRGdYdXQ3NmE5NkJzNHZwMTN0cFkwRGNweHV0OTdFOUtDVVlqS055VzdYSEZnYldvSXpFNmtua1NmeUcxQnpmY2lraWlEUXZia0l6b1RidFJIRHlzWmxEeFJna1hJQUorZ214My9XcUpLTW5EZ1pST3NtT0VzeUVrbnpIVWp2YnBRWVo4OUhSb2NPTjFKSEZnZE9SUFFIc3ZTb3F6Q2dWblpKV09Pd1Fqa1R3Qkl0NVd2ZmFpSVRMQk5mSGtZY29XQkQ2K1grNjUvU3FSdHdJc0JVYU1Od2lSdWVRZXJhVzBicUtnNitKN1hqSk1jbER5TDZxcEdpZzlqUmNaLzhBa21KSGtlMnlTR01TdEg1aXAzSUhhMUJ4OHpOd1JqWXVYalJCc2x3cXlNNUFiZ3BGMVkwRzdPeG8xbEdSREVIZC9PR0IralRWZ0JwZWhqbTVMQWwxWmRIQjVXR3BPOXlSdlJHS1NMR01vNGNsV3dKa045RGEvVGNVR25YenlJNVpVQVBJK1V1RHBzZGRldEZZWGpWMlV4U1hzNVFNNUFLdGUrMTcyb0hCSGxac1dRVmp0SEZmMWh4dUNRUHExMTFvT2VjaUdOWXprUzhDNTRvcVJzU2Y3U0hHb09scW1yRitQa3d0TTZOYjFMZVJ0RFlpd0oxMUpvWXY5MEdla2o0MEN5eGhpZ0tlbU9UZ2J2ci9BRW9qSExqNUVlSTBEeUFSdkh5eGxBRDI0bTdBQWFpNUd0RkhzbnZrK093ZVFKSlBkaW9hMWxYWUEvNlVMeTFaSHY4QWk1VHhOa3VnUmVRYU5GNDN0cVY1amY4QURlaVk1bVJEREpqTk5FcnVoMGp4OURZRnJtNUdvMDYwVlljL09NQ3hSNC9PQ1VDK2hiaVFMQWtEYW91TTc1UHN5NW1NSmxaVVo3K3VvTGdEc0FmSGVnMFk3Sml6Y0FnbWh0SVlwVVV4dVE3QW5ucjAyRkJkSWlOT1prVmhocVBJMGkzRmliV3Z0dnBWVFYyWjdPd2diMFpBb01ZZFVkcnN4NnJHQUdMYVVKWEh6NDV6N1lqRXh6Q1p4eVh5aDBzZGVWdnAzcUs1QlNQS2lCTVR4VEpJZlRSQ1dFbHRBcFViYmZWVVYwSVl3TU5jbVhJQ3FvMVdNaFJISXh0NmJLZk13STJ0Ukc0eXdPa0dNSThhd1ZXZ1c1SVc1MVYyUDdqYjVWUlFyd0YxVVk2UWxtK2dtL0VqcXAzQXZSRTQwaVNKc2dKSXl4bmxJRkhrTzlqY25yZXFhMHlaK0tNYUtTS1ZjYVNSV01Zc3B1VkZyRU1kbXBFeDUzTDl2ZUpaSGtuamR5eDlReFhqWUMycEFHNDZXcU5hMFkzMjBUQnNsbVlPdWdGaGEydXRqb2FEVGtTelljMGlZMGJ2aU02SStSeUFISmhleERlTGRhQW55L1VqaFNNeGwrVEtQS0M1T3pjbjE1ZUJvTmo1T0FzRVp4b3hITjVlTGFEYlFqUS9yUVdsL3VFSHJNWWdEWjMxYzJBNUtlVjlWMHFvdTl1a3c1UTd6WTdlcU5ZOGdFQmkzUnJIOUtGYzczSDJyTVNiSHRHM21ObENpL0xrZFRhMTZVbFlIOTFFRTBrQ1lSRHVWUjVsY2l5cG80NEhYekhyZW9xMkwzQ1BLYUtHQkdrbWlzRHlUZ0Y0N2NXMHVCM29tUHJ6WEp1VGM5K2xiWlJKdGF3M0dtbEExSU91bHU5QllDdnFlZlVYMXR2UUlnY3RyRG9LaWhoMThkQlZSSDZtSVBtN2o5S0JqaUdHL2liZGFCZzhqWXRZZGJVRGNBQ3dHdjVFMEVvbGI5b0ZnTDJPbFJVYkU2alVEVW1nUExmd3ZlOUJOeURxb3NQOCtsQWxGellFRFRTcURtRHVDYmFFMEFvREhRV0kyTzlRT3pMWTZBYjBEdVdOMjF2VkNhK3Y1bW9IeHNkckh1UHdvTG1obFNMa3pBQWpWZEwwRkF1VHY0YVVFMUdvQTB2MTJvTHZWOHZHM2hyMG9LdUNFazNPK2g2R2dZVmZBQWRiNkNnbVpBTHJ2M05xQ0N1TDZpK2xnT3RBZ3hMWEp1TnIwREJITFhYcDJGQUFtKzJoMHRRSEk4dEJZMm9MVVkzRnJVRUdJRGk5bUo4UDFvQ3dBSTZkeFFRc2RyOUwwRXpJU281SDVVRTBBSTIyRzNVMEFHTnpZOFJmVURyUUNlaVN4Y253WHJlaWtXdGNBWHZxRDJvaVo0RVdRYmZuUVI0dWpYR2hIejFvSWtua1NSZS9lZ2R5TlFRYi9UdHZRRnkxeWRiZHRONkJxYmRMNjYzMm9FamdOM3NkcUtmN3RUNVR2Mm9pYXFTTC9uUVJabUkyK1ZBV1l0dHJ0cnJRVFpIVlMydzJPdDcvQUFvSWhSY1c4dmg0ZDZDUld4dGJicjRVRVdaamJyMkZBMVFrMmE0MDJQYWlwY09TMzZEcWV0QkJnZU9wT21oRkVLeEl2NGFqYy9DZ212bUZqYTQwQS95b0h3MTBCdDBKMU5BaXpCOWI4dSs0dFFBTjB0YmJxUEdnYWxkeU5LS1pOenlBR201N1VSRVh0YzdkcUJoaU5EdlJVU2VXdTFFTWdnL29EL1dnRlVHZ2tMcWVZQVBVai9PZ2NqcVR5WGJqOVBZMFZIa3RpTEcvUS9yUkF0bUhsSG1HOXorbEF3SEJzZExkTGQ2Q2FMNVF4dnhHOXFBY1JXQlZpZkE2V29CU1dYamZRRzQ4YUJsTFgvUHcvQ2dROVBnVjE3anJyUVJzdGgxUGJ4N1VFYmIvQUswRjBjaUtOUHFINjk2S2hJMTJ1eDFQV2lBSTVYUWFkKzlBeUxOYjZndlNnVGhUc3RpZkdnU013NWNOYm5YNDBCd3ZyZlNpbVRHTkJjbllIYWlBRUcydHJiMEVTT1QyUmIzMjhhQ1hLUU1ibTVHZy93QXFLWVZuSjdnRzRvSWppUjVpYmZ0dDNvaEtiZzliV3RjYjBDSkIzT3RBMVFtNEkxRnI5S0FjZWF3c0wyMThhQzVWa2dQcUE4WEcxK3Q2Q2toanJiVTlmalFUOU9aVUorbFZQVFhXZ3FBYStnMU85NkJrL3Q2WDFQYjVVQ2NyZTJ1bmVna3U5eWROaWFDQmF3dCtkQk5MY2dMaGI5K2xCTG10NzN1UEFXb0lzU2ZnYUNDa2JuWHBwUVNBSEVuVFEvT2diczFocmV3c090Qkg5dSsvUzFCS09RQkNlSVpqKzQ2VzhiMEVOeHJja2RlbHFCRTlPMjFCVG1ScThWbEk5Uy9Ic2JIeDdVTWVYbFRJVElCZ25IcExmbmJXeFUyYmtLRG9lejVFcytUNnZFS2hYanBwYmp0cFFqdUxORExab2o1ZGlUcnFONkNYTHlnY1JlK3BHOUFyQUhlOXhRTlNBZnA1QTlENDBFZXR6dDJvSXRJcXVFTEFNMnRxQjNYcVBoODZCNnFQUDE2VUhuZmZzbE1mSTlkWElrNDJqVWIzSFg4NnFNQXlWay9tc1NiL0FFT0NmcTB1RHQrTkJaTzBjNm9ZSElrWnVQMjZuVWtmVXR1eG9MY2hNYVBDVm81VWlsaWo5YVlINnhiUXFGYlEvQ29PY2M2Q1ZJVkhMemk0eUpOTnZwQkg5YUt2UkZsY1F4c3ZveUVzN1A4QVh5R2pBazZONFVSbnhwcHNYUGtMc0Npa0t0eGNCZU5yY2UxcUQxK0hsUVRSUnRFUXl0b0NOTG1pdVY3bC93QWc5SElPTEhFeFlIenNScHY0MEhLeXNWb3lra3FySkVUejZjeUFkdmlhQnh5KzVabVFzUVVyRHlCS0tQb0IydWUxcURiazRVU2hzQU14bGRRVWU5MlBiamJwNFVNY2RvcFlINHV1cXY1emNrRFRVZVh2UVpjeFhsa1dGUVN1c2hrc09aQkgwOHZEdFFaNThaSXBJaXFtSnRGT1RJbkljclhPMjYycURGS2MrT1RqOXl6eUlwTW5vM2NGWFAwbld3dUtLY1h1VFR4Wk9IbEQ3UW8xOGFTOWxDWDY2SHpkQlkwRkdRTWRaSTVaWXhKSUpGYmtyTmRRZWpGUUxYb1IyOGYvQUkva1pjRTJYanpJSjQrVWtheXlzelJyYTF3MTlkS0p1T1prWWl2RDY1ZjFNdExXUlVLazhodHlGaGNtaFZrVUVPUEg5d0dYNzEyNHdZOG5BbGdSOUpJTnJrMFZpQ0ptcktlQmlZdUFJUkhZQmwwYml3UEVFZHV0QlZsakxpZ1VSNVI0SVNSY256THVPSUE4ekRxRFVWZDdUN3ZoUXNRN084eGt0T1krVWZrN3NBTGEzMG9Zeis2NDgwMlpKRTBiQXhCWlk0MERBV0FML3Q4MTl0UlNrck5penpZMlVtV3lLY3JXVUV1SGpaUnVqcHZjazFHblU5d3pac25CampTR1NGK1lNUWdjTkJaajVycGZrUE4zcXN4MTRQOEFrK1ZpTEhoTmhvMktRRC9MNVMyZ1VtTjdYRnp0YWtMTmMvTkVUU1N5Y1VhS1FXaHh1WVZ4S1RkUTIxK05LUnljMlY4U3lzZi9BTjRGZ3lqamNua2JGQVJvUEMxUmNROXdrZ0tyaDVqcEE5bXRHYmwwZTF3NFlicjRkNlZKZFR3Y2JLaGtiSEdRWklKNGd6c2k4dU45VjVYRndlOXFwWFR5dlpKMHdVbUxzY2VRQWZjY0dVcjIvR3Ftc0VVM01Jc3hhWXhDMlFaUnhYZ05FS2hOVzAxMXFLZjJ1QTJKRE1WWDBsYyt2TWg5UURUUWNmOEFLcUs0SWNQRWJJUnNpSEl4R1RweVZsNUw1V3R2ZW9uaWpGanhVUVpVT0krVHo1R1NCd2VBMHNycTRQTGxlaWtyVENiMUpsREx5dUpFakxScUYzV1JkZHpwclJTejhhSE1kWXZiNHdnU3hsOVJnbDlOVEdOQ1Z2ZjRVU0xjVEYvOFo1MmlVTUdIQ0tNNndxZG1QTFFnbnZRcTJMZ29VQ05XaVBJbVpnd1BrM0FTNXQ0VlVkTDJuTU1rcS9iZ29ZeC9FT04zTnpjQmxPbjRWQ3h1bjkwbm40Q0Y3U3FSY0tDcjZmdXYwMXE2a2psZTYvOEFGY1NTYU40cGdacGdSSkhFelBJblU4dVhXbFg1cXVQMHNPR1g3b3pPSVVLUUZMS2VaMEhxaisxaDFxRDYwN0ErWTlkeHRXMlZSdHkwMEhid29KSXloZHJranluL0FFb0lnNmFtM2Fnc1I3R3gxNzJvR3pDeEhoUlVTaFVnVzEzQkZFQUFzUmNXMytORkxVYTN0MEJGUVNJMHVEOFBHZ0xFZlVOOVJRU0JQRzlyRHJRTG0ybDdIdzIwSHdvRGxlMTlCMCtkQkpRTDc5ZEJhcUFnaGpmODZnZkd3dUxXOGFCT1Z2dnNLQmhqcGNDd0dnMm9HenF3c0Z0MCtOQTdNTjlTYUFMK1VkU05DU2FDSU9saDEzNlVEdGJjMERCYzM1WE5CSU9wOExkdXRBcmt0dFlEb0tBZHJ0MEFGaHA0VURZcWRRZGZFVUV3UWJxeDRpMTZDSUlMZVMvejF0UUIrbzYzUFVpZ1pqSVh3MytWQWtabE54MDB0L2xRUzRGbEpJUHhvQUU5TzJ3b29LZ0RseDB2YTE3N1VSRmpZM1RUWFFiL0FCb0pKeTQzT2c3ZzBETExhd0duWDQrRkFpMXpjZVh3b0pJT1JBQnQzSi9wUVRaeWdzTnoxb0lGOWJtOXlkYUJ2RWVQUDlwTmdiMEVva2pZMjIwdmMvb0tCY1NHTnRiYTI3aWdKR3ZZcU50elJVVk43ZHQ5TzlFVGVJcTJ1M2o0MEFzdHRBTkIrbEFNNUtrRWRkYmY1MEM1RTl0QnYxdFFIcUU5Q1UvRVVDQTc3RHR2ZWdza1BKUjV0dWxGUkRKcG9OTnFJYk1TYnNidDBKNzBWSU96THdZK1VHNmpwUkJJZ1ZiZzZYdDhxQ0JJMDZIcWU1b3A2RVhBMDYyb2lZWUNPL0x6YkJSUlVDeWtHd3QrbEVNRHkvRFMzalJRUXhBNDdBWE5CUGpJcWN0UWpHM3hvaUlPdGhyZnZRS3pDNTAveW9GMEdsbTF1YUtlcHNTT20vZWlHckVHd0lCL1dpam1MY3VwNnQxTkVNa1dzQmZvYUNMSFRxQnRRTmRHc2JnYmkzOWFCaHJrc1R5WTczUDUwRFoyQUNuZitsQWxMRy85dEF5QXBzV0FGdFNOcUtRUFRhLy9BRm9oaEdKOG9OeU5lbTlBTnlGN214MnVONzBFTGthWDA2OXhRQUhYV3czTnFDUUlkaHBvQmExQklTeUpjZzZIcFFEdVJZT0xNZW5RaWdSWmJlSTJJb0Z6RndRQUxkUlFTTXRpR0lCMDYwRUhaZVJ0OUo3Ny9LZ1lIRnJiL3dCMzlLQU51VjlpTjZCTHFTYkhiVzIxQk5sQVlBRXFiZlA1MFZCUUNDT1EwTndEMW9oaXhiekhpdlZqM29EZ1BxSnVEY2FiWG9KcEc1UWtXdWRMZFRRVkFlZmplMSt2WTBFcEdZa2dtOXRxQm1WaXBCc1FiQWQ3MEVXNUtwUmpheDFHdHZ3b0dIQkEwSklHcDcyb0VxdnlOeHAxSGpRU0tnbnpXdjMvQUtVQ0tXUEZDU0NOUVJRTkhDRWdxQ2R0UmMwRlpJSkpKMTZhWG9KQmdBTkxlTkFpekhsdmErdEFsUG00a2RkdXRBTnV3QUl1Ylc3VUJkZ2IzQjJGQkVsbE9oK1ZBd3hHbHROajQwRXVaQzhiYjdrZHFCRWkrdGg0RGJTZzUrZTd3eWlVRXVEZXk2V0JJdHBRZWN6VUhxeHNXQVZ1VE9nRm1ESFkzSDUzb0xrOWVHTGxqU2czMGxld054dHBiclFkTDJ6TGpqRWNFY2dhdzJKMUIzTzlCMkFBNjNCODJwSUE3ZjBvRXZoYzIzb0pnTllIWTN0dHBhZ1RCZ0FPdjZVSEY5M09YSGtBeHFHNUR5RFhscnZRVyszWnJNUkE0TjR4NWlUY2ZJOWFEcGN4YXhQbDdDZzUzdTN0a0dWQ1NiQ3d1QWV0dFJyOGFHT0E4anhsUklvaFpyaFl4YXh2MGY0Q2lWWExtUERIRnplTXRLcklwVlNYaktqeTdkejF2UVpwSnhHMFVVdkpzWVB6bDlVRmp5NDZEV3hzVDlWcUN6LzE4aGlrdWZTbUI1eG95a3hCWEZ4WTdtM2pRWm5FbzlPSmdqa0N5Y21KWHpiN2RRTmZDZ2VPWXBpVXpHZDNXNThvM0ExVWs5ZEIwb092N2Jrd3BJc21SYjAxSDhaVWl3TGFnMkhZYVVXSXdlNHNjbThxUnk2dnhrQkRXTnZMYzdmaFJSbWU5NDBpcnhCOHdZeUZiWFhpQUNkZTlFY3FIM1RrenJCa0dOTEd5c0Q2dkZqZXh0OVFGQ3JqT2NpRlY1SVFvTEdaaXk4d2ROUjAvd0J0cUNxUEpkUXp3VE9JaVFRN2crWmhvQTI5eHB2UkZSeVl6a3lTbUY0c1VOcUEzSUFrYURrUnFDZXRSckZNK1krWk8wTExiSEpERC9hVzh1Z0czalJFY2hjZkdnbjRwNmtnc25xcGRBTDYyc1JjbWc1cGpteVlZNTQ4UWthSzRrZnlPeWtHM0hmelcyb0hsTmovQUhKZ1NPWEZ4b3kvQkl6NVRxQ2IzLzNhZUZGTXlRUnUwVURNMHFMeTVXRnJzUjVIdVFSY2RhRFZQbSs2WlNSUk5sQnA0endoeDdMeVZMRzEyTmhwM29Lbnh4SkNrM3Q1KzZ5aXdWc2NvSTVVT2xtNU1kYjY2Q2d5UXd6QnNtS09Rd3pSSloxYXkzWld0Y0tEZmtMNzB3MVcrQk5rU2ZjcVN5ZzhuWkdMUmpXeFFnNkJpUm9iNjFLc1k1a3k1cDVYZFlraFhqeXVBSHNXNjhkUm9OeFNyR2pDa3g4bktqYWNPcnZJVEEwUjRxTmJYN2p0UksySDJuS2phYUVjbVNkeGQwVUVGdFdPL21YeE5LYXBtbU1XSTZ5ci93Q1dwdkRHcWFGRk9wOHUrbldtR3MvdGZ1R0ZDcVJ5UlA2ak1yUTgySldNM0oxQjErVlJiR3pOOXliSkI5VmxsNGh0aHdiamUzbXVOVFYxSkhOZkZhU0EyOVNPTlY0eWNneVJuVCtPOTdudUtpNm5oKzFlM3lZNkgxRVB1S1NYU3hiaUFxblNSbTAzMm9WMGNPWElQcHo0N0tucWhsbE1oc0FRTEtGSUZhWldTZTk1VUN4NCtSTWNnTWdNcEM4d2hOOVZzMjYyMHFMMnc0cVkvdXVZdUhPNGhVc1k4UnkzcHA2aFc2R1MrMTk2QTl4OWt3b2s5REdhUEJGdXNwZFpDcEFabGV3OHBJcGh0YytaY3BQVGg5QlkxSC9iazBZc2pIUUhqL1dnNkF5Y3VKSGplSmtnUnpkRlFmVVI1QVNUOU45VGFnNXpabnVHUHpaaVZNcThaWXRnMXR1U2o2aGVncjlCR2k1UHlTWVdNYXVwSVUvdUJQMUM5cURiZ1QrNnd3dG1JNFV5Z1JrbFNiZzdnSVJ4dUIzb29mUFJwNzQ1OVI0aUJGTElPRGMyK3BpTDdDM1dpSURKek1UTlRLa2VITWlCdkk4TDJ1N2ZTcE5EaHB5OHpIeTNlWEdnYkhzRGNqek1YSDltM2w3ME9tcVAyMVp2YjRzdVBNaXhtZFNPTHN6VGMxRi9MYm8vU2c1Y2NlWGtDUkZrajlLVWxNaFpwZ3Y4YTZpN2thYTdVTmZaN013c2I5L0N0c0sydDgrOUF4cUwzK0Y2QitYanJxT254b0VBd3VMYVh2Y1VFZ2ZOb042Q1lGckEvZ0RSU0pCT20xRU82WDYzN21vcGhUdU51bldnVEEvNitGQXpJU0FEcU9ualZFUnVUMU8xcWdrZUpzRHRRU1FucFFNcVI5V3RBY3pianN2WHJRUkpOdHJkcjBEUUZoYTE2QnY5V2hzTGRLQVpqb0FkQnRiOWFBWTIySGpjOWFDeFdBaU5qZmx1TGQreG9JajZQRWRQQ2dpWEpzU0RyOUlvSjhRd0ZtRE5hLzhBMW9GYnFMN2FpZ0xkZkg1MENGd3c4MWowRkJQa1NvRnI2OWFCQ3hCRkJGaUZzRi96b0ptWmlsanFEUVJHNXNiQWJVRjRjbGVJWThBTnFDSmJqYlczZ042Q0xNQ2JpM2VnT0picVNmMW9KL1N4REM1T2grTkZHdWxyYWIwUUJDRGZqZjQ2NlVDS3FXNGsydjFHMUFhY3Q3K05BMzAwQkZ0NzBDdC9uYWdhV0RXSjA3ZU5CSjFXMXhyYmM5S0NPcDNPZy9XZ2tpdCswV3R1YUNURW01dnlJMXNlMUJVUzF5Ylh0dnJRV1hQSFFYQjc5NktpcTZxTnlkZ045YUltbGczRndPTjllL3dvSmNXNDMxNDMwRkZWK29WMTI3MFFEUUR4Mm9HU3ZFZHowOGFBTGcvRHQxb0FFMnNvMzNQK1ZGSzk5YmJVUkpXSUIySW9KS25sTEd3dHYzRkFsRndGSnR5MklvSkxyY0JyaTNYYjVVRVFSWWtnbnViN2ZDZ0FTUUFUWVcwdnQ4cUNQSWQvalFTczVHdldnQ1d0cHNkZmpRSVBkYkgvQU90QllBUFQ1RWo0RGNIeG9JdVJiVDZ0ajRVRW8rSEV0MUEwSGVnajVRQ1NUY1VFbVllVWdra0Mxdmowb0NNTHk4MnZVQWFDZ1R1WC9ieEo3RFQ4S0NGN25lMXQ2QnFGNWE2M09uUzVvTFhCQlBFV0dvSTBQeG9JQjJCSG1ON0VMcnRlZ1k1V3ZyZnFldEFpMXhyK1BlZ2tyTGZUVmRySFM0b0Z5RnJXdGJTL2hRQ2h5ZGJhNkVrMFUxRFhBNjlMOXFJVmdqYWRqcUtDUDBpOXhyZTFxQjdpNTdmT2dYUWsvRC9LZ1k5VGd4SFhRMEViWDFPeE85QlpHRnViM0E2L0dnUkhNNmE2ZE5TZkdnUkNFRHhGcmRxS0VRcy9IcmI5S0lWaU5TT3R1TkFBQWpseXRidnZmd29KUk9xM2E5cEI5QXRjYTk2QnhQR1gvaytrYitQalFPVXhBbFFOejVYb0k4N3BxTDJPcmRSNFVEdFkzMC96b0pHU0xnQXFrc05UZWdxTW1nMTYzdFFJT1Y4Nm14SFhmVHhvTXVYa3Q2VjQydVd0eVBXeDhhRldSU3F3QlJya2RmaHZRYVlmVFptOVZ1UGJ0UVFZSUNiTVNCc1JwUU9RbHZNU2RRTmFDUEsrbW5jMERJVVgxMTN1UDBvQ01ua05RTGFnbmFnbjZnZGp5c0NkYmdhZmhRUllCUWV2aUR2UVY3blE3N0FVSEh5WjFTR1NOM3NQekgrVkJ4aGs0WXlyaU15b3JGbmdZV0xXRitYSTZHOUJHUE5SZWNpdDZaUmdWVlJ6SEVHL0FkcUkweVNZMHBrbXh3RlNNY2xZRzVibHZwdlFlandXWVlrU2tjYkRUWFhVZGFLMHFmVHNldXhBb0pSeUVHNmtIbGZrclVFSlQ1dGRqdmFnNFh1QnlwcGpFSmxVUm02ZytVaS9VR2lPVm1aVVdQa0NVcTRlS3lScU5RYkg2ajRGcURyNDN1eVpQdDVibHd5Q2hMRGF4M0Z1K210RlR4czZQSXdPT1F3VWdYWWo2aU9qVzhhRG55TEM4VFpzTXBtZFdDcWpFQzk5N1gyTnRyMVVaZmJjSnBaWlBTaDlYRmtZc0dZcTBpYTJ2YTl0NmlwbUdFeW1SbERzdWpNUnlaRGZVMkJBdlJDRHNKWEdRU0lVOGlxMm1nMktqb05hRERrWWJLekdDVFdJbThSczVzeCtwZTR0UVVRNHc1dmNOYVZsVDB3Q3BERDl0QjAyeElpb0Nyb05PT3gwRmlEODZMak0yUE11S1lzY2lLRm12TkV4RnhjMnVCL2xRWUlzUElremZYaFpJZk54VDFkUUJiVUVENFVGai9kdC9MbEpIOXBDZ0N2RllzU3hKQ3RiV3gvS2dXTE5KNjZmYzQ1RUxpNlk4YmNQS1BwWU1kTjZnaDdobHFNZVJJUzBjVVRHeWsvdTI1Zkh6YlZSelpEeHhXUEp5cXNIS1dQRmg0dGNna2ZDb3JvL2Z3SXZyWXljQ3R4TE55R3Z5RnRyOUtxTXMrWXNtYmFISVZXSXNjcmlTaDExUEhXNHNPdFNyRnVkaVpXZmtZMGt1UkhBV1p1Ykd5Si9hcmpqWWIwUnpqN2NrK1UySGl6U3RJeUZKd1c0aVRqcS9Fa0c5enJ2UlZtVjdiTEU1VXFWOUJFWTJBa0xMYTUvek5NSlY1bE01R1RsUkFQL0FOc3FMQlNRUHFCSFhXMXFEUDdoN1lINHp3cElnbVljUUNTejhRTDhkcjJvUmdpOU9mS1dGVk0waDVFRURpNEEydjAyR3RxRHBKaSs0Smd0QXJSeVl1WXlpV01rTFoxTjArQkZCamh6empabVhnNE9JcE0za2dNNTVsVi8vRktrZ1hZOTZpcHlaUng4TjhXV05pMHNubGNJQzRRZE5yL1Z2WTBUdFBGOXk5eGl5VExaMGdVR0lTTDV4cmUxaHZZOWFMNEI3Zk80bXptUU5Gak1WTEJ2cGUvMHF2MUZUMnRRNlljM0pqa1o1T0RSQS94TG9MTVZJSUhtSEpUVVZvbXg0Y3VOcFB0bWdrWmVNcXNXUEFLTDh1N0JyYUcxRTFqd29zNlpIQ1pFbVg2c1lLS3JGbVpkK0RBOVZ0UldoeEhob0lNM0hhQVdaa2tkUWVYbHZ4QTB2YzdWVW94L2NKNUNJOFpFRHpxQ1lRbGllSitwRC9kM29ZbkpuKzJKQklaVjV5a24xRkpJNUxzVGNiV05WR0dWSThjL2RESFNaeXBqVnlRM2xaYktXQjdYM3FLMllPUDdxbU1yWlZzM0NpQml4V2xQQVJnK1k4UWUzYW9MSTgyV09Bd3hBTEU2c3J1QXBMTHl2eFpoMk9sdTFVc1dRTjZYR1VxTWtNUUJqelhGeVBxSWJZQVVSRE9MNTJSREJER1JLYkxINlZpN0FhOFFUcHAwb0xvTTczVDIrY1J6eG1hVkhaNU1XWkdqa3VSeHNISEw5dlNxTW51UHVyVGlZUVN5WVdKTEUwcVlOL1V1bklLT1ozNUh2VUpEOW1YMnJPVDFNeWVOTWRQNHBBRXZhK2lrZzJvdFpmZHZhNU1mUEVHTzZmYnhYYkhsVmhJT0xINmpiZWxKVldGSXFtV05HOVJrMDQ4eVNOK1RMZTE3bnBRcXFUM0Zvb2YvQUEyRndDVFlFT2gyVU5mdlVXUmJqeSs3eVJKQkJDb2luVUxKNm9ReHRiek1DVDE3VTB4OWtibFljZE8xYllES2RDeHNEMXRWUkhUYnRwUVNCTnlQbDhxQmt0WWl4RitsQTQyc2IydVJ0NGZHZ1lZWHUyeFBtdFVEVWdBbmNhYUhlaW1CYlh2c2FCbC9LTGFBL2hRSmpjTFk2Zm9hQ0laanAwQjZVRmk4ZjNEeFh0UUhOZVZ3TG0vWHBRTWtqUWI5YUJyeWRybnBwcjJvQnJDNjZmOEF5TkJFcWhXLzd1M2hRSEp4ZFJvTDZnZHFCRzlpMXIvR2dadnYyM0Ezb0FjVDVyRzM0VUZ4UUc1UU54N2VJb0t3NXZ0dDBvRmRlZlVqdWFDVndUZFJhK2dvQlNiMk9vL0RXZ2tmTTlsc0JlKyt0QkVCZVF2dnRjVUV3RnZxZE93b0k4eUxxT3U1dHFLQmNTUUFOYUNSREtiTUxIcmZ2UVNBWGlUeTI2VUFvTEFKb0NkcjBWUGlRMjEvQVVSV1F0enhObDZVVllzY2dHbXgxOEtJaVVhMSsrb29JRFEyTzFCZmZ5alhSZGg0R2dRVXMxaVFvSXZmdFFRWWtFSGxmczFBY2I3SFE5NkNSNDhEWVhPMUFoZlk5ckg0MEV1QUZ1WnRmWURYU2lrNVQxRHdKNGRDZjhxSW1tcW14MFBYdlJSYlh0MW9nRFJxK3EvRWFVRVhKRHR1bzdXM0ZBYytBdUFRZWg2MFV1U2tBMk54dVRSRTBrWUd3YTNqL25RSUllSjFIalJUVlFRQ2ZHNStGRUJ1eHQrblVVQXhVV3Qwb0VwMXVCcjBGQTdlTnpzUUtCa1gzMDBPcG9BOUMyemFkeWFDS256ZGgvU2dtNElBTGFjaCtWRlBpbkkyY0d3NjMxOEJRUUxYYmJiWmFJa3dHbkM1dmJ6SFNnRGJVV3YzK05BeVl3ZzEzM0ZBZ1QydVJzUit0QkpJNHl2TGxZamE5QkVpeE5qcnBRQXRvRHNkZEtCRUc5N0VEWWQ2Q3hRUXY2MEVYVGp1ZitualFJRyt1M2UvV2lub1EzY25mdFJFV0pQVzVJMEhTZ2wyL3dBR2dZazR5SGpiamUxNkM2U2NFRUJRRDBQaFFVQWN1d0hlZ2FYRFdCRndML0NnQ0dJdmJUcjBvSUhrQnFiMm9KR3lxYkc5OWdhQjNVb0xFN2FyMHZRTkxFa0ViQzRBL1UwQUw3QTY5YjBDNGdFQUh6Ylc2WDhLQ0pWK1pGaWJha2ZDZ3NGdER1UnFWb0lNVk55TDI4S0JnRUtiTVFScHAxQjZhVUN0WUM1QlA1YVVEYlZ0ZW4xR2daSElBM3Z2Y2RhQ1BFYmZLOUFBQW14c3ZqUU9OQkl4VUcxcjBEY2tBb0FMRHY4QXJRUUFKYmE0RkJMV3dIZmFnVEtiY2dicnNiajhhQ0hRRWRmNlVGR1kzL2p2eE5tT2lqb2FEenJ2a2grTWpjaVc4aDFBQ2czTndOejQxVWFQWWNtVnBDa2tuTm01U2NSYjl6SGExUlk3MGNnWTJVNmpjQ2d1Q2FBbSt2MDlkcUNPcHZleDAwdlFRWUZqY2E3V29KRlNqRGtQR2dYcUU2R3g3R2drQ0FvREx2cXJmNjBFR2JYWHZ1T2xCUjkzRU1yMFpHc0xYSUcveDdVSE45MGVJTklVWURtdXUxbUY5alFjdkFseGt5V0VsM2lkZFc0M1pIMnNMVVJYSXNJeW5SSjFjU2xXQlBsRi9wS1hIVnFLbkg3ZEJoTklwdU1oTFNlZ0Ird2JBRWVYcnBRZFhDOTJZcURtSjZOMktwYmEzVFUwSFgxc3V2WWdqc2FDeHVQTFhmcmJlZ2k2a29XNmRTS0REbFNROHYybXk2MzEzMi9TZ3cvK3RpbWQzeXZvNDhnNE81M3VMZHVsRXc0OERHeUlpRmRrbUdsem9lSzdLUWVscW80QldhS1lxcU1vVWtFdXBQSmVQY2QraTFCcWlXYU5DN2FCVXNWQURCd3c3SGEvNVVFVm5sZ3hXTWNJVGlDSlpYT3BEYVdzdHI4ZDcwVm5qSXg0a21rY2MyTFdUWldqajFiejdhN1VHbVBQeEpiK3BBWG1kYndrazI4M1FIdUtJb3d2dWY1SFZoTWkrUnVBSGxBK2xTeDAzcWh4NVdURTB1UEpkSWlUNnBsSE80T3ZOVHZjZDZndGhzcm1LVmlzU2djNWxQTUU3QUMxajhUUTFxTTZ3UytoTkVrdW02a01MRFhwZWl1UjduRklNNzduSFV3eE1SeTQzUEVXL2FSK2RCbmtuaGpLZXBKellyeFpYUFVueThTdTVQVzlCcndjU1RKaGwrMlVBcWhoazlROGJCdGZ4N1VHZC9iSkV2aG4wNHBwRTVJOG44bW4rdE1MV0tOcGNLTlozaUx3aCtITU1HMVU2S08rdXRxaTFMUGprbVdKWVdVUE9UNnFoUUl5SkRkU0xhM0IzcW9ySXh2VFdIT1l3dWpNSS9SUUZRcXR4ODVGaVNiYlZCaWhmR0dTSW15R0V4a1pZd3d1c2ZIbzZuU3gzMG9ycEQzREdsamt5UHQwNHJZRkJzV1BsYVFJZGZOYlMxRXhranpjNC94Rm96QUNVWUtHU1Mxcmt1R0d4MEF0UlcvRDlseHA4V0dZekJ0RDVvellKSUQxSFN4L0dpV243dkRONnNIRVkwc2tPaXlKeTR5QnQyY2tpekE5YUs1c1dSaUpHbG9rVWgzaVZsTEZ0QnFiWDBGNmF1TkxvMlJKSEhFMGZsVzRqTnh5WCs0dGJ5bjQwUmg5eGdlZkhLeXdwRFBGS0JhemVvVklHcGE5dmdhaXRDRkRGRkVJTWlOSStVczZrQmliRzRKWWtjUVZvbWN0TFozc2M2U1M0YVMvZEhteUJtNGhqc0ZLRzl2eDFvT0Q3cmgrNHMwVXF1eDlWV2ZqR0NyY1k5bTVEVGp5cWEweVBpdk8yUEhGSURQNVE3U05xWEo1TVNkTk9nb0xKc3ozSEN4NUpHWGh5ZjBsZVpkT2FtM0MrdGd1L2FndndzM01DWmorbEZGa3hoRDl3Z0VmMWEzV01hamZRclJLc09mbFpPRmp4Uko2anlrOGk5bkpJMUpISTdEdUtvcjl1OWc5MngvVXkyamRFa1BKTW14dEdwTnl4SFVHa0xYVzl1LzQyWmN6Z01tRjBVV0RNZUtPQ2IzdTI0MXFwbzl5OXF4Uk03UXRHWWI4REJJd2FSakgvd0RIKzV0QlVJNVVPSDdoTEpQSGpnUnJJZWYyZ0xTOEpVT2c0YjdVcTYxeHdlaml4UktIamxsQkVqRUN6dURxb0JIbHR2ZmVoVkVpdUlsYVlyNllZY1ZrWUMxeGNnZjNXMHZhaEJFajVtU2ttRVZtbFQ2NG9MZ0tZKzEraDcxVTZaNXM5c2lVck9zaU5PeDQ4V3NRVXZZdGZ0VXF4eThxRVpFa3VWN2htaUxJNGpoamNTcldVY1U0RmJqUzJ4NzFGWFlPRWtpRXJMRThyS3l1elBZUGZxT1ErcGFEWkhpNHd4eEVzcnh5a0FxNi93RGEwUG1VN2thMVVVZTVlaE5pbFZTekJWTTAwSVVXWWZ0Qk92ajhhRVFYT2l3bWlra2plZkpsS0dReTZNcFRRb3hYeW5rT3RScnRvT2RrUnJNMHFyRkU5NUJFUE9RZW5IYTE2Zyt5WHR1QjQxMWNrWDgxamNrVUNzVGNqb2V0QWxJMUJONkNlNEdwc3R3VC9Tb0dTT0lXd3Y4QUdpb20vd0NINGlnWVVjYmszN1VDWmRiZk02MEVyMkdoMDdmR2dhaGVCSk5tR2dXZ1lQSFVpL2lhQVlsemV3QUhiUVdvQVg1ZWJhZ2sxbDBVWEkxK1ZBS2VKQmE5cUJNNVlnaTRONkNWbllYUFhhZ1RXdHFkZSsxQS9VTnJCanh2cVBHZ1J1ZVhKdGR0TmFDUTJIZmNlRkF6WUVnRzQ3MENDczNsdmNkZmxRQkE0aGRqMXRRQkZyaTF0aUFLQ1oxVTlRQnZiU2dRSkMvMDMyb0loMjMwMjdlTkJQemN0Q0MyK2xCWWhUa1M0NGpxTjZCZ3J5dUQ5SjBOQkdhUmp2cVRvZXQ3VVZBWEk4QnQ0VVJmR0VVYXRjOUQ0VVZXWE4rUlBsT3c2MFJDMXRmL0FNdEJhV0pzQVR4R3ZFZHFCTTl0QXUybXRBbEp0cUxlRkJKUnZlOSs5QWxGaGUrdlc5QkpaQndLMjF0NWlkdmxRUU5nU1JycFFUVndMMzA2TDM4YUJvNjM4d0JCR2cvMW9xSlBicm9UUkE0WFZWTjdhZkdnbWpoZEJwNEQrbEFtY0c5aHAzUFdpb0Mydmh2UkV1WUkxSko2Ny9oUVNLQXA1TC83aWY2VUVWTnZMMzAxN2VGQk45RkMyQUJOL0hUeG9xUVVjYlh0ZlVqcnBSRVc0V1d4SkhZOTZLanB2c1Awb2hvcGNXWGUrZ0c1b0pDeW0zSDRnN0Q1MERzRHRmVFdnSFZpTGhiTFFJaTZsbFcybnhvQlNBblRuY2FFZEtLUnUxejE2Q2lBVzJOeU8zYzBFb1FBU1dISmRRRjJvSmlieW5RRWJBZHFDbzI0bXgxb0lzVFlnL0sxQk5TcE50aURvUENnazdSQXNWQkE3bmNVRVFRUVNQeG9HcnFOYlhPbW0xQTFjV1BJMkExRzk2Q1NudU54MW9KV3UxbHRvTnFDdVJRQnRhKy9mOEtBSGxZWEduanRRU1ZvN2FwZTJ1bmVnZ0xNUjA4UGpRREtvYnlhc08yMUJaWUdBRW4vQUcyb0t4NVFPbmpRQzh2cTZYK3J4N1VBR091dXArVkJZdkIrSXZiamUxKy9hZ2t3NHFmSnJ1cE93dDRVRlFKWVdPcWphK2xxQ2RyQWtmOEEyTkJGRklISWFrV3ZmeG9KY1ZKMVlMNDY3MEVSNXJLdXB2WUVVQUEvTXFCY0RlMUFJRnN4WlFiYUFiVUVRUnkxL0tnSERYR2gxR2c2V29CMzVXQjFDaXdJMHY4QUdna0RzRHNkQ1RRU2w0S3dDbjhkNzBGUjB1RDRXb0pKb21sOWV1MmdvSTYzN2s5RFFUUjFXL085ckhpQjNvSEl5c1NWR2dBb0syY2xlT3ZIb0QwTkJsejNkSXh4ZmhjZ3MzZ05TUG5Rcm41R1o5eGorbUc0ekl3TGhmRTZXQnRlZ3B5Q01pSUp4RFJpMTIyTnRDUWFJeHh5akVrWU9mVGxZdHhhTWNyZ25SUTF1bEZkUDJtV1IzdjZxeWEza0ttOXpidlFkdFdHZ09sNkNNaWhXSVJ1V3R1UTBvRjVSWW0vaUIwb01udXhuKzNMd0ZtbFN4VURXNTZBK0ZCaHd2ZEpDeGl5UVE0L2UyZ050L3dvT2hMbEJZaElQT3R3Tk94TzlCY3NrVG9HUzF1dlhXZzVmdktyT3BhRGtjbkhzVUs3WE9tdEJ4Q2s3Um5MTmprTG8wVERrRDQ4ZjBvak5rWmNJU0dHN0hnT1pOdUxjU2JrQWlnbENJMXlIV2QybURJR2RWQUxXSXYxSXQ1ZEtLMVJ1bU1BME0zcWhCNWc1OHkzMUN2djAwQm9MSWNvWmNjdU9wQ0NRcUJHNXVMZGRTTjZJOUhocWVEYzNYa24xYWdXdnNCZWlyZVJIaUw2NmEwQ2QrSUpGd282R2c0c2pZNHlYa2lJTWJLUXlxTDJJMDI4YUNuSm1qaWdTT0kyZE9KUEVtd3QvbFF4SDNMRHlaTU5KNFpPVW5FZ2hkOVJ1U2FEQXVMTzhjVXNqdjZrTFhtSVpnZUNqU3dvaXFPZVplQ3l4QXhnM1VHNEpYdmZxMzYwSXR2SklKQ29SZlUrcFhDM1ZUY2txYjlSUWN5U0Y1ZVRSRlRjRGlIdUZWVHVlUFU2VVZqTW1WQWNZc0pFWlN5L3gzUTZhM0p0WVVSdnczeUpacGxSd0ZaVUxNcENCd3VvRERZMk5Cb2xNejVDdk1yY0xFTVZHdklpMXJIU3FOUTlMN0gwMUhGNzJMZzJKUFc2bnZVR1NQS2dqeG1pSTRqWDFKQlkrVzloWmQ3L0FBb01zM3VQS1JaWUdabzFVTndTNVVjdDJORlU1K1VNbkpaTWlOWloyMFhJRjBLSVJwMkIxOEtEWDdQT1ltYUlTYzVaRGRaazA1SDU5cUMvM1RDeVZFbXBXUmdwdm9wQkoxc2FJeWV0RkxhTUVlbW1qWEFQRVhGdHYzQTlhS3pyaFJwelF2NmdjaGtiNmJYMkY5MXVUYzFCdmYyZkxVLytaNlhvcVJ5eVZzWFVIeWl6azJiNWlpdVI3djdmS3JNOEsrdEdHQWpOZ3ZsdHRjYU1XTkRXUGhQSkpBcnhwRUhZeURqdkdxQzJpMzFIaFVHdFpwRnhYZ2phUnNkenpmUldCWVdIa0xhL0hXcWpmN2RrdzUwTWNFQ2lDWkxseWJyenVmM0MvVHZRUjk2aHhzZklqa2lsSGxzckFnM2JUZmUxcmlsVnpYYytuTHdqamRBYnlURkFwVmJmdHQzSnRVWFhHeTgvUFdNUVJ3RlNHSHFiam1wMVVsdjNDMjFSWGI5by93Q1RZMEdNc2VWRDY4bkVpTWtua0NkTFBmVStGVm16VmVkN2pqeU1DSVd4bmtBRTB3SmFOd1Q1ZlZRNldIU21yak5sWWlZYWVwa29reU1CNlVzWVpRT0p1TkR1VHVSUWN0cytSMVRGOVBuRk5yRkFzaFZ3bzh6S0dIOTMxV05SVi90L3RlYmt3Wk9TbVA2OFdDZ2VKRC9HNmc2ZWZ1RTNOQ3BTWjN1TXVLMks4Sm14c2cyblNUenlxemZUeFk2QUVqcFJNWjhSQkVrLzNIQlpvcmVtQ0dBUFMvSzJ2d05VMTBNai93QmhtNThXVWtVVU1qeGw4ZVBIc1l3a1F0eVVrN01CZjQwRytUMy9BTjFYQVNCNUpKc1VyNVVieXZvT1RzTzZqeG9raU9HbVJQZ2d3eXJKSGtNL294dUZNaUFhNm5RL0NrcTFoa2JNeHAvVW1oTThLa0dTSUFhS2QxRkF6bnp0bFJUWTdORkpJelI0ODhCVlNxQzFsdjM2RzlCMDhuMXNjd1pFdU9ja0FDUkptczdIVFVGZVIzb2tjM01rVEp6SkZ4OGRJQU9Ncng4U3FCajlTQUc1WFg1VUlKY2VIR2lkWG5oaXlpVmtpaFc0UnVRTjFFZ3NWdHVWNjFSbW5nd2NvdWdoaGptTEtza2l6T1lsYy9VK3ZmYzAweHg4akN5aklQYjJrL2tpODBjOE5yU0UzMUpPcDBzS3pXcFd6MjNHaXhZcjVPUWJ4U0F4eHkvOXU3YXR0VEIxc2ZLeFBWQmlaV2lsSDhnUVdDOFR1cE5CRE1ibmxXRjhXT1ZYOVdSTE9BcTZGdE85Tk1WWlBzK0RHWTQxOXdTVmdSNmR6eGlZazM1RmpvdSt0NkUxWERqUU96NE9YSkNrOGJjNHBJUUd1U2JjYjlRZWxxRDdBU0xHeDMxMDcxMGMwVk55YkVDM2ZUU2dDd3NkT3Vob0FHK2x2alVFMVlpNUpId3Foc3dJc0Z0M1BoOGFnSDQyRnh2MUhjVlZDY2lEcFlFWDcxQUFBZlVDV3RwMm9Kc3R0OUNPZzEzOGFDS0VnM0JHbXhvR3gwdmZVbmFnUElVR3V1MXVuNDBFbFMrbnkwN2VGQXlGQU43bjVVRWVUZkVkS0JBOUFPbXR1bEJKWC90RnVnRkF6NWphK3ZRMENBUEt3L0dna1dKTjkydnFhQmNiYWs2SDhmd29MSWlsanlKQStGNkNQSUN3dGUrdCt0QkpXVzRaaGU5d2RhQk1GSlBFV0FGaTI0UGpyUlJ6ZFJZYUwwTnFJamZYWFEwRWdEWUVEeHRRU1hpRnNEcVR0YjlLQXNDVGNudDhLQitCMTZhZEJRRmdXQVUvbHJRUjEvYnFMVUZpazNGenRycnRRSXFvWTg5Q1JlZ0ZVRmQ5VFFCQXY5VjdqcDRVRmpDWUtMamlHR2w5T1h3b3FDdXdiZTlqcmVpQXNMOUwzK1ZGQkkzR3R1bEVHZzYySTE4ZkdnUEtQRysxQUlMNlgzK3J0UU5XVmJnNjlWSGVnRnVia0M1SDVVVks0TmdCYSs0R240VVEzS2tBS0I0blhXZ2twS2Z0QnZ2ZmEzalFSZHl5Z0JnQVNiSUIrZDZCS21nTnpyc2FDeDFDaSs1NjlyMEVGWGlkZFR4Tmh2dlFGeWJra254M29BQTZzN2FucnVTZkdnTGdMcXV0L3E4S0NKYm13MHQzQTZDZ21oVUc5dEJvTGFHZ2tRZGJFZ0h4NjBBcFZXR3R3TnlLQ1RURXFGRzE5RHZRUVFzT3Vnb0dXc0NCMTYwQ0RrV3RzTnY5YUJpd055ZVhXdzc5cUJ1N0ZtZEJaUU5SMEYvalJWWWJTeEY3OVIvV2lKM1hRRWkrdGdLS0hDZ2pTL2NpaUlhRStVL0MxQkt6S0FXRzUxSjdVRW1DbFRJTEFmaFFRSklzeE9wTjZCdTNKamI4dEJlZ3NSMVpDQzFtWDZldHlUUUJCdVQrQkhqUUJmakh4S1hKMVVrZEtDQTVGU2R3T2xCWnkyS2dIeTNQYTFBZ1FSeEp0NDBBbnBYMXZyMUZCRnVLdVIwQi9LZ2l6Y2lBTlYvYVA4cUNVWUp2WmZpVHRRSitKRjFQeEcrbEJOVjVLVGZZM3ZzZkNnZzhqTnVkQitHbEFYdUxodDlCMC9HZ3NCS0VxM203Y1RwUVFCSVlIUUh1ZWxCTVBkYjNGem9TZW55b0lCN2N1T3gzUGEzYWdRSkF2YzM2VUVoSUJwYzhiV1BZMEVTTGt0c0JZQ2daNUZRRFlXdmM5NkJrYUMyLzlLQ2NVWWs1QzJwR2xqYjlhQ3VSVkJzTmRLQ3ZZMEUxbE9pbjZSdjJGQTVDbjdXTDZhL0h0UUpGVWtBbXdPL1dnRzRCeUFwc2RCZnBRSjBaQjVoWW5mdlFacytMMW83SnB4OHhCOEtGano4K1Zqckl4SUxaVHR4OU94QlFiaGlmNlZXV2haamtJVEdSR0RjcWhGdVZ0RHFhS3BqdzNlQjI1ajBsdVVVZ2tDNCttL1ExQ0xmWkhXQ2FZT2dVc0xyeHN0ejFBQTdkYUR2b3l2WTN0Zlg0V29vTEZ2Nm1nbkhkbkFHN0cydmFnSkRZOE9JREtiRndiMy82VUdETHdjYmc4cXgrcktUOU8raDN0Mm9NRXlpREdpeGp5ajVOeTUzc0I0R2lXcExuZmJRK2p4S012MXNRU2dKM3VhS3pUWnVVa01qRCtFai9BTE45V04rL1RlcWpGSms1eG5XU01TUnJFclJ5U2FGM1lqazF3TkxmMHFLNWNMc3ordHhlYVZRUnhGbFV1ZjNGejJ0ZXdvam9UUExrai95OGFNU0Jid3JBQkhJcnVMRzVHNFplOUZjMTRvc0I0cGd4TWtZdkdrbWdBSkJ0YnZmZS9TaU92alpPUmxacVNHSUVYQWtWQUFBMXQvd29ydndZVUtUTmthbG1BOHI2MnQyb05uTVIrWm1DZ0M5NkRsKzhlNGtxcVhEcklRV0YrSUlKdHVOdmxSTmNSUGNYVEtScFlUazQ3Z2prRklDalVDN2YzVUVZOG5HQk1nY3FITmpIZFMvbE55YjBHdzVrckluQmpJZEFpMnNMWDFIYlNxRytYOTI0V0ZWaW1JSXNoOHAxQTVFdHNCVUdhZkl4bnZqdGpTTm5GdUt5bHdZdVpOZ2JEYlhhZzUrVGx6NUR4WXVRQWh4WkNaR0MydXE3K29BTDNKb0NWNDFKV0Jyc1M0OUJRZVJRZlM5emJxYmNkNkJSNW1mbHZOSEk3TmpyR2dra2NLR1psMEJ2YmNiVzdiMEhSd292YjRGTVdRNnZreGtlb1lyTWdYOXR1TzdHOUNwNU9YaExFd0NCd0xjQ3hPblEyN0hyVkdEUHpKdlVnTWhFZ01ZQ3BHQ1hUVTNWOVBxT2hxRElzZjNNNGhqallTZ0Z5RjFEMkY3dVNmcStGRmMvbkg3VzZ2RVR4akhCK0FOaUw4bEduUzlCc205MHhzcFRKS29lWnJBUzgxQlVrN0VkUlRURXNkNDQ1WkhWdUFRZ296ZlVBQ09uYndvanB6WlpuamN5eTJtdTNHUGlMTXRyZzh1bHhSVktUZWw2VWsrTUlzVk5JVUtqaXhiWHpOb1NEUU5Kc2ZKeVBVYmlqbXlvQU9NY1p2WWppTDg3ZEtDajNMSDl3Z1ZZaEg2dU81SXhYMXU1RytuWTBJeGwyeG9QVWh5RllwcTBWMjA1SGlSeGJTL3c2VkZZdzByWlNCUFRpRndmT2JLeEkralhRRTBFWWNMM0dPRTVjY2FReEt6Y2pKNWdIR29DOUR5M3FvdVRJbG1QS09GVW1oMWt5QXplZSt2Rk9tdCtsUVp2Y2MyUitNWUk0SUFTclhibWYycXBBdUxkYWxha1V4eXRCRTBna01UWlZtangyY01BRXZ5NWVYUzUydlVWYzUrNXhCanZORDZqY09MMllhc2VQRlQyWGJYU3FqUjdoN2FRdDdSZ294aU9SR2RMcnBma0Q1bXYzb2pJSGtWR2htbjVOSUI2aVA1aVhTL0VtM1JlbFV3UGc0V2JqSEpYTkx6Skh3OURKY0tHWURkQ3ZVRVZGWmN2MjNIejhKWFpWOXRuaVZTaGRyTElFMjlLdzNiZHRhSFMzSGhlZDBSOHFKbUEvd0RMbERyb2gxdW9rQ2psZW90UDdXUk12SG1YMG5MM1dXSjcyVUQ2QVJmOXcxcTFJdmIzZVZwSlRqNE1jU1N4c2pJWnhJZE4xQ09DZUo2Q2hqbit2aFBHNnhSUzQ4d2NFS0xrbHVOZ2dWdFFPdERWUHVJaWxma1pKRUVnNEZIQjBJR280N2k1MjcwSXN4UGR2YzhDSXRIRU9DT0luTDNCdW92eUlZQWh2eXFMY3JvNFAzbi9BQ0psWEhrV01FaGdIa1RtTGpVbGRDUnB0VlN6SEx5OGFiSHlwSTNmaE1wWXZ6UUJTYjI4b0h3MHBTVnZ4TXBXajVUVHdKQkFwdno1V2NmMnFkQ1dvbGpOenlUaXZrWWZtamNpT2VTVWdnY2gzMUl0M291T1RNWmtBKzZrNUJBVWdtQUx0NmhOaUc0N2hRZEtLNk0rQkhCaDQ4MkprcGxLVHhZb2pSVFJnbTNFaGhacm5yUklvR05sZXRQUEpDN0ZReXZ6Ymp3NGk0UGwxMm9NeHlqS3ZyZmFNUXlsSTBaMklpTEVhaXdGL2dhaXgxOEgzRnNpYmdjVk1kQ2dXTkVVM2EzYmx2UVJ6Y0ZFa0NZcU5NRklkaU5EeUcrKzN3TlhFMWI3Um1lMEQzTUtYTHdhY1Jrb1FwYStnWUxyNVQycUxkeEROYkp5TXFUTTl0Z2p4WkZaMHUxbUp1TnhjYm50VlRwOWFhMXJuUm0vU3RzbFlXSUlCSjJORU1GZ0xqUTBDQTA1YTJ2cGVvcVZqYlg4NkE0MkF1Tk92YjQwQjFPaEZnTFZVSEU4dXZqNFVVd05kZGRkYkdvRmV4N1gyb0plbVFwSnRZYjBBMnQ3RUVYMG9HRlZkN1g2bm9QbFFNU01EY0RiUzlBN2tubC9kc08vL1NnQWxqdDB2YWdURWcyc2RkQlFOVGJXMm5TLzlhQnN5a2ZEOHFCOHg5SStuY0VqVzlxQUlLa05zVHIzSDRVRVNTN2N0NzdVRXh1VGJYVFUwQ0pKYTIvK085QkpsOHZsQUhTd3VkcUJIUTZOZnZRSVhKMUcvVGFna2IzdGNYMjE2VUMrUktqV2dzUjdvUVJhMmluL0FEb0kyWGhycjRDZ1BNMWgrRjZLRkpEa0FYNmFVUkk4QnFQcTI0MER2eHRjZkFVRWtaZUpackhzRFFSYVM1MjAvdS8wb0Z4UElLZEEyZ043YjdYb0plWW9HWW5pTkI0VUViV0ZnUEhhZ1NrV0pJUEx2NDBFdlVIRWhoZi9BQ29BbTZsYjJ2MEZBZWEvaFFTVUx4QS9kdVQwb0kyc2VSRit3b0p4dUJZMko2RFdnWmRTeHNMOUJmU2dFUWxpYml3OGREUURUY2ZwMHZvZE5RS0NISlNkZmxiK3RCTk5UY1dCN1VFck8xZ3RpQ2JiL3dDTktDWVh6aGpxdXdZMjZVRVpiQzRRV3VkUnZRUXNxMkd4M0pvSnhLb3Q2bWd0cmJjOXFDRmpmU2dreERXRnRlaCtGQUNSUmNuZWdnekRwb3ZRR2drQ3czMERVRmtiSUZ1VGM3QWEyMW9HYkVlVW13b0ZJQllYMEE2aWdpakxjYUFrNmE2QzFCRmlRektTTGZsUlRRY2w0OS84YjBSS1ZYU3dKQjB2NDBFR2ErMnQrbEF3eERCZ05SMXZRU3VnOHh1ekQ4TDBDTEtTZTF0UENnVjdIVUFiNm5yUU1FS05GdUxXNUdnQVhON1dBdDBHOUZKWGNLUVRvZEtJdUFqTDhXZlFEcnJhZ2dBUWJyc1AzZUI2VVVNR0FBK2V1NHRSRW4rbENGQUo2amVnZ3FncnZyMjYwQmF3dUJwUU5wU1NCOWZFQUE3YVVCeVRoeE45VzErQm9BNmtBYkxvWEhYeG9FYmNiYUEvamVnV3Z4OExiVUJ4T3JkUEh2NFVGckx4Ymd4NDI2M3VEcGZXMUFPUTRIN2JEWURlZ1RTY2xBQ2dXQnVmNjBGWVBIeTNzQ2IyMzEyb0d5MlhVM3ZzS0JtNEhCU0NEdmNVRUNGMEZ3UEdnbkpEeEE0K1k3a2czM29HTGlNVzJ2YS9qMm9Fb2NIa05RdlVVRU9WenFMbm9hQWNtNEp0Zng3MERzZVBMVzRPM3pvSWdqWC9BQnJRT09SbEJGdksyNHRRUHpXUFhzMitvb0V4QmJYWWR6Yy9LZ3p5NWtjVnkrcTMxc05iK0pvT1A3aEJFMllaa3lBaGU1OU0ySVp3TkZ0MDhUUVlwdmRNMWlaK0gwRGpkdFFVMHVvc0tJY2Z1TURZN082UEcwclhRWE4ydnRWRXBaQXM2ZXE1TVVRRExJb3Z4SlAwc2ZqdlVIbzhTVkRpcWJIbWRRZExXTkZYS3RpTGk2blVnYjJvQjNRMzRqeTlqdlFLd0JKNWdnYTNCMDE2R2dpcThoZnQrRkJtOXlJaXhXYVNMbjFDSHhvUE1Ucks4M0I3a2czU081MnRlekhxd3FvR215WlkrRTBnVmVYUFVuaW8yc1NmR29yTzJTRmluaFdPMHBaYkVsdnA4ZW11bHpSTlpuQlVMREdHV0tWZ0hIMGg1QnZ4dUxsTGQ2RHF3UnBrUittajJraUZnbjdtdnJvZXRoUVpKb3NjWllmSVY1WTBzV0Z1UlVFZWF4L1VHZ21tZkZqdEZMRGNZc1pJRFNMclltK3R1L1NoSGV4dmNRWXhMSis4L1NEZXk5eDRVWFhRYmdjY3NUZFNMNmR0NkR5T1hEZVFna3h4eXVmVG1aeFlLTmVKQTJOVkdFeHV6U3dxOGtjTEFTTEdqRWN5cDB0M3Z2VUU4V1htNVRpSG1COVdNa0tGTnZIdU8xRmJvNC9jSjVBMGhLeHZwTEZjS29PNmdXNjJvaW1kbkdRMk8wdmx2YzhsSVFqb3BKc2JVVm1tanl6a0ovTDZZUStvWEZpK2dJM1hRVytGRVo4YkdoQmtsblBOcFNmTUNRektObU92STYwR25IbFJSYkk5UlZSUUlKU3BZcWI3TmJwUlNWY2NSU0EzbEVadjZ1NmdYdWJnK1lFbWlIN2puUXhReHo0VUlTVXNHOUpWNGtnTHJZYmE5NkNOczZmRy93RFlTcXk0bzRnVEZSNVNQcFZyRzlCWjdlYzdrcjM1Z09KWkNoczU2RUM5TlhFTS9Ieklwa21sdzd3S3JBeHVTQ2Q3WElJMm9SWEg3Zmo1ZkNWdWFCN0k0VzdCRGUzR3cxMHZlZ285MC80eml4enlDR1g3dEVBS01oc1NBTlI1dUpHcHZRam40MG1LR1QxQXhXTzNPTmp1UWJHemR0cUR1UjVNTWNGMzNjbVhpOXVKNUN3QThLQ1R0SFBpZ3lUOGpBMml1eHNWdHA2YW54b01za2thOCtUS3BKdXZEUnIydjFGalF4Q0NZeXA5dm1JWldTMFVUY3loUU9kdGZIdnRVWEZZOXd4TWFLWEhSSTVGUmZUYmhyNWgvYklCNXRkOUtJZUxOSGwrbEw2clFUUmtzZ2tVU1FqZ05WZExYWWh1OUZVSmx5UUZ2Vmhqek9ZUEYxNWVrbHpZMmpOdGRhSXE5cjl3blZvNDR6RklESXdFY2dCQzMxSkliVHBSV3YzQlpNMlAxb3AwR3lsVkFVRk5qWlJhOUNPTms0T0xod1NCWjRwM1BGWXlTNG1JWFU2blRYclVYVGVBek9nVm1WQW9MUnV3WlVzQTNsSytPdERGdnFab3hNbVhGbVdUVUNXL0VtUlcwdWk5WDZrMExFUUJKaitqY1h4d1JHU3ZHNWtGd0hiVStZankwRXNhVDNaWWVNdUxHaVNEaW85TlI2dkRSZ3dBdXAvdWJyUVpreHBwWnZYeEM3a1hXUkxXUUxzQWdOOUxhVUVQY3NITXlKZlFLSUV4TFA2TUhFc3l2WXUxL3dCM2pSWXRTREhqUXJHc3ZGbTVSeUl5cHhDcVBwRGRSMkpvakxsQVN5NGtPUWhUMGZORW9Rckl5alZTeDdtK2xSVitDZmRlTXNDMnlGaGIxQThsbWYwd2JqK1RRM0hZYjFVUU9QQmtTNU0yVkpNdVNDZlM1b3pYWW5TemZ0WlQzb1JuOXdtbFFaQy9jVEhLZGdGa2F5cVJzM2sxMStkcWlqMk9TVDJ1VXVzYXl3WktFV2xqREFOMWJsdXBIY1VoOWM4REw5eVhLeDI1bzR5QWI4Q1Y0Y1ZOZ2VSODM5S0NqMi9Jd0pDUzhqRlZMRGdnVmVIL0FNdVhsL0NyS1dWZGhSNStGa3JtSXF5UTVBWlJqODI0bFZPNTZINFVTMWJtZTdwbFFJOE9FK0k4WlBxeVJGU0gxdUNWMDIyRkNRUis2NUV2L2p5UXh0ajQ0OVdKdFVKTGFrOXpmdFFhNGY4QWtudHZxRlBzMXhIbktreWtOSThjWUd2QjlmS2ZFVU1RWDIvRG10eHpMNHdVaUdZTUFUZHJlYlFiYjBOVlNZclI1RWZxU0JsRnZVVWIyQjNRL25URFhRaHpNVVFCSURLa3B2empESVF3dmZlMTcvRTBSaldEQ2RtZVNSc2ZMNUhncFErb1d0ZGJxTkxHaTFkTjdyRFBDNyttejVjVExxcE1mbUlzU3lONWdUUk1mVldjWEZocU5OZXRhUkVoU2RkTzRBMm9oOGR0dVd3RlVQaHhCOHdJNmVOQkpuOG9ETm9Cb0JydlVVSXJ2Y0xyYnpINFVFYkMvaDBBcW9YbXVRTlIxTzlSUllXRFhKTjl2NjBEVWtHL1hhMXFDZWx0TnV2WFdnc1c5dEZ2ZmMvT2dpK3EzQkE3Q2dnQVNMOU9oTkF3ZFJicFFTVmdMTUNiNzNOQUV0MzIxMC9XZ1FJdVFRYmRLQXRlOXp0dDIvR2daNmx0em9SM29HeXNmTnFBUnByUUlpM0c0c1FOYlVGcU1SR2V4MEk2bWlxd1NUWWFFVVJJRWh1TEhqL1NnbDViOUNQNjBDWGtEY20xdGpRTnp5RjJ2NGswVWZ0K20vaUtJQ2JKc05UYjRXN1VDQkFVbGg4T2x2R2dGRE5ZV3RRV3JHOTc2OTc5cUJtUG91ck1kTzlCWHFDQmY1VURJNm5jZmxRQlZlUXVTRjduVW1pa0F6dFlEZnAzOEtJc2REWXR0WThTdC93b3FCREFkcm05dmhSQ0hXM1hyUU5UYzJKL0Nna09JVzI1T2dQWTBGa1hBR3pEeS8zZGJlTkJHWGpmeTdEOGFDVVZ5Q2JhZ2IrRkZSNEVqeW05dEFEb0tCY0hWZ0RjRWJYNlVCNGRkdkdpRnhMQWtHeEF2UUFCdGJwMytOQmFCcUdieTdmNEZCSkhCVTdOeDFBSnRyUUsrdGlMa0hwdHIxb0d4dVR5K1FvcW5aZC9EOGFJc0F0c045aFFTNFdheEZtQm9CaDVibnIrRkJBOGlkOUxhRTdDZ2kzQTIxTjdEUTkrdHFBSEppQWQrL2hRV1JxV3RZZ0RYZWdrWEZ1S2kzVWcvblFRYTlpUlFPSmtDa3RjT2ZwRnQ3OTZDSVhrVHI1ZExYTnIwRWxYaUNRZFIxdGUxQWd4SkFiNmQ3MEF6S1Q1UllFOWFDZmx2ZGREMUg2MFVaTFFzdzlGU3EyRndUMW9LMUpVQ3hzVG9PdEVTczRZMzMvY1Q0OXFCdGJsbzNXMS9qUUhPMnc3NjJvRW5Fa0EzRmhxQjNvb1Z5RGNqVWY0TjZJYVBaYkVkYjMvQUtVRTVCcGYvQW9JRi9MYnQwNjJOQURrVG9MVzM4S0JnRWp5Njh1bitWQWNlSnNkTnZ3b0JDbC9NYnFUcUJ2YWd0RHBGSVVYem9ldXRCVXpLSFBIVUhhZ2tyTVdON0FtZ2dBM0k2MlVhMm9HTkNCdU4rTkJaS1d2dFlNTmJkYUNzZ0JRUWJIcFFEY3lQTUxLQUMxaHByb0RRRzZnZDl1NG9CeFluVFhTeDdkNzBFU0NQZ2RUYldndERxakFLbzQyODE5ZW5hZ3FVZ0EydUdJdDh1MUF5N2hBbDlCcHJ0UVI1QUpZRHhCb0dRNDMxN1dvR1gzQmZRV0Mzb0ZJUUJwWmY3aDJvS2ttYU9WaDlKaklHdmo4YUMwc3BXMm9ONzNPMUFtTE1mTiswV0hUU2c0L3VhWTNDV09PVmttQlVCZVZ0U2RCZnNlOVZLNU1pc3J4UnlSaEdsQlU3OCtRMkxIcjJINTBHQ1RJek1hUElqRmxqa0E5TkNBeElIUUwxWCs3eHFDV0djZWRGV1IzaW1XNVNNZ2xEeEhsc0JianIwTkJlV2x5WjF0R1JqaEhhUzlrcy9Ua2RpYi9BTGFEbzRtZE0waDllUXhBY2VFUFhYNlFUUWQ2TjNkTDNCSTBZanhvcXdNV04yRjdEZnBRWmM1cERDd2pqdnkzSTJIeG9WaGl6eEF6cTduaW1ycTFoWTI2VzZVUlI3djdqSFBqSjZibmttb0IxMDZqU2c0c2t3UmpsUUxaMFlvcWxXNDZqZS9hMzUwRVF4Zkw5YVpVeU1lSlY1eHluZ0dVNmVVQTN1Q2FEWDdxTWNyRlBFRlNKeHhuSmJ5Z2pZQWo4YW9xbmt1b2loeXZ1WXdyVFk5dklFRnZPMXpyWWRxZzErMkxCa1F5U3Z4UzNuVkFiZlNMM0MzdjhLQ3A1MVZKaWtiUGNnZ1d1cmFnRld2b0xqclZOWWNoRUVieVNjdjVTR2VKYmh5eXZ1QUFSb0RwK05RYU1MTXhJNUxCM3RadVJZRm1EM3Y2WStYV2l1OUQ3Z1dKOVJlQ1g0bTE3WDdYb09abng0azdJSVkxU1NSdEFGTE5wK1ZFeFMySTRuRWl1aXVlV2dPZ1lqUTM2V29xaUtQTHgxbFhJeHhJSEhKU1JmVytsaU85QnJ3NWNZUnFtWTdDVlZiZy9IWFhYMDIzMEhTZ3haWEJzYVZqTjZnY0FzbkhWQ3B1Ty9Jbncyb01lTkhLVVVGVEEwNEVrcngvVVltQlVzM1phQWd4c0tKV0JsQWlSSEN6U294QkJheGFQdHhvaStJeHVxNFRPeUVPQkhKSmNvNDNEQWJpOUZFd2ltZ2tTYVQwUWwvTndQbVpEOUo4VzZVTEVZV1JzbUtBS3lvSVM3a0Q2ZkJiZGV3b2llYk5pbDR5blBqSjVuNWdDeldzTGdhV0FvSTVrZ3hGaWt4RTR5QWN5cTZzQVBBYU5yUlZVK2ZQN3BPdVJMNXlFQlJsWUlTVk80dlliOURRVGdqa2t5bmtneVN3bmZsTEFoSVZTdXdjalFtL2FnWHUySklKNDUzaWxlSnJzVnVRZWVtZ091bENNQ1E1T05rbUFTOGNkbUJZcW5xS3JIVFc0dUQwb04zdUViUEswRVVhcmRoNnFNQllzbzBFWjZFV29LcEk4Tmd6Y3hLa290Q3BIOGpHNDVIUStXb3F0WUxGa0pVUjM1TjFOaHBzZXRCYm13SmdpUE85dmYxRzI0eXFHSlZoNTdYTmh4OFJWUndNbU9XWm1sZkk0ODJKc0ZJWGlpMzRBRGZlb3JWaDVVV0xueFplV0RsUmxTWm83dEF3SkcrL2hWU3RVUHZVVFk4OGVUaUpJMGdKeGNoOUdSeFlrcVFkTjZsV01TL2NObEpqeU1rN3l1SW9abUloQUJGd1BPQmEydG1xS0RpelllUVZ6WFlZaEoxVWpraEhVa2FhOTZJam5oK2FzSXhrUVNDeU1DQzRRbmRsNy9DaXh5NDg0WXM3bkY5UElpY0FReHpOWmxZaXhkazZqVTFGd2ptNWtmdUF5bzJ4NUJDNHRFaWNvd29QRTNqT2hEYjBwSTZFbU55ZU9RY0Rqemt1c3lMWlZhL0lwYmV5N0NyckxzWjJOT29qZTZ3VGNoZVlNd091dXU5aGFxUm5oOTBqd1lKa1p2Ujl3ZFJHdUtpTXZOVHJ6QU9oRlFZcHA0MmFCb21TU1Z3RWJpZVhDNStralE2Q2l4ME1QRWpsZ2tVS3JHNU1qaFRxZHJrZEtSSzVtWkZCajVIcFpITkVrWlZpY1A2aVJ1U1BQY0c5clVYV0xKOTN5UWhpeU12MG5CTWlUVzVJNnFUd0FBMm9xckd5cERPbVBEbFBqemx5VG52NW8zV1FBaHBOd0xhMjBxR05rcGlFaGh5c3BwOFdGZUVPU0J6QllIYmtCcW54cW92VDMvRzlPYkNTRU1XQVVSQmJnNi90c0xudWFIOGw3cDdBdVJGQkFFNFNNUElBR0RNVytqY2JDcWtyazVXUE5pUEhqNXNmcnd5TUpXaGpzRkJGbEd2N2RxeTFMcmZoNEV2cHpOZ1kweTQ1Sk9TT1kxNGk2cUdZZlY0VlpFK3F6UUxNK2RQaVJ5QkRLd3NKU3FLZ0hudUhPbEJkTm5SdG5JZU0zcnh2eHk4aVJRNmdLTndvRnJBOXFDa3dqN2hDc1FqQUg4Z2lOMWJyZnVPVkIwWXYvVXpSUVk4cm5IbHVSTTdvUzBhbXhRTVRwWnZ5b004OGJGakNnQ0NNSGxNQmZpdlFQYjhxQnlZbVBGanB5eWdZSHVWNmdQYlMvd0FhQ3pIekkvY3NhTmN0MWp5WW0vOEFFbllLa1laUnI2bGh5WmpVbEw4L2hqTStTSkJKbXpSU3d1Qkh4aFllb2JHNHZ1VGJyZXF1UHJ5c29CdWJIcGIrdGFZSEk5ZGZHcWlSSVlkdW9BcUtSQkExQjhLSVlLQmJuUnVvb3F3U3NxRk43K0ZCRGlUYzZVQmF3L3lvR3ErVzk3aHVuVVVCeHRlKy9qUUw1MEZtbGlRYmRDQlFSTmpmU3d0UU1FY2VwSTFDOVBqUUlHL1c5OVNLQ1dvRzFpZDZCZ0M1dVR0cFlVRTM0bEFBTE5iZWdTMjQzYmJiajFQalFNcm94VmIyNjZuOWFCSmNFRVdIeDJvSTNISTMzL1dnbXlncm9ibnNPbEFSc1VZTUJjZzBDSElzWDF1ZC9uUUFZalRXM2J4b0dMbGI5UWZwL3JRUFZtRmdiZUZGV3JJaXJkUnIvanBSRlpjazdiNmtVQ0Iwc0JjamY0VUVsZU1XdUxnYmpxYUNZbWZsY2JOc0I0VUNhUXRlMzFXL0tnWHFHMWw4dDdYNy93Q0RRRnJ0eFhYVWVZNmZqUlVuSEU2a2xqdmIvRzFFUlVBMzZiOGJkNkM2NENnWENrRFN3dVNhQ29XTit0RlMyVzFod0cvem9pSU9tcHNPL1g1VUUxREVnalFlSFdnWE1xU1BwdlFJdGU1WTN1TDI4ZkNpbXBOZ0FiTHZlZ2ZKcjZuVWE2amFpRzBqRThtUEp2eDBIZWdpQ1B5MzYvbFFTaVZpckZkRkExK2RBaTJvRnRiN2c2VUVkZmdlM2hRV1JYVzViWGJ5bnJRU0xFbmtMQWRodHJRUkpQWDRhMEF2MGx0TlBtTDBDRXNnc1ZKRFdzVC9BSzBVMmthd0pia0w3ZGFJZk1tM0lEaURxZkdnbVhYZ2JiN0VEYTFCSFJnb0EwSDFIclFIQUR5LzFvSmhRQVNONzJOQkdZM3RaU0JmVFdpb2dEbzF5YUlDYjNVSFVDMTZDUVJqYjZkUnA4cUJxUnhzeDRxZFRwZmJiU2dHS0lvOHBMSGUvVDVVRVdlNENnWE45ZWxBMEM4eUQ5T3R5S0NhK25jc2JLQnNoNjZVVkhrakhYeXIyL3BSQ1Z2VFBLL0lmMm5YWHhvSW8zbnVRTGRmalFWelRvRWV4RFBHYnZiYXgxMitGQlhpWmhuRFhVaTF0VDQ3SDQwRjVGenBxZXRCTXNvTnJXTzJ0QWVveEJqNWVVN2pyUU1sTG5rTDlBQnA4S0NQQnVPZ3VMMjhUUUFQN1JvMndId29KZVU2M053TlFkcUJBZ0VjTzJwb0dTNVBNNzZmR2dKRGU0UDFBNm54b0phQTZIcFluZlNnaVN6TGNpNTduZTFBcmxtWndiOVQyQm9HekFSaXpjbUorbnFLQ0tPU0FvMUIySi9wUU5oZmJmcUtDY1paRzQ3c05kTlRRS1IrVFhzZUs2Y2hwclFRUjB2ZFdETU5HOE5LQ3dTSnhLOFBNYkM5NkN0NU9WMlpkU2RDS0FkWHNwWTZFYUdnbTBRU0lTTXltK3libjhxQ21PUUdSZ05XU3hOajBPMUJKbkRzU2JMWWJDZ3k1azU0dkZHdk53QXlqeHYxb01LeVhrbHlPRWtrZ3Vxb0NiQWtmVWFxYTZlTk53Z1F6MkRrQUJlbkk2VkZYQmxZRUE3ZFA5S0R6UHV1VGp5VGVyQ3hTWldaWHNMcVNCYXpYMDBxb2VMREpOaTJaZy9sRFJQcmNucVBnT2xRWjJTQmVmR1VvektCSzNHL3BoVGJRdGNtd045S294eHRFM0FPZFlqd2E5dzdhSGd6S054dFVBa3lEVnBqSjZLaG1BSThyRnZwSFUrRit0VWJwWThTRm9wVWtKMS9raWE5d1NMMnYzMW9QUVlicStPcklBT1hZYVc3MUZYOGxCdTI0L2JRUm1ZTkd3VmQ5aGZlZzhyazRzalNnR3hEOHVOaGNsUmZrb0hVOWJWV1ZlTzBabFNIRmw5TmxVbVJpQ0pWTnRtdWRnT3RSVXNLWExhTjRSTXZwalNSN0FNdkp2TmRUb1JyclFacE1YTHhzZ3pTdjZnc3NjTWdWUUZER3pXLzNXMnRWREdUaExPVmhSdnRZRjVjUXArallnWDFCTGFjcWd4ZXI3WkptQ1lob29vRk5vR1BJV2IvQVBEc09nNjBHdjI4UXo1SmJ5aG1XeEljcXA4MWdRU0NEcHYyb3JYbDVFMFdTcGxqVitUbEpraUJzcUFkR0hsSTBvaWVWN2g3V1VhTXh5TjZhTWNZS0xCVDJmWHkzNlVNY3lEMW1lS1NOUUhCTVRKWStZbld3WTdNdDZwcnFZdktPL3JGWTQxQUJVMzEzdWFnbk5sNGNlQk1ZWVdVRFF6RVd0Zng2ZktxTUx2NnFRelNXOUZRVkVhbXhMWDJKK0F2VUVubGFXUDBublZFNU15ckp5c3B0Y0ZhS0ZnbWlpKzRTTDB5UUNXTnBKUFU3cGZRZzlSUVo4dWJQV1NScEU5Ykk1RjNnS0JBbksybzQyNHNCdDBORVo4RjVXelRCRkd5RmJIbEY1dHhzemJFMjNBb05XWjdibEZnckFLak5jcVZzbzQ2Z2hyOWV0QlhrZTNaalNsRXRKRnhVd09QS1R5T3R2QUdnbjdsblo3eVJSekVLY2UraXB4UWdlVXNlNW9yTERtU1JaUm05Y3crbUxSTU5GVmJYMStQNTBFVjl3eWN1Wm9JWTRZcEZVZytvYkN3dnlJUDl4b002UzVJalk0aXlyRTBnSlptWDZsLy9XVzErSEdnMzR1TGp3WTc1RFdlTWdXNDhUdnI1bHYzb1ZQMm5OeHNPTWtxeVJ5dGNrZzhlUStvY3JiVVJ2bDkwaXlvblJTcnFMY3JIdHNhTEdHSDIzS25CYkFaU3lIMUpRVzFhM1hYWFNneTVrV1NWLzhBUGg5YjFuNXhla1JwcHBlM2VnZ0lJSERUSkVpcW1oWjNLRlFSOUFBT3V0UmVrWlZ5bXM4dVI2a0VTb0VaUmU2WHZ4WWp6YWY3dGFJMSsrd05qQVplSWtZVEpRTEhDcmgvTmEvbUI3NzFVY0lMRGo1QWFWWlRLV1c4TEhqZG1Hb1pmMmp4b3BwLzYvSXpaMXlDVVp2cDE1SkdPV28xQk9sanJSUEYvd0J2N1cwY3NFTW5xWkV6V0lZSDBiVzBJWWZuVVdPVVo0OGtwRE1Td2c1UkNWRjlRTWIzL2R0WWRLalRYaDU2UlA2TXNabHdiK2sweWppR2M3QTN2dGZXaFpXdjNESlpZOFgydGdCSGpPUTJRQkdUNElISG1JNzBJNDAvdEdRcVNDUW8yUkZ5YTNFRzVCNURnZERxT3BwaEt4VGllU2FQTE1CQ3F5dkxHbjFKYlZRb0ZnZGQ3MUZ4T0pzdjdyN2FTTWtYdTdJU3FwcHoyUGxONzJIVVVIYXpZRG5ZNmpCa2ttUHBsbVYyREVFR3pEeW02ajQxV2VuSWl6Y3VaNDhYS3lHWEtnZmpCa1pKSkNJMzdMTmNLQnZSck1LYkN4VXlRY1NmMVdqNHltZU5oWUFpM0VENDBUV3RNMzNGSURKZEZBWFVNQ0hKSU43a0VnMnRwUWpaUERnSDJ0WXMzSGIxc2dxMFdjR3NvdnEzOGVqYWR4U0plM0p3c1NPUE9SOGFTUEtFa3BpV0tWUXlGRkY5ZVhScU5hN0Uvc1RZWEZzbFVFV1FDMFRTcjVMZERaVHBZbXdvanBUU3dwN0NjZkhsS29nS3lEMFU5TmlScjUvcXRSUFhrWW8wRVVoa0RLV0hISFpMTVVEMnRmWnFOT24vQU93bGx4UUpQY1hmN05CNldQTVcwZGR2VGNEeCtrMFRGR0xnZmN4aVpWTXpaSE1TSWY0MUFIbUpWejEwM29OLy9IWUpIYUpvc3RVS1RCVXhKcnNDNzZXWlQ5UnNMRTFXYTVQdkw1RVh1WWVTS0ZvbFlyd1ZRRmVOU2I2L0tsWDVYNCtURm5RcWc5UEZKSEdPRnJxbzVEbHlKNjFGZExEbndzWERDSXltUmx0TERJckZ1TGFLeUU2Zk1VUmw5N2s5c1NPT1VLc2dhejVBUncxOUxEVWJOM3FrS0RHZ25qR1o3ZTBXUElRMHM0bWt0R3liQUtwK0dnNjFGNmMxNHhrTW1NQzdZcElrbEE1RXBjM1kySUhFWDBvTFBjaDdmaHo0OEJ4bVZYQW1XVmovQUJ1TDJEQkRyK05Ta2RqMnIyRDJ6TXdwSnVMK3RmMVpFU01LcXF4MEt5RWppS1JiWDBiYmY4KzFiWVNVa0tTTEwzdHVLb0NRTGc3blkrRkVKaVJvV3VPNDFxS0FuR3pXMzB2UkVqYTR0clJWZ0tMOUJ2M0oyRisxNkNMb1VBVmpxZGJEWDhhQnJzU2JEdnJyUVJKOEJZOUtCeHNMYWprVCtWQmE3SWVKVmJXM0JvS3l4STVXMFA4QWpRVUMrSitJdnZRQUZ5YmpmVDUwRWxVaTVOK0kyTkJKV0Nra29HdnRmcDhLQ0kwTnh2MUg5QlFUc1N3QXVUZlVXMW9KU1hCNEM0WFp2RTk2Q3ZrUVQ1UVFkTG1nbEd6RHBwZTU3L09nazc4YmhldTlCRzNsMU5tT2hIVW1pbU9RU3d2dmUyK28yRnFJbHpaanliZmM5L2xRUnR4OFFSY2VOQWdEYlluVFlmMW9wcVZ2eXRZZmxlaUFrRWx0U08rd29vWGxxQllBYi9DZ2ZKUVEzMURmajNvSGNpNTdqVWZINFVRd09RTnI2RFQ0YjBDVFM1MkRhRy9VMERMK2JsMDhLQ2ZxQU14a0YyMkhnYUNCQU55VGU1dHBSVFZpcTN0Y0U2aWdiT2RQS0FCYlFVUXlReHNBZTlxQlgvYVQyMS8xb0xkRlVXSVArdzBFTG5VOWIvbFFCQTRnZ1c4Zkdna0pFR3k5QmY0OWFDSEsrdDdrOUtDYUZBZk9icU5UYnRRU2N4RUFoYkcxZ0NUK05GS01NYmdqVHF2U2lCdU55SXdRQUxtL1dnZ3BPb3ZyMVlkcUNhMk9vK3JvS0JYVXRzYkFYdC9YU2dZWlN3c3R4MlBlaW9sTFhiZnNOYmEwUktOVTRFRTJXK2w2S2NoRmdBZFJ2cHRSQVFMZHdScjRmQ2dRWHlYK29BNjI2VUJwdGF4SXRxYUNhYlh2cVB6b0U3bTE3MzZVQ1psK214MHNDZTN3RkJFY3VYWW44YUNRYXdOaDVlb0hjZDZBVnVTOFJvMTlhQnVKVUhFNmJmNlVDWjJiVndXYzdkOUtCb3JFa0xxUjIzb0VQTDVTTmQ3R2diY1FOTnlOZE5LQ1BFdFpSWWtqV2drbHhxZFZHbXZXMUF1aEpOeDIzMm9PVm54cEZrZW9rcHVkQ0RzT3VsQlg3ZmxNNElqQ2lLTTNKTndTMS96MDJvT3JGTkc5d2wrUy9YMHRmcFFhSTQwYU4yWWtBRzVKR25oNDBGSkRBQWdXQTF2UVdXdUxzQ0QwMDNOQkpGYVE4UzRSYjZYMHNhQ0VpcWoydUhBTnI5RDhLQm9wdVNSY0RmNTBDYlFNUU9tb091bEJGV0kxNi9qUVRMRFRqdCt2alFCSUszQjcyQW9FVzIzODI1TkF3T1BleEdvNkcxQWlGSU91bHJpKzUxNlVDQks4Yk5aajA2V29KcXlrRzQxNlcyb0VaSFZWQTBJSklZYjBHVEx5QkhaUzU4d0xGVjMwMzBvT2ZIbmxHaWxoSEpKV0t0eU9nRjk2STdTVFJ0SFpIREt3MUkydjhhS2hja0FEYTFoUVo4NlpvNDdxNVUySjZIYmUxQ3VZMlcvcmxsazRSTW92WTliZi93QTNhaU5udGM4aG1ra0o0RUZRdW9KSUF2ZWl4MDQxWHpYWUVuVy9iNFVIRzlRdG1TeW9HNHBwY2RiSGFxaXlhYVdOMjlNRU5LQmE0Mk50dkNvcStWc2hjRWVRU1BvV1RyZnVQaFFjeUxKeTBZaU9NbVhVYzMxNVgrSFNpT2MrUG1TNUJkSTdYc3V1Zzh2MU1BTy9qVkc3N0tkb0ExbTE0bms0S2t0NDY2RHdxREQ5cndNbjNEUmxXNUtBOXl5Ry93QzBMM3FnbXhjUjNUMEpnbVFoOUtUbU9SQzduZ3luOW82VkJmaFBGQ3J4RkZjRW5oWUtUWWJzd0dvdDQxUkdDZkhraFZKb0M0NW4rWWVlNFkvMTdHb3JxTDdxRTR4MkNOeVpIVy8wSUJxV29JeFprdVhtSUlmKzBOQ1NSWXF1dHhWVFd4NTRXWmtXU3pyOVJIUzNlb3JqVHIvNUVrcXplUitOZ0xIYnI4cXFNTW1ITE03VG9WSmlCUWwvcGtKMEErTlJYUFFTUStyNVg0QWxEWlRjR3cxWmUzZWlKcWNWWW1MRjc2OE1nbG1XU3cwME5yQUg4NkRxelJaazJMSE9raXZBeThGeVdVTWRSYXhGK1JJR2dvckZQN1VtUGx4ZW9oZ2xXMGdlS3plUmg5VGpxTzQzb2hURmZ1L3Q4MExGREN3dGxRV1BOQ2ZKWTM0OGZ3b0pwbTRFVWNZYjFNZ093OWZHYTRQSy9sNHNDUnRRSWNZY3ViSmpoRHd1M2t4eXhadHIyTzE5ZTFCS1IwZUtXYWVSWVdad1RFbHdWY2ROT3RCQ2I3YVNaWTFkMmNKNmtYSTh0VG9RZmpSV0ozeXpFMHZLNk1RSW9tYTNMZ2JXdDNGRVdZZUJMa2VxdG14WWtBZWRuQTV0Y2FDM1RyUlZicUlvVEFnT1V4Y2NaM0pCamZjMjZmVDNvTFlmY0l2U21FVHVGTWhqaGtjK21uSzEyRitsN1VSSTQrU3FLVmxWeGtSbjFsWi9PZ1hwYzMwQTA4YUswKzErNEpCakxMSEV3SVk4bDVYSkkwREJlMUVYNW51VDVyeElGQXVySGlsdVFlMm0vZWdwdzVKYko5d1JhMWdRQ3dCdnhLaS83dkNpb3RGbnpSOENRbUZISnhUSjBIRWsrWGtUcVZvTW51UHR6R0VOSExISXJnOHpHUVNMZHhZVzFHbDZGYzlreDFrU0NlVm81WWtVcUZBNEV0MVBqYmVncys3amovaWhUa0dIL2xTRmdGMXZiand0WWdhMEdyMnhJa2tiMUFESWc0b3llWkdVNmI5YUNVME0yTmp1WVpHTFBwS0RaMFpUcXE4RHRyUVpIKzVOOHd3OGxSU29NWTlPMGx2cE82Mkg1MEd4UGMzbXhrYVhHaWlNQ2haV2lleFl2dGNIcjN0VVZaTzJQOXUzR1EzakxNWVJ1ck1MOHIzL0FFcWptSExoamdaRkJmSDVBRlFGTERXN0htUE1DS2lJK3NrYVNzczZ2S0g5UnVMZ01GZTFnVnQ1L2pReGplYUQxeml0Q0ZjbThXUktTQ0dPL2xHbGo0MVIwOEhFOXR5NUEyVGxoSmxVcVdZOG1mZ05RQ0RwODZpdHc5cGd6RU1PQzZ2TEpwajVEV2pzUUxFRWJhQ2lPVlBEbDQ4Y21HakQxQTNtUlNOR0ZoeUIzTi9DZ3BWSThkaWtpaDhkeUx4UFlBUHNTWEhVZERTcXhaSHM2USt1K0Z3a3hYWUJ3R012RWtnMkZpTnUrOVRGbFZ6ejVKV1JjbEVraVdNUlk1VWVvUWVWeXFrYW8zaWZuUTRHVmdTSEt4cDVHbEVUUmVwelgrUmdSb3NjcWdpNjlOS0NxYlB4b0Z4a21pbis2REZabDVsRU1adnhVVzFHdlh0UWlTeSsyeVkwanhJQmtSU0JzVlN6QlhZZnNJTyt1MUN4bndjcktsbWxqeElDWllyVFMrbG9oNUR6WEo4M2wyR3RxRmlLeXBJVU1VeXN4NGVxaEJ0ZE55MTdHNFhlMUJmRDdjOFVNV2ZGTC80ck9Ca0JPSWZnZnBzQ2IydnZhaXhyeVBlbmp5WWlXSDNJVGcwWHAyUGxHaldJNCtZVldRTTZYT1BKY0JHaGhqNEdQelhQcWFjdVY5KzNTb3VKNDN0c2NUSVpBY1dHUSttcU1wOU1PTkdQSTZYK0ZDbjd5ZmJjUEpSSmZVTW5JQnNxSmlZU3ZTNmszdVBDclNNdVMyVTcraEZtTmtZc3dCUkVGK0trM0FJNmtENnIxQ0tzZUtXT1VldkZ3Y0Fna0E2Mk9qWEg5S0dIbDVENDBna2hqQTlNaCtkdVFIVGpadEdGQWZmeXgrM05qUXNKb21KczFpUFQ1YXNGQU5nR080b3B3VG5JVkZObDRFTkxHb3Q1NzIwTnRLSmlqM2FkWFk0a1VJTWNqbVFvTkNxcXR5TGtYMW9Scng4T0tURys0R1dpU3dxckxFckw2aFZ3VHlzZEc0N1dvS01nemdHMHkrb3FLM05sWThReTJIbEgwOGZ5b09lc1FPUHcva25pY0RqS0QvSHlPalhKN0NvcVVrYVFwaXpRd3VpamE5bjFYeTM2ZVE5S0RUalorTkprU3dTWkVpWlUxMGo5YlJTVHEyM1FHaGpKa1llYU1tV1JnSjBKTEZ3QXloVTJJMS9LcmlTbzRHZTc1Q3JqWkFpMHVTekZJeDJEWHZVV3Z0MTlDQ3V0eHIxcmJBWWdDMi9oMHRRUUhJblQ4UGoyb0dGVUFrdHFQcFhmV2dDUzFoZlVhaWdrYjM4dzE2azcwQnFEdGM5NkNRdVFOTnROZjZVQWVIcDc2MzIvcWFDTWFsaUZHdjhBYXR2eG9MRFlOZHVoMTdlRkFua0JKNjc5YUJNU1ZGNzY2Q2dTaXd1M1EvaWFCa2s2N2VGQUM0Ni9FVUU3V3RmUWVOQWgwNG0zWS82MEM5UTNJdmM5VFFXTThaVmVLbGJDeEoxMW9FeWdYc1JhK210elFDM0Z4ZlhTM3hvR1h1d0FzdkhjOTZDVndHdmJYb0NOL3dBYUJDVThqc0c3aWdrbG11TGhWM2J1YUE5UlMyM0ZPdmNVQXpIajBzZGRONkNMTjQzSTJIU2ltVnRZWDhTUnJhZ0JjYWdVREE4d051T21sOXFJUy84QWNCMzBON1VFdWdzdkhUNmhRUTFQajhxQ1dnUG1KQTdlRkExQUd0aVZIeU5GVENYTnJBQTdkcitOQWNXdVFMa2RUNFVFTHFSWmJnWHZicitORVREa0FtNFVYK25lM3pvSkNOM0Jja0FFMitQaFFRYzhUdmNBNzlhQ093MytGQllqT3dWUitXditMMEVySUVLZ2t2MnRvQlFRWUV0ZFFRZHFBNEFOWWI5QU9nb29DdXg4cDIyOExVUk1IakdmN2dkd2U5QWx2eUlVNk5RSEYwQkd5bmNkNkNYRUVXRGFpNXNOd1BqUUxpeTZrRmROOXJpZ2liY2JXdDJvSHlISUJ2b0FvSlJ1T2ZKamNhM0hZVURmanlQQzVVNjNPOUE1Q1FBbDdnQzVGQWdyQUh6Y1IydnZRRG5tdklqVGEvUzlCQjVPTWJPZjI5dFRRWm9KV2psZVdSMU1aTndMNjZpd3ZRYW1IRnIzdGJYa1BHZ1pJQ2tmdXY4QUw4YUNhTWdJRGdiNmduY0Q0VUR0emE2THhqdnBhZ3E4d3MxallHd0oydlFXS3lXdGZYYzNGQXVUdDVsOHBCNmIwRGZtVGMzSWJaajFOQkVhTUI4ajRVRW00STVDRzl0VllVRUN1b3VkU0xrMERrbWpqaTlTVTJHZ0lBb09Sa0ZQdkpIRVhyUlc0dXJIanhKR2pEL1Nnd3hZODBNZk5abFZCY2NXWUZReDFzTGRxRHRZRVdLa2ZLSitaYTNJaTUrVkJ2amxqNEZTak14TjFZbTFxQk9SWTl2SFdnbTczalEzNVdHeEZoUVFVaGJnNk1CYTU4YUNKYTQydjJvRVNUZmZwcFFUNFdGeVNwSXZZOXFDTFc0M1U2ZE85cUNJQ1hGOUZQeG9IWXNRRk81dGNlRkFyQzJwc0RRU3V4NjJ0YXg3VzBvQ3h0ZGhvZDJQaHZRVFVhQ1BrQWpXWU1ScUtCRThqd1c1c0xCZkhyUVpzNlVyQWJXV1FrS0c2QStQNlVIRnlwWHlYQ3U0alZoZjAvcVluYmNiVUZNOGF5SXNJc3AwQmlKdmM5bUkwb2pxZTB5U05BQXhKVFVSbTNEUWFiVVdPaU43a0d3MDNvTTN1T1hDc1VjUlM3bi9BTFl0dmJ4b1BQeXRJaXlFTVlrSkxTbXg4dkkyQUFBNmQ2SXZ4TW4wWm1jSVRIR29DSXVvTnhibmZxS0R2SktyUmhyNmFYdDNORlpNaVZseW5NYkQwMHR5QkpVYzJIVWYxb2lvWkJrZCtVZ0hGQi9LZGdkZ0FLb0ROa1k5OG4xMU1UTHhaenFkN2FMUVlNakx5WVowdkplU1FIa1JweVRvQmJhZ3Z4YzdqWldVQ1FnaUs3YUtGT3Q3OTZpcGZkTktWZVk2V0RFSFlnSHdvbXFaY09MSWw5UzluUEZsQXVWSUkxVys0L3BWSFB6L0FHN0l3SkZ5NVlUNll1Nm9TTEtybXkySTJGdSs5QlRKNnJUUXV5cmppeGNPb3NlSjZzQnZVRmZxWnNlTDZqeHZGanl5aDRPQUJGOWt1UitsQllzaXhCRUN5U1RPTEM5dUlZMzlRVy9hTGREUWE0cG45SlpVeHVCaFltU1FteEtXc2pFSHZSVnM4cUxLSkMxNVpGSWRiLzdiampiOGRhSkl4UlR3UEs4elNrQ0xqZEdGaTVQOXFycWI3WG9xdjc3SG1KZ2VObFo3c1VWaFlFZlNma0tDV04vNDhzWW1ZeUFra3lKWVNjUm9UeE8yK3ZoUkZ1TGo0T1c4eGVhTEhneDE1cVRxckVmMms2SHBSV1poQlBJc2FtUnBpV1poRUNoSUkwWTMwQStGQWthU1ZPVUJLK2dCYTlybTl3UTJvNWY3ZkNpSm83K242c3krVnRKT0JVcllDd0Z2MjM2MFZUSmpQSkJISXJvaWhySVEyeFVmVnBycDF2UU01dVhKempBTHkydXBzQUxKcHlHZzh0RVdZR1puTkd5elJxOEEvaTlPVkFkRHI5V21xN2cwTmFKaGpFcU1lTldaRjVUYzIra0xzYjlUZnBReG55WVo1TUpzV0RpNFZqSzhJVUNSQXEzNUE3bS9XeG9wNFdOalJtTjh1VXRoRURuS2dMV2EzVlQyMm9JKzZOZ2VwRkpBQVpPUG1jbXlGU05BeWpTNXBwaXZEeFJreWpGS0kwMHpCbUJ1UXZGZDlOT0pHbmVpTXNrUzRlUXpHSm1QMDhaYmtpOXdDdHJmU052em9JRldqVkpZNUN0MURKRXh1WFp2cTVXL2JwcUtLMVlibUtNY0lWa1FLWGxXNHVxcWJzVkoxQUhhaUpRNUJsUm5RZ0twRE9BM0Z3cElJa0s2NjlQQ2lyUGU0NVZXT2N1SllwN0lpeG5RMjA4eDBISVVITFlLTlkzS3g2S2VSdmNtK2xqMXZVVnFuOXZlZmpqek9rT2lNaUd4WW45M21IZnBWUTV2WVlzVjVKVmZoNWJQYTRQWDZkMU45dGFZU3BlemU1Wk1MK2pGaktZWmdVQWxzRkpHcS84QXhJcUZxV1Y3bGl5UitteU5ES0d1MTdNR0pCdFlEcDFxam15ZTRZL3FGV2tLTEpmMVkyTEtEMERNTlJmeHFLb1BBQ0tOWW1ESzNuanRjcC91Qk9sbThLQ0UvdUVrWHJZNnJ2YXdRQmlmTjVWQjM1VVJSa3VSTkZKREtKWkNOVUtxaElHcmduYmxVV1JISXlZTXJOeGprNFhvU3V5aFk0aUF6b1BwUEliUGZhaXpoM3M3T3daY2tMandUd2tXam05ZmlXSlhUUWdjZXZRMXBsemhqUWhpVWxWbFFrNDNOT0ttdzgxbTMzNkdvc1V3ZTdMRlBHMHJIR1puNGllSFVjZ0w2RG8xUld5SXJsVHpLODVuWldaakl5bEpSeDIwT210Vm1xYzFtampXSXhtY1BkbkY5R3YwQi9XaXhrdzhiSGJJS3RJTWVCUnpYR1pUeGZVQXgzVHpYdlVXcCs0Um9tVksrTlBMR2tVbklyeFptZHQvTURabDhPdEtRWjN1M3RjWHRub1lzcmV2SUx5eFpLK25Kb2YybjkydXZRMFNIbWUxck5oSDNISTlJZ2tMNmNVeUZ5KzZnWEpJREx2U0s0bVpPYkw5RWZFV2tDYXkydmNTcU9oRjdhVkdzYXNGTUxJeUk1OEdmMGNtSlFwUjNaVElxbTRZaHJBV1AxQ2lPWG1RWjh2dU9WS1FrdVNybHZUUUJlVDN0NVIrNGZDbEp3MjQvdStWblk3NGNXT0kvWDRxMEhDNnFBZDQyWWNnU2Q2YVkyWldObHpSWThUUVJ5S1ZKaVVFS1dzUUxPMjl4VlJiRml4bGJUeW5FZEU0cXpYTVpJMXNMRGZUclFjU1BPVlNxNU16VFFDOGhYbnhheGJVQlRvYUxqWE5NaytFc3VaamNJZzNIRW5qYTFoMmRMazN2MW9Jdk1tSExDMEtldVJianVQTmJWanIrNG1sUnZqeWxoaWlHVjZza1NLR1ZlQlZZM2ZjTWZEODZEWjdmUGdaTTR4NThqMGVUM2pVam1GUDdmTDFvakhtNGNjR1ZNeVh5SW9DUE1uOGFjbFBtOHYxRW45YUxGTVh1a09UTjlyR0ZpOUt3TW9RcEs5OXVRL2RyUUdmTkxDWlc1Q2N5TUdJWlFQcE5pVHBleG9rVXU5NTBtd3NhU0pFVW15bmw1YjNabHZzRzNvcTFwSXNtQ2VXT0tTYWFSeUhUek00aUc3cXlmVjQzRkJSN2NZb0l3cU1zMExNZjRKT1FVOHRDZE5BUlVWUzN1ME1XUXVLWUZpaFZlQWFFa1NFRnRHTjlMbndvcWlmTzlTQlZtS3NZVGJHanNvbEE1V2RuY0Mvd3ZSRmZ0K1RsT1dpYU5seFh2QUlGMDVuVS9WL2RiclJiR3ZIamd2REZFRWVKaXhNT3BJVmpzN2J0eHRSSDJuekxZZmdRZXRiWVFabUxYWTZudHZRTVgyR2hPdndvaVFzcFBMVytsdDlhS2o0ZzNPMXFJbUNwQXZma2V1LzYwVk9PeEc1dHRRUjVzQVIwNjBFYlczRzR0UVRqVWdIaWJYMHYxb0U2a25YWHVLQkRmWFhwZWdrUUxEajV0RFk5YUNObXZZYjBEM050UjNGQXhjSGtMV0h6R2xBK1ROZGp1ZnFIZjRVRHRjR3d0ZjhyVUF5SVJlNCtHMjFBeTRhNHNiZEtCS3hVNzNOOUNmQ2dsNW5ON2FucFFTRjBqTnpZdDBPNUhoNFVGUmE5dTIxQksxclBjY05yLzZVVkoxT2hGaURRSmpwWTdnM05FTjBOOVJZVzFIK2hvcE1wRmlkTGdhZjZVRTQyRmlDbCt2d0ZFUytrNktCWVdJL3JSVVhOeWJFMkdndnVMK0ZBS0NUMkhjNkdpR1hQQzNiVlJSUll1TzVHN2RxQnFBNEYvaVIyb2hYMTN0dnJSVm5yZ0xianJmVnFDc0hrU1NkKzFBMHZZMjFCNmRLSWEzQkFHaDhOemVpckUwSVhheG9KelJxQU9KRnQ3aWdxdGMyK0cyMUFKeVczaDJvaXhFdXBZTHF2alJUa21kUDJnRnh0UVJVQVJNemZXYktCdFFTOUZvMVZuSEVNTGczNlVFQ2VKUEVBcjQwQWh1UVdiemROTzFCYlBLSkZRS2RldHVsQkdLUXhzSDBQWUhxS0J5ekNZbGlBTkxjZmhRTGdwUzk3MkZsYnB2UVZsQmMzTmhleE5FU3NCb1J5dDlRRzlGTU9lQ2piZlhxUlJFUUxuekUySFViL2hRS3pzZW5ZRC9TaXArbzNFSWRRcHNkS0l3KzV5SVZVcnk5RUh6aFRjRzI5eUtESEhrUmxicEdYVGx4ODFyMzZFK0FvTnVISzNOSW8yOVE3djhBN1RRZFZvUElDTEMydnpORlp5aERrYm5yUkZ2ck1zSmpVYjZrOVJRVjhXQlZTZkVnNldvTTgyUXNXU2tKL3dEeEFSZnVkOTZDOE1BUnRjalErUGVndGZrU0VJSUpHZ1hYNTBWQlNwNkRwY2VGRVJZV1BJSFFuVDRpZ3NFVGN3b1lYdHZmVDhhSzUwbVpGTThpc3hQcEg4U043andvakJKbHc4MDRCWkl5VFlLYkEyMXVUUU5jT0thQjRZelo1QjZqSWJBS0NkVHBzZkNnN0VNTVVVU3BHQXFpMjNYVFNnZVBORklTVmJSU1FiMzFOQmRJd0NvakN4QXNEL1dnNTh1UjVPSlA3clhKMFBVVUY4RXhtZHJBaVBUUTlEMTFvTkEzSUd0OXFCZ3FiTXhBdnVCNFVDR2dNcStVWHNBZW9vSXB3Nml5bmZqdlFPNmFBQWtuZlg4RFFMaXgxQjIzSGpRQlBRZ254OFRRVGlqMEZ4Y2Qvd0RPZ2xQWXNkQW8zc0tDdm5HRkcvUDl3TkFpZEE2NmE4UVIwb01YdURuaEpkbUJqSUxiWEs5TkRRY2hFbGVWekxIZUp1TExMY0FYVnJnM0g5YUl2bmFGSnB1UUJzb2s1OGZwWnRCZWlsZ1pSSVowQlBKeVpqWWhRQjFVZm5WUjFwc3FLR01NN3FmS0dHdHJqd3RVVnlNdjNQQzU4eVJlMTI1ZzJ2ZjZmQWVOQmx5WlF3SlZDVHpESnJmaURwZlRlaUlwbHZpRlBUa3Q2MS81aUFkVHBkckN3WHNLRFJCa1N6WFNPeER0b3ZJZGR5Q2JDaXBmZXpKRTZXTEZYRnp1UUFORklHOUJaRWVZRWpBaGd3S3hwWWdhZGo4YUlva21FVGNJVms0czFqeTFZY2dSWmVXaDE2VVZqeHNmbkk4VDVTR1Qvd0REUVh1d1BSV3R1RFZSWmppZVdXOGpMR1FQUjVXSVVrOTc2ZkUwR3FLVkJHV21DM2lBalk3OGw3QTJzS0NXQm1NdWI2TUwyRXdKYTJwdUJjYUh0MXRRWXM1cFptbmExNFppT2NJMHUxN0RWdjJydlVGR1ZoNVUzQlZrVmtoc0dsdnhLcnZiWFZoZWl0RjVlRWdScEpVaEJjeEVIZXdVdFk5TlRZMFJqdzJ4bGtMekw2Y2JnbTRKQlhqY2ZOalZTTmE1bVRqaFFzU21OU1FxeWVaeEdUMVVkU1Rlb3FqSnlrYU56a1Jua0c1dUFPTngwYnNEUWxRQ1M1RnBIakViTGFWcFVBRmw2Y3JqZTM0MEYrRmlRZTRUTGlJOEN0TXhLTy9KU05DZUE2RW5xM1NoVkh1RU1jQ0ZKL1VTUkNxUnJhNERyb2VUWHVSOGFFWmNmQm5NU1FjQndKSjVOLzJ1RE5yeUc0dDNvcGVwRmdNeXF6ekdDUzE0d1ZWeDA4eE4rSjZVUjFQYS9zcElzeWVYSDRjeHpqczFwRkpGdGIvaHBRWVd4M0FMd1dudHhMeDlDR3VQVU52MG9JWlgyeTVEUGtNMzJ4WG5hRndvTEhTNVh3MklvcW4yMlhHeTRvcFJKeFFOYjA1TGk5cmxRMXRiZUZOTVQ5MDl3NFQrakN6SkhrRVNyQXA1UmxsL1RYcFVxeHpKN3N3ZGhlZERhUmxOdktUY0VydFFkYkc5N1NiRWl4RWlXQlZZcTgxbXU3ZlQ5UjJGanJReHE5NnhmY3ZiNEJESk1wOVErb1lZbUI4bHJEbDB1T2xFMVg3RmpJY01IS1NSL1UwU1EyS1hQVy9jYlVpMXBsUmNmSUR4djZSUnJMSXVtcStGcXFJbUw3dVl5VFRSU082aitRRTNDMzFIRTdnMFJUTDlyRk02aDBuUmJreUZRdHI5VmI5S0t4bGNVNUJsTXQ4TVB3NG9UcTdDNS8zZWJ0dFFiY24yM0U0S1lKU09mbTlOZERkUnFHNzBSaHlmY014bEhQOEFtZ3lqYzZnTUdVV0o0MjBZcXB0Ull4SkR6aFZsQSswUnlqUGE3S1NicnlBMkxuUVZCdmVUM2FRd1NSNUM1UnhsTEl2RmZLaWFGU091blUwVldHaXlCR3BJYUNWeVRHUWJLekhvVHFhcU5tVjdTNlpaaEZ3QW9NQVhrNnVscmdjdWxCem1sV1NTd1ZZbGpqNWM1QnVWR3RyNzFGWmpMUGpaT1BHSThlWlpDQ2VJOHBCMlUrQUhRVUVjTlpESkpqT25CbDBMcytuRXQ1UTFyOGJIVVgzb0IvYjVJbk1zUTVpSnlacHJGRko3a254L0NncFNJblBiMFlCTTRKNHhFaHhjaTkyMnViOWFDekZ4L2JvWnhMbmVva2pzWTdweEpYdCtkRFd0L1pzMllaa0VCWmZSSHFjSDgwYmE4bFBZWDMwTkUxeGx4cDU1MWlXR1V5Z2hIZ0o1RHpIUXEzUTlxSzBEQ2h3a3lSTEVaeklMUnU1c29zZk1XUzJyWHBoYlFNdUNTWUpsQmxrVlNXSEhSdExnZ2pWU2U5QTRaNHhJSDliMG9tdllOYzJERFVYMHZmdlFWNUxxbUxqc3FDUkE1VVNPeEJZQUE4VkEvY0tpcVBlL2U0c3BZR2JET05sc1V0bHd5T2VYQmR5cDh0N2plaElxOXVoeDhxU1hJOXdRTkt5bGxFaERNenIwTEc0MTN0dFFxV0w3UmtZN1N0alJsWVpiM3NPWTRsaDlTbllVRlUzdG1YOXhOa0JsQ0p4RXJKWUhUUlFmRytsRFZlTzA1eVkwbWFMTHZjSkZIWkdZUDlhdVJZcWUxU3EwNW1MRUdFTU1CVkZibkZmbDZrZHhaMFl0WWtpcU90aCswNUgyNnpHU1AxMUFPTk94c3dzT2hHL2JpYU03eTV3bisxeWNrU1F4TzhqcDVsSlFrZzJjS29KVWswVnF5L2Q1ODJIMHBZZlRoalJaR2NMWnVKMHZhbXBqejBtSmo1WHVFTXpSTWNjRUNRUkFrZ0RjaSs5cWpic1I0cFZQVTlxblU1TUx1WkdKUVNzTGhSeGpjSFh2VlpZYzZkNHBZMlNGcE1KSlZIcHVGWHI1dHRpYi9DaEYrTDdsaFJTdkJJcFJuQmpsamJtNlJ4bjl4QlBtUHdvRklzeVRlaEtzRXpHUUxHT1hCNUZJdUdFZzhxcUIrQnBTTDhKc2NaeXdPcnk0U0k3elJ3RlRLaFRWanpmUWtlRlFiUGJaY1QzR0RLTXhoaHlJcnRpenlxRmt0MERCYktTZS9TcktsbVBNU1pPVERtUnEyVTRWb3hIZXdZRW00SUpONy9HbzIzU2UwdmpZelovdHZ1TU12QmVHVmpKSVRLSHRxZ1MyM3cwcEdkWVYvd0NRU0prdmFIN2FWbEFqZkhaa0hNaXdVV3R0ZldpNGVOTDdsQ3pRTVFKK1ErNTlmUUZ0MVpYOEJ2UXFtSXg1R1RJK1N4Y2x3ektMYU1SZjZqYm9LTGpka2UyZTRaRXhTY0hNaWpqNUpKanhnY0ZPdkUyRjJDL3VORTJSUW50MlFTUkRDOCtGR1NXeW83a0p5MUp1YmNmblJYV2lrOUNTSjVsVm9pZzgzRUw1Zmx1ZTlFajZwc1BFNjJyYkJkVHBlMUJPSk9XdklBRFU2MEVYSzlEcFFJTVFiRHRhOUJLK21vSUhRR2drcmFXUHgwb0VUY2dzYmpxTzFBdkszaFFXSzdjUllEVGMzMStOQWxCYTdDN2RDT29vQnVCQU52Q3cvV2dkeGJld1BUNFVCR1NiQUhXZ1pBQk4yODM0aWdpTmVtdldna1czSzc5RDJvQmJrRUFFa2k0TjlxQkVpNTVXMi9PZ1lWQ0xjdk5lZ2FDTXVBd3N0NkNSNUxyb1FScGVnaHlKWDQ3WDdkYUFDZGJYTkJOUU5ibXdQV2dra1paV2E0QUE2bldnaUZGOWJDMnQ2S21FY2Z5Vzh1NEIxdlFLNFlFdDlXNEE3MENJSWF3UFMveW9nc2I2YUMzWFlpaWc3MzdiV29HdDJ0cGUzYlcxcUladVNTQjlQU2dscVZISHA5UkZBNDdCanZZZzJOQUVMWWNSZnVlOUJFbFI1UjAzWWZwUUFrVmVvVVgzK05CY1U0dGJvZjNiRDQ2MEVQMzJYVTcwRVdKUTZFQUhhZ21wTGZWYXdGL25RVEJRYTcvQ2dVMHhZQzF5RkZyV0duNFVFQkxJcENnbTFya1VCY3Q5UnV3Mi93QXFLSkEraGExaDEyRjZJa25tRnlkZGhmWUNpb3NDdDdHNDcwUklLSEJHZ0FHL1RTZ2lBQWREcnNRZkhwUVBpRHRmUTNvRGpkckRVMnZmL0tnYU93OHZLd3ZyYllVRWh4MzZkTDlhQ1RoUXFjVGM5dTE2S2FFS0MyaFlIcnJmNVVSV3JIa2VYbEoxSU8xQUVncnl2NTJPdlRTaXNjbVQ2Ym1SWlE2bGYrMHU0c2JhanZSR1BLa2RReGhVdEcxbWNqVUVuKzBVRlNnUHBHdGd0ck1Gc1NvK25mOEFTZzM0Q3grY0VsbVU4bWNhZktnMkxsaCtLcnN4SXRlZ3N2cmRpUnJZblhTZ1VZSFBqeTNOcjlDS0N1ZDJqUThSelpHNHVvMU5xRE11WXJnK3F2TFE4R1U2MnZRUTlYSUVpeXMxNGtIOFk2N2FnMEc5TE54NktSOVEzQW9KN0plMXdUYS9XZ1dvc1ZOZ05EUUpudWI5RjBzS0RpWlI0dTh4L2lKUEZWQUoyMjAyMW9LbGtSVmtrSTlGazR2T0RZQnlmcHQyRkJaalpVYXgrcXNSTHlqbHFiQnJiMkZFV2ozVjJabGtzSm9RU1VRR3pmOEFTaXJjVDNCWThaK2JHU1krZVN3NmpiU2cwWm1hQ0VIMUhqeUk2anNQalExU1VkNGxSMUhrSTgzVWs2OUtJMTQ3S2hXQUFsanFMOVRlMUZYa2tHMjNIWWRSUVJCSThDYUNySXlSRkdXYXhJRitPeFB3b0pSWlFsdVkvS1FCY0FkQ0tDNHh5T3k2ZmhwcFFVU3pHRUtMK1JtQVBlMUJZaGhmekl3S1gwMTEwb05FZVNXSHAySlA3VkEzUGpSV2FUTFVTaU0yRjdrbS9iK2xFMW1PUUhaSlRLZ1ZnVjQvdTAyM29LNWM5V3NzYWtPRDJPbkhyUW95c2VITWdsYU1CcFNDcFBLeE4vMHZRUWZGeDQ4UmZYQlJnbjhpWEpCNlVITXlHYVROaHhlQlp1SzhSZTV2c2VWdE50aFFDTG1STTBTTmVYbUl3N2FFT1Rzd0hTMUJHZU9hVm5FekdQSWpXekRveDJBSDYwUm1taWN3cUlrVFFjWnlBZktUNGJqeHFqWC9BT3ZLSGp5SHBFRCtTUHF3R2dOdWdxS3BTQ2NZOHJ5cnlQRW9VYnlxRUJ1YkMvOEFkUkdjWVVpSkUzRXNyb0dWYmo5eDFCQTE1YVVHa3ltR0ZYVjM4OXc0UlFHWTdHNTYwRW9zcHNLZE9XUWtpenJ4c2RDTnpxZjF2UVVEM0l5ZVJlUHF4RmxrOVRTT3pDNDRXb01mb3pXSDNFaERlVm9nQ0ExaWZLTlB5b1kxVHA2TTBrV2Vpd3p1ZlQ4ek5aTm11U05yWDFxaU9GbHpDQjRyTXA1Nkh3SGEvZWdiUzU4RGdHTUNVRm1qUmh5UUMzbTUzL2ExdGFpdEFPTzhiNGpPazhrZzVlcmV4QnVQS1FlZ0Iwb2pucTBjR1JGTExDVDl1eWdTeGtoN1hQRTI4MnBvcmZQSTg4aGl4VjR5TS9LYVBrUTdMb1R5N0NneVNZanp6TUpURXZFL3hJbXFxVHJ0Mm9qb24wWTRIU01NN09Sd25JNU9vQTZXNlVHRnBIa2lhTlNjZ3JvcmpTeUxweFZqdUNkelFJNTJUSTE4a1NORVVVUnJvV2UzMGFMb0xIdlFaWTVJU3dhNWVXSXJMQ0NDT0p2cVQwMU9ualFhNWhudGtHTVI4b0VaM1ZqclozRjNKTnlwQjYwVlNjMTRGa2o0TDZZVUI0MXV3SlRVRlNmN2oyb0wzeDVqaUJqS0Z4NWxENUtBOGlGMjE2NzdHaUpac1h1K0d5WlVraGpFMFhDOFZuajlQam9wVTdIcjRVSEx4cDhlZFVqalNTSUd3ZklqRFhaYmNWM3R2djJvcXRrajV5S3k4QUZ1aGU1MEIzTGJXSjFva1ZManlRNDRuTVFnbHVHZVlNZTloeFhvelg2VkZVKzZRNC8yY1VzVWJOTXlNUFVJS2t5RVdIRXI5Vi9HaXlwKzEvYlF5elF2TTBzY1NyR3g0c3FsVUZ5ekFqa05kTG1vVXZjNWJ5ZWxGZVpTZFVqYlFranlxU2JBVlV3Q0wzZUJJd3orbkxKY3hSeTJjQ0cyaUtXUDkyZzcwWFYvcy84QXlNeFloZ1llbkpHd2pZU3FRdzFJRnh0Yy9sUWF4bVlqWk1QSm1hQjJJZHRONzJ0cnBhL1dxalRuKzNRNGtQcUdRUzhTTG1MZE9SOG9VaWlNZzlxbW1oa2JuNmNXcmt4L3lMb05aSHRkbERiVVZmbVJMOXFrd1NFWmE4UWlRbXpsYmVZbmtlSzZiZDZETGhaTDQvTExLRjQrQlhnV0dqaytWbThSdlFWNW1Pa2NxcElwZVRKY042ZDlDRHF2RmhzYm1vbzk2SDJvYUtOMWlVRUJRd0luUWhibG0vdUJCM3FwRldQSE5rKzN5WlRoL1Zpa1FReS9zbUp0b1RweEtqclFhSko4YkxqU1Y4ZVJwbWV4VXVwalFyYTdEZ09WdmxRVjVmdmVUa0xIaTNIQ0VrbVVOdXhOd0NEWURUU29ZcHlJOGRHYStRR1lKeFpDcktMblhnVlAwMkowYmFnNWVWaE9zQVhHdXBnQjRxMXl5M2E0WkxkYUszUUo3cGlTSEpkbVJwUXduZUFlV1VrZFNOemMwTmRlVDNQRlBzc2dNai9leXNBa2pDMGNvUWNUNWRmTlJLOHprK2x3a0Mrb3JxaGFFeUEya2NBRzE5TlJSVnE0QW15WTVvSUpGaWppRDVUZlVOL0t5cTU2bWhWOE1XVE9YeGZ2d3FSRG04V2lweUIvY0IzOEtHck1pS0tHS0RMNWhSSVNGaGpVaTF0Q2VRK3I1N1VHamppREpLaGprNG9BWnA3V051NUcyOUVLZjIrVjVtV0JWbVMzbUJIS1M1dFlhVVhYUFRGeUlJSjA1SGliY3NPUldFaXN2UWNnQnhJMkZRdFlJNWZjRW5rbHhYV2FBdGFJTWJLakVDMWlkamFqU2NtYmo1R0ROOTdHTVlSTUhoeEFuSkR6OHJNR0dxN1hva1pjQm9zYjNNRG5Ia0pBMWc0RjBFYjI0RjdkT254cUs5TGwvd0RJcG9zV09BWUlhV2NGbEtHNEd1bTNYc0sxckg4OHVUaGU0aGVhWk1DQ1hNTEk1dWZVQkJ2clkyc0RwclVhb3ovYnZkZmJjaFo4bkZzcmp5VEo2YkVJQ0xGZ2hib0tFb3ovQUhHTnNXTWVsSzJUS3diN2lSdENxM3V0d1NHOEwyTlRWa1pIOTRDNGpZdHlNbEFXakFJOHRoY200MDEyb3VLaGxaOE9BWC83RWJTTjY5NHhxRGEzbU9vOEtKZTJmM1hKSEdNUm1SbFpUR3pLRnZJQWJraSt2SHRlaEZQc1B1T1FjaEk0cFQ2cmVUMG5CWU9oTmlQN1IwcEN4c2pYRWt6WGVlVDdXN0VQRU5VUmdUcXRyNmZPclRIUnl3NHhKSWNmR0VpTHhBWjN0S3BHck9CMm9sWXMrUEl4MENFd1pVU3hoaTZBTTZxeDVFT2REeTZVTzNLd2xiTW1saVNNaEVReXh4RTZhYWk1YmNlRlJycGRGRmtabU5NMGNTeG1ORUhKeVl5SFg2Z2dGd2I3Mk5DcElYSldITmtSc2dLUVg0M0JVL1R4NGp6V29qZEhGaG5EVXpLWkF2SkhXMWdwR29BSUJ2eTZVTlltOXVpeElvWE05aTdIMDJqQjlRRUc5bUJGaUt1RnJPMlBrcE1obUpsa0U1OU5pZ0tjaUxqL0FHa3QycURxZTFTNGJ6Wk1IdWVJc2tiUitTZEZaVlJqNVZad0R0eTF1S0ZoWWtIdHVHSjhaa2p5WUpqWjhwZlB4QUpBWkxXL0doMnZ5OCtYMjEyeDhQM0QxQkkxaGk0NExFSXczOVRvZTlLVG54eThMUHpWOXhFRHlUTGpDOEpRTVVVQnpjOHY3dkdoZW0vM2pJZ2pRNEUrT3J1b0hvWmNJYThpL1ZyZXdOVlBuOHZyaXNvREJyM3RvZTVyVEtISW5iNWphZ2FpNXRvYi93QktJY3E4ZExpNTdiVVV1UjFBK0ZCaXljeG9uWlZOemJ5MzB1YjdVRnNHV0dJREFoanNEUWFTU1NmOFdvTXYzTEhLTVFCNEQ2cjBHd2hDTGc3ZkkwRm9KL2I1YkMybmpRUU51LzRVRUcxditIeW9KS1J1ZnB0WVcwb0dXWGxjWDRqYStwb0lpOWpyWTlpZFRRVERzQUYxNDloUVNCdEdRUHFCdlFFTWFFRXNkZjhBRnFDTndwdUJvZExudlJSelltNU5qUkV6SnJZQzNhKyt0Qmx5Y29SQWpUVFZxS3p4ZTVrTnhZK1ltd0M2M3YyTkJzZ3lra0FQTGJSbDYvQ2lOTFNhYXJwMHYyb0VwRzVIL3dCYUJ0SjZqQzl3T3dvcU54Y2pRRHNkVy9LaUE2YWtYL3lvcWFGU25GeWJENS9DZ2NsZ0JjM0M2VUVDUnV0d0IxRkFOZFFPb2JyM29pWlVxTE1PTjlkTno4YUNRbUtpMzdTTlNQeW9weHVxZ3MvbkEwQUg5YUlqTE5HdXZFWDAwT3Vwb01PUk1USWhBdXJOcmJZSGZXaXBSNVd5blVDMnQ5N25ZZkNpTnBaT0lLbTl0Q1JRUXM0T21uYlg5S0IyQVBtdllEV2dtdkxSUTJwOHhIVDRVRExBampwWUhTdzNvSUVnV0JGQkpYYmtMbXdHbC9DZ2FNTE14RitnVzM1MEFDNUhDd0ZqY1g4YUNiS1VITHFOanBSVmZtVTJKc1JxUjBIalJFeU9URGlMSFc5QkZ5TEJWdXY1MENZQWthM0g5S0N5RlNHWHkzSjJvSlNqZ3h1Yk4rNGRCUUhHVGdDd0lUcDJ2YWdpMmcwSUREb043MEJHcnNkQnJxZDk2Q0U3Q01DM25aanhJR3d2OGFEREt5U3dTQlJ4bXZhNmpYWFltMUJTWXhIYnl2ekE4aWpRWE82L00wR0YybVVMSkdwWHpjclgyTjliNzN0UWJjYkpXQk9MOGlwSDFqVzVQUTJvTG9wNzg3QUFxYmFuVUUwSFFpTFdISStlMWpRU0dsdTQ2MEdSdWFTbVpMTUcwYlhjYjZkcUNNWmhDTThhOGdmTmR0QXAzK2RCQmJTQW90eHpZTVdJRnFxT2dQSW9XMWdCcFVWYnl4eEVQTDV6OVE4YUNzS3hZS2REdjhxQXR4YTVzUnJZajlhSzQrYW1SSEs3eURsR0V1RHNvdnJyMkpveTVlT2NTUjJMcVA1QVFBVzh5dU5kUWVoNlVWZDZhNHJyS0w4YkFBallMb2IyMXZSRjhkMzllZklWMk1saW9Hd0E3Z2Q2SzNNOE9YZ21URy9oWkNDWEF1VDRmalFLSkpZOGdUWk1pTHpWZ1lpZUxoYmIxVUtETVJ6eGpQbEF1RDArQVBXb3ErRGxrNVN6SmZ5blVnMjJvTkpuSDNBaDMwTFNIdDJvTEx4QkhaanhZRFR0NG1nNVB1YzhUQWcyTEZlQ2tiaSt1bHYxb0Y3Yk1JRzlPZC9PeTNqVUhscDhhRHFtVitMZWExbHV0LzBvT1htUEhKS2drWU1McUdOOVFhRG9ZOFBvUXFodXhHdkkvalFYRUFOdWRSci9BS0dnNXVScUR1UUJ3NUFlWWc5QlFaMlpSa0swbHdVWUJMQVc0MjNieEZBOHVVdGR1UU53TEM5aHIxdjJOQlREbFNDSkRHQXRnYnNUWWRnV1BhZ2t1Y2o0eXBJeitvU1JxYmxXN1c3R3FqSklrU01lYlB4QTRjbzdNdklkNytiUVh2UXhtV2ZKZ1lRRlduam1QL2pCZktRV0d0d2JtOXU5UWl4Y2l6ekswWmprWk5JRnVUWlAzTGZXMmxGVUZwbGtNN3lNU3ptU2RTQ3k4MkhsRzM0aXFqcHdlNVk4bU9zSkNnT0x2d0J1aTdWQUJzV0ZGVjR6SjVpUFN1U1YwMGtPMWkzUmFvdmtpeDBSWlZpTEVxZklQSTF6cUQxdlVHR044NzF5c3h2ajhMbkhGeWdqSGUydWw2S3haTFE4ZlNWVEl2SVF1TDhTM004Z28vZGJ1VFZRU3ZKTGxKamVvYkpjSXZDK2pueXF3dG96TjFxRFRQaG9qUU02cER3VmhJb1lrS3lDNVd4b0t6aUhPbjlXSndqai90eGFrcU5CNm5tL1NxSis3NEVtTmxvbVBJa2tsbDlEalpkN1hCWTM3VkZVTkxuKzRRTmp5R05vc2RoL0dRZWFsN2oweXczV2dwWTQwN2hTQXF4Ry9NNk94QUF0eUI3N2ZqUU5wY09Fb2lQNTNabVZybnlMYlFtKy93QWFDdkcrOG1kb1ZkZlhjRlBVNDNKdWJ0ellkTDdVUnV3a3lZcHpPWVl5bkgwNWJLWGpEbmMzT3Q2RGFZeG01RWtDRk1WNzhZa3VWQkNqcGY4QUtnd1BLTVdkbFJIYUlIMDVWdUd0b0xodVBRMVVPVU5PY2lWZjR1TExkQUxEZ1JZRlZQNUcxUlhOaFhJeDFjMkt3T3c5VTYyWlZQSUE5L05ycFJVcHBwMXpIaURNa1ZneVJ4NksxOWVSSGEybEVhY3Q4ZHczcE8wSFBqeFZuNUZMNjJCT25TaXNKbGw1d1F4RWgyWXhtVGFNTGZYa0FkUmJYV2lWb1Jwb29sY0NmSVZ3eWNGa0hIZ0NReEpGN0FkcUt5VEJtWGhFa2pNVGFhVWdoR1FkTExvU28wK0ZFYXYvQUdXRGh5OEhaR0hsTVl0NVNUdGZrTmRkNkt4NHQyenBNa3p2SWNkbjlmR1ZReVBIS0wzUS9TTEVhbm9LZzArNDR1VmpJSllJWkpPSUVqUnpFU0lGWWVVV1VoVDRNS0REbFlzOFVPVGt2T3M4VXBqKzRtanVibGwwaUxkMS9PaXNaelpCQXFMNmZHVmlxcWRIQ0llU2Eyc2IwTmE4cjIyR1pjYktiM0JSUEtDcjRjeElZUDA0cy8xS2JhSHBWUlJreEhGeVZFa1JDbVFBSTI0a1JkUmRTZkpyb1RVcXhzZUIzSERGOUlaR1I1bVJsT290cFpEdmZZbWlOdnVJTVdMaWljb1ZkYklJQi9LamtXQWxKMFArVkJrZ3pNNkJwakJhQ1FrY1VXM0pnbC9KZnJyMzNxak5BOGVYRVFBd3lCZDhtSXNWUmVBdng0aSt0QnRFUHQ3WTdlbkxKRk9XQ3JDeTJ0eUdyM1A1QWlnSk1WcGNTVEpseUVsWXlEaVdJYVhrdTR0b2RodlFaczJQRGFMMXZVbWRpM0NOcFdKczdhNmhodVJRTEZrbWJGOUhsSzZweVpJTGhRdWg1RWc2Zk9oWFR4c2FKY1ZabFV1eklJMzRIVU1ScDhiNzBSemZjam1TTUEzR1NDTjFLcFlJeXU0SUxXVUFzTFVWbWZENFRtT1lCa2tpQWplSWk0TGJjMnZVVlZpZWw5eU1aR2FQSmlkWFI3K1loTkFWWTZlWGRWNjBHejNReHlpVG1rc0tPYjNCSjVTQTNMc2w3THk2aWc1T0JnZXZMSjZ4RVVDZ3JCSWVaUUU2N2pVRzlCSWpNblY1VjV6eklTa1pIRUFNM2xKVmR2TUxnK0ZEQ2xqOUJKb1lGWmNLUlZFN25rZ2prWHkyVUU4clgydlFFa1VVVUM1bGlnVWNXUkFDQndJSFUzNW1nMHNZVEhITExJOFN5SzZtTXFRd1ZyRzRJRnJtMjlCME1qRnhzZkhobGhCeU1FRGpLWkNZeEpJVTVNdDE4d3NUdmFocm04L2NsSlZPUXhabEo5VmJEeUt1M0lhM0c1RlJXWDNUTjlXUjMrK2VlWm80K2NwTFdVOGVJWm1hL21PMUZ4RDIvTWxEU05oU0QxMFQwMmo0Z2lRTVFDVkd2bnYxcEVzYVo0MnpabDQ0cmN1RExLV0pVLzdwQ0Q1ZUYvTGNVRk1NWHRxSk42NE9OSVFzU1JyOUpKTjI1RzNtRng4cUYwMXlzV1BKSXdwM2s5VUIwaUlQTU1kR0NydWJIclJZVVdJY2pLamVTS01JUUhrREEzY2plOXJFWHBwaU0rZWtDUjQ3ZWtJcEM3TUxFbU5sSXNIL0FIVzhLYW1MOFBNZWJIa2h5VEFzV1VGSE02OFNOQVFDTk43M3JNVmp3ZmFVeXMxOFFNaTgyOVAxb2xIcGNnQUFSZXhIamVxVzhMLytVKzArNjQ0aHdNMmNUc09JaURFRU9xRHlnT2RkTmdLdUo4MlZ5Mjl2ZVdSTWFLSmxFaC9rakRLZVM2RmJQL1NpdXY3ZmplMjQweVlrOGluT2lsNE5HMWdFRnJqemZ1VzI0NzBUZGRIMzMyWEh4cC91bmtoeUlmSktJRTRoWEJJOG5CYmJVcVMzSG44QjVwOHVSUXZvbG1ObWtiaWc1RzNFazYrUTdWR25VeWNUSHhNbG9KUC9BQ29nQnpuVmw1Skp0NWlwSzc2andxc28rKzRQdFFUN1hBblRIbmFKWExNaFVPUWJoSTJ1Zm5laE5jTEZta2dlU01zeVRwY3FyS1hSM0k4dWdQbExkNk5kcU1PU2JGa0w1RWJ2REw1RUdvWlJiL3RxMjYxQ3RtQm15UGxSTmlReHROeUMrajlVWmpHMXVSK3JwclF4cDl3dzhpQ1diSG45SnBQcWhDaytSM0JKVWtHMTdhR3FtcW95aW1QSHlYTVd2R09PUTNSVGE3TUdIV2dxa3lNUllaOFVIa3pvV2lrQ3N4REE2Ni9DZzMrMFltREJqTkZsbDhhYUZUTEhNRkxSdUdGeGZpR0s2VWhhNDAwY2YzYnpsWEdNOWlIZ3R5NHFiTzErNXFWclVrZUNVK3BDM0pJVkpIcXQ2YktMK1JyNmducFJFTVZQZDhweGp2a1NDR0EveHBJUTNFbStpc2ROTDdVWGg5d0szdnRwY210dWF1OTloeEhhZ2IzaVRtd3V1dHZHZ3d6ZTZScDZKVHpMSzNGaWRMZkNnMU5seEJBQXlobStsdDdtZzUwZ2NzL3FENmRRU0xqeHRRUVJ6ekxKNXlMaFcydHBWUjJZU1JDdklpNEF1UjhLaXNXUm13Sk9EeDVNUHBJRkJhTTFXVU12ZXhIVUdnc3hQVzlUbXg4dHR6UWFlUUpKUHlvSWtnblQ1aTFBeCt1bndvSldXMXliNjZkTDBDdUNkZEIrUW9xUVhmWDhkcUltd1EzSU4rdzZVRmlla0YwMFA5MjFGVk9PUkpHeTYvQ2lLWFlvaGNnbWdoaDVLem96QUZiRFRyOHFLeDVtUENadU1qRWw5ZUY5Tk85RVk1QmpxVnNuQXFiTU5yZ2E5YURaanhTTTBaaXR4VThtWWFYK0hlZzdTcjZoWFlhMjFPMXFLZzFnU3Q3Z0hRajlhREZsVHJGTDZiZzJleEZ1MUJSN2ZsZW5KSUcwMUJRbnJmclFkVU1HdGZmOE5mR2dWZ3JFQTZnNk1ldEFIa3BOeGV4Mi9yUURXWnJnZi9WZHZqUU1Nckx4T2g3am9LSXVEdXA4alhKR21sNy9BQnZRVldZMzAxRkJYSTRSTGsydjhoUldLUnAybDVxNE1Zc1VBR2hBM0pKb0tseDhsRTRGamJremx0UmUrNDhLSXBSWkc5d1JWUEFBQTNPb0E2WElvTzVFM2xXeHZZQy8rZEJhNmdnV0ZtMHRiYnZwUVJKWnRlbXc3VUJ3WkR4dGJxZm5RTThBZE5EMzZVQjZyOGdkT1E2R2dmbjQ4aTNsQXNmOGhSVkJ5b3pNSURvMmxnTkxnOWFJMHhjU1FwSUJ2Y0dnTjNKMDB2UUJUZ0FaQmNuVy9hKzIxQkVBWDF2cnRhZ0R4RmxXNVBWalJUSVVzQ3R5VHZmVFdpQUZ2cVlrQVhzUENna1N6WHN0d0JjbnJRUkVodHhCdnRwNDlLQU5ndDdFTmZXKzFxQVZnTEViOXZHZ2R4S2ZUY2ppYjZrMkFKNjBIUGtnVER5UTZxd1cxbWMzR3ZTZ3plNDViK3NUNmhNYUFOWUVDeE8ydjlLREJCTW5EL3lYQ29DZU1MWEhIbHJ2c2JudlFXckd5Y0lvR0x5MklrazVXVFUrYmJwYnRRYkJpcDlzcklDSGtWdURFM0doMUxFZnJReHJpeTRzYkNWMkpDRWFodHoxUDUwR3ZGazlWQktSdjAveitOQml5b1hoa2RneGRXTnl1K284S0RMTk96ajB5R0RTV0grMEFDOUJvRXJRRldrNGtFV1FMMUhTMUJzRXNna1N5WFZocWVnOGFDWTh5OGxJWmVob0xBVVVjV3Z5dnYyMDJOQkZVNWtCZGlhREY3aXlla1kza0tCaUNwR3YwbmNpZzVPVWtNcmpJdTJRNnN2cHlNQnhaZW9zTzFFVVpFcXZseUpFSkVJc3dTUHFScHgxOGFEU21aSTBNa0hwK2lvNWNIYlVHMjZraS9tb3E3RW16QXBIckFlaW81eGtCYjZiSVIxb0UrSEpETHptbEYxUUtoY2NuWkpON2ZDaUxGZURpN0pkRXVvVVcxQzIxUHpvTDhTQ1ZaT1FaVlZUWkNUYTRJdnJSVnlLMHNwVmlOYmNpTk51bFZHcVFJRnNibFFOUjhLaXVXY2lCNWs0SjZya2dNVTAwc2R4Uk5ZeGpwSm5sa1BBeGhRRllibGhiaUNPZzNvTytoSG9vRlBLdzFZN21pc2VaRENuTUdNRlgwdUJjRTlTRCt0QmZoUzhrT3R3ZEJ5MXNLQ1dVNDlQa3pzQ0NPTER2MG9PV3ZxR1FUcmtxYkVnaS9HeEcvbG9LR2xWSTVMeGNwU09Rc2JxZVcxL0dnSWN4akN1T3pXa25GcFFObElQbHNUdFFPYWYyNktWSXpvcEZqYXpzVzZ0Mm9pdEkvVGRwSDVySEllTWV1dzFEZ0h4L0tnMFFlMnJMR1RCZXlzUFQwdVNkNkVaOHZoRkt4SnN6bmszcHFWZGlCMHZvby9yUlhQQnlNaVVTQnpJOGE4WmxhM3FXSjFFWUZ0ZGR6UkdqRmYzSXFJMUpreDFFbk5TZzVtUHJZbldnellMTTJTMTdKT1ltYU5HM0VadnlKOE8zV2c2TVdYQmpSeWVtL09XYXk4cmYzQVdaYi9EclFYTG5EMTQ0dVN5MlIxVk9QWGp2ZS9mYWl1WEk4OGpJOTVFeU1nV2tpdiswNlhYd05yMFJrYU5wbWpUZ1MwbDBKdnhIRzV0ZHpianhvTFBiWXlrQXRPWkpNbFRHTFdCUjAyQlk3OHhRT0hKbXc1NU9haHlDRkRFZ2JEVjIwT2dvT25BNGxhS1AxVis1WkZVeWp5QXFkRko2aXFDVldkV2RWWjJWckJtWFJndWhKTnRMVkJrOWI3Vm5qa2k1ZXJxbkUrY0xlOXZtZTlVVlJMaVpFWkVzWVJWWWhyajB4Y25mUTdLYWlycDhkRm00S2JyRUFFa1VxRUFZM0pCTnRXdFJEeHB6SGpMa0xOSGhCK1FXUUR6RWxyMjA4d3QzcW9saE83NVErejRUQ081dnJaZ1A3MU94N21pNjBQa29KZlVNWldjQzdOYm10L0R3UGFpTUU4eTgzbUVZSElYS2o2YjdqUWIwVXBtamNveXhzUUZDWFk2RmhyWWtlYmlLZ3l5K3JDcWlWaDZpSHpZZ0RMY2xia2ducGJTOUZhdmJwSTVKSFRQaldLR0pyb3Q5UWJjbVFiZnRQbDhhQ1o5c2l5K1dTeUZ2VDVnWTdEOXQ5MlBVZ2E2VVJtSHRIdUdWam5JaWk0eG9XRGtFRUZEcGE1MUxXb0tNWEg5d09BemptbUs3V2tTd0QzUVh0cjM2MEY4bVpPY2Y3TWs0K1BFZjVvMXVEeS9iSVFUbzNhMUJSYjNHRDA1dnRrbmhWbVdQa1Y0S1NOTGRidnJ1S0twd1h2SkN5VC9BRzBjdk5KRjRrSWpNTlFUMTVEL0FDb0w4MVFmdUlZcEpWUlU2ajZrVUFXQTc2N1VITng0NThuRit4TW5xUGZqamdyWlhoSUxFc0IxVzFoZW9yWmg0c2E0bHlpeWNDelROS3pNcTh0QVZYVHpEcWZ4b21za2VMN2RseVJ5UW9pSU5YUWtPUTROanZzSDZDZ3FuKzJoeUZrRE1FdUZtZjhBN2dXKzNXNjYyc0tEcFlXR3o1Y1lhVXVwaVgwSkpYREx3WTNFZW13SjcwVzFCWGdoVDdTZUoyeUZKOVVvYitYVWdEZlk3VVFaNjRja1dNc2FlcExKR3B5SmhkV3R0eCtJM05GVFhGa09ORU1HTUlDT0VyaTU1QTc4ejM3WHFvd3dPdVF6aGxZeUczRlhhMGhJMDY5eU5OYUN5UE1FR1VaczZOblZudEt1aU9UNEU2QTlmaFFoelpja3lOeWsvamtzRDZzUTA4OTc4ajlKMUF1S0R0U1lrR05oUjVFcUxKTXJBNUw4anhaV0E0alEyMDhLUkhLa25pSytvQzNvcnlVY1NDYm5ZK0Z1dEZ4VGw1Y0VFTG5KUmpsU2k2c1R5RGcrVStjZEtESmt4YnhRamhJUXFuRzFCTmhmWHZ5UFNvck9zOEUrU3JqSEhxU0FlbVdZcUJJcEhIekM5aWRqdFFiVEI3c3Z1SmVVZWhLZ1V5bHBDL05TZnFQUTJvUlpsWnVMSkd4aGtCRHlFSFhqSXdIMU95N2N2aFFXKzFZM3RzMkM3S1hUTFdRQ0ZVWFRrRGNEWC9PaVhXUE14M21uNVhrV2JVeU14dGR1dmxPbFVpL0J4SXBzZVl5RGpBUndpSVAvQUd4Y1hZcU5UVVZyeVBhUFd0NkwrdkhISFovVFBrQ0xwNWZqdlJOVjVIdHF3NExOQ0NYTFdNdDJKVkxXdC9iMTMzb09KLzZKaG1xUHVsZG1WK01ES1NBQnFHQk51SjhhbU5mMGprKzI1azBDczBzRVVpb0k4bUNNV0RJUmYxRzZNZWhwaHJQR3lZbVYvd0NHb1huRVFycURvU2JOdytOdXRSZTBmY3ZhODFaZlJreUVsankxOVdHVkpBeFVLTGxTQVFWTnYyMVVsVXo1SWJEays2bmJIa0VTeHcveHM2enJzT1RIWFRmVHJVWEVzTXlZeGpreTBDY0kvVXdNaFdETjVkR1hsY0VNZWdvTzVLTUgzSEVpT05sckRrS3BaMWNNa2wwMXNwSStvazJ0UVpjajJ2M0E0NlNTaEpZVUpkVWxVRm43aG1HcHE0bXNneFZRTEsvQ1dQS1NRUUpaajZNa1pzcmFhZzlRRHBVVmZIN1JrNHppTlJrY1pBcmxwVjh6M0Z5eThkd3Axb2EyNWl5eTRBZ2QybFlYa2lFdXJOeUhRbndGQnp4Q3p6cm1GU01WVTlPUWh4cHlOcnJZWEhoUVR4MHhZcEpIanlJUFhabWg5S1pPZDQwSDFLemVYbFZTc3J6ZTJuQjQ1TW5weXh0eXhENlpCbVZyMzg0Mkl2cFJhaEw3bEFEQ3VGSzVCVkRsaWRWVXJKZTNrdGM2ZUZRejh0dVA3cGlSeHlLcStsTVVjQXFCWitXaFluWWpXcW1PTGsvL0FMVkhFY29SbU5PY1pVczNFLzJFRFl0VWFobkE5MXlpWlBWV1JZMkVraHZ4Sk54c2RDZDZJNkVjMkhrcXlNZVdScWdWdEFlSTA4eDArZFZGSWh5Y2RZczZER1Z2VGRTSjFVRlNWMlFyM043MUZTaDl4OXVpeVhYM0tDY1JzM09TT0p1QlVXdmNjdjdqcGJwUThUd1lreTQ1UnhQSVdNa1Vtb1h6ZERiNmlEVkswVGUxbDVuZ3hzRmhrd3lsYlN2d0xSMjBRamU1NjBSeThmM1QzajJ4MVhIWXhMSWVNK09RQ25IbHJHZVhnTmFpNUtxR1lNVDNLYWNzc1lzN3JDdm1qQ01kbFVnOTlLRUdSNlRRU3pwa3JPa2hSWmtiaHlabEYxc3RyOFZINTBWSDJsNTRGRE9oZEppQW9rREgxT0pzdW5nYVJQcDlzWWdhZERwYzF0aEhjaStsK3RCbHpzc3hjRXZjdjVWdnJyNDBIRnoybHRHUkc0QkpzUUJvYmE2OUJRV1JGWGhpQUpZOUxuYytOQnNrZVFoRWE3WDBCQTdkNkVTaFZUTVpXUzNBRWdrOVIySGpRZFhHYjE0VllqUmhxTnFERG13ckU3MjEwMDdBZUhqUVpKSlRGRmRiV0l1ZmllOUZhTVAzQ0lJb2RyQUN3QzY2MFJ0R1EzRGtRYlgwdDI3MEZzY2d0eVU5L05RUGUvZWdrQ1NDQzJ3QjEzK0FvSkEzUFhUWW1pbUFRMXo5SXRjR2dSQUY3Z3FCdGJ4NzBSRlgwSUJOclVFbzNpQ3RkajZoQTRxS0txblpsaFptTnI3bmNENVVHSEJrWkp3azF3dGlTZEFXK0FvTStSSmpaT1dIUWdIWTgyNHFMYlVFL1NqZEF2cUF2ZTRacmxVVWJrL0dndjhBYk1rQ1Vxc2c4cTY4aDA3aWd2ek1zUXlnM0xjZk1XR3dGRVhITWo5RDFWYmloRjdtZ295M3g1R1EzSWI5bzJKdU81Mm9yTXlsUWVXaEZocnQ1ZHdMYjBHL0d5VmRRVHNTQU8xejJvalhFT1RYOGRPMmxGVGxOaVZHeHRwLzBvS21lNmxiYTkrdHFCeGp3SnZid0ZFWFhqSzcySjJHK2xGUTh5QTYrQjYwUmt6Sm9oYU55QVg4bzVlTkJpbW1TUUhIQ2VtRnVQRFRYZWlyb0htOVgwNW1KUmZwa2ErdW0xQmlubE1HYVJ6UEYvcE50aGZxZXQ2STYyR0dDODJOMmF4WUhjZEtEYk5ZZVJoYXd2cnZyOEtLZ0xsTDIwR3grRytsRUlrQWFra2RQblFPUndFQnRZZ2EyNjBGZnJ4TndDT3R5cElPMXZuNFVBY2hEaWcrcFp5ZGJDL1dnd0E4c2dUcEdiYkVqYzBIUWhtam1MTURiaTFtdHArRjZLdUw4Q09GOWVsRUlNU3V0cmJudlJXYkthWVBHNGNLdklLVkoxTnowSFdpTkljaCs1SGJhZ1lQbDRsZ0NTZFR2UUlzUTJvK1ZCSUM2bTNRQ3dGQU1vREMyMituK3RGTG1MRzY2YmFVUW5jS3ZuSEZkQUQ0M29Lak1WbENNQUF3MFk5KzFCUEl4eGtJWTNKYXgwMU50YURselFZMkswbk9PNkh5aUk2TmR0Tkw3MEdlZURpaXNTWmNXTVdWVnNiTTJsbXZyWWRxQ1h0Y0RMQ3lxRlJTYkxxYlg4TGRPMVZHeVhLV09KYkM1VU1IMTE4UmFvck4vT2NlWXVHYmlBMGFteEZqVlJmaGVzK09JUWVWd1RKeVkzVzIxUlZ5bEo4Y0o2aE1vWmhJNStxL1VMNGVOQmhpMHRHN2hJMU52RVgxK056UUNsSkc5S01rT0RaZVI2RTZGanIrVkJvRXNzNm1QbGFRRUVvRFlnYmROcjBHbVhJV0xISWpJREtRdkE3Z24rbEJvamtQQUFrYWpVWHRxT3RCR2VkRWlMaXlnQzJ1M0xhZzRrMlEyZHlSdUVVbW9hUy83T3EyUDYwRmF1dVBFRlVzMk9vSStvQWdEdFlVTVFnT0hpNUlFTDgya1VPR0I0eUZXMjM2ZDZDN0doeHNvU2M1bWpoSjVXSnVDeS9TUlllVTY2MEZyTkdrUHFCakpNcEplUFp1UU81NldKb0p0bXpUSVoyQUNlVU1oRnhiWTJGQThlVkdsTVFONHhjTVZQbk51L2hSRnp5UkNOaUdaazA0S2RBUGxRUEVtbTgwYnNwY0h6Mk56cFJRUGRyTzBlVER3dXhWSEo4cG9NYis0eHc1a2l3UjhBQjV5UnlWVHZmVFN4NkNnZ3N3eUhWcGs0U01qZW1ObTVEdGJ2MHZRZGIyeVMyS2p0SnlML1FDTGVXM2pRVTVwVjVBSGZoZTRCR3RyYTZpZ3orMzVSaW5sc2haV0toRjdkT3RWSFVZeXl0NUY4aW5pNUZSWEx6TWVIMTJLT2taSjRjblhScjZtNTI4RFFWdzVIa2FPRm1hd0t5a1dDMkdwQStkQm1sNUxlV0dSUWJBUENEdU9pZzl1OUVSeHNqMGVMaEJJVWEvb3ZaZ0N3MXUxaFJXMlY4TVNSeW9pZ092OHF0b1VibGZicmJyUVBCekhFM29CdUxNZjR3dWdQV3dGQXNyM0hFbkxJcXBKS05WSmExbUJ1ZFIrbEVjWVJwZFVZV3lwUDUxTitJQkxhZ2dmM2VORlR4WlFqeVJTek9rMFFaVWdpSjh3QjFBWS9yUkVZNEEwcXV5bFVVTThjajJQbU94a0hhK2xBR09ScG8xTjR5UjAvN0xQSDVnQTNjZDZDNXNhUXhOSk9TRkREVk5YWm44OXVTYkVDZ3R6Y1ZvWTE5T1QxRlRYbllYQUkxVURVNmZ1b1ZtKyt3MWpFUWpCNGZ4dVh1QVExdGdldXRyMVRFNGNXZkl5RzlSa2llTUFJSEtxcFpUb2dBM3NLZ3U5d1JmVSs0bGhaVmtzakc0Y00xN2tDMzdhSFRMS1pKSE9VQVVrSktMTkhZY2RDQjVkNkRxNExaa280K3JKRTNwamttM3EySDBoZE5kYXBITTl3aUtSclBGZHBiajFTb3Y5TzJvN2RhZ2xoNEVndE5NaGIxZ0pXUkdVc1ZGK0pGL3B2UlUxKzJqaG1aTHNWSWVaMmF6Y1dPdkZQM2FkYXFNbVhqcDZjT1lDckNTUm83a25RYi9BQXQzTlFLV0djRGpGR3B4VnNGa0JJZVhsYTExWDZ0VHZRYjRzOW9vWnNSSVVsUjdzV2pKK20reEI2TFZST0RLNE9zYlJDWXNBTE9CeENnYThyVzBxS3haV1JEeWx1bjhia1hqUUVLb0lzV0RFYmNkS0RKR3FTbkw5R1F5WXNmQVJ5RVhiamE1Rjc2anB2UWIvdmNmRzlMMXZPaFM4c3pnS1dMQzlqZSt2OUtETkZseUpISXVISi9GbEZWa0oxSUJHNmc3R2hoWmtudVB0dUJ5ampNZ25EaG5ZSDBpMXRkQnNRUENnb3dQZHZjSXNTUkU1SEZuQU1zUnNmVVp2cTMxQkZ0eFFXKzZ3WXFySG5SeXF5ekFKQkdEeTRQL0FHeWdhOHV2alFZa2JDVEo5UXpCdUpBa1ZyM1ozTmllSjZMdlVhYnNMSngybHljSlloNmVTYlJaQkM4aVZJUElCdWpiSHIycXBqTC9BTWd3L2NsellIV1dHS1JBUnlQbFpWWTI0dURhK2xCWkZGTDZTL1pSaHVJdDkzZmh5RERVY2Y3dHdDS0RPNW1FazJPNFkyazlRY2w0b3loU1c4NXNWUDhBdDYwRWlXVGljK0g3Vk1xTVRSOFNKUTR2WkhhMitodlVWVVJoSmt2SkxHdVRESzkyU0kyVUVDeW01MUFGL3dCMUVpSnlZVGxpSEd4d21TU0hlWXVXV1Ftd1ZTRGFQeG9yYzJWRHlreVU0UE9wNDVSQ01nRDlndjBrZE5LSXVXVEhjQjJqakxHUGtyS2JiNkVFVlJQTGxnbWo5Q0ZCaklVSEJnRC9BQ0VkSHNkQUtDaUwydUptaXlNVXU2QStmS0F2eEorcXcvZFVOUXo4ckNaeDlzcHhzaU1GSm5kUFVVbnh2YytJcWprKzQrcTZ4U015OEdzSWdmS1RyNTNZYTZEd3FLaDZzaXh2TTZTSmp1R1ZWSDBLQWJBMk93dHJRYUhXUDBESkZHeGdsc0V5T0pXUHlDeDF0WTBGNXdNZjBHa3lCY3huenlYRFJvUDI2RHZWUnpzbUtUSlRJa1VMTzZCQVdRMktrTmU0dnJ4TzJsUldZUlllTmttQkZsbmV5aFdDZ0FzMnJxdzJJL3ROUlYrUU1XTnpGQkswOGE2aGsvak81dEhlNStrNmFWVWJzYjIzRHlYWERoNVk3WklLZXV5aVc4bHJtekhpVkIyb2hSZTNaZUFQVVIrTEtxc1pVMVRrQmEzL0FNaGJZOWF1R3RNMDhtWkU4dVN5VFREanppQUt1ZVhVYVdCSFc5UlhMeXBzTVBhVkpqS3BKeGpvT2FEeEZFalI3ZDcxbjRRWUtWa0FIUDBRQVdzMndUdlFxNmIzL3dCV05sZGY1RFp3Mm80SGZWVjhwK0JvWTVvZ3lYVnBwSEVnbVhrSkpCWURtYkFMOHZDd29yTk5BdnQrVEEzdXdNV1BrTXlySkNic09QVmtQUWFYcVZZMnZrKzFEM1RIKzBWb1llSWd5OGx2T2psckVsUWZwVzJ3RlFZL2Q4ZUo4aWI3U0JtUGwvaVIrUkN0b0xYOHh0Yldxc2N2Rk11WXVMN1hrU0tweEM4bUxjQkpTUzEyVXVkTk9sNmgrMW4vQUtvUUZCbUxJcEx0TEloWFF4c0xDUU40SGFoTHJzK3p5NFUrWkhqeXM4VWcwOVdVM0RXMFN6Zk81TkV2VHY4QUgzSEFhZkdqbmhteUNpK2tsdVJLTWZNVU94MHJUTzY4dm0vYVJCNDU0L1FrWTJqVlE0YXgrb20zVHFSUllzZjI3M0hqSDZHUThtT3lsRms1TXdSVHRjaXpMcDlRdFVWbWpWc25DUm55VWFTQnVFYnF4RGNRYkZyblMzYTFSYW1aVTl2em15QmxSelJ4QUprWVRqaVpGT2hBNGszQUZDTVdLMEdUS3l4WXBYREFKeVZpSUVwUW00czJ0K05CUXZ0K1hQa3lDZFgrMFA4QUtza3dJYmdEOVE0YUN4MUpvYmtXSmFLQ1NKMVNETTRlcmhHeFlTUnUzMWxpYmFXdlFhc0p4Nk12L3NJbWFkaXpOT25FUklyTGNXR3d1ZDFxcFYwVUp5Sk1mTDlGVWlZRVN5SW9sQktqWFM0OG9IZWhxT1o3dmh0SWN2R3cwWEhWMldWWmZOd0FVRFFhRUUrTkRHWER5Y21ERGtrVEdXVGtBWDVpNEFhNUFVNjIwN1ZGU3gzOTFXRllaQkVZb1Q2bDR1U1BZSGtSeS8yMzZpcVhGV2Jtcmx0NjJaQTgzcXNESEp0TGNkU3dHb3Qzb2tqcmUzd1EvYkFNeGpibFkzSEdNOEJvcEs3M3ZTRmRMR2dqTVluS3l5MlBuMTFCNmViZjUwVFhNOTFqbWdSczZINmxMTTZOeGtWVmJjT0gzWlFiMHhaWG5zdURHTHhRTTV5WUdXL3FSMlVxWDFWcENkZE8xUlZROXM5MWdseFpIZ2tTU1ZnY09meTJaQiszaVRhNThhTHJyWTVsbjV5eVpZbGJrc2Zwb29SOUZKR2pYV3luUTYxWWxmWEdOcmc3ZGpXbUZHWUoxeG1kUEtiWFU3L09neE9Zc3VFcHkva1FnaGpwNXdMNlVITTkxbW5rWkk1UEsvRHByWW5ycDRpcGExRmZ0Mld6bVBtd1gwZ0ZLbnVUdnk3MGlWcjl6OXplR2RId3dYSDA4MTJEYkVXOGJiME1TNU13TE14dG9YMHZvZDlxcU51RDdoSjZSalk2N1JIYlFVRTh2SW5XR3pjV2V3dUQxN1VHR0tJeUFldXdBTjduNlFEdUJRUURwSEpZTU9kN2p4c05LaXRzT1pLVk1aV3gvYzUwYXFqVGp5eXczRExlOStQZXhvTGx5RnRjblM5dEtDMVhSOUFmalFXdU9OZ0xna0EzTnRhS1N1UjVpQ3k5TmVwb2dMa2dqYTlqUldiSnkxZ0tzeWNpNXN1b0Z2RStGQ09WN25rVHg1cVN4S1hLcmZpRGI4ZmhXVmRmQmRwc1ZXa2EwanFTU05nZmhXa1lKWVlvWkNKSEJZYUwxdURwMDJvSlQrbkdpeFFRcTBvR3JIWFRxYURKa0VxRC9JdnE4UUF1ek1XRzF0cWlyc0hDa2ZINTh3RVUyQ1hzMnZqMXFzcmNnUmNVV1B5STkyTGszTGp0NENnMFI0Y1RZaXh4eVdYVnVRMnYxdlFRWE1qanVyK2Rvd2JFajlEMXZSVmJ5Z2w1WXp6aS90QUZsSFlFOTZDY1dRek1GZmlvK282YXI4S0RveFREaXJDNERkOUwwRDlkcE14azBpaVZiaGlkUCt0Qk1mVVFOVHNMVUZzYm9vODMxWHRRTjNEbGVLOFYyb2l1ZWNSdUVjZ0U2QURhNDcwSE95cGlIS3Vsd0NER3gzNzBHWkpHU1B6a3ROTm9nYlRXK20vaFJkVGNNaU5MTTVrWmxzaFkyQUIwK1ZxQVRIV1NHMWk2N3N5NjZBYVdOQjBNVlFpckd1MXJsdjAzb2pRdzFCMUkvclFXS2lqNmlWQitmeW9JTW5GaHBibHFCZTV0M29Jenp4b0J5SDFqanliVFh0cDNvT1dFOUhJNXpQeUJ2eFFhZ0FEYTFGVkF5U0J5bGxDT2ZLVDFQajRVUnZnamRBU3JFeGthTGZVbTJ0NkMzRWlLc1dMazJPb1BYU2cxRnI3RFkyb0JiRURTL2NkUlJWY3lZNUNzOStXd0ExdmJ0Mk5FUnhDTHN6YW8rc2ZpTmdUUVhQdmNEOEtDeEpBbHhhMXhZbTE5UEM5QkVQeGpJMUxFNjNHZ0hmNDBBa25OUzQxSXVUYTVGaFFLT1FjVGF4RGZ1NjI4S0N1WW4wbVhsWUFhRzF4UWN0c21hQzBqUW1hSGxjQTZIbDFOejA4S0M3SDl5WnNvc0h2QW8wSUhtNUhYVWVGQlpsREhsUXRJU2o2Y1ZPclhPbHdCMG9Nd01xdy9iNDVIQ1BrekZ0T0p0OWZqYWdvTXBXTXhSZlQzRndXTEcvSW5UZndvaTE4YVdOUVVBWWtHNFlYYlhVYmIwVjJNT0srTWdhd1lnRmw4ZHFERE56aHlENmFBTzNLN3NDQUZ0ZnB2UkhMYVNXVEk5WEdJanlFc1dZM3N3SXVScDNvcWNlUTdRTTBuSGNxN216RzQxdFlVRUkwaWQwbFptV0FMd0lBMk51Vi9INDBHbHVDU0pKRVcxQVFzRC84QWJVOXJVRnNzOGJnaVFXU1RTOTdNUU5kTDFVVXlTU0xNclNSc3NhM1pvanFUYjZSY2RlOVJWczgwcXh4cEllSWtia1hiWWFYNGtHZ3o0cXdzODByU3A5dUFiR1FXSEluVWp3MG9NaytPMGtmT0NTNnlOZDJVankyK215ajl0Qlhock8wTWhadU1rVEJENWI2SFRydWI3K0ZCc1dlYTA3cU5JQndMM0lCSkFHaDMxb2d4WGZrWFlLbU9oREtTYjlkUTF0U090RlFoaTlWOGgvWERRSUEraDFJNVgwUFhYOHFBL2lqblIwLy9BQkRZWEZqcWZxSUY3Q3hxbzZFdVZBOGFjbVZUWTNiWWdqVGVvcXJIbENUTTBybFFCZEhBSDhsdTNoUVoyZUIyV056Y2NiSWw3dHlZN2VGRVY0dUtzVE53YVNRR1RrcUFmdjhBOHJkYUs2VWVLUWc1c0hkd1hrWmoxdmZYL1Nnam41K0xFZ2tqTEFKNVl2amJjZ2FXb01PR1h5Sm8xZFZzNU55U1dBRzk3ajkxQjA4dG9rSEdJOGlCb2Q5YmJYb2pUSElod1BTUmlzckRvZFFQOTFGY3ZLZG9ZbWptUzVIRWw5d05ORDQ2MEdTT1h6dVZsWjFpSTVyR09KNG5WeU9sdTVvQ1hLamYwa3hrRWE4dkp5K2tYTnd6WHRmeE5CUUpYZ25PYms4TW1PWFZZbFd5U0VEZmlOZDlyVURpeURsVGhGalpQV0JhTnp5ZTdpNVpDU05MRHZWUmVjaG5aY2ZLQ3hzNUxOa0Uvd0FvRnJjZE5kL3BxQ0VXUGlFU2pIVzhDYXJQcWJBajZwT205Qm14OFVQa1N6ekZvOGlPVDA0Q201c0x0Y0RYamJZOXFDOThuSmhsUXhjZnBKS3J2L3R1Mjl1dHFLZ1kyRUx5VHVXaklBbUlCQkFLNm5pTkFvZm9UUTFjbVd2cm9zanE2S0NzT29aZURycTNGZGowMW9NOG1UalJMd1hteUM0ZFk5UE1OYkxjNzY5YUkzSy8zY0VDTmNQeDR1cHRjRGNxdHIzOEwwVno1TU9TYkxra21XV1JvNHd5T3BCQ01yY1VlUkNMRW1naGpUM1lMNll5Y3Bpd2tkLzJzRDVUZTlydFJIUVZaOGFLemhSTklCYTQ4MFpiK3diYWlxaWlmR3lZcFZLdUxCQS9xcmJVZEFTTzNXaXA1VUhvNHNIdVAzYkd3SkVTa2N0QnEzZ3RCamd6MUU4Y2tDcFB4WmxrRmllYkhZZ05jY3UrbFJXMlY1SjRRa1FkcFFCY0FEUWFuaUxiZUZWR2ZBaEdleWxpWW5pUzhMTzF5NUp0eU5yM3NmcXFCek5MaHp5eDVNYVR4RzNFL1NMS05WQkdnQm9NeVE1ZVRsUlNRSUk1SXJCRkYxalpWT3JCdE5qUldZWldSaTUzSldJeW5EaVZqYXhSamJydTJsN1VScWt5Q2tLRlpQVVJ3eFlENnd1bHdmRHRRVlpzcWlOakc0bFljVWRlSXZ4VWZHMjVvb25mQ1NOb2xqZUo4aEZab3dDWXpjWENoUnJ2cUJRT1pFKzdnQ2tUZ3FHVWdGZ1d2eDRhMkJBdFJCa291RzhVOEVYRlpBd2xobElhUG1ObDh2OEFiNDZVRmlMUE1vS1NCWFZTeGFZOGc1dHJ4Sk9uWUEwRWNhTEdrVm1NaVFTVDJWVmZrWkY0alVLZXZMclJWR1RMSkJrWThyQlp5bkVlb1NvNGNoWmgzSUEyTnQ2Z1dVTUdhU1BFeG1LdzNMTkZ4OVFGOTJJT2x0TjdWUTh5S1dHVWdRdzZvdkdlVnJnQURrZ1ZoMTZhN1ZCbXo1WGN4bG81L1ZrakhxK29SZTJwYmh6NmFhRHRSWTI0WXhQL0FGS3puSU9MT3BWNGkrcUVFWE5uL2MyM2xxb3daMmRHeUdFQW1DU0I1dU1oUEwxUUxGelkyTFdiUzFESFFnZDQvWjF4WW8xTHhrT2NvRG5jeUxzRGJxS2dxeDhiMjI5NXNuK1plQ1BHZzRzYkhiVUZUNVRvZWxCSDNITGhta25hVi9JRklYZ2lqbUEzRU5JRG9iSGUydFV4NTlNd1llWmFNOGtkR1ZsWnVFUmt0dXJIOXhGUlhYU1hLaDl2aExxL3BQY2hqcVFUWWRkeGVnaGs1eVNZQngyallQR3pBektiSTBRSUhHNDNjbnFLRFo3TDd2bitvK0M5ampLRDZSWThGQXRhek1vM3ZRcG1NNDBzME9TTG05bGphd2tMMnY1ZHhRY2pMV1pzdEdnUlhuajMvc1ZOK2xCdmtsanpNdHppS1dsbVQrZUNROFZ2eDA0Z2ROTDdVTVhlMlp1TkI3Wk9rOGNwaTRrY3l4OUgxQWRQTHRjOWFJcmh4NS9jTVNZWW5PUlVQTDBJZ3E3bTc4aDJIUTBLcVB0NWlpZ3krS21Nbjdkb2RGWlpYRndDbzMwNi9qUldqTjlwZWZCWjNmMTRWZG9vakhwTEZJdGcxMXZ5NGlnNGNmdFdWQUZqYU16bUlreUJnQXdHd0MzM3Y0Vk5VbGlteE11OHpTeHdTSmVDT1FzYnJ5MjF2eDEycW83dU5rdTBaVVNUZWxNUUc1RWczR3haUnV3N2lxak5MN2xqdXFvV09EbFFzUjZ2UGxFeUgvWVIrdFFpaDhHVElVcDVJcHdRdzFzYk5xQ0xmU0NLU3JSbFltSkJDM3J6bHNxSkFJSWtYZlhWYm5UeCtOQlJqUUtrVWlvUkhMSXlmeFMzajVGZHJzUis3d05CWEJGUGtja2FJTVpQNU1aUTkxampXN09tcDFCdHRlZ3pSU1lzczZSc0MwU25tcnlIVTk5Vy9BYTFGeFJOSkpCSE1nVGpqdko2bUxiL0FMWktmVm9COVNxZEtVaTl2ZWs5d0VZbmIwbUNnUlNRamd4RjlRU3RqdDFxTG1GSDdSTEptUXl3R1FzN01JcDFIcU01YlRqeGJTd0cvV3JVMVBQWEppeW5TSlpXZ1JTc2h1V1hpRHg1TXJYYU1YL2JRV3hESG1naGtoQlVGd2lUeU54akRuOXB2cUQ0MFJESXhzdE1rcjkwcnZHZWJUWTRaNHJKKzFkdFFOeU42S25ndERLeTVMeThrY0d6U0VuWGxmUysxQzhJNXVWRzVsUlFaWkdMU3VpK1IyWWplKzM0VUpISk9MTGpRcGVPWDA4citUSVhpRGRiMlBIUzFSV2w0c0xHbkdQbVJpZUpsQVdhTVdtUm1Jc1gvd0RpTkxVTmRLYkJ5WVkybjl1blNVUzJ0SkVQVGRsQXN3SXFvckNac1RyQXMvMlFsVDA1cFZCYTZOdmNMYy9UdlFZMzl0a1NCMGtDT21vaW5ZTUl4d2J5aGI2Z2NlbEZXajFKL1RpYmo2WUFsbVJDYlNXR2hKK0hTb21OTFJlMHcrcEpoU1BpMzBlRjc4UUQzSTNGNnBKV1BJeElaR09USGsrbU1oaTBxS29KTWFqek1WR21wMkZGWnNTSXhIMGtaMXczSWRyM1ZiblRpZncwb2E2T2RpWm1PSS8vQUJrNDVQbVhJamYxSFZDZVBKaDNJTkdZNU1SeElKbSt5OVRNUkkyRWk4aXJvNVBHd1U2OWFqVHIrM3p1a3h4bzhjeVNSM1ZJblBGZzF2TUNHOHA4S3FMSk02ZkVQSlVkY1pyQmxjajFPQlA3YmJnMVV4eXNpVEptOXdSemhyT0xjM1IySXNmRy93RFdwV29uS2NWOEk0ME1YcFNTeUZzNVZzUU55aUJkL3dBS0l4UDdmbXh2SER4OU9TeGtReU1WS0FkU0RVYTFxeG9zN0htR0pqeWNESlpYUWdNcms2NnQ5SkFOWHBPMzFlU1pFeWJsamRoOU54YlRyV21GV2JrQWhkTGczNDhTQmNnWDQ2OTZLNExad1YwV0dGeVZKa2trTGNWVzIvSyszYXBxWXQrNUdZMFVvVUVPU2hqWFVFOUNUcHBVVmlSbEVQQmJxOGttNTF1Vi90dDBORktTVkY5MlRHalVDR01BTzNJRmpmVStHOUIwY1QwNDA5RStRTVN4dWIyc2ZIUUN0SXZrWWxiUkVCMkZ6c2JmL0dvS2c4NTRjbWNGVDViNnNiZEtDU1NFcUZJNGhXNUtuVmlCMUo2ZDZDaG01dVcwNGtYdFlXMy9BRUJvTGNTWjBkSUNwUnBOT04rV2dQOEFXcU92eTRrK29DekRUa05SWVVHVXprdW9ZcU9Sc3E5YURUQmsra2Q3ZzZBN1VSMFl6SHN5bmtkYi93Q2RCYStPd1VPUllOOU8xNkRMazVTNDhhc1Y1WE5yaW9yRjd0R3NrQ1RGQ3lxUVNvM1llRktPVGxUbkluaVlNc2N0aUZ2cUNCOVdvOEtLNlB0K1JER1dScGRVVURpT25qNFhvaGhua25WbElaZ09ic1I1ZUI2Mm9LRUtTNUJaRHdTeElsVytuR3FLTXJTYVVScXJxU0J6R29EZkdvTk9MaSs1R0ptaVRsREZmMUdCR2x4c0Qzb0VnUVNPc2ozQ0R6cUNXNDZhL1BwVlRHckFtaSszY3lEMDQ5MVEzSk9sQnpmZVpzU1NIMDhlUW5JUndHUkJmaUwySFdwV28xWW1SQ2tNVWFnTmZUaTMwbHVoUGpSRjBnTWs2QzRRbTMwM0lGdHlmalZSclJKVElKV1htRDVWSVBRZFRRT0QrYVV5QlJaVGMzMjViYUNnNk1UbFc0RUN6QzF4ditQU2lxY3FlR0JpSkdBTndEWTNOenRlMUFzTEk5ZFdZcjZaUWthbTVQajRVRWN1S1JDaldXVHplVTNvaW1UTFRtdklha0VGQ043NkMxRkJFV1RHOGJPRW1VVzR0dUxkalJHV1dXSklnbkpuS200YXdJdWVud29Ca3l1TWJLQVkyV3dXL0VuaWIwRjBXZjZicEZ6RnhabTVzQzFqcnRSWFFneWhPeDQyWUJyRzNXMUVYU0padFR2clFKaWVWbkFIZlNnaFBHc2lGWkxrV3NDZXc2Q2l1VEtrVUxlbmRuaUk0OENiQlQvdU5FUWdHQkFXVnZQSGZramk5bUhmNVVHb3pvRkxDVVJwRnNDTld2cUxDZ3p4KzRTbVd4YTF4Wm10WVdKMFB4b3JUZ3pzY2dxemxsSXZ6TnV1M0dpT2pISUdjSXJBa2Z0WHQzb3FyTFJnaTNRRU1kUWRQd29sWmVHVnkwRmd3QVlqKzNwdFFiNGxlTkZCSnV2WHJyUU51UHAzTGZUMFBZZGFEbmZlbCtZREd4SkNLTjcvQU80L3BRWExOTkRDRWdZa3N2QndwdFlIcjQ2MER3SlRKempLY0RFZVBjazdHZzNrbzNKUW9KSHoyb09ON25qb3FTQWhTakFONlRrNnR0ZFI4S0NoSVc5QXMwdkhrRkRJQnJZRFMxdGFDNkZCRHdSbnVENWdiWElJNlgzb0tzdjBnL3F1d2lYVUJBUmNnOSt0cUNzWnVPMFNjVWs0TGV6RGJtVG9BcDJ0UVd3NCtWa3dsNHh5ZFNENmpFM0o2cUxiQ2c2MkdKa2dYMVY0TUI5STJBSGpRUnppN1FzWXlxbHdRdDl0UnBRY2ZMRTBLa2VtRlprdXJDNFlXR3A4YjlCUVVtWEhFVWo4bS9uQWF3RmdCb0QxMzcwQkhrWWlUeU5LeE1OaXFNMnNpa1c0N2RiZEtEZDdmSGp5eXl5RUZaa0lrSXRkUUcydmZUYnRRWjQxT05JOGpFTkh6SUMzdU9PK3AzdHAwb05MWng5RGswYUdOcjJZRWx2QWZHZzV4bWtrbDRTSCtJWElNdDdjdHdMVVRWZVZrNDNvUEV5SDFKbEN2RmF3RFh2ZGJVVmZoWmVQanE0SVk0M0Vxa3JxR0dodHhzdHVKQjcwRm9LNHYzQnQ2a1lHcFVnaTdhQnFxTXdpeUg0U0NJcEZ5djZpbTZ1cDFQSTMzQTZVSTFFWk11UThNRXJ6UXFRVXNnVVByOWZXMWhVVlRKRnhrZ2tkZVRSbDdSM09oZlltMXIwRm9kWlZUbmJuSmVOcFYvY3k2OFRmWUFhQzFWRVFyTkU2VEVJdi93Q0ZiVUU3YlcwK2RCcE9PZnVJNFlmTVlsK3VROFJhM0lnRTZiMUJubGx3NUpIbmpZdEdoSEpXRmlHSTB1M1hXZzFRTml6VElaUzBERUgxMXRZS2ZsMW91TTBXVURKS2pTRlBUVzRSaHhONzZFZzdpeHVLQ09iTUpzTVFUaElUWUJTTlBQMDFGK1Y2cUk0Y0hETUdOR2JPNDg3QnVPdTdFWDZFVUdncFBiaVNvVjdLUm9DcWo5YjlhRFJINlFqa0tzeFVBaGlBT1hHK2dOUldTV05KdUxBaThBWnJOMU51MSsxRVNsNHlSdUE2cndVSTBTampaTGh0dXRtcW11WFBIaStTYU55ODYzOVJWQUsySjBUaWRMYTFBbE1jMGdPUkN5S3FNRnRyeDRtd3YxRlViNThQTW1jVHl6U055UmVMb2JFZExEWWtBYVZCa01Va01ybmw5SkFZcUJKcjhUcXQ5cW9xZkh5a2hiakhLVHlJKzJRbFZJdGE3VytvQytwcUVhc2pIQTl1VVBLVDdnckJRRVFmeUl3c1c1QTNGcldGQmRERjdYam96U3hNRG9ES3h1QXhOMVZPL2VnSklZMk9RaXVlSnU3aVc0SkIwRngydWRLbzV2Mnp0RTBnVlZpV1JWbmlCQks4UnViQzY2NjMycUMyT2FSSGt5RnZLN3FPYkVBRjF2YTVzTER3TkZhWW9ZeUZ5WkpnenNoUEpTUTRVRHkyQTZXR3BvVnp2Y0d5SEFkSlNDSTBkbTQySnNiOGJEU3c4ZDZxT3RDTWZIaVdmS0lkV1lPRHhEdXBPdkM0L3R2ZlNvS1BjTTdIeUg5S0pUR0pKUU9kck1SMFlnNldKOGFBZDhxTDFvRVQwc1l1QU9SMzB2eDdrK1UwS3hUcWw0c25JaUgyRWJEaEpGYmtWdmE3cmNrK0Fvc2FNaWJJZ21tYUJFamNrT1lKQUFxL3RWazJLbFUvQ2lKeVRKanNzZUxsTVp1Sk0wOXJQR3k2WGpLNkZXRkJ6c1BMOURGSVZIdEMzTlppQ09URTJSV0Z2TGM2Mm9ORmx5WmtseTNKalJKRE1pQzNCaCs3bnFQblZGQzVlT21KNlBwTmt3amtZVE16S1JzUU9JT3Y5YWdweThXZkpXVE1RbG9BNktrTWg1T3VuTDY3ZlJZZEtDMkpYOUozeHBYQWhIcVFFZ1c1RUFNTGkzVDhxQ01XTjdlTUoyaWFkY3RJeGJIa1VQSDZqTnJkdjdXNzlLS3ZnTXMrY3NIdHhReXRxL24wTEFXZEU1YmkyeE85QXBNZWFScEFvOU40VjVHRnlxY1FEZHdwSjF0MkhXaUtXaEQ1a0JrVzZtdzRLYmNpdTNPKzF6MG9Oc2Nxcm5za3lpUDFlRCtxeHRIR1YyRmhvZjYwRWMrVEFqa2pmSVNUS2g0UDZRZzBBYis0TXdOOVRlMUZjT0NQRG5jS2daM2hZRlkzdUpIUnR5TmJYRnRLaXRtZE5BTWh4REgvQUFZM0YvU0pOaUxDOW1IbUI2R2lhNTR6VDdqbERFKzJiSG1qWm1qSWN2NUpEZjAyNUN4Sy93QjFGeEJmdkVaV3lNZzVNRUxza3NRYTh5eGtXc1N3MFVOU2thWXN2M0NMN2ZIbGt4NXNSMTlReEU4b2xKdlpuSStrbTIxTk1WU3c0MzJrVW9OazlRaFYxWnhmZU5kVG9mMjNvTmkvOGxpd29UaXdrbzBjbHBYY0F1M0t3NE1nMFBnUlJNMU9QMnpBT0lXbXhaZi9BR0R1WGFVTWYvMmR0ZVBEY2FkVFFaRnhNNXN2S2hpdTJPeUF4SFM1Q2krcE9nMzFvcWovQUk5QkEvcVFaa0lXRlZZNDdUa0JPU3Rjalc0ODk3VUswU3JtVG1LTU9PRXA4c0tzemVrb2I4dkMxQ0o1dU5Dc2tXT3F4SThhOEpTSFBtSlAvYzdDd29OQSsyUUpFaG1ramxBTVpDMkFjbTNJRUcydmpRVSs1USs0U21KcC9MNXVIcVg1Y1d2OUxEVFhUYjUwU1J6L0FFOGlITkRReWVueVBwdTEyQ3NUcVYxSFcxRmRERzl1OXltOVBKVmxlUnJFeVJnQW9nMDFIVnVob2EwWlNUNUU4dUxBRW5SdG1DRW9zaUw1d0ZKRzNXcWpuNGdHQzhVY2dtZ1FYYVlNT0xEKzNqWTNzZHpVWEduM0xIeE9QcnBrTk9TREpJYkV5SzNIekE2Z2E5YUpISWl6bml4aEhIS3BlZVFXeGlENmhVajZnMXRWSThhTk5zOGJyOXJreVJNc2N6TUk4cFpBM0YxR29LQTMrQk5FaWg1V21lUEhhSWZkcGY3bVh6T2tvT29JdmUxbDBOUlhvRm5pZ3daT2NZamttVUdLVjFKS2hkd3BPeDhhckx5L3VxeS9lcEZrY1VaV0hNbm9KQVBPYmJnQ2xXTW1jLzJFM0NGMWRHTmhKeVBOMStXM0hwOGF6VitWOEdaTkl5WkhwU3lZOFpDeElpc29DN3NoTmo1cjlhb2Z1SHVPS01QSGhsQlptSktRa2NXUWtHOXllbllpcnFTTFBaWjhXTEVuamRPYk13OUYxWUJFSTJQeDZWTlhGK05nNVBxdHluWEppa1U4VkRLNm9EM1VEUzFCZXZzMkI5d0RKNlU4S2ovdFJ5c29ITzMwZ2k5KzlFOFovd0QwOEVjTXJpZTA3cTBiUW1NaG9rR3EyLzhBbDM2VU5aL2NNL05pRWJua3poUXNmR1BpQ2JicUYwR2kvVUtLeXI3aDYrVGppVDB4TmtKLzVFN3V3U1RqYzhiQWZVZTVxTGlDbVhLYmhIait2ajh6YUdQajZpNlg1T2UxdGozcWpQSGgyU0gwOHFWRUxIbEUyclFtNDh3WWIxQnRYMU1qTU9NczhXTkR3QnlNaUVmeHZKMGtaRHNmZ0tFWmZkTU9ESGFhRzZ2SnhESklDVksyM0JIaWU5V2txWDNQdXVCZ3RBWk9XT1FHRDJzd0xMMUoyRGYyaW9PbjdQN2M4Mk5seXZLa0VkbGtNa3lYZFNkUmR0MTVtckV0WDRYdUNKa042MGFtTUVDUjQ5RTVBVzBIUVZGeXVsN2gvd0NsTWZsWUFrZ3ErZ1BmZnByV21KYWhrLzhBSnd1Q3VJc1N1OFRlbTg1dG9lNEg3cW1yanp2M2ppVXBKamNmTXl3RU1BaE1tNElhelg2NzZWR2xIdCtYZ1NaNnk1VHNpRGtrY0E4NitZNm8xenl0NDJxanJ4NG50V1BoTUVTZDRKSTJPU1l3cENzMzBIbFk2YWJHaWNzY0JlYU5ZK0JMd01HdXBDdndHaXFBYnJRcUdPaVpGMEVjalRvM3BMQ2pEVzl6ZGJkdGRSVTFXTE94UFJ6aXNMQ0htU1hhV1FBTTZpNjhuSDc3NzlLdElzRStMSmo4VmtIM1prdXNnNTNrVUR6QVgyK1oxcUM2R1JaWkVPVVFBaUt5QUEzc0RvdiszYXFGN2xsT2s4R2ZqeUJzcmFTUWNpdzVINlpBd0lObDBxRGttWjQ4bGNva2ZiODJWY2VUVmhiOTF4WTJONkxqZFBMbWU1eCt2SzRsa1VBSXJTS3NnWHR4WStZVzhhdXBtTzNnZXhuSnd6SVhWUFRBNFJ0Y2JiMjZVak51UFFlOFRlckhrUk96SzhSdkVVQUJJT25IV3FzUndNdjFvbzQ1ckx3U3dqWmdUNVQ5V2xFeHhwbnloTE56VmhGSTF3TkFoMy9jYjZlRlJTZTBra0xUaGpHQUNFWHlnNmZVTGZoVlJ0ZU5JYm01Z2lBNUlMM2V4R2w3RzR2VVZYanFzYnA2Z1FJdzV2eUFJSllkeHQ0WG9KR1paQTZjQ0lpVlNNS1F4T3ZmdlZHNkpZWWo1aWVLNkVEVDVYcXN0TW5JTUcralFOWWFuYTlSVkJpY2g1cFprampSZVRLVzh4SjJBOFRRUldlS1BFa2tzanNEWlFkNzIxSnYyRktzV1lNOER0R1VMRnVONXBRUnVlZ0o2VVJyaWxMdEtRMTRWOG9IKzRiMm9NdVFRQ21TV0xLeThVQjExSjdDb3NhSW1rQ2M3QW0zMGRmbGV0SmpxNFUxNGxMZlhhNUIzdlJGMDJVL0VBa3NmeEFwcXNHZG54dkJKSEc1VnJXTjlDZjlLbEk1aWU2eVRlM0JTR1ZtWVJzQnVGK0pxTGptdmZIUmlHNEZuS281ZTJoR3RyYmswR2oya3VNZVpndDVKQUI2amtCU3Y5NjMxT2xCMGhKR3pQS3NubGpVSXAvdUo3QTFRNWlGUWhydHlBQ1JxYkR1RGZ2ZWdwZ0dNNlNyWUdVYXNTYklPK3ZlZ3VPUkdpUEhHM0JDb3R1eHQydjBxb3RSWTFqR1JjcDZnOHNSRnlXR2hKdG9CYWd2NHdQaHU3ekVGZFY1RFFBYlZCNTNOZ21reW05R3l4TnhEQVcxY0c5NzFGYUlwVWx5QUNTWEQyc0FOQ2d0dDBOVkc2YWZ6aTdzQWdCWUFhbFRxYUtuRjcxSEhqQ0tLTmdPWGxrT2lxdC9HbW1MWXNqS0NJNm42MllxZExHKzE3VlVycHhaSWViMFN0andEYytoMTF0UVpNM2hITTZoU3ZyS09ULzdoc2JVRW9KSTRUNmNEWHU2czdFYkE3M3ZRU1dkM2x4eksxMTVPVlc5ckp0ZHFpdEUvd0J1MzhuTlNScDF1S0k1c2l0Sk5jRzVPcnNCcHhGVkRiMFJOeWpKWUFjZGRoNGkvd0RXaXJuUHFPSXd3QkhGdEdGd08xeHBmNDBTSy81QVNpaFMvSzNKbDZucmZycFJYU3hwVWpjUksxeUJjV0ZyajVVRzMxWS9TQUNreW5yUkZQTWs4ZGJnNkEwVXBwWGpRTWJteDE4RFJHS2ZobFJ2RzVQcU9DRjI4cEhYV2lzS1kwaGtXT00zalZWVit3VWFzUG4zb2lHUXl2SzdHeThSNUU2VzhMOWFLVUk1c3lxV0hVaHRMSFlXdFJHbHo2TEs4ZkhtZ05pZXZmNVVWcWl5ekJJbzQzYVN4WnYyZ04yb0xmY2NqNlFGWThTZUp2b3Q5elJGZU43bkpIakYxakJCWWw3ZGo0bWcxUlpNc3loN2NPcFVqOXA2M29JNXFPWUc5TTJiY1gxRkJ6VEhGR3lNdzQ4dFpIMnVSdWZoUWJlRWNURlVGbFlmVVQ1aVA2VUVpOHFTTkx6Q2h4b0Iyb05XUE1HUW0xckN4QjAxb0laVUs1Q0FYczY2b3hHM2UxNkRuK2pKamNsOVBrdXVvTnlSYnZRUnk0OHhZUU9ZajRnRXlnQXF2aUJRY3gvL0FDSXprTXBZY2xObDB2ZlM1UFMvU2cyd3c4WXpHQ0ZBUG0yNGlPd09uaTNlZzdFT1N1UGlYQzhBQVJ4SUEwR3hBOGFLb0dmSTZrQUd6SGd3N0R2UkVGeVNVc2VJWDZWTEh0MTAxb0syeUJQQTFycTBCNUIxM0FHKy9TZzVZWkhnZVdVY0pPSjlNTVFvQ3B1YkRVOGdhQ1lFZnArcWdzem9zWVRpQnlHN0RscUFQSGVnMjRPUmtZcXZKSER6aldPMFFBNThXdFlscjZzQlFabUVlVHlmZ0dubEhxSTRKSEViQUMvbHRRTEhETkkwb0FReEx1UzJnNk1RQnVQaFFTbm5oR1BHcVJpOG1qTnFmcCtwaUJycWFETE5NNHlFbGtBYUpyRHlrVzVEdU43MjFvT2pqbFlmYjNSWkxlczkyQUYyMDMzR2dhcWpETzdLNFNSV0lLdDViaFZLRFN5Z1grVkFuZVNLTnNUMVZqUmlHU05IOGpFV3NEY2JqNDBGS3VxeCt0QlA2VEtidkZjZzJBMkZqcmVvclNNMXlTem9Zd2JvNUgwK2JVTDFvTmNhRXVxRmVNY2krbWlrM0M3WFlIb0wwRUkza2o5VVRQd2FRbEhVZldMR3cxNkMxVkVmV25pQXhaRUVzUElFc2YyRzF4NWpmVGJTb0twcFpUTStOeUs0OHhhV1VuaVVhLzFjMjJCMDJvcWt5b2tUQ0lYeHNpd2R3VFl5V04yMTE4QU5oUWFzZUlJUTBySzBnUUtYSkRYSkpHaEhhMUVXU3M4Y21QTkNnSE5lYnJKb0QzUEViZkNpczNwRXlCcGxBSElzcWdraGdUNVFQQVVScEdUTEd6TUkvd0NSUUR4SkRlRjlkcUtvYVFYdktlRG5pZVdvdXU5cmVOQmJrKzRZc3NvYUNNS29DbHVac1MyMmgvem9NNnpUczBrMDU0cEtPTEl0bGIvSGpReFo3ZEJpNXpyazVIRmNXUmlpa0RqY3FBTkFPbHFJdnpzbElaaGl5V0t3Z0FXUUdSZ2ZwNDJ0ZHVwb0drckpKRTJSelp3THhrbmJscXUvNDhSVkZQdUhycGNjeUdtYmo2aTZOZTEvTU8ydWxRWjI5eGplYUwxRTlTT0lDT0tST1hIeTdxQU9sOTZCNVNya1NDUXFWWnJpTmZwYXcrbFFmSGZYV2d6elllUTdSd09Ia1VFU3JKeTVMY2kxclh1YldxaXpKU1dCeXVRd2NoUjZnTEc3VzFVYVZGaWljZ1lmbWRXTE5ZeHh2WmlUKzgyNzBFTTJLYkgvQU9NeTU0Ym5OSXdSRUpLa294MVlIOXkvS2hGWldSMVhJYVQwZ1VDcEtBcGF5NmNiQzNicFFYWVRxY2xKUTYvYUZBSm9lUjVXVTM4d091dDc2VlViZnVzTko4a3lHMFE4c1VZWXF3WjlVazhmOHFnemVndVRNelFveUlyQlNJemR3OXYzRStYamNiQ2c2Ump5SW9vOHVhVlpHa1gwMmtQbWNnSFRoZmF4NzBISmxXZjdsc2VBS3Frb1hlRWNnZGJLTk90QnFnZ2tFVnNwaExoNUIvbVNNWGtBRFdKNU1iaTFCVkNpNHhXU0YyRWNMeXlJemxiU2VuOU43ZzkvTlFXWk1Ldkg2bnBTUkxra1NsV2J5bVFHL0k5eDJvS1kzOVdJUkE4WTNYbm1BaXhJUStSQXAzQk94NjBHZVpFeDM5ZUZWRjE1WS9Gckc0UDd4cllIVUh4b0xZWldURmp4M2pjZXE0YWFVT1JHMzlxRURSRzEwdHRReFhQOWxraWVBQU42YWNzaEFUeThwc1FoR2pYNkh3b0l6NWFoMGpDaFpDQkVaQVY5TmxIMFh1ZFRmUW1neFJSU3JPcjVOeUlIczM3UUpDZFJaTzM3YUxHekpDRUhuTGNTa1NzVHVkU0FpSHJZK1kwUkxMKytDSGw2WEFBV1ppQ1VZV0piVFEzOGREUVpqSTd3SDBndkVFbHBMamw1YkhqeDJ2VVhGWHR5WnpHV1V6dXVWei84VURad2RBbkViRTBHYWYzUjRzMDJDcGpBS1JDYkVsZ2JMeDB2WVAxb3FjaVBEanlUdGttWjFZbytPTk54ZG41RGNwK0ZFYU1JNFJVeXdaTEpsa0QwcjI0TkhiUmkzUnU5QkU1Ym5FWEtueWNaTXFQaEdrRGdndkhjL1MyemY3cjBpMXpwSWNZVEtqUXRQeFlHUmdmSnFMMllkRUJONkNNZUMrUEcyUkRJNUViY2NpVWl4Q3N0K1cxdFBoZTFGTlBadmRCRGo1S0lQUXlHZERrUDV3Skg4eFlqZXdHZ05CM29jVk1Ways4eW1oemlQNDJqUE5UeDBIS1MrZ043V295eVBpbUp3cjVycEN6RnVLcVFCcGV4dDlPOWphaTFueFl2dVlKWUpJSFhJak9rb0JZQkw4cmNSdDJvVnBKOW56TW9TZTVaYTRycHphV0VBc3BhdzQrZExXYTJvb25YVG01SVByWTZDTXlxN2duSlUrWjQ5N0FhL1Y0MFYxekJOSUoxeGdQS0xNNGF6SC9ZVXZiUWIycXByQlA3YUpuRVVZdjVGTGNYdXcwMUs2MjVWRlN4bWt6UFFaVUsrZTgwTWh1M0szSGxyYlVBYTlxQ2c1ZWZqNVg4VitQcUZRcWdGUTJvVzZOWlNyZDZEZGo0a0dRNHhCSzBHWmtjUTkvS0E1K3JWdGxiOGFJcG5ueVZsbk9haUY4UUNNSUdCdnJZY2JuemJhbWcwNFgyL3dCNTZ1UkRhUDZsanRjV0lIa0kyTnhWRjV3LytOS1psbGhaa3NmdFNORzBJc0NEc0JyMXFLODFsUzRzZVlPRUo0QmczQXRaRzgxaHlBK25UclFkZkdrRWtVbU5HZ2htOVFzK1FMSGpDZGdIVStZZFRhZ2xtUlpVaXk0Um40a25rVHVsbDJDZHFJNStUN2JKalk3L0FIS3RHMklPSmtEQThnNThxMkc2a1VXTWVkN0lrZWJGUEhLVlNZSk12bGFRT1RxVlBVY2JhV3FMcXpBOXdtR1psU3ZuK2hsYThjZG45UG55SEhpQmJpU0J2UVk4aVRIbVNOR3htV1ZUYWVRM1pUSGY2VDJ2L2NLRHF5UUdITE1VaWVrc1lCVThPUzhHMStyb2RldEJ2KzJqL2hWT1BKZ0Q1TFhhK3EzdDRiMVVXZTRZUWRWVC9zdXVwTDNJQXRmZjQ3Q2lNMk8yVGpaeXU3WHluWlFyTTNNUGJRMzVhMm9xbDVJNHZjNXBzMEVCQzZ2SGltMHdOajUxNWVRcWRxSTVrR0M4OXNhSGpqeHlBeXZLNDBkQmUzK0JVYVFpVEt4cG9KMmpqeEZ4d1kxNW5na29HNDVhNmttb3JwNExZZVBPdVZQT0l3eU1zOW95VVJ6ZmlHQnV2WDl2eHFweTQ4dVJsUkU0NXhvVnhyK1dmNjBMZ2VVcktMc3ZMdFVXRDNITWk5Mmt4bXlINHp3QVFyTUZYemxmMmtBTHoxNjcwSndwYU9OSWNmN2FRU1N6WGtsaWNYNGxiampZZGFEcisyZjhmeXN1TnB5c2c0QWNGTEc3TGE5bUcxNnNTL1dNVW1Vc1JreHp4REZmVGsxWmVJQjVlWlRvVC9nVVZaak5neVk1eUV5VWdhTndxUnpIbGVRRCszcGZ4MHFGVlN3bVl5T1RFajVUWE1SOGtSZmJsRXkrWDVVR0JzZjNQbEpIbEZ2VVJTZ1NTeklySDZUZmJiclFRZ3lVY2ZZaU9HR1NOd0JrWC9sSkgxRU50L2xSY2Iwdy9jY0wxWThhVmxFakNMaXNpdEc4YStaeElCdmIrNmlJWkxaR0lYbEU4Y2J5SVZSNG5JZXpNTGc5R3Ywb0UyZmtaRVVlT1psVjRRVmdKWGo2WUpBdVdYWGw4YVFyZEIvNjRZSmYzVEhNN0Jpc1JVZ0t6Z2ViMWVQbkgrMDlhRGtRNHpJemlGakdza1pYK1pTUUNSWm1HaHZZYVhvclhDWTVQYTU1SkpKRGtRaEk0MEgwT28xNG0vbUhsMTVVS3c0M3VFaG45S0luRzlUeXl3TXBJWWJnaS84QWJhaFkweTRXSmxJZ3RCQk1aUXJaRWJzVlZTYldrVWl3djlWeFFpeVRBVldMT3NKUVNHT0tibDlTcC9icDVSMW9qWFBuWldIQStMalR2OXZ5NXl4TjVnb1lhbTl0cjlxcVBTKzV5a3MvcnhnU09BQmMzRjlyTFZJeXBCaXhyQ3BqYjFsdkk3SFNNQnR0TjcxQTQxKzRlZWFSdlNNZW5NYkJyYWNGT25tb0RIRU1raXdUdUlqekNQS1RvRCttM1dnbVc5dVZYaUJMU1JrMkJBWlN2VnliaTNoUVk0K0VrekNXL0c5MWpJQzNCMlB5dFJXNzEvTUlvd2lJdW9aQm9HNmtYb2kyUE9qaVNJeWoxRUJJczF1WEgvSFdxTk1jc2FjYkR5NmtCQVdKTy9XcXpRK1hDVWtTWWtBdUNRRUJjaTIveXFLNDJWTE5JM0JwZldWTlIwTmdOckRzS3kwMXdSaGdxazhib1hDcU9JMHNPUjQ5ZjFyU0xteUZqRFhiMHlWMUFZWC9BRDYxQmlpeWhsZW41dVNhcWcrbTUvRzN3dlFkZVBLS3NZNUJjMnNxbTlocCt0VkcvQ21DWXJUbTU0cm9PcDhCUWtZY3ozQ2JIeWhGUC9IQzQ1c0Fia2N0UU5PM1VVVW5sanlYRTRkT01OaUIrMDMydlkwR1NmSktNWWtERnlMT1lyY1F4T282OU90UldlU0NNejhYYUlBMzRLdDJaU2RWMFhyYWlLY1NZSUh4ekh4aFVGVUwyc0F4MVlIcWZDZzFZY2tEVzlTU1I0WW5JU1FyeDUvL0FBWHc4YUM2ZkpVS3ZQMU9CSkZsQnZjN1dKL09ndGdhTVJHTlZIa056SWVxTjBhMjJ2ZWdsa1hlVWNBT0p0WmliOHI5ZEtGYlVkd1JBL0VLbHVNamtnaGUxaDNyU09mbFJzY2s4MmVJS29hTVd1RHczSnFLelp2dUVhd0RCaVVyWmc4dVFGSWF6L1NndmUvSys5UVhRR0tJZXI2ZkhJVnVVaTJKQ29CWUFzZHpRV1krU1pwSkpaT1N1NmgxVmdia0c0R3VtMVVkRElYRGp3WTVPU2hUYmtwc2RmRDUwRk1PU3o1YTQ2c2ZRUnhma0FINGtiMjZDa1N0eVpVOE9aeWpDeUp4TWFpK20rdXRCR1IweVZjeXRaNG5BVGp2eDNPbmpRUlpTekVNTE1SWUN4QTJ2OFNhRE1RRlBPVlNZZG1zZGlCc1BHZzBCbWtrOHNpZ1hCSVUzTnJkZmpUVEdsTTFZb25NbjBXSEU3YVZSaWhtWnpOd2E1WWN1UFhmNlRVVnNnNVJvdDQ5V0JCMEYyQjNGVmxvQ3hyRHdSUE9TUUF4dVFENGRoUVZZcEtaZHdXSTQyWmQ3SGJXaXBHZC91ck81UkFMaGIrVzkrL2pRYm1kZ2lrbnlnRXFwMXVUdjhLSXFubGNSZVd4UFVIYTFCaGt5bzU1ZVE4a1VOdWJDMXoyb3FhT3YyMHNZY2lZcjg3ZU50cjdDZ3k1UWhJRWlEMDBZamtMM1lBMkZqMm9oVGk3Y29PY1NrMkNYdmNnZFA4QVdnc25neVZRU0U4RlFpNTRpd3Q0OWI5cUsxWVdNT0psa0FSenFCMTAyK0ZxSVgzdnJNd2xISnlTb0d3OEwwVlcwN3h4QXF0akZ5UHBrYVdBOGQ3MFJvaDkxZ0R4eHNlQWNCajFQbUY5cUMvSXpZV0ZnMW10NUh0ZlViV29ybHl1SEhBa0hrUUN4dWZFM1BTaUxueU1rUmdDRUZuWGlvdis0SHJRUWVXZmg5STVrQWxnZGZMc0JmYWlySXNtWk1tSnBXQjlSZnF2NWI5TFVSdWx5R1ZDeTdBaTErM1c5QldudTBWeDZqQkdPaWdBNzBYVmVmN2pKNXdndXBzYjhSWTIwQXQyb2F3NDh4SmpmajZrVndaWTFBUlNvMDI2VVJOc3FHYkxaSkFjZGVSWmxqSUsyQXN1bjYwQy9seWNSMmtjUzRvSVVLTEszRmRRVDAxNkNnMlJvcWUzRlJFVjV0eUNzYkZ1b3YxQm9Nc1FlSlRINlphZDlYZFJyeU8zRy9TZ2F5eXd2eEl2YXdabUhJZWJjRWZuUVZaT0VrVEV5Um9zcmhWVVdKc0dKODFoczUvU2dSRXdnZ2pERXVHSk1SWFd4MkduZWlMTW5MeWNhTXd3SWZSS29za2gxNWdtNEYrbHRxS3lOemp4a2w5TUljcDJHTjZURmdoVVhGNzYrRkJQR25uVllqSnlrWmp4VlZIMVJuY0R2NXU5QkZ2VmtrUEpGUWhTcnNwQzNXKzVZZVVHZzA0MkV6NDE0SWc1THFQVWNMOVdnVlZKN25lOUJWTStQQzNBcXdhUnI4U1BNQ0NTd050bG9LOGpJeDJrc3dWYitRRzExMnZ6L3A4YUlqRkhKTjl2SEpHcnlFa0pHUm9YWS9WY2RlcDdDZzBTd2lVTEg2aVd4M2Nlb0Y1RjNHZ2E5aGNMc3RBNGt3WmxESE5BelBVc0xnZ0Zqb1dlK25tSFUwRmM3U3RHWjFrREtROGFwY2NoeDA0alk4UmJROWFLZVJseHpKR3NYbkpqQjVpd3MreHVTTmJVUUNVRVF4bUkrdnlJYU5CcXk3QXRmc3cyb0pMbkV5cWs5c2dYWnBFRmt1VkgrMERSYUtyV1kvY2h6RVFHY1BDTDNDM0hIekE5ZXRCZEFrK1RrdnhqVGdnWXpYSExuWTNJNGJhRFdpT2hMOWloSEdmVkVWNG1JMEduK1cxRlljdFpmNGxpTFNvcjhqWVd1UnFBeDdudFFVenplakRLemdzbWc0QzU1TU5WdVRiUzdkNkJJWXAyYVNTOHhaVjV5NmxRRDVWMVBSdnhvS3o2UXlPRGsvYmhyTEczbWRnRnVUeTdMZWdzNWwwakFtRmx2NmFXdnk1YStZMjFIZWdxbUlXYVdOUVkxa1VCRmtQSGtiV1hqeEI4dWx0S0J6NVdSTGpKbUJ6Rm1KOUl2NmdkMDA3YVdIN1RSQkI5NUtNZk9BOU94dkpISUFRWDEyK085VVBNOXdUTEVoeVVNTVlpNEpJNzJSVDFJdGZ0cCtGUVo0Skd4cEVrUUdBSndXRVNXTjFrTzVBL3V0UWRqM2lES2ZDVElXU011aWxsdllGbUZod0NqVW1nNDJObFNFZWdPS3VQUGVQUUFiOFQzWTlUOHFEZGxoNUVobVdXSWVteC9sNVdWbTY4d2Y3UllVSEg5MXlSaXhpVlltVExsY3hTRnJBQno5RW5HM2xBQnBWa1FPUk5pNEs1OG80ckg5QWt1QWgySlJSdUFhbFdSREwrNmIyeE0xR0hyUko1VUg4aThtc1dLRWRDZW5TcUxzWmNmN2lPWEtKNHlNdnJSS1I2Z0hIVXFSNVExRWF2UXhTY2h6Q2ZRWWdRTzdCV0FQMHUxK3RoUkd2QWx4cG5raldUbktBRlF4blFycnN2WFdna012N2FZTXdYN2VNR04yNGtrRy9tMDZhYkdpczhsbm5Wb0NGaFYrVFNMY1dVNmVVOVd2VlJQTmxqeDhuMGlyZ2hiQndPSnV4MDVlRlFVWmNLWk1DeFFSQXNMTktvYTVKQjh5bnNSdmZ0UXFFWlZYUE12TWVQRlR5dXFOMUFCMFBsMjhhQ3M1Y01HUmxSdklKSXBZMVdPUmo1alkzQXYvY0c2Q2dyU0YzRWJSQmZVa1JrZDdFM2pKNjlpdEZzZFRIYU10Qkc4S0dDSGpGS3FsbUQ4ZDVMblpqUkdqN0wyMDVlUXZyK2c2cmJHWWpqNWJFOGYxMW9hd2oyakJ5Y09kaFBHdjJnRE0wcEFOdHd5alM0VTBGYS9ZdkhhUGdabFpTeUVjZVpZV0dxNmdIdFJSamtZNmd1c1JUSUpqdElPWHBrRzRaU1BwUFEwUnlmY01lTDdsY25FbEx4QmlqQldZU05HTlE3cFkzQmJTaWtNS2FDVklrUW9IL2tNUVpXVmhhNVlPZktDUDdhaXRXSk42RFBETEVKNHBiSGt6Y1dRcU9WMXR1RDNvT1UyWmpmZDhva01rckgxSW5jRGdvUTJ0MTViN0dnMVRlaG4rM3lNc25ESTVoWkVTUCtNS055Yi9VV0pzVldnNU1VT1ZCZ05uT3JIRCs0S1dCVXNYNDJLMi9UcGFocmRqd083NHM4VTZZOFVpV2pRRDFTWFVjU3BEYUtqMzFGQnZ5OFk0SVdQSm1kSHpJL1N5aWpnc0k3MkNsYmNlT3dXcWpOa3V5SWtudG9ac2pncWlPTWhWOVFEaUhaeVNHdU9ueXFMRWo3dGt3UlF0RXk1ZVhNaXMwa3d0d0kwYm1nOHZJYkFkcUNVY1VjMkF1UmU3bGlDR3Z6VnlMN2ZUd08zYWdxbWxMSzd5dndSRkI5UFJic3VoQVBTOUVhdlR0bU45dkZMaXdSckhMTmltUUdaM3NBekJsNmNUZTFGVVp1TGlCMlZjZU9QMVQvQUF5aXpSMlUzS3lFN1gvV2hFMXc4N0d3REhHeU5CS0FpUkgvQVBXM3Z5NURWVDg2SlNoeWNiQ2tUTHhaQkhuY2drejNLTkUzWHk2aVFQc2IwR1lSNDNGSnB5MGhtZFM1aXZ6WHphc3E5U05xSzNKbVFSNWtqUlhQSldpOWFNTGVRYnE1RzRZOWV0RVJ5NWNqM0xGT2ZJcGN1UWtqOGdickdEOVEwdGJTMUJ5UjdpOHVXTWQwZU11NFRMaWRneml3M1Y5VHFhTGlMTmk1RW9reW45Rm93eVJqaHF4WGRXRjlDTzlCM2ZaNEZkRVFFc1RxbGp2MllnOVBoUkhZT0pDc2drc3BDanpKS0wzdDI3MVJ5dlQ5bUR5bWFGbkVxbFFTdkpGOEQySUdvcUtqOXpqNGZDTERNZVFrVVpadlVqRU1pTVBwS01keUwwaFVjbjNkSmNPQlJNcG5MZXBKQ3FHOTdXSVpTTFhQY0doWXpxY2JKU0Q3NUZLeHVZMW1Ya3J2SC9ZMzdWT3Zsb01zcnp5cXlUSzZ3d1NxSVE5dlVTOStKSkZ0TFVNUnhYKzZZWXViaUxKanZlSDcwS0ZjRkcwY2tpeDhUdlVWb21pemplR1FvaUZuakNLcThIQTFQbkhoNDFVUU9QRXNrUWp5V2p3NXRIZ2s4eDVnYXJ4dWUxQnFlSDIxTU9HVEh5REpPL21hSmlGc3QveG9KUzVaRVpRL3pSS0NxTEpkZlQ1QzRZdUFiaStnb1l5UXlBenhxNDRvNkhRaTdpM2ZsMHYxcUs2R1Q3TGpISGd5WUpta2xZZW1VVUx4Q25UcHFHSGpWVFdMTXdKdlo0b21rbFNlRXRaWTVGYmx4TzEyRnJlRkVsMXlZY3IzT1RQYUNFSk9rOXhBaHVBV092SmVYVWExTmF4VkxpNXNPVTBHV3JZbkVFd2pKQjlPUW5ibngrbS9RMFZaZyt6UzVBWmN0MndXVHpDT1YvSzQ1Q3pCUjFPMUJsei9BR2lUR2RzRjVBQ2lsbzVDcWtYYjZtSkY3VzcwcVM2Y25zR1Y3ZGtyajVpbVRNTVN6UnhHUmJPanFiT3NpNkhwWWIxTVhXLzJXWDNKNEdkMHl2U3hyck5td3VHS09SYXhSaUFibXJFdU9iTERqekdXV2VBdENiaWRpeERjdGxicjExc2FDckN3cHNiSkt1MEprRmhGSmtlYUZ5d3VxT1JvR3RzYWkxbWx4YzRXVW9xb3JHMFFGMUJYUnVKSFFkYlVIY1NITlZqalR4eVM0d2dQSWF5UnhLUmNsaVBOWlJ0ZldneVM0WTRSTjlzcTR1UTNCSjJzcUVqVHl0MDBvYWE1RFNTU1Fnb1pZQXlvN0lyRXh0cFlsQlk2YmRxQzFYV1gyeHNmSTQ1ZjJxUEpHQVFqSzVJdVpHM0lIUVVHV1dQRUh0Y2JZMlEzM1Vqbjd1Tm9tVjBHMnJueXRyMW9ldEdaaXJpUlE0K1JNWE1uQ1ZKVVpHV3cwQ3Qxc1BHaHJGN2g5eHBoR1ZUUEFYQkMrYlJySGp6VThUZWxXVmRoWUprUkhtalMwQktORTZzUE9ScXZNYmltSmFyOTFkdnVFQWpFRXJDNGtZM1hnUjlGL0hyUWg0bURrejRzZ2RFeFVsWG5NWW51clJBOGVYcGszMFBicFNGZEsrTDlsR251YzB6TkNwaXhNckhYaW92K3hsWmZOMzcwaFhMenhINndoRWttVk8vRlJreGtlbUVDNmowenUzRTdpcU8vTm1UbHhKSXl4dEp4UlZPdklycGNHaUNQSnlWbkJaaEpqQmdyc28xV3cwME9wMHFvMFpQTVNoUVZXTk5lRERWci9UdmZrZjBxSzU3c2t5TERDQUkzSWFWaVFRcE9oc0RvQjNvdWpITUl5amNsbzRsSnZ1R0NuWmlPOUIwcGNwc3ljcGtIK1NWZzYyVWZTQng1TWZIb29vZ0VjUVBFZ21FTVkwbDVjbVlrMnVGT290UVJCeG5rZFVVdmpxUVJJdzRzeHY4QVQ0ZUpwQ3VwajQ4K1RJT0g4UmNCa3VRaUtGQk81MU5WSEplVnNqTDhqc0d1RmQrbkVhWFVud3FLMTVtQkprUk5scnhFRVpDcW9OaWJkQ05ORnRRVzRiUlN2R0kwT1Q2Z0t5THBIcW92YTI5aFFZOG1KK2ZuV3dCTjF0WUJkOVdvS1lZb3BaT01mbERuekN4dW9VWDVhZEtEcGlhYjBySVZsWGw2WHFIemFmN2ZIeG9Mc3FXUjhXTEVpNU04aEJ0WWt0cnJwNDBOWk15QW5Ia2FVa2VrUXNwQmI2dXFxVzM0clFSeDRHbVNLQkdGcGJCTVpSOUtqYS9XNW9xNzNDWFB4WjJnQVc1QWphTmd1d0Y3QzNXaVJ6bzJsaGtFbVV5QkdZeUJGRjJBMi82TFJXajBaVUpmSWtqVld1MGNldkVLVDVWUWJzYUlVUmYwcER6SjlOZVJ2WkxCZGR2bnNLTGh5ZTY1QU1Wa2QvVHZJRFljU0czSXYyb21Ob1lManZDU0x6bmxLcXNDYkhVY3lOeDJGQmVDMktrTXEyTWQrS0hjbTI1SW9MOHJJbU1EdWtTamtwdWgxSEszMWI3MVJ5bXpPZm9jMkk0dGRVWUcvRW03Qnp0VUkxelRmZExMTEl6S3lXYUljUXFDd3N2SGpxU3Y0VU9tR09QSXluUkZad2lFeVNMZnpTYTNJdFlVV3RVRHFXeVVXSGxFVGNJNzZYNk03RGZ3RkVFNHlHQVBwaWJsWnVaWFM2N0RoMEFvTGZZdlNmTmYxeURFNitVQzl3UnVTVDNxb3Z5ODcwQVdYekZPUWUzMHFvTmxBdjNvS1V6bmtpOVZGUE5HM0ZnYm5YWHRSVm5yemxtZDNFcldEdklMNmVGRWl5SjRwK1NmOXl5M0pMRlVCRytuVTFGWmtoQm1Ec3hhUWdsR2oxc05ncEhlcVl2UW1WMUladjQxL2tSaGEvSGNhYVVRUnVxRXFqRGsrckt1OWlPcDZXb3VObUxJU2dFcGNteEpOOVN2UWExVWFXeWxNYmppaWxRRkpIOXQvcEpGQlhIbElWZmpaQ2dzQVRxeEoyQkZCWkZHakt0d1dsdUN3MDF0MXY0VVJabHpMeVZsY2xMRWhCKzd4b3JMTmtJNXVieHBxckJocHFMVVJoV0JWU0tGaXA1QW1OQ2VLQmpvQ2V0UlVJcFNpdXdjeHRFYndjVFlPTFdKMTduNmIxUmZCRE9JRzlRZWtXSEZiYWd0YTlxQ2lHV1pjcU5IY0t4REQwdDlWR3BJNmcxQnNmM0E1RFJCU2JMcVF4Q3g2Zm9GcWlPSmtLdVFoWW5xM01rMllIUzN5TkVhU09icks2cTNxWEFJUEVFN0FtZ3krNHlNM3BvNjZhRjdFR3cxSEVXNzFGVGRUSVlSR0ZqZ2RRQXlBcTNLMWg1anZid3FqWk9ZdlNqRHo4aXA0cWJBR3c3NlVHTDdkcElwSlF4VEo1TDVMRmp4T2dJb2hRNXp4c2tjQ1dzYkZpZktwMjYvR2cwUXg0akVLWjI1cmNTSVRma09vVWRQalFVUGtUTG5TNGF4K3JFcUswWi9iWUcvSU4wN1dvTDJ5cG5zc3IzUi9NdkFFaXg2NmVGQlJsRGx4c3dDcmRVa1kySkJGenA4ZXRBeEpHaGlWZjVVWlZNVGIzYjlOS0M0Q1FxMFFQSnJrU1JyYS9BSFZnUjE4YUNPT21POGJSeHg2eEJ2TXdLM1BZRVVGRHh6c3huSVBwcUF1bGp5SDdUWWVOQnJsbmtsakFLK21pSGpiWGtSMXVhQytESWxXMHlNUXdBOG9BOHR1bnhvTG5DeVk3M1BObllrQUN3Sk91bndvTWtZUHE4UTVlY0F1dmxMZksybCsxRVNqakUyT3hra0N2R2dKakY3RTM2c05nZHFvcHpWQTQ1TDZMd1VvUXdheFA3Q3YrVlJXTmhpbzh2T1VxeW9BanVDdHdSZmtnNjBHbkV5SVVsUVRSU0lvdjZjcGUxaXV0a0IySjYwRkw1YXhzMlRZUEUxL1EwSEZaTitUSWQ3RFNpTHNqSmpmQjlOcFA1bUk1MnNGREVhZ1c4RDBvcU9VK09rV01xTURsLzlvd0Flb1RjRUQ0bWdqUGl5NDBNU3lBS3o2UklTR1pXNWFscmIyN0hhZ3p3QllNWlpDN0VxcktzZ0pWdVphNEpJMDVMK2xFVGo5WEljekZoREV0bzVwUnlrdVNicTF2Z09sRmFIbWlNaFpJRE5yemtWaFluaWRHUGoxdDBvak5sSkRDL3Jla29kMzBVa2tJQ0RiemZPMnRGWEdKMWtVUU1pb0VWNUViek5IZjZiVzBPMndxb3NEcklYZGh4TUNIbkl3c0FHdis0MjVWRFZjVTBLNDBFa2NCbHlROXdkbENzQ1R2dGVpdEdQaHdPbkVYMGNGaHVRcEdpazlSUkUrTWFaSWQzRUF1T0UwWU91bWlnRDg2S3laRXQ0NUNxbDVZNUZCTFhPdXBBdnBmNFVGbUxCSU1aL1ZtWlhBNVBIM0JOejM4M1R4b0tzNW8waGtKS0pqQUJmUU56eGE5MTVMZS9TNTFvTXpTVHRFZ2NzT1lSWTR3dkZIUUVua2VvUGFnMHRpSW1NWkJNMDhsekpxMzhZWlRaN0h0YTN4b0tQU25tNHVZVmpMeUVpT080NEVpd3NBYUlsaDRrbmxlY05LSWVYRGtTdkI5dnErSFNpclRBZ1FSZWk1bVVIaXkzSGxQOEFjQnYxMTNxb29HSEx3WXBLc2pFNnc2V0l0YlRyZTNmZW9LY21OakEyTmtSK204UkNxaDBGL3dCb1VmNHRRVzRPS1VYSVZqYVBIQisza0ZudkpZQnRUclFTaFVKQzRZa3V3Q1hWeGVKMVBMa0F2NlZSemY4QWtPUGt3NWVFaVJIMC9VczBhdjhBVU5ITEs1MnFXTEszNEV6NE9WZVVLM0ZyeE5LQVFCZmF4dnlKUFNpSDdnMGVYSFBGSkQ5d0FBVGt0NW1ZMzM2Y3FMR1BLbnloaHlReUx3T095dEZCSUEwaktSb1d1TGtmMG9JZXpTSzh1TmlKUDZUVE14RWRoeFFLYm1JS2RsRnFnMWUrejVHUDdqRkE0UjN5MzRTSDAxQVZOVGFLeFhpZWhBcW1MSjhuSW5TTVNMd25pL1lWQ2tGZEZVMzJPbmFneGUyeXJKUERscnpTWmxaaEdvNHNuRnJmVWRDYURSazVPVEpHa2NwV0tKbjlTTkQ1bkJCMXZ2bzNXOUFzN0hXYUdLV0wxcE1tT3p2WWlNQVgyUUh5L00wUkZwMlozbE14V1F4aFo5RElRTnZMdmJqYWd2aVFOZFhjNDBRUlRNQis5dDFMWEhJbWd1eU1USHlQU3hZVkVVck9FNTdCbUovY3c2ZE5xQ0dmN05oU3d4NDZ1RXpZUXdMSW9Db3lhc0RZbTViYTlCWERDOEV1U01TUXBFcmNwU3gxZDlMYUhvTG5TZ3QrMG5iS2FDTi9YbWRBMGJSRUtGSjFZRy8wdGFxWXpaZVlsNFJPeU1vYXkyYTdoaFpiRTkvRDUxRlU1RFEvYmt1alNNUVpKa0ttNm9UWUVFOVRiNGZPZ2hDY1Z5ZlNWbW5rQUprMVVIemFKWUc5Z090RWRHYkhoTWJOSGFXU0tDNVc5a1M3YThiMnZZZm5RYzZURmhnaFZZUDQ3cUNxQThneU1MTnoxRm1HOVJXWm53c2lCdmE1a0s1VVBGb3NsUDhBc200dVF3UDdnYkR3b0hFc3E0VnNoRVY1TGkwYkRneHZwNVNkckRjVUhOa3gzNXlOTEl5Uk1uUEc0V2FOdi9qcHFld29xNDRFdUk2dGt5OEM4ZHh6UUJRVDVsSUFPOUJyVk1FKzM0eUdWampsanpDQWxtMHZZaytGN1VFbFZaSkRIQVFZbmJsanhPUUdDcXRnRGJTOTk2RFQ3Z3pKSXF5NHFZODhDZ3ZDcUZnWXpvU2VkN0RyUkhLbnhYUkJKRHprNWxtalJGNGVtVkk0a2c2TXR0YUxxTTBtVW1KSkxDMGNzamxROFp1elRJVGRwRksyRnRLRFJoKzVQSElVaUpJNGMwaFp0QnlJNUtMaTQ4UitGQ3EvY01rNDdsekl2ckZnQUVLa29WM0xvYmg3RC9TaEFKL2FSQ0Q2c2ZxSW9zNnE2NmtYRHVkZVp2b09nb0NMTXlQdEROTmhvOHpTRzJRV2IweXQ3NnI5Rjc5dm5RZGIyMkxGekNnYkxWSmpkakdRVnNlbGxQU3FqbmU3NG5wNThqVEZIalZBc2hTeGRRRHV2alVWa3c4RjE1eDQwLzhBSWg5UllKaUZmang1WERmVHIrTkRXdUtYQyswa0Vxbkh5QUxLNFEzVTJ1ZEJkU0RiWHJRYzNHYkl4MEU1a2FKMVVrZW54c1VKMERwZXhEZUZCZGtZMlBIa1J5NUViTjZxY3BQdHVLbEFWdURwMHZwZWhxdkF5cGNlZHBvR1plVHJLeVNGWk9mVGk1YnVlMUIzY1RMK3o0dkE2b2hZc3VQR1E2SXg4M0VNZk54MTFxb3BtOTRseUp1RE1ZQ1dKSVUzc1Q5UEc5QlFIYVZmUVp6SElTUzRmWU11N2IrTlJXWERlZVQ3aURJa1VTb0Zsc0dJTGtIUXJvUnNkcWl1aERJME1FVVErNFRLaTVPc2JxQXZGZ2VWeVJyZnQwcXBYRnl2ZE9Vd2VOZlJRTXYvQUkwbHlFNG00TC8vQUt3ZGp2UWpRdVZKT3FpTUtwbnU5MVhrRVc1QjRHNUlGdERlb3F4dmJaSHdIa0VyUnJDMy93Q3pYSlhYeThvei9kM05DcE5qKzVSWXd4RGQwNEZvZlVKNDJQOEFZUjQ5elZSenBVL2hONFMweTZOSXY5d0ZnYmJVR25GWlBSVDFaWHVWSzJLcXkzYmJ5NzcxRlhaZVVUaG9KRTRJbDBhV01teEcrMjUxMTdWVVFrZ2hNZm94WkM1RjFYN2ljY2xhNUZ5QUQwK0ZSV1Z6N25pekJ2Yk1qN2lQaGQ1aHlRSU9xbS8xY2FGdjVYUmU5cDdvWm84L0prYUlLM0F4V1lJd0ExS3R4TnFIVG16ZTRaQ1JLaXdoWjQySkFSRHhheHVHQitwU2JhMm9xTVh1RW1WSzhIdVRSbHdBN09DVVloZGVJQXVEdlVEelBjVmdpYkYreklnZmkwT1E1TFN4b2JIelBzeWpwdFF4WmtHWE54bGkrNUt0QzFvUXc5TjNVajY5Ti9nS3FMeUkvc0k4aUVKbHpRVzVxNnNVSEVXQ0FEVldvT1JMN2pQSlBKSkhDWVluUE9hQ0FNQllkZUpQNjFMVmtkcURNbmw5dG1rd0JDRmtRTkxBWS9yS0g2anpQbE9wMjNxcGlqMi9KamloYjFTaXdjV2thUUJUeGUzbFVCdXQrbEIxTVgybWJKREdOMFc4SmxNVWpXUGxXN1dRWHN6RnRxSnJYN1hNa09CTEE2R1dXUTNWWk5iYVdKTzE3ZHFRdkx6ZnVIdEhNL2J4dThEdWJSSUNWUXl2cHlzZE51MUd0VlljR1RHNnZpWkxZdWNWNHlsQXF4S1BwYTQzVnVJcUNDWWk0MzhlZWhXSEkva01wOHBaQmNEYS9JY3FEcCszU2UyU0pKQTd2a3N2a2hrVUtGTEE2S0ZKdlkrTldKZFlaY2JJVmxjeHFscm15NldlK2hPOS9oVWFhbDl2blp2VVNjUnU2MkpLZ0tEYTNVVldhc205eHk4VldHUE5FMGNsMGtoQUlLeUVXNUMrbm10MG9PV0JsWTgvQ1NYMUpKbDlTWkprRnZWNkJRd3FLMVE1T0hNSGphZElNcUtTOHFPb1VQcHB3WURTM2FxY3VzUGM4aGNVcEhBTXZHeDJEeTNzSEFiUzZuWW40VVRISXdzYkhta1l6bE1SSlNTdVJjbVNFRDZkQjlRMDE3MUZkakpqbGFCNWNua0FiQ0ZSYnpkQWZCUlNyRnFZV0hCRXJJcEwzQjR1UE1iancvYmVxeXY5SVlvQnNxaGdRdlc3VzFHblMxQmw5eVQyOXJSWThnWWtEMUpZa0lDazdnQW5XL2FpeFhmR3haamRES1dzZUNIY2o5cEhUYldvSDZtVExLSmNkU2tlcERzRkRYSXZ4VlIwN1ZVT0dGNHhMa3pjMGtzRVZ3d1R6TUw4Ri8zR2lrSkl2dFFKNS9TTndBaXFTemxOZk1GNkQ4NmcwVDVYTkJ5SHBSdWhJZHZJZ0EvUDhONnFKWWt5V0tSdUlJaW9rTEdQbTFsMkE2Nm5ZVUtKc3ZKTUJsZm1Ia3ZZRWNWYlhieHFLaWtxSmh3cEZ5U1FrbjFRVGZrRGZVMkZCYmVXRVNNekZtY1hlTjJ1UzEvTmEzWDQxUnpvODgvKzFhR0dMa2grcVFteThiYXFMZEt5MW5EcGxUNlhyd0VLeUFIMHV0ejFGNjB5ekxKN3pQN2o2Zzhyc1ZJSXVORzZHM2EyMVNGaTZXS0laVVdQTEw2a01ibHVVNTRoSGJja0E2NjFVYXNUT1RDbmthUCtWd2VISW9BcFVkUnlHZytGTk1YWnVIa3pySExKRUkrUXNubFlnSC9hTjJvYTR1VkdzTWpHSkJ4VHpOSll0cjJOOUwzcUsxUVpMODhlYzhmVWcwZDVTWlNTb3ZvdmJ3RlZGN0NWMWxtdzFqK204ODVGMkhKckFCRGZqYmFnTU5ZTWJBZVdlUW1TUitQRGVRQWpvdjd0ZDliVkZwWWlFaE9VWG1VWFBJNjJYdmJjMnFvNktIRUdQTE1xUEpKRWw4WlkvcEZ6WWs4dk1XSTE4S0NpV2IxbzFnUmp5VmlXeDFIbXNCY3N4SGhWRk1tUE1pQ1dSUTd1ZVVVVjdyNmQ3a3NLQ00rWWtMWGpqRWsyUkYvSkdVS0l0anB3dDBCNjFCWFBseXg0VG1TV05KV1BBY0JiZ2U3RmlhS1BiOGZsa3c1Q3R5VWtIbTJqRjdYNVc3ZHFJNytka3hSaHVhMzVycmJVQW5ZazdDcWtjL0hjTE0wenIvQ0FER3R2S1RwY1dYWmFLV1V0NUJOWXE4amFFNjN0dllIcjRWQmZGSmo0a1pNajg1M1N6S1NEYncwL2RWUmM4Y2NpQmJKRllCcjN1MWgwTnFES1A0V3VvQ3ErZ0xHMXgxYjhhaXBKbEdKQzBnWGhJYmkyaks1MHRwUVh6U3hJc1lRR1BuZHBHWFd3Nm0xVVVSd1JTSzA2L3dBUVA4Zm9pNWZqZTVQalFEeUdOWXlKTExHZVIyNmRBRFFXRE5seUlic3QyWWprQjViTDBQRTk2STFZYUUzY0lMeWpqR3Q5dkVYcWkrTEhrZ0RNdzlQam94dlluc1BoUkZNRFNSaWFkM0JZWEtLdTRYdFk3V29xaGlmVjlabUxvcW4wWTdHeXVUb3hOQlJqWWpQTXJ5QUZiRW9zbXBMTHVOTjZoVmpRWXM0bGZuWm94eENXVUZmL0FKLzB0UVV2Tjl1c1gyckZpdXkydVNEMDF2WW1nc3pKRGtNMlN3RVN5SW9sSTRvT0F0ZGgvdjAyb0JIU0IzWmxNa2poakNoRmxXOWd2TDVhMm9KQ1NibXNwVmtoeDE5S1VrNkhsdGM3YStGQk9USk1NYW1JWDVFQm5BNUZDZHJBNzZhVlJHYXpxV0xMR1dQRkZRVzhtNVczeDN2VUt2aml5NXNjbzVDd0lPY1JZM0lBdllIb0QxcW95NG9rVEtLb1FlTWRoY2h1TE51ZGU5QnJNaGNNNDBqalpVOHZXUWE3ZHFDN0NoaHpNaWFFdWloVjV1YmdXNDdCVDhhQ3BzY1F4c1dZU1BQNWtXNHY2WlBtTitsOWhlZzU3TTJYbThWUXhRSXQza0Y3bmpZS2xxRG9DQ1BHRVJSbUtTRmdseGU3ZGIyTzRvSzV4TVJNcmdNeWdMcXZsdWRSY2lnbGdTU2ZmRlpNWWd3eGc0d1VqYzY4d05pQlFkREtDRnZOSjZjazExbm50WU9MYURUODdVR0ZKaWkraEFpTVhQRzdzVHFkR2ZTMXJBYlVGdUZEakRGbExOLzJyMjRuUjliS2JkZ0tDdUtXU09GZ0N4aFppb0lzU1IwNVc4YUErNnlGQ3ZLQ3FRa2lGYldHbzFPbEJjSFVjVEsvcHc4ZWRqb1FON0FYb0lpV09BeFNTOGtWN2EyT2lNUHBIVWkydWxERG1ud2tRckh4WEgxQmxGeURib2I2M0hhaU9mTkxqZmJtTXRJSkhzUVdZRkxYdmZUYTFnS0VXNTJBRXg0SGpmMTdxeGRuNUtvNWFnZ0hYVHFLS3VFdWRqcURMS3NoY3FrYmkzRURlL2JpUDBvSzh5R0t3QmNPc2pFaFVVRlcxc1RHdTlsM29LMlNLS0NaSkZZRzdKQzFyQjFVQW5YVzI5QnoyRjNVUUdTSTJLUXlFV09tbHVRMUg0VU5hOGFVK29ZbklZaGlnVmxQbUFHN2R5RFFiSklNbVoxaGlSSTMxQ0JsdHl1UHE1am9vdjBvaU9ROGpqMFpVNGVpcGRMSFVxTkFRdzBOcUtJM0taQ3lKZVVUb1VTQUhWTGkxemZYYmNVRm5MQm14a2RZeVk0eXF5TXkzSEppUXVuWWIxVU9IRUFramVNdHlRbmd3RjJjdnBvQmZSZkhXZ2lqVG1YMFZjbnpOd1ZoYTNJMk92VzJ0QkNlU0V2STdKeWlUajZRc1FoSkJVa24vd0RTMXFDM0J5NUk1SS9UQmtWa1paWTlBMXo5SVViOGhhaXJwdlVqeHlzYWM4aVM3cHlJdW5FWCtuZSsrdEJ6WnBac25LRS9GcE1nMjVEeWhTM2lCKzVoMHRRYXBabDlCSW9pN1FJZUtNd0NXTGJjN2EzR3Vnb011VWtzTXpZMExMT2pwZDVEeGN2MUFCMjBvTEwrc3dsSDh2cEErcXN2U05Wc1czSDAzOHRxQy9GamZCeDQ1Z3hueHNoU3E0N2tFaU1HNmxmL0FMYjlxQndZOFR2Sm01YnVKT1ZqRXZsYmlmcFVkdm5RUEJaMFp5MW5RQUVBM1pBZGYvMHZqUkRPZkxDM0FzVlVnY2lnMUFiZlh4b09aTmpSdG54cTB5QWtuaThiTHh1MnhIKzdhMTlxb2xIN1VMT21TamZjUkRtZU9yV0p1V0pKTnh0VUpCRmg4WVdtYVljMkplVXNTQzVOcmpoOU5GRXNPTXJJc1pYaEd3NXlhZ2dnM043ZkhlZ2o3Lzd2RE5LWlpQVG1TR1gwMkZ1SUNzTEIxdU5HdnFDYURHRlFUU0ptU0lYWXhuR0lJVUxHMmdZMzFCOE8xUVhaR2RFMlJBc1JIRkZFTTc4MnVKQUxDVlI0S2R0cXBHZjNYM1Jwdk5EayttTENKSFdQMVF4UVhTNUZ5cmIyNlZGdy9iZmJCQmpOTWpDU04xdkhLUUF2SlJ5ZmtEWWdtcW1xdmQvY0pKTUxGa0EvOHIxRjVLMGZLUk9YbFhncHRiVHpCcjJxVlkyNDN2ZUljY1F6U1BsenJaTWw1eVZMUldQRmVSdVZaUmVtcFkwZTNEQ2s5cExYTVlGekV1ck9VNUhpSGJyNGQ2cU0wU3g1YWVxekJJWTlUSVIyMUZ2SHdvdGpObHd6WkdTa3pTRWtYOGhQRU9FMkpUcHBSR3ZKbHlrQ21acksxeGRWQUtvOWhhNjdnMFUwVEpuZ2ptKzVDcTZzL3Bha0ZRZnFrYjRqU2lFTTZOVlZZNHdzd2RXUXRyeDhwOG8xNm42YW9zZkpsd2pIS3plbTVVU09PTmh5TGJYQm9NWkp5YzNJS0FRZi9pU29wdXlBZEMzUUdvcmJMbG8wY0ppUlFzUy95TkczbTViQWsvdWJ2UWM4U0w5eDZtUXBrUmZNeEZpNjgvM1JqeG9MUFVFV1g2MkhDcXdrbitTVGtlWXQ5SkIvU2dyeDQxankweUZoTHhjakZ3WXNoWXY5VEJoMlk2TDBvTnlOTE5CRmlDSlF3bGJTVTJaaWwrUjVOMHQyb2l2TmdzRkJrSDNrdG1RSXc4dGp4Q3VwMlB3M0ZGY29PK05KeWdoamwxVnBWbEJJVU1iT2I5cmpyVVdzNHpFTStVSmNZeDR2RmhFOXJoRi9jcW4relhTaUpZcXp2amVvbjhtTGYveDBZMlZFT25sc05HWWFlRkZhSXNRdGpDZUFtYVZCNXhQNTFZTm9JbEJCc1JzV3E0bW9aQXhZSmNjWUtpR0pBc2hWanIxNWcyM0JPZ0ZxZ1dQazR4bEVwZmhrRWtiRm8yTEd5c2lpeDVLMUIwSW92Y2NnU3l5S2MyR1NGbWlhVnVNM2tGZzVzYmtlSDVVQzlweVZpbkRaYkZjZFJ5ZlZqNnFzUmV5RW5VWC9BQm9PZjd2a1lPUmxNOEhHSEdqY2ZiQW0zcEFYTm1HM24vdDcxUmtpOXp4eXdrZUtXUXNzY2NUT3R2VDE1TVJiVXFEdGVvclptNCtJY3dqSWpnbWpzc3M4MFBLNzIzZFdJM3R2YlFVSE1SZjVwWXk2UmlaWHNndU9KdGRTaXJ1dGdMMzYwR3NNbm93dExrT3VhN2hYajRFUWhTdXR6OUlZN2JiMEdtYVA3YkhqS1hPTEk1YUhrQjZxcXY4QXU3WDdHcWlHTWdsbFZJM0FrbkIva1poNmdpWjdHNE94M3FLcm05cnlNV1E0cndGV0JhUm9wN2dsVitnanhvYXR4OGwwa2p4QkN4anlHTGlTM0dVcXdzOGJBNmNkTGlnY2o0cVFOaVNZWWQyYzhNaFFlUVhxVlVHMStPOUVIdHNPRFB5VEM0UEpDVi9sSWRUYmwrOGJWUlpKS0Y5N2hHVzhKeHpKZEpVaUNDT3gxRWlFVUZudXYyK0M2NUNScE5oeXN3NEtiS1dPN0lSc2JiWG9SeHZ1WU0weWNFbFpGQmNMSmJrdHZwYXcwWmZuVVZYazVNTU1hdms4bG1CWDFRQ0dUanNyZjUzcVZZdXdNYUU4VEt3dEg2anFrUkJja2kzSUU2Zk9nMFErK1Joc2ZIOXprZVAwK1NSelNxV1VJUnBmVzk3OWFDcjNPU0RJZFlyTE5KREdPQnh0cEFPckRYVVZVU1FGRjlLUlJETFB3SEdQNnd0cm0xejE2ZzBWb3czbFNGWlZEQ0ZHSUwyNUJlMTBPMUVhY1pQY3BCYkZOMlBtc3B1dGs2aS80MENYTVZGQnlzWCtiUStVS1ZjNjcydFpUZWdvaDl2am5pa2p4OGQvL1lSbmx4REUyVzFpRUErbzBHSmNOb1ZENVNzWW9tNG5IWmlwQ3Rxd1c5QkRuakpBOHVKSHlnZFdiSWdJdTZSZzc5TnU5UmY5VG13eTBjR1ZnWmMwMGtUM0tSZ0tBaWk2MlU2WHYzM29PUTBzTTBjOHdaeGsrb3pOSkpHRjQzM0paZEI1dEJSVnVEQjd0T3E0MlZNendGaEpHTmg1dDJNbTYyb1Zra3oxZ3luZWFPWVk1Y2NaVUtzeVNyb2hQSVdaZTlTa2l6S254VGdHYVdLVnBua0orNkQyak1ialZIVWpjdCtGREdqRjl0enBGaVpaVmhnVmVNZU5KSW9JYzZqMG0zNUhlcWxxb1FaN3UwY1UvT1dKZ1FWVUpLVWpiUmh4K3BnZEtERmtObkV6RVpMRnlXY2dFQnp5MDgzZnhGS3NTeFBla0VFT0xNMHNqQjBqbGpJWGh4VWtxUitKTlF6bDBwY2Rjb1NqQ3gxeThkbmUwTXplbkpFQUFmVkxyNVNkTGhkYXFZWHNFMlhIN21jZkRraXl6a1JtTDBabU1KSExyeUpIbVdpM3BkTjdwN2hqenlZenlyOXhHTGVtNFVzV0JzU3BGd1RRR2F1UjdrdkdSbFhJWStxcFp2UkNzdWwxYS9HOWwyb1NZNTYrNDVVRThxNU1kOHAxOGtvWDZ6Zmx5YytBNjFEdDBjWE1oeTlHOXVXUndnV094SVFub2JlSFkwaFhIZ254NFpHaWt4cE1qRWpZRXh1d1dTNU5tVW0zSU4yb3NkYVgzdHNPY1lXRTViMjUvd0NhT0daUDVJdlVGdUJMRGtlUGhwUkpOYWpud1I0Z1hrc3F2YjFRbXJnLy9FMGlPSGs1aXBQeFNQMVdRbjBvcExGTHQzNmJVV1J6ZlZ6WjFhWnBPYmhSQ1JJZFVGN2hRVFJjZGVPQ0RJK3ppeDVDK1dKTFBBd3Z3ZndBSDBtZzYwK1hsKzNRWk1YdUdHSVo0d1FPRjEzNjhlaW1xempueVRUWW1MOTdFQktydndFYng4azBBTis0MDZWRnJwZTk1T1JqWjR4YnEvMDhuSjh3RER5M3NQTGJ0VXJVNmRWU3lZK1BMS1l6bHVMamtRVlZPaElPdHpXbUdITnlURmlQNUF6UGNySXV6SFlnQTdBVkZpTXhrbmxpZjFIWExoWGs0QVVmdEExdFFoek53SHBDS0thZVFrdTZIaTY2V3RvYmEwVThSVldVbCtURzV2WUd3UzFsNEh3NzFVcmYvd0N0eHBzUk1oZVRxejJjdU9tbjBpOVFZRVdKNVl6NmRuVzZLVzBIRWQ3YUR3SFdoV1QzZWVTUkZVY2lNZGd5OHh5NmFhRUc0K05Lc2h3VGlTUkowbFl1TGl5NmdIczJndHAycEVycVNzOEFqRHV0MXNxODJBTnp2OVgwaXhzQlNrWHhxVVFNeXI1eHlSV0lGaHR0M29pempoTEs1V1MxbEhLTmxOamZmYXFyajgybTk2WGpDQWdGdUtkRlRjdGZZMWxmRy9JWlhNYW56QUFzRWorcTNYYXRNaWRnWUlKb3pKNlNLUk1Rd0dwTmh5K1A0MUZjOTNubm5raVJDc2ZsdFlENmYyN2k5QnRpa2xXQUxLek5JakJXVldCMFRWRHhHaHFqcCszKzZUK25KTStzcVI4Z3pNYjJ2WUJBZS9oUkt6NTBMUG14TmtFUmMxdTF2cFVBZVZqcGJUeDNwaTZyaC84QVZSeHpJNUpKdVkyVlRlNjcyVG9HN21vSzRoQUl4S3JSK2pJeFFLU1NicU9WZ2x4NWI3QTFVT2JLTUFnRHljNXBsVXVTRGZnZFFGQjI0aWlwemU0WXdLcEhqbUZZR0xEaVRkZzJ6TVRRRTJaTTB2cU0zTVNrcFpWRndUOVI4dWx1MUVqWGd3UXN5dDl4eEJVK3FvWGhjTHNnYnhPOUlVa0dVY29jSEhGZ1dkYjhiSU5iYTlMNzk2UXFuM0dUM0QxaE81L2tVK1ZrQlVzcDJ0L3R0UWN0VXZqdkdWWGxOb0pMamtGWS9UeGJ1ZGFLNjJISkdzUmxkdzg4ZGxFRzFsR25tYjZSUkhQT1ZrK2RXUlhqWnVCVVhKQjZYcUs2T0drN1kwMGQwa1AvQUc1WkJjRkFmTW9GVkVwNHNxU0ZKSlpmVjRqbEd0eHMyd0FIZjhxQ3BaVVZRVlJnb1lBc3dCSmRqc3B0dlFkT1hFa2poT1Y2aXByeEl2eVluYlVpcU0rUGl5VG1hWUVTSWdKNG5ZSHYzcUJRSkFmKzdFMlEwYmVZanl4aFQ5SnZ2Y0dxTEZtRXlTU1NNc1N4ZzhUclpyR3pEamJ6RTFCWGh5NUVTU2haZ0pKUnBJbXJLT1dndWRBS0N6RE0yUWlxQXJFY2hadkxjcnJ5YS8xRHJWUmJFWTFoZDNnOVdZSVpDU3dCVmRnU0QzNlVFL2JwSitSRWdVaFFBRjNQTGZWdmgwb3JvU1N4dkZkbkY3bnlkUmFxam5TZVpXZGxaZ2RMVzMxMDQyNzlhZ3F3bnk1VDZUQWhXYSsvbE92UW44S282RTRsUjFTVUtITEMrMmlnMitud29PVjZVZnFsb20rNVlsdTZnS09wVTIyR3RRWDVLczJMR3lyNmNjanBHekp2YzlXSjJvS2NyTmdHSjZHV3FJSkhNVWJEVjdYK3Bqc28wMG9IaUswY0tZc2M5cFlrNVI4cjhRWE8ydW4wbmVnMU1CaDhwcEhXWml1c05pRlpnUU5RMm01MG9NbkRMQ3UvRU5PeERBa2tLdHp2cG9mTCtGQkxIeTB4QWh5Vk04by83TWtoSEh4OG5VTjFvR0pzaWFPYTU1TExkcFNwSVV0ZTYzL3Q3V0ZVU2h4MDVLSTVFVld0STVZRTJldzVCcmIwQWdkYzJNd24xR1JXRGN3YmNXUG1hMnhvTktzamVxWVVVU3RaQkhiVmpmbzM3YlVFWnVFT0xyempMTnhFcDIrSGRxSXFZdjYwazBrL01oUndjSGp5T3dHbldpclVEZmJvTWgrTjVWNWdqWHkvN2grbEVUeUpZa2xqZkNkbW5jZWYxQlpGUzFqb045NkRQalNRSXhqbVptdUc0TkdDQW8rR3ZsLzIwSFRHV1pjZFN3SDNrQ25tTGZ4b3FnTjVmOXhGQmx4akRrRU1FWGd3SlkzdU9RMlllQTIxb01tVEhFTW1VU042ZWd1d0d3NitWZGJkNkRVZlVuTGdHeVhVbGVQQXRwc3R0QVBDZ3NteWdZbWVmZ21yQlV1YmxyYm50UVk4YUdYTWpWZ3FrdFlSbVlteURma1IrN2JTaUtNeWVYbUEyb2ZRS0d1dGtHNTdFOVBDaXJKWjhhUUs1SkZnRzlPM2xMbXc4ZGRhQ1ltbDlCdnQ0N2NUZU1sTmwyNDJJMVgrdEE4N0FuZ3dzVUxrQUxJR2RsQko0OGQyRnoxOGVsQW9Uak0wSWtKZUVKWkVGcldBc043SHphMEZyNU9KSEs4RUFJYVJsV1FNRHk0MytHbTF2R2dtalFCL1N4WWp3Vmp5YVM1YmsyM0hYUURlMUJHZG9NZU44YVNJU0I3TTA0SkJoZGpZZW4xTFc3MEVYaEVjWEdaaE01Y0VvQ1J5MnQ1dE5iNzBScnZsQXJsWkRzWklpVVFYMTg0c1JidFJXYk16SkZ2Rkc0SEM3VFJSMnNxcnZlUWRPdWxBWVRqTVJJNVpmUmZpWGlDSGNqOXA2M0lvSmdOaFFUcEw1bHpGNTNZRm1ZblFMR2YyK05CSVpVdC9RdVZZc0YwRjBEMkFKdjEwb2kyVmNGSW9vMEpPYVdhTjNiVHpOKzBBVVZueWhtbENFVVJ4WTdNSlVJQVluVUV0YzZuNFVGUHFDRUQwU0I2aUFpUm8rWnVvOHphRzY3Mm9IajVjYjhadlY1TW9ETEpma2JIVGMrT2xFWDNpRVI1SVljaWRmTWhON3N4UEpyZnRORlZ5NHpLeEVnRDJVa0UrWmpvTE9wUDdpS0RDaGN5UndRTXdTU1FlWFRpU0JvTFd2eHR1ZTlCdHlNbWVHV0pJWkJLV2N2R2VBS2RpUEJRTmZqUVd3WUphVUZXc3hEQXU1c3BKQk5nUnFHUGFnb2lCVEhqbUUzQXFESEl3c1dZM0lzL2dSdHBRYlpwaEtxUStTT0ZsWG1zZGxDMi92dDEwdlFaTWg1bi9BTzA0YUhrRWltWTNKVUc5dStwMk5xcU1wZDA0eEtvYnpxeWpnTkxkbUdvYndOUlcvSXlRVWYxSFpzcGxDK3IzSnR1ZDdEclJHTjF5RlVSeHhreHlyWm5HdHdwM1VmSHIxb0s4cVdGbGRDT0NlbDZSUTI1SGpjK3FHWFMvVTBWeDF5WklJWkRPaHkxeVkvTEt3NGFBbmp5NmEycWF1Sy92Vm5pV1poSUJENmNjelIyQWJucUl4ZnVONkRzaUNETTl2eThrUmZiUks2SE9rRmk2K2JRS0xockhiU21vNEVvOXZXR2ZCbWlrVEprS3h3T3BQMUgvQUxaY2dpM0UrVy80MUd1WGFNZ0dYOW0zcExFRklsbWVUK01pM0ZoWS9UWTMxTzlYV1huODNDeGg3ekpqcG1zY1FTSUlGOVV1UFRDamlGY2JwZnhwVjNoYjdaaUpMbFNZN01mczhwMmRwQW9MeWhBVkIxMURYdmJ3cUxycFFlaEpDcXh5TWh4bktTaFdOdUtnaGRMOHJCdGZqV2tkUEVLZWpIRksxbnZiaVI5TnQyS2pveG9sUEluSG1tVVdtZThVc3AxVUVtd3VXdnYwdFJGZVMwTHBISUdBbG1qOUpsVWFXVWZVdmJYclFXeHRQaHdTQ1JVWlV2SklvQkNxTEFBV0gxYWJqdnJRVTVPU3l2RXBSSS9VWDFWS3JyZGRGSnVkUmJhMUJIT25mS3haOG5JUE9XQWg1SEFCSnVCWUVEVGZjMENnaGlsaWhNNU9QbEc0NUtTeXpvUmNEaWRyYkEwRWNiMjk0WWlSRXpNV2RJMWpiaVFvRnovOWg0MEVKbzBUSGFUZ1RJL0VZN2hUYS9ma1Q5UTJvTHNxUm13WXJUcytQQll6Z3FPY1RqVzFodXZacUt3d1BLeWlTUGxOa01ESXNMRXFFMXVldWg2MUZXNS91TVdWbHgvZHlDVDFTQ3M4Ukphd3RjbGRpTDJGVklnVWFiSmZHYmxHMnJoeHhaaEpGc3YvQU50TDJvTXpZY0puKzVoUWpncSt2anUvSG13R3ZsTnJwZnBVVkRGZ3lDV3g4a0w2Skk5YlUyUU8zbHNwNkNocVB1Q2ZaY3BNU1lHUFhIVGJTeHZyWTZXL2RlaEczMi9MOTV4eUljZDRRckQxSmxFYXNDakFpNnlIVmJucFJNakszL3JwYzFBVDZjZ2paWlowSG0rcmRXMkcrbEZaMk1yeVkyUGpTbmhqTVY5U1U4R2tCQlhqcHBwMEZERmNyU1J6Tkh4a2dmSElTQUszSmZUT2prY3RiNjlhRWF2ZHZhc3hjVVNUU1JjQWdaMGlOaWk3dGMzc3Q3YlhvdXNZOXFlZG9NcUh6bmtRamZzS2dhbSs3TnJiYWc2Y21DWFpreUg5Tm9ic0JFcWhReEc5emE0YmFpYWVES1ltWDdqVkVEeEl4V3llZjZGVTI4cEIyOEtESENFV2NsWStFakw2VHZ5NXFwSjBNWlhxYmJHZzNqMjJWcGxobHRKelVxc2xyQmlSb1dQZStodlZSWEhISkRHUk5DcnhxZEFGSkF1YldOdW4rNm9MbzVmYTRwMnlZM2FMM0ZTREN6V1VFQWJFRUhsUlZTNU14bGVTWlh5SkdKUkhkNzJKMURIZmFxa2RPVEcxTThRQ0JnQVZjWDRzUnJiOWFLd05nTng0eXZ3Um11d2gwQXNMY2pmYlRmdlVNV0Y1Y1NQMDVJL1Q1TFpKZ29SaXA3a2JnaXFqUGt3WkNLc00vQXh5TmQ1MjFJVTZrSDVVVFVmY1lVbURyak42bUh5QWtpSytabUdxc0w2L1RVV0tHeFlZWW9sVmprSkUxL1NzQThhbTJxSFRrU2FLcmFQL0FJNCtiWnpKSkRNT0hQaGZ6Mkp0d0JCTnZ5b01rR0h4a0xZcFYzWnVMd01DbzNOeXBHbHRyMUZYU0xoU1pFY2JPaU5HUnlMM2NrbllEeEZLUnBuT0xMN2hKQjZNa2FJTEk4SkFVZ0RVdUxYNDk2cklnKzJ6OGxaSFBveGp5Z203RnduN3JuOHZDbzFpZVJQQmorb2tqcExLYmhaRU5nM0hZZzdINTFVUnhvc3hZbVlIZ2dzd0xYRnlmMjNIV2dsa0prTEd4QTVJRC9KMTROMzAyRkJDR0o4WDA1a21DZ201UEk4MUkxNUcyeS9PZ25tWjgvOEFNb1AzQzVJSmFXZE5DRzJLOXI5RFF4d1htOXh4RmhlT1l4eVFGU3BGck94T2dQSUVPQUtqUzdCekVmMWNhYkhCa2NGb3ZjQTdLa2JoaVNEd3RjZkhyUkVjZU9ObmM1TVpqYVVyR0pHWWxTOS9NMmdzVnZSWHFNVDJmMjJESGNtYmprS3BDeklDNnR5SFVIeW1ySXphNC92RWFwZ015bFZETUZPS1ZIRWtpeGxRSDZTQnBSWXo0b3dEZ3ZCUHhqZmlMd1NhUnNvTnhZNitieHFRcko3ZG0rMkxOSVBjSW5XQ0pIRWNzQlZtdW1vSEZ0R1VBMjcxRnhqeVRGQmxwbUpsUkNHTmlvY0U4WTVIWGtRTGEzMHRmYWc2dVRtZTArNjRpUERqckRQQ3l4ejVVUnVxaGdWWmdoMWE5Vk1jYkI5dkh0K2NUejFFaEdMekJCZExXdjV3VlB6cU5PMWxmOGVtazlxSHVmdDhuM0VTQnBNaUVXL2lJTnVKQXQwcXM2NGN6ZTVaQ3BJdU1nYkcvWUc4M002a2xON3Rlb3FNT05IREFza3NhdlBJeFpJWkxoazQzWFR2cjJOV0ZhWldtYVBoOXN4Z2RsUm1JOVIxRVlCZHdENXFncSs4dEhLRWNPa3IzZ0pIRnowQVBhNjlxQkw3amxZZkY0LzR3WHVFSi9kYTZ1RGJwMW9wak5neUl2VXpFUjhxUm1MNUU1MHNmOXk2bnR0UkswdmdaVTR4cHhJSllwRVdHTitRSEdST2hZNmtXb05HVC94ZjNIR2xoRTdDS1FmOXBvbVVqa2RTV1lFMjJvYXJtV2N5eXZqL0FFTW9nY0ZGTFBjM2J5RFRqcHZRbGFZZmIvYTF6R2hraWxpUldFamlBQWkzRzRIQTMyMzE2VUdUR3lmYWxuT1BPanhaSmUwT2ZDelJXSDdiMzBzM2ZwUVBNaTl6ekdUSG1XV2VFT0J4dU9UWCtrRnp1VDNwU01ieW1ES2JDZkVtam1qV1RsQ1BNNVlqaW9ZRTcrSW9OQXgwT1hKS3M3R2RDREtKQVU0ZjI2WFBJOXJiVmx2WGFYSmtiRUhCRys0SUZpVG9xOVJvTDFwa1pHZEZLSXNlVlhUSWF5a3NRd0MyL2FPOVZBWjRjZEFyY0dtdUNVWmRDcS8zRlRyVUYyQmk1VXNpeXhxRnlDeDlLT0pSNXVRdmNnM0FIYXFOT1ZEazRsb3BMTEt6Y2dWSjVLTEVGUUYwMzNxVWlwL2RmdDRJWTBibEtvQVljU0RmYmNuVTk2R0s4WjNhTm1tVkhqbTErM09nUnRsTEg4eGFneitva21hdUhsU2Vya2NDclIyMXNCNVZCRzlGVSsyeXhybERIUWNIc3ZNa2dzcCtrQThlbldrSzErOVFRdEJFcGF3RDhrbTFNbW4vQVBNVFNueTErMnhEMEJ5UmhNeWoxaklMRWE2SHZSS3Z6ZlVoaFFoVlZwUVRGeGJtN0tUWUU2K1cvalFqbTVHY1laemhLRmpqY0tCZTNMbVRleGNhMjBxTG5BbGp5QzM4TEJJbUk1azIzdnFiZUZWR2pHamtLelBERzAyRkM5bGxjRW83MzdmTFFWUkwxN0x5bVZ4Q3hLbVVNT1R0WVgwM3NOcUNxZjFHazQ0MFRRaDJWMmpzVkRJZzBKSjgzalVOUXhjNzdETmF4QjVLWFZXSE8zaW82SHNLRHNlMnpETlgvd0ExVzlOV0tLSkxXZGhxTHNMYXFUZndyVVpzWmM3SGlqeW1sTi9UZjYxUWt1QXVoM3Q5VzRxTmF4U1ErdENzaUtJV0JDeHVkU1ZCdUEzUXVEMUZFVXdwN29tUjZjNitybHlOL0hJL21JNTYzK0ZCdnhvbGx5V1pqNjd5TjVwa3ViRWFjTmRCUXJVK0ZIR3l3UnV2TTZzMGR6d1lEa1FWTzRGQnN4dmRNU0NBTEZBc3MwTGx2VVlGcnNSb1dVWEdoNmRhRGl6dk5mN2pJa0RtU1RtMm4xdVRxT1BZZE9nb040OTJZU3d0TzRrbFlGSStvZTM3VHQ1UlZUQktmVW5kK0NjWWxaNUFRT0txUDd0ZEQ4NmlzVW51bjNFYndveVBONW5CVzZpMzloQTNvSVlpRlZhWTVDbGZMZEVYZ1dhKzF4OEwwSFR6Y3pGNVF3UXhsSTUxVXo1REFrc1FMNmE5dEJhZ1VXZUVoYUtKT1FZdC9NdHJNR3RZY1RzTGIwRWtzMkl3aUxuS2s4clk0QkFSUWZNeHZwNWhhMUJJUXp3NDRTUXFFQU5ocFpSZS9JWDY5TmFET1hseCtmcFNrZXFic1YxNVgyc050TnJVRnFaR1NPY0R6Q0ZpNnRPaHRkajBVRWJBZGFvdUxZa2ptZGxNa0pZckdpTng1VzgxMkhUWFVWQnI5cWhXZFhIQzBzYTg1TGl3MnQ4enJWUm1sdytieUdKaXFjU2drSjFBSjE0ajhnYUt2aHdaSUpESkU2dVlnRDUvZ0JwZnQzTkVLWTVFdVE3VEw2Q3Nna2pWTnl3OEJRUzl1ZEpVNWdubTF4SXJpeEY5d1BqUWRIMUNMbWRRRklzTkRjQWFkS280K1JJRWxTTkdaWVg1dWdRK1dOdjI4bU8xelVFWHpvcDVrWU8wc2hWcmlOVFljZHdDMi9pYVVoSkxCSktqTnk0eWNoTzZyeWIxRkhsUWYvTHcwcHE0dEw0N1NCWTJNZnJyYVFjanpScmNpaWdmM2JDZ3hOZ0ZyTEtESEM3Z0xGSmNqMVIwdjN0clNKVGt4amo1RFI0N243WUN6TzI3V05yRURyUmNiY3YwMWVXQkZFb3RDNnNDSEtBL1RjRDkzVzFFRThLUVFrTElNcVJ4ckdibFFUb3BzTnIrTkZaRVNDT0ZXWmxNenN5U1JrY21XeHVOZGJFMm9SMThEQ2xhTlpFZm1XRElGQzZLTDdnRGMwUUNHV0dSM2xDWEpLS20ydXhKWHBjVUdWODV6N3FXaWpDQ01MRXNTZ0ZGQjNKdnVmQ2cwekxHa3dZTnloWmhlTU1GQllhTjM2ZmhWR0xMeUF6UjNzWXBKQ29YVzdoQlpWQk8zalJGY2VQSTJYam90LzhBeCtjajhBYmNlNXZwWWJVVTJ5OHFmVWxSQ05SRWx0UmZVM1BjVUd1YkphVDA1Ri8vQUFsQ3h4L3VDYjhuSUZqeU81b1ZXeW1JV2lSVmYvOEFVZ2t1QVRlLzRVUlpqZW5ab2kzcUlMbHZTTzdkaDNBNzBFVzlVWDVCNW1QRVJLUUZ0MkJBRitOcUN6SnhrVjNlUXJDeWZYS284eWdDNUhFWDBZbmpRT09LYVZKWmVZaHhzYUpaU2dKSEpiM0RGUjlSSm9JQ05aVmltVXFzZ2I2R2F3NG5VV0d2bW9LWWhlVXhJd2VPVFJWSUtsQ3V1bHRMZHIwR24yK0pvWlZ1bnJ4dXJhUm5nOXIySStJM29Lb0pNZVNSZVJhRkdiemdEbGZoZml3RnI3aWdzbXlaSDVLNEVNTXlvNnF0enlLdG9EYlZiN2swRlFHRktiKzVxSUNqRXFZUE9YTnZLdDcvQUUzb0l4dkNaUlBJZ0t4SzBjSUsrWWNSOVYyME5pYkNnaEpsUk1zTG9oRW9VbVNRcjFVbXhWaFJGcm5pRVdJbFpDM0dWOVFHNWpjTjN0dlJXdVBEKzZaRk1JaW1qUENTVldMRzQ2dGZxZHphaUxvTWlDUElDeU9KTW1OaUhadk5jRGEzeG9xL0k5eWd6Y2Jnc1RpVmd3VUtwdHlYVUVueDZXb09IS2lyeWhDcjZNbHVEY3ZMYzZNTDZmVCt0RU9hTW9Ja1o5WTE5TXVvc2Q3K2J3RjdDaXJtaE1MeHh0bEh5QU53QkRuMUNMNkhZTFFaTW5MU09DS1FGa0xPYnc4UzRZZzZjZ08rMUJ0aFpaWjd5aFVUa3J5QUMxbVhvdlh3b2h6WXJTUy9jWENPR1BDTjJ0L0VGNVdJSDY5YUN3enh6S2Z0MVBwZ0JaV1E4YkJ4ZXpFM0M2OUtMcmx3cGplbndsSHBsU2VBT2pMeEZybTM1VUdtTUZvME1kbzVRT1NUQzlqZGR2TmZZVUErVlBLUFNSREVMS3NyTU5RZDdNZXpVRVdtekpNS0tFeHFmU25QOFJJVlJ6K25rd3NhRGZMS1Voa1E0N1dkUVZacmdJckVBMks2YTIyb0Zsd3RGaHFvbExQQ1hMYzIwSUF2ZmphL0xwUVoxbVNRSXNmRUdNODdxdkZsWmdOeWQvQ2cweVJqN2RuNGlPRWhiRWtNV0pHeS9HZ3pSNWVNdnQwcEVFaGFRRm9Yak56SFk3c0QwSTBJb2pMNmlTc2hiakc4WVV5UjJJdXcxQnQ0NlVGa1VSNGVweFloaWJrRTIwMUtzRFFqV3M0QWFTVC9BTGJLR0VOOXRkVGNiRTIwRkZjNzNPVnhtZ3ZFV1NZYzNtS2pneWtDL2F4SnNMV29PZmtSU004ZjI3UEhJcDlXVUZnRWw1RGp4WFEyOHRSV0wyLzNYRGhpbnhWQWtrTWpnb0ZPblJTYjJhOTlPWFhwU1VzR1k2eSsxcExqNXhsbWRYZG9MbEdRb2VKQjNOdGROYWhLWHR6Wmc5dWVUSUNpYklVcElkU1JDNHV4SlB3MG9xekFra3lKVTlVaWFhTkJFUzZrajBWMVEzN2REcHJWMUxHUEp4Rjl2TFpFVFg1dUZpRW5Fb0dZRU1wak4vS2VYbDdHZzZQdDgrVWdNS1F4d1R3L3h2d3ZibURleEQvU2RkeHZRYVZqbTlYSTR4aFo4bnl6TW1nWlFOYmZPaWExUVpVajVFT01vV0JGVUpLNUZ4SjBGL2ozb09sN2xndWZMNlRFeklBNnV3S1dUeksyblVXdFZSeDVWWmdqdWpBY2pJd2NncWVQMGNiV0kwb3E2WEtsbGdiMFlwSTROQ3ltNUFPN2tDM1RjVVJpTHJOaDgwVXlxVGFGWFVnaFFUNXJuUVgyb1ZFck9IUDhpeHlHTzhrWWJRRlJlNXNmTlFiSnZjbG5DNVVzSUpFYXhnc0NGZGliaGxBK2tyYlMxQnJ4OGYxc1pNckpMeVlFejhTNjhiODc4aFlYNUxZOVczb0l2QTh6VGVrQTNvdUJJVVVrcXFhbHlGMkg1VVZrSTlTREptNDh1QXVKYjZBMjZnNzloUVpzNlJuU0xIWjFIcUliU01PTEpKeHR3WWRONmlzdUhqeSsyd1lvY05Ha3JCWGRYVTZnK2JsZS93QlBUUzFCdnlNN0dDTDZKUTJuY2g3K2VNUmtLV2E5aFkvVUxHZ3hlNGUxL3dEc01oWjVKdzJRckJZUXpXY1BvVjlVZEVGN2swVFVzbjNMM0I4TXh5OFRsNkNWWkNBU1VCVmlEdjVnZEJRam5uSE1ycW1USjl0S2JSaFd1UFVkeHlXOXIyNUFBY3FLZU93VGtYa0RaeHU2c0xvZ1N4V3pJQ2RReDAvR2dlUjdnWVlGR1FqNUVxb0VrVlJja09iZVJoOVNXRi9qUUxFeHhraWZKeDFESEhjTWtiZVJpTDJJVmR1V3ZUZWc2WXpiVE9ZWVZMd3BlU1V0ckc3QzFtM3Z6L3RvSzRTb0tMN2lqNGtNb1lzWXlHamZyR3FxVDlJYmZXZ3Q5bnltd2NqbENGbmRyRk1keDlDSDZnUEhyYWlPaG1lNVkwN01wSENSalpVYXlsZ2RPUGg4Nm80K1psRElaY2FGeEhHNTRzckc2Z2p0NDZXcUxodzR3Um1Sa1lTS09Ba1ErVkFQTVA4QTVXMm9POTdabDRjYU45d29FbkhtajN2Y0hRZk5qVlJreU12S0pHVjdhZURwZXpFVzF1QVFSdGJ2UWN2TW1tbkhDUmVNS2tPN3N0bTVrNjZpcFZqUjdiN2pEaTUzcFdEWTBwVm1WMXZHU05QS2UxQjZiSHpjT1VNVkZuQk53ZFI0ZktxemVHSDNZQkZKNGdYTzZkUXc4TmhRaktyUnhLaGJKaWtkQUVXQjI1TnhPd0ExMm9WaTl3WDA4ZVBKS0tWRTNwdkNkSEl0YzllMUFvUGRmYmNlV0gxRlgxUVFFbVEzNW93K2xyNkJoMXFMWWw3M2tZT1lWT0lXaG1RRnd5clloZ0w2SHdvU09aalpFY3lwNjhZS01xbEpob0ZGN050L2RSb3A4NFkyVk1CNURFUUlWSG1WdGI4Ym5RMzNONkk1L3VHWGpMRkxrVEkxOHBoNTE4bzVnLzY5S2loUGNwY2lNeHlPcXdNQnprTndScmJWeHFWUDdoUWRIMnFYSm13L3NHblZJWTVtWkpGU3hBdGZWOXluYWhWc2l5eXhpUElqOVdPRWtxNnFWWUFuWmgySjJvREd5c3lCaERGUDZPdjB5V1lEanJxRDBxaFRaN1FaRHhUM2d5WEhuQ2l5dXJDOXdSNWRSUkVJSjVXeXpINkwrWlNpUU51RDBCSTM3MU5Xd3Zjb3NwWjBFMThlZUtOWS9UQU5nYjN1NE94MTBxb3dQSms4ZnRjeVZwOFpMQkJhd0IxWTJzT1hJWHFMSFQ5bHljTEpSWWNxVVJ4d0txd3E5aFlBNkEzSG1KcEVxSHVZdy9XYVdKeGtRek92TnlQVGNkQUVCMCtOVWpTdnU2WTZlbE1wSkYxVnVoWWJhaWhqbXo1Y1U4SmttakR3d3R3bFhtQVQ2amZWM1BqUWpObUQyOVBiNE1pQXRLcnM4Y3NMRUhpQ2JMNmJmVVI4UlVhY3VUN2haMG13Z3NtUHpLeGhTT1FLalZYUTZBZnJVRkxON2JKUEV3eDNVTXRpdGc0VjcyMUgrZEZkZUQyYjNmQ3lXOXd4SUpSSEczT1NReDM0SWUraEd2NFVTMTBzejNUSHlNb05sWmYvQUprWkF0NVdBVUxkVEdoQ0E3NjFwbk1VU1pibEpmdDVIanVGOVpWQkN0ZnVGNlVNNGNxQUNVeVN3Z3g1QTFra0lQcUFIVXVwTmhZZEtpeHZtelBiRjluTVVVTG5NdGFXYVVCaHZmbEVScUw5YVJPZGMzQi85amg1N0hMZWJGYVJRc3M1VzdpSTlWWTJzSEJ0VWE0V1F6UjRqekNTTDE4TElBTURBZytpdkx5Qnp1TGpjaldnaGtZK1RrekJWZU56RVR4Q3lLVkNiM3VQRHJWSXNnOWdXWEZmTzVLekl3TWlwOVFYWUZBZEN0OTZoYW94bCs0U2FKSUdQMjF1RHJvU2IySWUrL2diVlIxdmIwdzRIU1AyOTV2VkFWNU1lVURWK3ZBalFoYWtLdHk4SkJrckpMbVE0MzN4SWZqckdxcisxaEhjZ3RWWmppNVF5NC9jMnlSSnlqalVYa1J5Q1N1bTk5cWxhblRvZTZUUVNZR0twR1BJL0wxWlhpRm5SR0hFalUrYjRkS3FJKzFTSUpWaUJZUXV4aUtsN054STh0eTJnR210UlJPOFdQN2lFbWYwMjVjNFpTM2xWajlObUhKaDRBMWFpY0dCTGpaQ1RaZVNEN2hOSWJxVUJzRGF6Zy9TMXF6amV1ckZGNk9ZMzIyY0poWStwSWgxa3Z2YTR0OGFzWlJ5c0hqakpNd1pzaVFnckdQcENMdXpQcHBRaWxjTXZsa0tCSU9YbUtmOW5YWVhPNEZEV3FmTGl3MFQ3V2FTV1VKeUVvQlRpNE5qb1AyanAzcWh4dm56SnllL3FuemlWaHpXeEEwQUdnTjZJcEU5ME1XUkFVWk5XbVUzZmlUcWxqMU5Sb0xrUk1IOVFpeDhxamNpdzB2NDBURVl2WVo4d3llNExJUHVJQUNxWEExT2w3Ym5UdFV4ZjY4V3EwOHVXSldReWNVQy93QVlzR0lJQVhRZlYyRzlDTkRxSS9WaHlzWjVweWJqV3o4N2FLQnRwVlJ6WTVjNmZIa25qUXpIRDBtYVljbXVOU0RycmFzdGRJNG1ZODhyTzVXTW56RlNMbHV3RnRCVjFMRlBweVRUbWRTcEdJZlVKbHNFdTV0YXc4eExVVjNjbk5TSEZqQUVjYzRZbVZRQXkyQjZEV3dGVm5HY3JsdWl3aEhpeHdlVVl1M0U2V0Zxb3NiMmsvYkxsU3F4Z1BsU1p6eENnZldGSDdqUVJoemtrWnBGa2R6YzhRQXhEWDBZbGoyMnRRWFFSemlTWVJoSVFUeE1qcmNyWVcrcy9UZWlWZkZnTERqSzRJZFZmK09QY0J6b1N4UDQ2VVZUa0dhWm1lTWNwQXQ1V2I2RzRueWhhSXF6SXN1UlFpRXhGQW9sVmROU2ZOeEJ0WUdvclpoUW95eXh0S3l4TEdFU2QvTHZyeEJGK1h3cXBXSlNZNCtPS2dFQkJZU3YvSHpUOTlyNy93QzBVQkZsdmp5RDFXYUdGcnZFWFVjLzdScWZxK0ZGWHlTWUtTakdoREdTVWNqSWVRdXR0emExNzBSVml5Uk53VGg2bVMrcjh4OUpiWWYxcEN0cytGeFVjU1ZBdUdLQVhJR2xoYWdqSGg1c0NQRng1UnN3Ym1UY3FwRzR0ZlcrdDZLcWp4WUVoQ3M2b2pFTUp5dHVWdFZYeTZqa0tJSW84V1NiMVlWZU1SRHlvTE1nSitya1c3aldnMUxQandlYUQrZElyTXp1UExlMzdiYWVYcFFVWkR5b21QSXR4NlpIUFN4UEc1RmdQalFXeSs4enBPektnOUNkTE16bThybTMxYzdhSHcrVkJHRDNMSWlqbEVwNW5SWTFPNEl0WWFjdFRlZ3lTUG1mYm5pQ1pRUzJvdmN0YzJ0MHQxcWl2RSs2THBPOGJuMXdQV3NiQmdOQ0xIWWVJcURkQVBiWXNsd0pIYURWa0xBTHlhMnhJMldxT2hqeXpJcTVMNVNxV0hFS2hYbHh0ZmlFR3dBNjBSaGFRWkRMSkZJd1d4SVpqNWQ3N0xVVmRnbzB6Y0drOUtGZ1RKSTdDNmdhazI2ZzlLb3BtRS9wZXJoeU8wQUJFWjBDc0ZPcDE3SHJ2VUduQXpsU1lLRHlTMXcvUzl4ZTEvR3FqMFUyVmlPcUFrYUR5c2RRYmEvaFFjTE1QbTUrbXIrcUxjTmVQWGpiYWdnMk5MSEdnQlNPTkxsR056NXJIay9mcnRTa1U0a1RKeW1pa2NCbEVTeU5ZbGd1NHNOcUtTVHpETHZoTTNKVkxHUzNFQys0TnowTzFCdHk4UnBBbnVKUjVYUXFZNEdmVnJDeFlXMlArNDBSVEZHaHlWYVNNczBoRHlSTHIvSDFPbGliZUZGWlZtbGprdEFDbk5uQ1NBQy9EOXh0dVRmYWlJeFNzVDVtc2lzT001T3E5Yk1CY2JVTmRJZTNZcW9qSmtjdlYyeGkxL1RXOXlTYmJrNjBHNytXRVBOaXZ4UlFVVXhuVHpDMWg0K05CenNWMU03Y0Q2a2c4cnhrSHlrRFZpUnVLbzA1QzRoaGhpVjd1dDVwMXNvUlh0cDVocmFneVNTY0RHV0lzRklUeldDRW0rcEEySzZEWHhxQ21ReVN3TGtSaG15SlRxQVNEeEZqY0RYNnVwcWhTWkQrckF6VEZvNUZ2eDJDbGdWS2dqY2FhM3FEVEpHMGZCWUk1SGQ0eUpIYXhIRmx0eXNCMEd3b0pZZVJrS0VRbGllQ2tTYmNsRy9rMjAzcW9qTjdoQkVIOUVNSEo1eVNFY1M5OUFxMjEwOE42Q0VrOThmbkZGL0t6cW9YUk9LZnVWZ1B4b05XTmt6Sk1oZElXUmgvRGRpakFuWnBEZTRQWVVFcElpWXlacHdwbUpNei93QzY5cnNldGo4cUN1TEh4Uk1ZZ1hrNGtvcEYrYk9wMUk4UENndHp4aUxrelFJL3FCdFdIR3h2MTh4c0xkRFFYNFhweFlxenBDb2xSdjhBdHZld0p1WHNmaDlKT3RCRVp4ZkhranhXWDdhUndzejI4eWN0UXl0OVJvckUwcXFGYU5HWkxsZlVDYWdIWTZrQTZmaFJGME1FalF5TEp4ZEkxQk1SUEVnZi9YZWdwbGFGcGZSWUIyVkxpdzE0NkZRRnQ1ZTFCbWl1TTU0TWkzcUwvRzBRSnNoSThwMUhYYWczeE1NUW5HRVRTeGh3Rko2K1c1VS9DZ25PY2hsVkFGSXZaSVdIbGpZZEw2YURZVVJWRk1MaUtXYmc2Z0RuQ1FWOVFhV1ludVRSVjJXZ2xrUWNGQVR5UUlwUExtZkw1ais0RTdVRmVQRm1veVJJN1hTN0JtWWNOQnFOZGlMRVVFVmRHSSs0SEhHQjlSRUFGaXgzQjhmSHBWVFM5Nm1XYmpKalkvb0xMLzNVSDBxQUxBYzl0Uis0VkZZOFNkMXpGaUtGWXBJeUpZbVd4VmJYSEcrOTdiMEdyN2FRWWNjbzR4d01qTkdUeUpiaTFpcTczb0xKbFJaME9NV013VlNWSTFVMnVmRHBRQldScEc5V1JyazhqRVZzR3VMbmJiU2lOdU1JTXYycVJRV2pScjgyMkpQMUlwNytGQnpwVElzcExBRm5RcTc4ZzNKVjBzVjJIYTFDc2NUUzR4NHlrcml0Y0NWeHBjalVxdzJ0c0tLNmhrNFpNaXJHcXhPaWhiM3NDVjVCK24wMEdkb1pZSkcrNGF6TWc5SjFBY0ZyM1BOVDlRWmUxQkpzcVZvVGhueTQ3anpzQ0NuS3hZV0kvdVBUcFJCaTU4YSszdEdZMk1pMlFGbkdwMlVjZFc4dEZSamh6WkduYUlLMFVBUTVUblRrNTZEYmowdlFWWkdMS1g4ckF3eDNIa0pKQS9jUnkxc3gvU2lPaEhoQ2YyMXBraVpZMS9qOWJrTHNMZ0ZiZGRhREZsWVVPRkdzcEJsZ2tZbUdVQ3pocithek5jbFZOQW1XVEptQzRjb2FDUlZNaFE3UHR4TjkyL1NpdGM4ZU5qTzZUc1VXTUtMY2I2OGRtdDE4S0k0RXYvclpaNEZsbkVlVUcwallzeXZ6TnVUMjBDallWR2wwMlhFc0VaTVN2TVgvQUlMUDV4WTNkWEhhMjFWSFBneG9wTTNKeW9SYkdkdlRpamRTck1BR1pvN2o2anBlM1NvcVB1M3RCWll2ZHBvU2tObzBTM2tWb3hma0xBYmp2UWl5T1k0K0hrWXN5ODRaVjVSeXB5WUpIc29hOXRSYldoWXo0ajQ0Q3pxeFZrVm1PUXdzTDIraGxHNC90SW9yZkhqdzVxZmZSdWtTWXJxMDc1Rmdoa1RVQmgxRGJiVVJ6TW4zRnNyM1dmS20xYVpXUjFGeE9GU3hUaXUybTNpS0xIcDVuUDhBNjZCMHRJWFc0dWR0cmtkcmJWV2JFOGZLeG55bzBIQk9URjdrM1c0V3hPdndvRDNyT2VQS1RHWWxna2F6ekJlcTdpMXFDUHE0K1h4WER5bExNbnF4ckl2RnlENW1zMysybW1LNE1iTXp2NHlQUkxYa1czSlZsMUk4aCttd29qZGtlMTQySDdkSzA0WjVHVkhRQWdvSkZGaHpQUUVIWVVWeGZRd2lGSEJZNVdqQ3kyUzc3YXNiYURsUkZ1S3pTeEtKSmxZcWJRNDdDNUJKdHZzdWxyVUZ5WTh5M2d1b3ZhUzh1aThrdUw5cmRQR2d6bVBKd01oM2drbDlFcGVUajFERUVyYSt2Z0tETFBqUEpLc0Q1RWJUVFNxOEFMRGd5Y2hZTXd0eEtqUWlvMUdqM2JCbldRWWVZSkd6SGJsR3NaRFJua0NRUzE5MjZhMVVqQkZqajdlZVREaTlhU0pFZEkzWUQwUXJCV0pEZlVlL3hxS3Jta0xNMlBIS1F6c0h6c1psVlNWVThnVnQ5UitGVkU4V0dkb0dtZUpQVmRTNGtSN1BvZVZ0N1c0ZEtnTWdUemhHbWdqZ1VTSnhsbHZjamNjdmhzMXFEbXk1ZVQ2eUlNVXg1QVJsYVlEVlF6YkcrM2wwVWRLSzBMaGUxUVRyS1htbWlaaHhkZ0JPdkR6Qm5BMHRyc0tDT0srWGxadnErM09Ja0N1eUR5cXRoOVE4MXZNYUd1dEZrQ0dRUTVLbFlaQ3E4WUxLaTNXNUpKRnlCM29NT2VxNFh1TFkrQklKc1ZmTWs0K29vZFdISTIvRTBJb3kzeW5XUWs4aEZjUGh5QWpqR1JkWFcxaGE5aHByZWd1aTlzeUpJY2RwWEVYbGFhVEpERzFyL1JjSC9XZzBaMDBMeWVwT2hkMlVNaHNBMGdUOXhQN2pmZWc1OEpEeTVNa1JFODhWcFlrNGl6V0dyY2REclFkUDJqM0pZOGVIN3JpWlpsTGdtNVVLTkFDVG9EYm9hcURLeTR5STNDaXdJVzZnQU0zSy9rdHY0M29KKzM1V0pnbUZaVys2aGxGNU9COHlGV05oOGZsVVYxUGNwc2ZnczN0cWM1Q2Irbko5SkRiTTNhak0xNTE0dmRNb2VwQ1BVZUZXZVNNa0JVWTZzeFhxRFJXMkNWOGJIOVNhUkRGS3FHRjFQSnIzczVLNzFRNTg3M0NQRXROR1RCSTFvM3ZjMjM0L0cxREhKazl3YWJQSUhHT0lyekRNTGxHWDZnYmI4cW1ySTJaL281T05EREdzZ214bkpuaGZpQVR1cDVBM09sQ0tvY0NWcEU5V1dPd3ZKUEV4QzhRRGU2Y3JHeDdVRVl4TXhjWS84cXhLVEZHV0FBYnJ4UGowQm9NVU1PWk5CSVlrdk1HMXdncmNXVzEzZEQ5SWEydEJjL3Q4NzRPTmtwT3M4WHJjK1FhMC9qZU0vd0JuYy9LaHFxR2VVZXY5empmK3d4c2tNdVBQSVNwaklOaVNCMThLaXVkTVpGbm5iRnhSSEhFcEVrQlBLeEc3QW5kalFhSVVtY3hRTE80OVNOWGhtY1c1Mk9xa0Uvc0hVYjBIUngxbG5lYUl5UEZaUVorVE54SkhSZ2RTRGE0b011U2NUMVFaMktLVjFZQWxlWDdSZmNlTkViOGpFbGFBTWlzUUVWWk9SRFcxL2paTkNDRDRHaXNEWUh1VVRtUXN6aUlYa1JtNHRjNktRRzFPcG9OYytjTXFDTEhYZ3p1QTdTcWRRQ2RRM1g1VlJzbmt3WjNpUEJwMGpqQnlXQ0ZHNS9TU3pBM3R0UkhPeVBaY3M0OHpSMm54a3NSa0xkdlR0cW82SHcxcUxyQUo4aVNJeU8zUEdqYithT1Jpb2RtNkFEYndvSXdmZHFKQ2tJbXhTOWpDcmNnaDMzM3RlZ3F5cE1oWVlraXRFNElmMHh1R0Iwc0dHN1VYMW95L2RVbmdlYVRHV1BQaVlOSktpaUlXNDhTQWkvdTE4elVNYy9DVGhnbVI0eUlaQzRYZ3hIRWYyc1R2dm9ha1d0ZVRCa0xqREhRR1ozVXh4eXFBemNENWlqOGRicU90VkVVOTB6TWJKaUVzay9vU1FBTW9CdHdCN0ErWWN0S2hqSjdkRzJYbFBHcUxQbHFyT25yRUpZQWFqaTl2cHZRcjEzc01udS90K2JGTGdnU0F4ZW1WeWxEQVBiaXk4dGlhcVZsOTRubWtta3lQY01wTVp5Q0dqNDI0a1dCS0tCcU8xS1J6cFlmWi90NGprUlpFV1I2bDJ6STJCamVCdThSdlpnS2lzbVRtK3BPOGNUTk5CZjB6Yzh4NklBWUVBbjYrdmFxUkNET2dqNExKQUR5TEIzdVFUYnloblVnNjI3VkIwb3ZZM2NUKzU0c2NqUktqU2N3UnhDM3RaaHZZMExjVVl1Ym1aY2tqSi9CQXJpS1QwNzJWWlBxSkcrMU5YRk9maEdQSmpUQWFlZVd4RTVaZUtnbzF4eEkxSUEzcW8xWVUyWGx6Tjk0N0JURzBVY2pMYTZLdjlnMUJIU2lWeWx5Y0ZNZWZCeWxNazhSSnhwNEJhNEc1ZTltSXR0NDFHand2ZXN1Tms5ZVFoRVJsamVORkpBWVdJYlN4N2EwaFkweDRjbVpMOXRqZW8wS3hxNVdWVldRTXYxQXNPMUVSeVZuYWFTUGw2bkZGU1ZIUHB1ZE9OK05yRmFEbVpSeC9VVW1OZVVTcWhWU1NTZTl1cElvMUhZU1JzZGo2aVd5WkVKa2lrUWdyeUlDaFFDYkMydCtsUTdldGpqeGg3ZWlNSW9yQUFzdm5Zc2RkQU5ScDNyVExqWmNzczB4NXpQT3ZMK0tNa0JMTC9mYTNUb0tnakRrUndSYzQzUUl6QndxbXhIY0lwdnBhaXVobnplelRZekxpSzhTeGdCSTNQSXVXRnlYZlpmQmFKRVAvQVBKTTVmYjRjZGZUKzNqVUJCR0NwQURhMlp0U2VsK3ROTU9IM0tPVDFmV2laNzZvTFdJWS93QzQ3MVJTWnBoa2lYSmlEc05VR2dBSFRrRnFLMjVNVU9SaFhTVzJVZVpVanlzb0F1RDMvclN4SlhuOFQzMzNMQm5qYlJsZ2N1VVBMZ3hZQUd5aXh2YmMxSlc3TmI4M0liM1ZYeVhQb0d4dUVIRlZ1TkZYWGMrTkVqQktneGgvKzB0SWpSckhZM1lIaWZNUWdJNURqVUVvaTJQSXFvUW95TE1zUUI1V3ZvYjZrV290WTg3SWRQY20xYzhSYjFGVGp5dHVFdjMrRkNSc3lQZGtpYkZneGJjZkt3REFzZWYrODkxTlZKSHA4UDNSbzFYMDQvNEdqdEpMSUxBSGRyazMzYlRUYXF6ako3bjdwREpGeWtUemdlVlUrbFJ1TkQvVHJWMHhtOXNVWkdNN1FNMFVkMlJnV0pJT2hZdDB1ZWxSYTM0K1o2TU1yTnpmSWswZFpCNURiVGtMZGVocXN0VUdYQXNETkluRmJnRjl6LzhBVUdpdVpON3JPc2txd3dsR1UzWkMxdU54ZGVQYnZyVUd1UEp5OGt0UGxLTXZLblJlZVF4dXd0MzFDbmJTcWlKeGZjSnZVSElSaVA4QWhsV01YUzdpOWtKRnVkdTFGVy9ibElSRkxJeldzT0xmN1JlL1hqcFJGWHBSWktEakI2aUNVbE9mSXE3MnR5VTdlWHQxb3FpV0FtRDE0UXlvV04zVzdjMzAzT3dBN2RLQzNFbmlqVEhReDJjRWhta1BKRlp6cUFGRno0WG9PckFaMXpmU01TeXlzREdQVlBGVUFIbTB2Ymwyb2pudzVlTkY3bVl5ZlZoQ2wxa2NHN1gwNHF0L2xycFJXakN4Slh5VE5sb2NjVEJuUWtjT0lGeHdDN2ZPaVZuZFhXU0hGOVZuaUxjQkVnRGY5emNpOXVYYTVvclBqNEVVVThnaEpNQ3R4aFJqOWJycjVpVGJRamFpTjZIS3ljcFV5SEFkTmhZZW1xcUxsaVIrZEJOcGtTTnc4UDFKNll5T1F2ZDIvWWgwQjB0ZnBRVXhZc1J5b3B5R1VnL3lRaytkcmFndFlhSHhvUFNTUVlJeENGS3RrVDYyWDZ1K3AzdlZxU3ZNRzVna2lua1pzWlNDNkE5YjN1UGhVVnNtR01zc1JpWlJFQ25JRmVRRmh2WTlDS29pMldrTUorM2dROHBlWEp3ZktodUFiSFVnK05RTEd6SGpQSW9PSE81QkhHeEkzNURTNDZDZ2F6R0s1WUJoNWk3a2tHMXRyalEvQ2d4eXpLa2YzRWFoSXBTRWxadExnL3RRZCs5QTRXYkVZR1JYOUdJV1p5TE8zVzFqVkhZbGxYSjlzUjJMTkRHQVhXd1h6SFVXNm5haUtraGdrZDRXS2h3TnkzSUJTTDhSME5Bc3JNZ2psOUpVTHBaUTJ0K1IvdHVPbEZqRkhJMHNSaGV5dDZnVUJTYkluKzV0L2hRZENMRHROemdkZlJVV1NhMWk5dFRZYi9qVEIwY2RqaVBlTU9sMjVhYWtucWRiN0NpTVdRREFzMHdBZFdVaVZIRnlvWWNyOUxFMEhNRVBxNmtpTkVRVFNzaEYzalloU1YvK05CS2NYbVNDREdEUnFvRUJjZW1DckgvdU9MNmdiMm9ITXJDUmxzcUxIb2hYWUFuOW9Hb054cGVnbTgwa2lLQXJBRWtzMXdMcU9taCtxNW9yVVloanhySkVVVUZ3NEF2YzM2S2UzZWtSZk1jMkp2V0ZrVlgvQUoxQ3FidWZEcnBRUDI3R1RLeDNWUWtlV1pBNWhIbTA3bnRRUEp3SmlaVWlZUk1VUEtRa293NmNWdDNxakREZ3JHL0ZBc1F2NU9aQlpRQU9TOEJ2eU9sUWFaTWdlMkxKak9aWkhhUldtWkR5dWdHZ0Z0Ulk2YVZVVUg3bUlzck1qUEpmbmpENjEwTERrVCs3d0ZSVkxrNUo5TlZVU3dvUzhrVnhlUTZDTXFkeUtDeUdLYkdjNVR4RUp5WS9ieXVMc3FBQjJKN2s2ajhLcUVaWXMwTk90MGlVaG1qUUVsbUoxSi9Db3F3ekNWWklYSlVNcDRuanFMQzdCYmRxb01kbzJDSzBnTUJYeXlQOWR1cExiS1RhMUVkRjhyTFplUURLc2Flb0c4cldqSXV0eWI4aWJtZ3laTHg1V0w2SVZWeHl3a0V4dll0MUZ1cEhqdFFVNU9OTmlNc0V5T0pWVXNwVHpFaVFhRWdiSGpRRUtaa3BqTXJoMWpIa3h5Q2JjdTIzWGUxQk9OWW9zY00waUpMSWY0bVc0WW01SzNQWFdnbk5EbHhTMkRJeWtEMVhYVFZ6Y1dieC9XZ0k0WG5rWTQ3ODN0ZFpOeXR0NzMxWWp4b2l6R3o0MHZMSkVYZzFzdDlaQWQ1TGo5M2hSV2pKL3dEWCtSY1UrdE80czBqZ2hRU0xmU043RFNneE5sU3h5RlFzYkcvRGkxaXQ0aCt0QlhpZTR2Tk93bktzVzhuTmRMQnZOeUo2RmRxQzA1ZVRGL0hpSWkraTNuNCtkQ0JyWTMzdjFORENreXNoMVQxRUxjVGRJMHR4WlcvYmZ4Mm9JUnpESVo0Q2dYSGtLdkxHck1FZ0J1UWltM0llWVVHUXlaYlIyVXhDUWtSck82M1ZJMjhxRWdkZFBsUWFtemNTWlpMeHRGRXFlanlWaVFwSUNsdGZwdnVEUVN3WVhLTklxR1FwZHJFLy9ocmNjNy9WMlBqUVRtVnA1WHlwcGc4OHBzV1VpNXNMZWNIVFhwUVkya3lGZVRsWVdZeDMzVmtJQU5yZjBvamJoQ1NlZUtPZU5UamxpWEJ1b0RmVHl1dm00V3NTS0J6WVV2M00rTVplY2FFTUpEeDlQaUJ3dUw2bTRvSVNyalk4eENXbWhqY0NWQWY0akl1bmtCdGNBYTNvcXRZL1Q5ZHVUTkpJeWpHbUZ5cWkramRRdXZTZ3NmT2lUSHlQVmpKeVJKWmVKQkxLYnF4RmhhMm5XZ3FqVVJST0lXREt0bWxKQk8rZzQzNjM2aWdRbkViaUlyNmtrektaSlJKZFFtNDViZGFCNU0vM1NTR0lHS0pEeldNazMzc3d2OGQ2RHFZMk9IVm93eGhnalZaUnpzcERnWDRqdzAzb2pON2drS1JTejhXWWppeThpRkJMZjNnNzh1bHFEaGUwY2NlRzBUTDZucXM3UnFUNUFEeTFiKzdVN1VWdG1lUE45dkVFRE12cU55TXg1Y3ROTkwrUFdnOC9sKzA1Z2U2aDNXWXRBc2FLUWVVUUxOYzlMYW0rMVJxVnV5dmFNak05dXg1WW9vMVNJQVNDeEVoSzY3Ny9BQ3FKR2ZEOW56SjhZUGlvNWZqZVB6QmVYbkN5RlNUWVZjTmRUQnkvY29zVUs4WHFZYWt1RWRyQm1EV0NGUWV0dW0vd3F4S2o3dmwramxOTzhEWStNMEpXT0JSelI1Qlp1Tjl3ZkdvUnh4Z0wvd0N2Vm1UaEt5bG94cmVTTzVKRWh2c3U5dXRScEF5NU9aSEdxU09oWWVzWXBDUExFaDBFZ0doUEs1RjZxTXA5cWkrMml6czJibk42Z1l3RS9VbTNJRUVhMjJBMUZSZGVsd2ZjdmJvUVlzbEhrRElKTVJBNWIwN2kzQjEwNlZXY1pac25Ga25nWEZsYVpZcmVwR1VLbHBOOWIvMkNsVlhKN2dxQ1NTY2VuazVBOUtPTXR5NU9XOHRtNlhCMHBwaTMyN0NPVjdwSjZKc3FrUVJ0Y2NpRjBLQTdBRWp2U0ZqclplRm5ZMCtNOGtPUkxoTUN5RGtBRUlON0xZa1hINTFXV2ZMa2tsUUk2a012bGpWTHE3S2RtYjl1aDY5YUNzWjhDWnFPaExSeEp3VkRkR2tKR3JFZkxhZzZPYkhFK1ZCa1JFZWpKR0pFaGpKTnBldWpmQ2dqa1pqSGkxMW5pakFWVHNRTjJXM2hSV1A3M0ZuUmtWWFdYa1JKR1NQS20vSkFkemJ2UVpjcE1CWHNWTXJHN0xJdmxKWUw1UU5EWmgxdm9hRG5aSmRzVDBYbGtTQ1FFU25qZnpyNXVKdnFPbXUxUlcrUER3SGtaWkllY3JBY3BFYnluaUw2QWJlTkNsaCsxUnRPWGF5eGFNNEFQRlF4dVFHUFJ3TFVTaVg3SlVtaVFLWllUenhzaU0yaVZXYS9GeHVMYlhvUm45eiszNFJvSjI5U1pXTVJYektpbXhkcnFPUG02VTB4bXk0TW5IUVpnQ1NReUl6bUJycTNsQUFKdmUrdTYwV3BabURrSmpRKzZRNWFoWmh5WkV0OVo2TW12RmRkdXRGVVkwV2Jqa0FRRSt2THgrM0lIOG5RZWsreDZYVTlhSW5rRC9rR1FGOXZuVm5WVmY3UzZqMUZLNmdXR3Ztb2NkcmhqNVVzYVRLaG5hUll6anRaU0l6R3dESzl6ZnkyTkJkbSs1czJKTlBQSEdTTEZsYS84aW9kQ0IzRjlBS0dMc2IzUEd4bzhabGlRbVZlU21XeXF5bnFWdWVIaGVpSmU2ZTRSUmU2eGV0Z3RIUHdab3l4Q29GWFVycGNubDBwVmptZTRGcFpJL2NNTDA0Y2dwd3lvMUJVUmxpQW91YkQ4S0ZXWTBtTExpR1AxRWFhVm1VUlNEaVBVWTc4dHVSN1ZVYU1XSEt5SkRCd2VOc1kzbHVRdjhkdHlwMzJPdFFWeksrWlA2bU82aVNGeUZqS2haT0szc2ROQnFhS3pDTlVCYjd3UXFMcFB5dXpBTG9lZiswMzZVSFQ5dVdHUXQ2OHg1aXhhYU94SkZ2STJvdVZ2M29sUnlvb25ieXNCeUZubEFDS1N1dnlKb3NaL2NjbUtCaWl5dVlHYTVXVUh5TVYxNDJQNTBJb1dUQWt6ZVVZYWJJREs4R29Wbjh0aVZjNmVPMUJEMS9kWXNyR01xUnhzZ1psbkhHNVNNMzh3R2hKdjlYV29wNWlTelA2K1hBejQwcThZM1JpR1IzODJwSTJRaXFqVGloWmVJa2lEZW1BREx5NGMxVzV2YzZjcUNqTGw0U1k2NDRuamdWMmN4dDQ2RW95NnR0WmdhRFZpTmpaR1BQT3l4cXpGV0FqNUtBUWQwdjlJWGJTaFZlZGh3T01ocFpWVlhYMWZTRGk3MlBUcCtGRWNjZTI0a01pNVVVN3pQR0NaNFdCVjBCK25lOXhidlVhWFFLa2hMVHMvRUZTVTBiaWVoSTA0MEdqMnRvR2VUN2hqTi9JVHlTL0psUFkvcFFySG14NUlhUVl3YWZHOVZUalRTQUE4MjNYbDNwU01zT1RKN2MyVGpSTkpINmdLNU1aTjFKWTZvUU9uKzRVVjBZSTJ5Mkt3U2NaSkU0aFptQ2d1TGNsVW5Ra2pZMFJiNmNNU1NRelFwQXlPTEszMTNCMUN2VlJ1YmlnSlZtRHR4ZEFkVGNiQjZFV1BtTElHRGMyeUpSd0tBRGkzWGlSY1ZGY3RZRmkvaWtRaU9WQXJnZ3N5c0R5dUZHL2hRSklQdUhNa0xSWTY2S0lsUHAzQ254OHB2dWFEUGs0bUprTkxHenZISXBZeDYzSms2NjliOTZEUDlveXQ2a3g1NUFJOVdKOUNPSXZ2MTVpaXhTMlZqelNTb01lVkN4NGlLTmhHQjExQnVEY2RxZ3VqU0NSeStLNVQwVUpXUUFyUHpCQ3NENDYyMDNGQlJuU3VtVUlZSmhOaEx4aGk1a3NJMlVjbVVYMUE1SFVVTVVTUUtVRUdOSi81Tmp4WkJ5R1F6SCtSUzI0TmpwUUVQdWN1RDZ1S0dsRU52T1R5SENRYlNCVGJYcDNxNm1hcjkwZjNTZUNPT1lGbkM4b1ZiVndzcDB1M2MxRmlyRlVNbkNZa2NHNEswVGNlTnhiaVZPcCtGRmQ3LzFXTGhzaEZtQkJZRmhadEIvYWYyK0lxczZ6NWt1SkZJRUNzbkpGYjFSNWxJZlhqNFdxS0pseWNmSGdTWGxCQk1QVVJGa0g4aW5RdGNkTDdBMER4TXFMQ2w5R0NSMHlaQVRCa3hsUVE1L3VCdmRiYjBNWFQ1S1llVkRQaFRDZWRrTFhFekkwYjNQcUx4SUE4Nm0xVkl5TjdnMHNpZWk2a3lTQ3lCMkVzVmpyeGY4QUs1cUxqQTVoZ3ovVnlJWDg3TllNYk9qcWZvTEhRais2ZzZheTVHSDdiSDY4TVdUaVo2RlJPNFc4WnZjOEdCdmNEdlFXNDhxenRqeFlqTTRVZ3h1RzRzWEoxSkhlL2pReHY5M3dzR1BJOVRLU1JzMk1DOXdWNWZ1WUVHNDA4S3RoSzVFczJFMlVqK2txQ01xSUhBNEZnTjJjSFRmdFVwRzY3LzhBdTJaNFJCNnhCU04yMXMyMnJlSTYxSTF2RHNlNjVNSDJhaEZkVmRyR1FEUm12clkyMU42ck1jZVNPU2RJNHBXYU5JQ2JLVnNUeU4ydnRyUllwanhvMnkzZG01YTM0bU95Z0Q2Vlh4Qm9yYTZlbXZxWkhFSElOb2lkU0RiZm9OZWhvaWpLeFpHQ3VrWEtHUFFkejFzeE50QjhLSXR4WkI2b2FROFcwTVRQOUk0alFXK1cvV2l0cXhuSms0dE1WUU1IbGxVWFBLNUlCSjFzYUpZcFpab2MvSWVWSGxGd0RNQnhqVUhWV2I1MUZyTDdqaCs1U1J4K21ucVkvSXZJSWdSZCtoSk85UnI1cXFTZUtYR2tVUDZveDNXNnlmeHhrZEZzdlcrbFZEKzVNY2NVaWdTczc4NVY0TUZUaWRJMUkvYjBOQlI3MW5aOHhpdkV1UEpBb1prWHF1NFFkV3FMSXJ5VGx6QmN5R0l4TklYUko1QVNoQ2l6S3QrdjZVQ3dKblgvQUxjcXJNcHNqc0I2Wk5yYUcydEI2U0VaTE1uQmVTSXFoWGMyaVo5T1ZpYkw4QldtZGFQZEhEUU5qeFF4TzBiWGJqNXc4bHJNUVNiSGowdFJJNS90T0h4dzNhZkpXUlVJVlYraXgxUDAyMVBjMUkxOVYwTVJ3a0pjWFpuSVlzd0JLaS9Ud1BXdGF4aTZiTzl2YVNGSVlPTWNaWm1MRUVGaHR6SFdnb2s5dlVTR1J6SDZpRzdGSHV6WDFzRnRzTFVOWkJDeTRqck85akUzSWh6eFJTNThvNGp6TWUvYW9yYmk1WHVNY1N3U09XeDBKTVNrRUFNU0N3RnVwN21xaTB0RkpHWWJGVzRscHpKcnIwUUVhL09neG84ZVV5eENCSStNbkpUeVBJMjhvSTZjYWk0dHlvOHZHeEk0STJZQ1NReXhSSzNDenJyeUtDOTZvb2xkMmhhMDBnbkFNcmp5OGZVRzFyV3NiblExQlBDeWpDbDNpRWlzT0JhenM2SUZ2b3c4U2JqclFLMDBtUkl4Vm1hU3dVRGNnYk1iZHVsRjhYNVF6VmxhU1ZqSXpEVVg2MitwaGZlMjFFUnlvOCtQRnZJd2p5VGZ6QTNaUWRCZFJzckNxalhEL3dDTGprWlBEMUprQ3hUV3VmVEFGNkRuNCtSaitxOTE1TW5teHkxMmlJWTYzSDd0ZGhSVXBVamZNa21tZFlIVlE3SVNTcEhaVDBvTk1NZ0R5d3NWbElBWjV2TnlBT2xtMSttaU5FK09xckhLOC9vdEloSVJMNmtiY3UzSVVITkVTUDYyUTRKZ1lBMjE0TmJwMy9EZWd0bmVRNU1yU3pQNm9jTkhFVkNxdGw1TVdicFFLV1BIbWl2RE10aUZhWG55QkFiVjlUY0MyMUJmR3VJbnQwTW1NNWpKazhzSUhMbHkzSjVkcjJvTEJrTzZRd3gzSzJmajZ2bGpSZjNYSFZ2SHBRYXhobkprVkkxamtrOU5qREpvcTNCdGNBL3RzT3RCek0rUEkrNGdNa2ZNcC9JRDZsdlVISzExL3FLRFVyeXJBMHNwVW9pY0dUbFluVWpRYWJkcXFNNnZpR1owY004VVJZeGdYVXQ1ZGdvNlgwb3FHTzlwTHFJbW1qRm5oREVKcUxXMTN2NFVFOEhKamhpaGxhSXlLak9IWG5mbktOTGdqVzFxZzdXSlBER2tWN3RweWN0WUVzeDBBL1N0STE1ZnVBVzhrTElKSWhZRzRKQjIwSDdxZzh6UGtOa2h4Q1hubmx1SkVMQUpmNnVTanFkTjZEb3hHV0ZseFlvdzdNZ2xaM092cUtQcDAvYU5yZFRRVlJTcllrMkdUTklXRFh0NlN0WUdRVzhMK1ViVUVEQkFnOVMvSjUyQ0VzcEo0b2ZxSk9tOUN0UENHTCtkaXM4dHVFUlVFalRRTVFmeTcwQXM3dkVpQnJ6d0hqSUxmdHYrMC8zSHNLYVkyWW1Ra2VBU0pCOXc3RXVQM1dGN2IvdUZCZ2hNc0FqeUZjcXh1a1VpRy9Od2RiMnYwYWcwTm1HVkdFdkwwazFMalJuWTNCVWJtM2VnenorampNOGc0MmxBSzh5VHhZRFZWSS9kUVZJR21NYzBMQ0ppeXQ2aERHeWtmdjNOK1ZWRml5UlRaRWtjbHlTVnNFQUE1S3dzcm5VZ2FYcUt0TXN1RTdSNHdZQ1lzRUtNTDhtRmkxeDArRkJSSms1MCtUL0xJWnZUVW94ZTRzRkdnQitJMitkQlVjMmIwWWNmR2xDcVc1U3VQS0FWYS9wOTNPbEJmR3BlWnN2TGVSb1VOd0FPSjRhM0FVYWRiQTlCVkdySXh5aWVqa1pFYlkweVhWU3hzcW56S2dzTngxdDFvak0zUEhHeVNMTW9WSHVRcFZUY20vZTFGT1RQVjI0b2pLR2U3a0c0NUVYQjAwK25TZzE0ZGhqQ1I1R1dkbXRHdkxZVzBMa2E5ZExVUm93dmJjN0lrajQrYkxnNUFPNzI0QWZTVThMYlVFTWVKNUMrSzZCZnR2NXBacExMZEZOZ1UxdHIxRkVZSjhtZHNwcFZ5VExITlpJeTYzVlFOQVFpOURycjBORmRxSEM5b2JBWXdHUkhTLzhBR0dOd3U1dWRMaytOQmhIQTR6NHlTQllBNDRzeTJrYnFMVzJzYXFLT0U4WmlDdVdta2F4VUFpVGplNVk2ZVhTMTZncFRHakdWTXFYVlllWW1MRTZxVDZndC91R3dvc1hLc1lrbXlyc21XcEtvc25Iekl5Z3R5dHBlZ2cwVVFqOUFLVU53RGtsdkl3WVhLOFJhd0lvTDhyS2dpYUc5dUxFeVl1Z3VRb0FBSi9hcElONzBBSXlpUEhDNWlUSTVUWktFV3VOTFdjOHVWN1VHSDdGVG96Z0NHUkhqWVc1Y1pOa0F2cUtDK0pacEJrRlpFVlkvSkVWVWVZalRpUjFvSVR5eUdXTER4NFZXRUlwWTNKbGtMZHVKR2w2QzNIa2k1VE5Manh4QjFLRU5kK0xEeWtqaitQaFFPREw5TDBZWWhGTWorYUkzK2l4dXdJOGFEWEcvcStyTzdBQmY1R1JlcHZiajN2Mm9IN2tQWGdFaEhCWmVKUEJSb3FIUTM2TWFEblJRQWM3VGNrSUFjVzRnQUc5aGU5d2RyanJRVEtvcVB4SldKN2xXUWtEc1B3b0tFdzFqSVZXbDVBaFdCQkhJQTNzUWU5QjJaTUdmSXh2dllrKzM5WGlHakFIcElwUDBKZlhUdlFZNXNJTmx4UnlFSmpJd2lqbUFHZ0d0MnRvMXFJUGNWanhmY3hIQlBkVkFDeXBZZ0FiajUwRS92b1RpbUxIVkdSMUN2T3dQTU1vTnlUZjkyMTZERTN1dVBsNGNtUEhrS1dsQkVjYmc4N3BhNVVIWFRZMFZ6UGNCSGlZR1E4TVR4NUxJQ3ZPd1dXV1Q2bWpQUlFUdFVGbVMyUmkrMmNpU2t1UEh5bEJ2eFBDM2xXK3Y0MFZ6Mnk4c3c0MmJDME9VVE15U1FxOWlva1MzRkk3OGwxR2hPOVRWa2pxK3krNzVidExqVE1qRkFSNmgxODRZM1ZWWHhGcXNTeHo4K2RWdGtMSTBNQkRLMkl2S3lzVHhZYVhVRm0ySFdsSTN3ZTVRK2dwRXQrQ2lNV1Vhb3EyOGw3OWV2ZXFoNWZ1ZVhpbURHa1lTaGxNYVhISzBiRGtIQkl2ZFAxcUdjczgvL0lNRDNCWWhEanh4aFY0U1MzQUkwNHNlSXR5QlA0VVZHS0xEeUhWSVZQMjRXOHNrcEFmbGF4NUhmaUxlVzFCYm1OeHc1TWJHNEZHVzVqS0IrSUgwdUd0ZTkrMUtrY2RNY1NTeU5PNy9BSEVnNHdqaVNMOTdrM1VEdlVhUTl4eTU4YjBvRUZwSXBFVnAwYmx4QjFQTTdYWnI2MEpGOHlwOTFrSktTK1NXTGpMWHpKR3Fqa0hLbjl3NWNSMHNhdUpvOWg5eDlDQVpUd0syTkpMNlkwS3R2ZlcrdmwvT2l1N0pseVR6eFBFVmZIY0VScnlJUzQ3NjFXZWtjbWVPUE1pZ2dETTVBTWlFZlFYSG1pQkp2eDdHZ3FHSk04N3p6TDZjRjFDeU1DNVJDZEZERFFtd3Fvc09USEhLNWx5Q1ZrY2hGQ0FCQ1BvNG5wcHJVRWpKa21MSnUzT0lXV2FVMnVWWStReDNGK1Ixb1JRWFRIaUVraUlGaUtvOHpoaktxa0d4TnVoMk9sRlk1bzFzODZLMlM0amVRT3BBNFJrN2dkZU5CejVQNXNiSG1qUW5LbmJqUElSNUdUam9ZOVRZdGJVTUt5cnFZRUVlRmdSU2Mxa1dSQzRaV3RLcWdlWkhqUG02NkdxTkdlYzFFY1FrRENtVldhQlNkR0F2NW1IVWJzS0RBbnNQdU0yT2VSVmVWNUk1SXhjUEdxK1lzUmV3dnZwUVJ3NHM3S2xsWW1RUVlxS0dkRnVBQm9DVkd3NjdVUWY4aU9mQk1GaktaQWpXNnozc0RFdzFRWEZyM1A0MFdNdUZqdEpJdktjaUtZRjJXRWFxRkJzekwxQzlhQzR2SW1QREhqcDZvTE5KRzRjb1ZVZ0I3Ui8zT2RqUUxEeDgxekhrd3Brd3o0N0dPT1YyNUJRTlZRQWVlN2Z1Sm9MRldORmNUd3NjbU52NVlyY1JJN2JFRWR0N1VDeGNmSXpJSGdpZ0xZeThwSEFISndGT3ZIWHFmeW9OL3Nod2hKTUZoNDQwQ2NvMllCK1FiUjdrZy9JVVRGdnZzbnNtTWtHUmhLOGJCUXhMOG5acmZ0VW1xT1o3aE5IbEJuaFJsVUJWY2NTQmRocXJBN1dQK2xSVmVNNnhNbU5Ja1VxT0E3eHVEcHl1b0xFV0o0NzBHbVBJT1ZKLzY3S1ZseUlWUERLQXNXRnRPYkMzbHRzS0NNWHRXYXVQajVlT0hqQUxwS3lhTUJmcWFHbDdrWkVpaGtSSThuSVVEangwQlVpM25RN3RmY1VUZVcxU3BnV2JEVGc3cGFLSU56bDUydTRBdGJqeXZSWE85eExaRWQ5WTUyRjI0b1ZWWE80WkRwcGJ6VUZPTzB1Ukg2RWtTdEhDQ0JNbm1lNUl0eUhVZHFERmpZTU9ia1NyRXhFWTBsQ05xZ0gwdDV0U3QrZ29yWmlRNUN6QTRBZEd5T1VkcExGUUYyWk9keXUxQ3JqQm1yQjZzcFpwaEp3ZEVQRUt3MktxZkNpSnhaQXlsV0tXSnZTV1FtV1FteElUUThsR21uaFFUOTZud3NlSklNVnkyTk1vSHFTYmhyMzVMYlVHOUNPUGpzMlBKai9hek5ra2tnNDhpM0FCSkJVTUQrNGRLSzdFVVdMTmpTUk5BaVRTQlhqVlRkWVc1ZWRXTFd0eXRhMUVZTUthVEllVlB1dUV5cTNwSTRQOHlLYjhDUnQ0QTFGcHdqMmVLTnA1WXBGZVp5c2tNd0pRaXhMa09MSGtEOUk3MEt5b0JpakhreEpROGNqWGsxRE1uRTZNeTZFZU42S3V6czdKWnBNbGZUUXY1akRHT1VidHR5Q1gwL1dpSy9iY3lGNW9jajNTQVNrSjZheEsxbVcvMHVPWGp1RHBhaFduM2ZHaXhpeVltUWNxR1dOV3NpZVFOZnpMYi9hdENPY0pzbHdSSTdsR2NoQklUSllwcHI0MnFLN21Oam5LQnkxYmt5TGRsRGVjTUJvZU85cXJLeFkwbnhKNUE0V1dMVjFPZ0RkRDhhS2psWjJYbFFxR0FjTXFzc3FrZXBHNjZkQUxBanBSR0dLSE1IRklXL2lrQkRLTkwyTnlMSHJSVnpZU3lha0dDUk5RdHR4MytkWEUxR1lRekZwZVN3ekJmTW5Ia0NWL2NOU2RhaXVWbFplTzRrREVZN3FQSkh5MFBYeWRWWW5yVVZCc25NVEx4WmxEUSs0c1ROSmt4eVhZSmV3WWcrWG1LQlNqQ0VReVRMNnJtUXRNdkh6RmwxSE8yek1kNm9veC9iOGxPWWpnNFRTL3lXamJseERXS2NCMEszcURmbThzakdTVjJqKy9nVllXajVIbXhIN1dSdFdQRTZucFZHbUNkWUhrS0xIa1BIQUZBa0lrS0t3c1FDTGVaZWxFUXljZkRnbml5TU9OU2hqNHl4dUFRcElJREtkTmFpcHdlOSs0bkhUR3pKbGRWUFBIam5oRFRwWVg0S3cvYS80VlV4dHg4UEI5M1F4UnFFeWJtUjRpTEFPeCtnTU54YWh1T1o3bjdQTGdTSEQrM01PYWZQanVTQXNnQnZhMnV2aFVzV1hYQ21reXBjMXNqS2lSWmVaazlPMWxZN1d1TmJOYW8wMXVzaHhGeGZSNS91V1llVTYvdElON2pjQzFWQm53aUdLUElpUTR4UWlPVEZSbTVGdEdEWEl1Rk5xRFBsei9BSDdSb1ZjUm9TMHl1UXhMdnV3STFONlZKTWFGaWtYRmNZWi9qaUpBNW9qU2hyMzVHMzY5cUZkSDJ2Mi8zaktrTWd4bGttVkdhZHBiSUFCWWw5Q05oVk9NU3kxYkplTnNnK25GR0FaM0xGMmZqKzdYcWROcWd5WmFRVFJMQ3FDWGtRNk9yMlpFMUJUanFMM05VVVlKemxXYkl5bUxScXc2ZVVFYWNpQitsWmJkWDdpYk1oRHRrdXlCaDZFUnZiVS9VQU5GSDUxcGc4UTRyWllRU2xyUHhuYzhyRnI2a2ZwU0pYUTl5eUlaREhDdkZFajhzSmpBNUVFN0ZqK3RTckl4eXpJMEN4eWxtZTR1eEJGbEJzRkFZNi8vQUZGRmF2YllFWlVqeVZJbVkzRWF0eVpnZnA1RWVWYkQ5dEVXZTRRWXVMbGlLSWVvVVBxZjNBZDdHZzBTWkdVeFNkNHcxbDVDSlY0aFZHaXN5MjJvRm1ZK1A5b1JJczNyc0FCZGdZdWZpUGhURFZNL3Z2dTRoWDIyQ0lSUlJvSTNOd2VWeHJ5K1BoUS9tYnJueHdwSGp5cFBHNmNGTWpPb1BGR0pzdks5aFkvclVhRUgyZDN3c2VHVDd4TE45MUtRdWg4ejNVNlc3SHJSS20ySXRzZHBpQmhjUkNNZ0xmWFVtL0krVnJHbUd1RGsvd0FHUXlKUEc4QWNyRkZJL1BheEhxSG9CMTQxR25RYklaa2l4SWs5V0tNTTVZcUZQcUhxZU92SHRRZFNHS0l3eHc1R1Mvb216RXVDNDVrZnNBL2NkdmhWWmFjSk1OTlcvd0RJVmlSd0FJSTMwdVR2ZnRWUThEQnlKTXMrcGRWWWcra0x5T1diOTF0cjlLTHZEYlBCRkZqK2hHUUpyRlpTYmNpZjZWV1hMaU9OSkl5aVJsVlVCVUlwNWxnUDI4ai9BUHBIU3BGcTJSVmtqNHgveFNCd2ZXYTU1cmF5eHEzWWRUUWd6TVdWUFRYSWtOa0o0b3JBK2R0U1FQajFvTm1MTG1DT09ISXRISHlJamhMRGx5WFZqWVhQNDFVUFB6ek9xSUhJallza25wS0NUYjZiTHBjWDcwcEk1WHRzVFRaLzhpbGc1WS9jWEtEaEdQTkdpaTQ1RS91cVJxM2gwTTJOTWVRdkZJNWxjQVJnYUJWSi91SnVTTnRLcUZHK1NraGRvQXNwZEhrVnh5TEJBZXAwSXZyVVJMRFI1TXppQ0dmZ3E0MktTVkJKdUFRUnBiclJhbEhCbVk2dTdEMGo1K1F2dWx0U0NUOUpvTElzZVJZakxrdll5Y1dTRWdLT0pHaDVFaXc4TFVDeDVvQ3N3eW8ybWxtSUN6c1NwN0c5OTJ0b09sQlpIQkZMaUNNR09TUmlQUjRzeHVxRzNKaVJ2YmExVkdVU3lRWDVYbHQvR3BUWlZOK1F0YTNtMnVOcXFNcEVCWndmSzBZNXRGR0M0WGliZ0VudGVwVml5RDNNTmRBRVdVczM4dkhrekttdkZtRzdkcUxZMVlXWWpSeXV5Y1N4SWVhUzVaVkhRZ1gzN2lxaVpqZ2FISGlPU1RMR3pTTENGNUt2SzNFTVFiK2JyMm9pcVRGOUtLUU92UElrWW1UaTNJQU5xTHNkKzlScHFWSU1lRmsva0x5SWtXUXdRT3ZKemUzd3QwR3RFVmZaNUQ1aVNDWlU5SmlKdk1BUllIZ05kTmZDZ3paSmdXZm5QamtHTWpuS3I4cmplM0h1YUNVV1R4YVJ3eFY1MUk0cVNRaWczQXNCK2xCdGd4Sk1mSGhueUc1SnE5bUFiNHNwUFhqMFBXcmlhaThNaVJRS3dDTE1STEY1bGF3WWtYa0ovdFd3c0tLVXVNY2NQSEgvQVB0R1FWdTJpQzN4SjBIYWlNSy9jaVNSRDZiTkFoUE1teGZYVmJENnRkcUswWTR4dlVSNUNZMVloQzMxZlVMYmpTd0s3MEdyQzRyQTdOZVNiaVNZeHFGWGE3SHVlMUVMSmthR1dDVUlHSlUrZTVLQUViRHBvS0t6WXlsOGgzS0c4b0R4UmdXZGdBZFIyUUFhVVE4YVdPRlhNTGhqSUM3TnF3UWRCYzYzNmZHZ3R3Y0RuRzBpbFlVRGNaWlpUZGdwT3JXSGJ0ODZJTVdTU1pSSEF6eUtDRktzUVkrSnVEdjlPK25TaXRtUjZJTUViWlFrTGdldXErYmpiNlY1R3hObG9KR2JGOU41WW5JV0VnSzNIVXVQcHVPMm05QXBvRkVsM2x2SGsrYVJ5YlcxdmJYdFZFSWlxRmZ0V1BwS1F6bDdEejdGdmtLZ0o1SklzZU4wWm8zV1hVT0xCd3crcGJiMEI3aDZiRUswUkFVcWIyNUtPUTdmM1hOQkNIMFZuVjR5M09MakUwVXAxYnFTbzYzdjViMEZ1WkpGanppWENnRmsxblcvSzRVNzIvV2dxbXk3enBrelNjcENPTWl0b3FYL0FMVStmYWd0T0tjZVEza1pFbUhOVmtBc2RiQmdLb1N3K25PTVhnRmtpc1pBMWdHNUc1dVJmYTlCT2JLTU1YL3JwaVh5WGEwSlRWU1hOd2hOdW01b2k0UUdZUlJ1T2VRbWt6RzNFa25YUTcwRVJnajd3eFFqbGpLeEVhc1J5QUl2elllQjBGRFVKc2FXS2FScFNITWQxU0FoUjlKdVg4Zm5SVUgrMlJGYUtSWG1tWVFNOXdHQmJRc2cyc0wyb2ljZnVVMkRNSS9VTG9nUG1zU3ozOGd0YWdqOTR6TDkxTDVlYmdBTU9Tb3FteEZ0VHY4QXROQkdKWmx2NkRxUWorcXNxc1J4Qk54Zi9jZjdhRFpMbE1tYkpGQmR6SXdXWi9LQUpScmJyUVNQdVVTNUVVYjQ0bmRPVEM0SURCUmUrbHVvNjBHZUNYUHlweUpXYjFjMk5sZHdlSkFJNUN4UGV3K1ZCVWpORTZsSHVia2VsdnpqSS9jZE5pRFJGenlCUTA2ckdSZTBoUUQ5NHVORGZVRDhLS3lUNVdTY1Vjb3ViUEpmSDlNOFZMMnV4NUc5NkN6MlNMSENzY29LcXhqa25OVHFwSG1VajQ3R2c3VWE0aExaWld5UzZRNHpNU09URGpjR2lQUHJGSU15U0dVbGpvWmtRZVZ1SjVlbnkvWmJ3b3F5SU45d29SR1RpREpJZ1pPSUE2TjhQanJRVnh4eHJLWThoR2tTZGJtWkN5U1JteElqRnRXN252UWEvdjRIbUVJaitwZ2l5TVQ5SEc5aXcwQjA4elVHVXE1VjVjRXFZMllBcTl2SVFOMTE3ZGV0RVhSUE5INmtrWlVQNVJ6QzZmeWFQWmU0b3FabUUzS0ZlWlpDcTNCTEMxdk13VzNqUWE4VkFtT0RPRTRTRzRaaC9KZU1XQzNGN0MxRVFXYm5MRTd3ODhaQ3hXSnRsT21tbXBIV2lvWnBMU3laRWtUS3JxeVJNM1JyYWRiajUwSTF2NzlLTWNZQ0lGVkV0Nm5Qa0NRZGJYRy9XZ293WGdKa2FabmtWQVdCQzNzT3JINGQ2REZseHdqaHdGbFpWRHZjSGtDZnFJSDkzYWcyeVlwaldYaWdhTXNBZ3NWUEM0c0xFZlRlaU9SNzM3ZXNiL2N3K2lzOFRYWGp1N2I4QjQ2MGFMM0QyK1NXSko0WjJNWVN6eHlIL3RTTjlYbFBhOTZnZnE0UVZjVnlWV1NQaXNpWGtaaHFwZHI5S3FjdUZOaTVKSWo5dmtYRWh4ei9BQW9pK1lzbmxVMy9BTHp5TzlaYTFzeVBSd3Z0b1pBSVVIQkhDMlhVazNWbUJZNm5ZOTZxTXZ1a0VtRG5ZMERaRXYydVc1bWtpTjdNNElOejE1QmRxRWFNN0NHVDdoRkpENmZvV012b280aTlORVc2T3ZRTGZVZzBGZWJGblJlMkdjc3p5UWF1V1lBaHJhZytCRzFxRFBnWUdUN2htU3pLbm9HTUNRcWx1SVRpQnAxNVgxUGVrU3ZVNENLY09HT2RWa2RZN3Z4Rm1JSkp1YXVGcko3bm5RUXhNUTRZcTRVaU5kR1VhQzdyL1dnNThtZGdaZVFFbmtkY1BnVWx5STR4Y05hNlgyNWVhMVpWWEhpZWxnWi8zUENSY2dSK1FDMzc3M2h2OVp2OVZ0cW8zZTRjcHpKS2thUnp3d0NSZVJWVkkwVVg3bHJYNDBTTUdGbENHYmpsd3ErTlpwc2hDUUdDdjBVYmE5RDBvdFQ5dTk2eGZ2M2pLOGNWQmVNTXR5MjJoQzdkd2FHTkdObHY3aDdoTlA2YThuVWdLZktBUis1VDhoZXFWMW9ua2lrNGdlaWlJR1pPWEx6RVd2WTZYRkdkWlZ4WWNtVXh1ZjVHYTRib2JhajRVSTZReC9iTWJEa3c4bVl5NWVRcE1ZVU1TdC8zRzNTaXZPWmVWT1kyRWlCaEUvRGs0dXprK1U2N3Q0Q2c1N3FtRmxZNm9VdjVYbGpZNk1vM1Z4OE9sUlhXeE1pSklKcG80UFRnWThDVFlxMTJPM0xVY2Y3cURuNXYzRUtOanpTb3FnU0dPTlUxZFRacmh4WXNMYWlxUlRnZS93RHVFY0t4WThQRnVKTWdBOVZoQ05PYUU5OVExOVJVR3YyMzNGOGpGTVdPRWhFemhsbEpZVEtoUEZSRmF4SWI5MmxCWGh2L0FEL2F6NVBwU3lzYnpvU3NKS0c2YUxyeDdtMUN1eGp6UnZGQmxUU2d6UlJyRzJPNmdyTkdDVjVxQjNHNW9qbSs0NHNpRlpVVklwVWNzajI4NFYvb0Z0dVBTbzAxUyszWmVMSEpQbHpMSFBHdHZYVXF3WnRHMUFGeG93RjdiMXBseHNuM0RQT1JGa3hPME1remVwSUloZG5kRFlrRTkxNzYxRmlNano1ZVlIa3NBQTBzOHFNZURFbmZpeDI2R3hvT2o3ZG55WU9TbVRpTXBtQUJaaXZsQVkyNWxSdUQyb011UXVjMmFtWEVyd0ZuWXNvdUJMcnExdTFGYTgyS1NiTHN3ZVAweHl4Y1ZsWjFRZFNML3R2ME5FakpnWk1zWmVOT0w2OHBZcENUeUd2SWpzYmJpZzYwbVJpbnltSUZaUURqT05IUjdlY3N6ZWJpdzZVSEZuZDRzdkZiR2RwQkU0L2pacjg1TDZONHFvNlVHekYvNUcrUGt5ckloWEVrSjlWRUJBS3VmTVZRM3Q0VVRHeWZPd0pKV3hNSjR2dHBvK2F2T0FHSmMydHkvYVFCb2FFL2JsNUpDdXVGZ0djS2pGb1kySVY5dnFRald4N1VWZk0yUnpMdkw2c0xvUFVaL3dEdUlTZlBvT3JiMEdQR2hUN2dHTk9VYmFCMjNKdm9OeHZRZFRHLzQ0N2U0SkJCS2hoZFFPRHBZeEZ0YlgzYmowb2E2UHUvdE9UakxqeFBrcVdqSiszSUd3SnVTemQ2ck11dVFaY3hZSjNsa1hJdVNVazQySUEvZHlQMGtnRVdOUnBobXhQYjhWb1ZpamFXV1M1TVRNUWlJUnlBU3gzQTFOQmpsOXhiTEVLbUw2YkJWK25TOWdianBRTnhOa21PSjNtT1I1cEhYanh0NmV0eHh0ZTUvQ2d1aWZOU1preUViM0IzVldsdS9FbUkyc0ZQN1NEM3BpNjNKUGlTU0dhTVdqVkFZUklxc3dON0ZKTEFjdkFpaU1udU11ZkV4VEY0OFowTE5HQVN0MU92RWVhOXFWWTUwclIrNFlVMHhWY2JKUmVVc0NpeW4welpSSDFzM1VOVVhwdTlsbDl2eS90MXpuRUR4Z3FKZ2dXNXZZOC8ya2p2UXFlWmlvODVsVm9jaUl5cWhhTWptcEg5aVh2cU9sRWhaT1ZocE5MQmo1V1RFMk9WYkhlTVdBNnRkVzF2NEdoaUdESytUa1RZV1JtREZpbFgxWGxaQzZQY1hEQ3dIbVBlcnBqTlA3a3NDTkd4NFFrOEZtQkpKQS9jUWRldDZ5c2RWUGJwY2VQN2w4dUtQTWlpV1NPRnlIRTBmRys0dUFiSHJWUzFWRzhFOFNtSXVybi9BTHNYTFFHMnVvdG9kclVLNjBJS0pINnFlcUZQbEJOemM2bmphcWpvdG5LWXlGZ3RDQnByY3FlNHZRY2YzSVFwa2V2RVU1dklGVTJ0YnRZN0c5QnhaZmJWeVMwbjI0Y3JKdzlSaU5sL1lBUHAxNjFHblJoLzQ3N1ZsUUw5cXpqS0JZeUJyQ01pMzBLTjk2WWxySGtSTGhSTmhSMlhJeUdVb2pnQlNSOVI1ajZiRHZRN1hITnhoNkUwRVAyYzhYOGNrcElraWtVZytZUm56Zk1iVUhKeUh4ZmNaMkpQMm1WcDl2RXJIMHhZZVkzYnpYYWlxM1NXVElqeU10UTh6S0xBRGdyOExCZHU5UWxiSlBjSGdsZkQ5SjhxT1JJMmtTUmVNaUFYTEZHMk5yNzFVYVk4N0RuUXpTU243alNPT0Y0N1hnVWREcmF4NjcwQmdaV0xBM3A1Q0ZKVmNNbVFqWEFqNmhnTldPMnRDckppdVJLYzdNeG16TVdNRUVBbU1Ob1FyQmhzMUJ4eG13dmp5dG5QOXBrNHZIN1VGUmF6dGJpUWQ3THRVYUxIaGl4eWtxT01lSzZDTEk1TTk1QnJ6VTJ2cmUxclZVclFzZWI3dG16emdzZmNQcmppZGRXS2l3NC9TRHBTa1VTUTRrYU5LV1dDV0NNaVQwVkpkbllnZnlYTy9hMVFPUDNMUGpuSHVYbk9id2FOWjJRVzQyc1RaYmFuYjg2RmhRKzVTR0ZNN0psays2akE0bGxLeHVvQnZIb0FHYXJDdEMrOFlrc1VSa1JreEFyTzBTZ0Y3LzhBeUd5OXFhbU1PWGw0NlJ4NGpZOGNRa0lkWlF4NWdtOW05UWJYdlVha2RGTVhJelBQbmtvdjB3d1g0UktxNmkydXBxTk5EcHdaSllVOU1KWkZLY2dMQWZVcEhhcnJPSlE0azhjMzNVamVyWkNrVU52VHVUc1RZZk9pTk9lQ0l1V1hHcVN5V1BQVmxqakhsc3kydjV1NG9Rc2RVU3dBZHNnMkdJcUZSeVJyM3VUZGswcWlzeHhvc2lSUzhGWWh2TGIwMFpocVMyNUlxR3RQdHNHTkRJR2xkSDlNTXpSc0NpN0RpU1NSUVJ6ZmU4eVNaUzRTS1VXakJ0cndHM0pUMzhhbXIvTWJNN014Y2lDTkg1T3lMNmNzaEhGVmUraXJ4M1BqV3F6SXhKa3dRcWpQR0RMQUxSUjlmTWYzSDg2alNySVI4aUtYSXlvUThFYkErZ1dZc0RmdzMwb2FvenlJQkhMRGp1aVpFaWk3a0hVYldCTjdDK2w2aXh2Wk9lT2NZQStxM25rQlVCUUZObDRFbTVGOWIwUnpzbjJvWk1rY2VhdnFwQXZMMVlsV01sQnFBTDI2N25VMFdWMHNmSHgvYm41Y2pIelJXOUsrcmtqeTh6ZHZ6cXBWZnU2NXVmRmRJeENNVTNrakdvdW1uSWRDVGZRQ29Scnh1RElrT1hONlRSZ1BKY2pWcmFMY1h0cFZSa2s5MEN5VHpaRTVXVlNuMjZzOTNJTjE0Y1YxSkhVMzBGVFdzNGFjSE5ZQjVRbjNCMVpsa1R5a2diRGowdFRXYkdHSjVJc2lKeVkzeVpXdUFCWUJUdHlIUTloU0xXLzNCWkdoRWtza1lnZ2NyRkFCYVE4dHdGTjl6NXEwekdkTVdhUXE5eUZleXF6QzVlUnRCYSt0aCt0UmRYdmp0aXdURm93azhnS1Bja213L2NHSFc5NkNmdHVOSGw0a29hWkMwYVhpMUtzRUo2WCtxcWJ5dysyNCtaRmxNc0RoWTVBVlJyMlAxYThMNmVZNzFtTGE3U29aRkNTS2lNb0FZcW9OZ043TWV0VkdiSmw5dmp3WG5MeXZrcXhUa05RcW0vSFU3SHJ4RktSVmh6b250OFVNaEpXT1M2U0ZlTE1yYmN1dkhlbzFVOGxsOVoxVlE4b2JsR1ZONCtQUlY2YVZXY1dPTW1Od21RNnl5cDV6WThtVmpzb094b004T2MwamVyS3F6YzBLT05TVko2dGV3REhwYlNpNDE0Y0RSd3lwd1dLTkNPY3BHbzYzUFUrTnFxVlRrbHBEREJCR1pIWW4wU3Q3QytnWUQvY2Z3b2k3Mi9Eang4VlJMTkkwek16U3gyV3pFRTI5TnRlSy93RHlvTDhESFJSR0lZVW1uZHVYQUFzdGpvVllmM2ZDaG95NFl5c2pTQStvZk5LYkFBRyt3VUFXdDBGVkZpR0ZYTHpvdm84Q1VFWUNLejdDN0xkajNOUlVIS1pUS2NRR01sd2l4b1FYc0J1MXZHOVdKV2FWcHNaL1Nad1ZrdndTTWhnU1RxQmJaajMzcUthUjR5WkhxU3NKb2pHWGNLMStQaGZSdWEvdEZVUzl4OUZCNk1FREdmbDVsZllyYnltMjRieHFDV09yeG1KVENzU3R4OVJTQ1NHY2JDOVViY3JNV05wbVdaM0xvSTlkUkdJOVNkUisyMmxRY2RJMnlNcVZvK1VrWk5zZjFQT3JOWUZ1ZDlnZkNnMHhHWDFJOGN5S1ZEV0o0bHVFYXI1cmRUYTlWQ3hNY2VoTkdPRXZKakkwemc4bVZQcFJUZTV2MnRRRFJRTEVVOVVwSklnYU9HTWVYaWRsUGlEUVd5d3lZemVteEhrRjI5TVhWLzhBN2RlUGhReGRKQzZ3RnBJbiswZjYzVWNTeUxxd1ZUMUxIZWdvOUdTU1Rtb1Y0V3VGQ2txeGZjRGxmNlYvQ2dzeHBvWmNaOGFiZ2thQ3hsakJPeHV0N2RDMmw5NlFydUhEeEZ3WHlNcHd6T3ZMZ3BBdllianBlMVZOZWJ1eXlrUnFYUjJBRVVtOXI2RWNmM1hId3FLbk82UThqSVNzd0lFVVNxYkM1NGsvSFdpcElNaUlRaUpWOUt3WUFMZXpNYkFrOXFJNkRaR0dISzVMTkl5UjJDUmp5bDczc05iQWQ2Q3Q1dlNab1ZqamE2Z2M3bTdBbnd2eTEvS2dxZko5V2VPR2NlbUFwS2w3RmVCQjI4YjlLQytSWGlaVmVONGxYVllnck16RnRPYkU3QUhlZ3kvZVkwYnJDYk1xM1lTTUI2bk1uek1MYStib0tEb1ljTHJNcndGWkhoZG00cW9iaWdGemRUYTlnZHoxcW95WmJ4ZW9NcVdJSzhUa0FhS2VSQXVPT3QrOVJSazVlVGx5ckdJbzVjaVVDT0lEeTJGeFo3c2VPbXREV0lsWUptYkhsYVJnMW1OL0s3RTJGdTl1OUJ2OUdCSUVuamtYN3BwUE9HSkNyYnpjZzJ2WWkxTk1iOFNmRGVOMVlFK2tOR04rZmNBamVyRXFpUXV2TmNkZ0JHM0p5Q2R5dHpicWVIYnJRVnlpS1JIbktGNWdxeGtFY1M2MjZOZlFuZXhvTStWaVR2RThoSWpCQVVKYnlsYmpjOUtDckZpeU9SRVVSazRSOEZrR3BOdGJMeXNiRHYwb05DaWVTQ2IrVnVCSk1oWURRblhWUnNMMFU4YUxKZ3RJdk9XRHk4R3VwWWthMkszMm9nVlpJbUxoWXpLVHg0ZzNIRjlXYnhJNzBGYmpJYTd3eVNGU0NwOVE3WDNVOFJlNTNGOXFDSzUzb1R1a2w1WWxza0tnK2JzR0xhbTYvcFFYVHlaVWZCY3k5cmhWRVZsdUhiVm42bTFCWWtNalpYcEpHSFNNc3ZxdGNLT0syc3BIZmV3b0tHaWVKVmlKQ2NCNVdIbUREb0ZIUnU5QkdTU2IwNUlHNVNvaDV0NWdPQUdvNVhGOUtDMTVNbFlvWTJQSVMybGlDamp3REVBSC9TaUxaNHZSRWpsZlU1c0hMOHZLVGJ6WHRwY0NpcVhtNFlra2N2RlE5Z3dPaHZlNEk4TEhhaUo0cEJaNXNqbE0wUWpqanV3aUJzVG9wQjJDN3R2UlllWGw0UXlKTVhHQmRKUXQ0aWZOeFBUUVcwdjg2QmtKSWt1RzBheHdRTnhsa1R6T0drMFZkT2cyRkJsTHRIQXVMSXZwY0NGWnliZ2h2THIxdUxkYUk2Y1NBeHd4Uk5jTHJLeXR2YllBalk5RFZGZjh6VFRMNmdqQklNVEVHeWthdHZwYjQxQm5saU1BUUNZcDZyQjNrSXVleU5wdHAwb3JaS3lRcGpvOHBsRXFpVWdMY1hhNFBJbnVLRExnUnd6R1o0b3o2eUh5RG8zQTl6dHAwb0hrTzRDTGk4c2RtUnZVNDJQTWsySVpUMzI3MENqV05aUHRsQitubXlzTHB6VUVIWGZmVFdpTk0vdUNmYndGcHZXTW12Rnl3TjExS3R0WUtCcFRWeG1reU1OOGt3VDg1RUVxUDVMTGE1Nm50clVWbU9SbWlPZDFqUnNac2g3cWJBeUZSWWc2M0hsb01FY2tLcWtySkpEaWtLSWs1QXZaV3ZaZmtkdXRCMG80OEZNVDFvWUF4a3Z5VW5rcHNOUjRONDFXWGw4K09LYUJCamdNNmxteTNrdUNIREFRcnkvYjVhamJvZTVxa2VaSE9JUFhreklVVUlTeGJHYUt4TWltMzFhSHk3V05FWnN5WEdueUMzMnhqRWprWk1WMVFXR29Jc0w4clhKNzFGVnZocm00OGk0TFNaV1BDcFppbDdvVmE1QStsbVVKWWtuYXFqVDdIN2w3ajdObnpSd1loeU9mRVNzNHZ5ZFU4d1VqU3pYdmFoWkxHMGpNbjl3bHNUSEZOR0xLR0pSQTJ5MjdxeDMyRlVjdjNMS3l4aUhBUUIyNUJja3FRcFJFYTVVL1BVZGF6VmlIdWd5Z0VXSEdKZ0FWNW5CUkQ2YU1GSEd4SnZjNm0xK3RDTDh6M0FUZTN4WXJnUklPSnc1Q3dMQXNUZG1QUmRON1ZVeEIwR1ZETGpRTGVXM3BTY0x0WXA1dlVQUTMyb0VJRms5dVFZSzhta1VDWlhZK29yRFJ2S2YybiswVWhVdmFNSEJ4UGNERkRrbWJNS296VHlEa0ZZcVFRdHhhNVZ1TkI2eUwyYVBHWEhLanpyZHRMN25RY3I5TFZZbXEvZG9ESGFTUmk1aWtEb1ZOMUpPMS9INDBSejRYZVJpWXlXVlg4akFqMUdhOS93RDRtZ3h6WitTdnVYbWthRmI2TXY4QTNOQmNKY0RZMzFxTlJQSW54STUxRGY4QWtwS3BabVFHNEpGMWRmQmFDV2RGN1o2UWxCR1hOSXlLanlYc2h0WStvdHI2YmkyMUUxQ0MrUWpZK0NJNHBwYlJsSElWZ2lHNEtGallNM0hTaTFSeHg4eklUSHlNaDQ4ZGVRTGl4c3hOcnArNnlrN0Uzb09mbDRJOXZ5Rk9OazhvSVZkVjQzNGprU2REdlp1bzNvTHZiY1FManpPeXBCTEtPY1VSSkhwRWprQ2pOMGJVMEtJaG5KR2t4aWpWZzJpdXdCTWdOaW80M3ZjYjk2RHN3SEl4a2xreDVRSnBWYjc2RW9CNlJOK0txVHNEZllVQkxoUk9HaDh6T1VVRGlSOVRXTm1KNkRwYldrVzFuOXlWTXhsRTk1SEs4WXAzSkhFS05WWU5iLzYxV1ZVa0dORENmdGNka2trVFRKQkk4M1YrT3VyQTIrRlJXRDdWc3lXZm5qZWpvdkRIRjI0YVdCUXQzM3NhR05LZTN3T2t1Uzd2aVNvd1dTSWZTNm90eUFnMThLQ3ozTEtDenhxbVJPY0ZJaDZFcWoxQWtoMklVNjhUMVhwUVRQdUdGRklzNzV6NUU3UUtrY3hKVU5yYjA3ZjdlMUJtVEZhV1o4bVhHZDRWYS9aVlRwOU8xQmFKOG1UbEpGeFBwc2VQSWdoazI0azkrMUVTVDJlT1QxNXBFVlZXUG1XNWFLMmxpZzB2cnZiV2cxREJtdzhoTXFPWEhsUlRmZzVSemFRV1lPbTUvcFFaUGVQK09QQzhlUml2RXE1SkxJbHJLUzMwOENkQUZvc3JEaVFUUkJWeWtEWkVKTC9jMzgvQXFGQVcvanJwU0ZlamdXV2JGVkhBV2NGZUxGUUkyVmg1aTUzMW9tdUZtcC9LUjZmb3lNeFNLTWFxeDVmU3JmdEhZbWl4R2ZOa2daSWtlK1JJRjlOK1RHOW0xRGdkZjIzRkJyZkt6TXFLU1YxT0hNaGFOMFlNYmx0QUR2eHVlaG9JKzJaK0VrYlI1VUgzRVFzVzR0b2JhWGJscDhxREkwb25NeTRxaFZVaHNkbXRvbzJDazlPL2Vpc1dUbFR5WklqQ3FtUUNRemNPTE1ScHhhM2wyNjBHMCs0NHJ5U3paTUpJVlVRUEJJUlpJenhmV3grb2JVVEdmM0VaK2FxdkZILzQ0QkN5UnA2YkNPLzhZazQydmY4QXU2MUZXUXplNlFxTVdhU084NkJaRVVYS2hOUFVZV0FWaFZSMHNUQUt4VEx6ZHNsRkVzYXFuRWdqVzNocHJmWTBIbDhxREltZkl5TWFUMDFhUUNhQmlDd0xibm9OOTZ5MGxIZzUvSS9iSjYzRzRsU1BXNHRabUN0L2NPbldoYXY5djlza3paMkRZLzIrWUF6Unl4dng0c3BzdHdUcHg2MjFvVnVoeTF3aEpsNXNhLzhBc0loZUJWQllOSUNPV3VvUDkydFZEbWdoemtteW9wVmQrYXJORTdGWkdMSFpZaiswZjdUUmVtV1gyK1dTV1ZKSVdiSXhqd0N5cm9xTWJhLzdyN2RLSnJWN0Y3ZE83U3BNell5eHN4anpEeDlOR2p1d1ZyZ2hTeEZySGVpNnU5bnpNUlBjR2t5NHhLcmxtWUtlQ20vN2xBMm9qclN5WVhyK2xEeVJITjFXU3kydU53UlFRbWRNV1JrTHROSHNiclkxVWNmTE1yZ1JnRXhrM1ZkbFc5Ull4dy8rTE1Ga0I5WGt3VnhxaEMvM0VlTkIxRjkxaHg1L3R5aUdTYXdTVWVSVko2MzJ0OGFxWXlUcGk1ZVQ2RFNwSStRRDZjbDd4ZzJ1VGNkUU9sQmlHREVzcytUa1A5MUJBb1ZraWJpNFFXQWRPVzNtNlZHa1pWd3BpamdKSGRGQ2x5Zk5xYk1TTGhYYW9KdzQ4K1RNTWVVTXNvdnhqbWEzL3dCZ1JwVlJGWVo1WWx4bnlGVU1RQklXdWxsK2xXdnF0cUt0eElabzBCeU1ZeUNSU3NNenFiYzlOVVlhSFFVaUtKUGMrSHB4WklSVW1ZK2l4VzNweUtiRU4vOEFMclJjVndSU0l1VnduS0hIY2NrRGZ4V0I3RTYzT2dvaTdOeHNUM0RobkxtTDl3R1VUSklwYms3V0FBVWl4Q3J2UTZaVXg1V2hZSmxyTGl3OHlNZGlxQk9XN0p5L2NiYmRLaXJYbTl0KzBNVWdlVE1LaEdsUnpJbnFuWGt0aGNGRjNvWXg1Y09QUGtZelNyOXJFd0FYcnk0cll1YjJCMTB2UlkwWWhsU2NZeVJmZUpySDZVcmxRT0k4dkVnalVYdmZyUkU0SGxWL3RKQzBtSGp0SkpDaGZrQTNmc1NwL0dxTFpHbGhrVjgySDBzTElCY3pSb0Fza2lyWXFPdGlkeFJISjl3d1MwQWxrWlVNWEVSdDBZRTZCZkJldFJyY2UxaHdJSlVpV2N5TXBGMUxEUVdPaFZUMG9ISklJODJLSGh4eFdOaTZrOHlxalpkeHFkNkRMa0RJWlhrNWVwNWl1aHV5cmJRNjZnTFFjbjdqSmtrdGs4bHhoY0dTeEpZRHBjbTlqUWE4R1pVeVk1STRnRm1GaVpTQ0IwMUE2R2lZMnc0cCs0SHBrUEdSd21OcjYydmF6QUVXb0laYk5uS3haQjY4SUNvRVU4WDQ2a3V4T3VsU3JJNXVMbVBKTGtTWkVxSUR4RDhsNGhMYmZINVZHc2J2V3hjVmk2czd2THFrN0xaR0ZyQmx2VjFNS1BIdXhKY3ZLVklXOXdMbis0L3JWUkxOOXV6SW9mVmF4eHdDR2x4emU5LzJtNStWNkNQdC9LZU5WamM1U3VGWldIOGZGMDNIbUYvTC93QktKMHJ3aVJKSjl3L3FOeEsyc3pPMnZLNUp2MTAxMXFOTE0yZWIzT1hIQmQ1TXhHLzhpSUlvQ1FvUEtkdmxyUk14ZEptUktzMXpKT25BaUlFcmZUcDVmSGVyYWtpckFSWm9UbVRBeDR5eGppR2JVZC96b3E0UDZFQm5sZFlUT0w0MFpCZHl4ME1qWDJHdDZnNHNaRDVVMEpoOUtaeXNieUc3czMrN1E3dGZXbzM0MjVQdU9maWc0ZUhLeUZ6NmN5cG94VWFzcGZwcnBwUXlWYmdZN1JJY25KbU1ySzEyZGhaYmtia25Va1ZXYTBZYiszWldWSXlTcStPdkdNdnNPV2xsMU5JbGlXYlBGRGkyZ2w5WElZMlZ0dUp2YlFHOXpTa1pzSVRDSmhsT0FmVTRsRlltUm5JR3dQbENnVWhZN09EN291SEhORWlpUjE4c2EzQUZtR3Z5OEswem11QmhQazVQdXVSa2xMUlJIMGhJN0FxR09sN0RUajF2V1kzWFdQdW1MNkpJUGtoVUF0KzNsMStyWFhwVjFNVis3NWpyanhaQWtqTU1NWU1hUS90WnlUL0lTQmQrL2Fvc1k4TEsrNk9OTm00M3FSeGpoTnlkb2kwdGp4Wm02YWIyM29OSmxnTXFDU1lJMG5sWFM1dnZjQVdBQTJvWTF4NHVHaVJEZWU1RGNqc053QW8xT3ZYclZSV1ZXUjVvbWdrbG1WbWVKWXJFQnI2dEkyZ0FPMXFFV1kySEtjYVVUK25DTGVxN0Z3T0tuUmRGdWZOMk5DczVueUlNWWxWNERoelJ5eEhIbDVPV25RcjNOVmxwd2s5T0pWUndVbEhxR0V0b1dBR3ZFOSs5Q3U1aDVqUVErdElvaU1aL2lDL1R5NDJGenYxMXFqSi83Q0h6TWlrZVE2dU9SWnRqNVRwWW5yUXhta1NQRm1sVE5CVlVJdXEyOVVsaGZqcWUxUVpUbDVqU3JCN2ZFMk9Vdkp0eWZpNjJzMWh0cnNLbzNmOEFxWllzZkhkZ1RLWTd4T2RTVkFLbHJEWGZyUWJQc01Wc1J1YnJGbE9SNlFHdHVPOSt0ejB0dlJIUGk0SlAvd0J3UlBKL0NXa3N3Si9lUjF2YmJ4cUxWK1o3akMwRG9YOG9rVUNSZ2VYRzNsQVpkNzFVYzNsbERuR09hTWJMSXpmU1Z2eXQySExlaXRrZnVNMEpHU0VEQklpN0l3UERpVFllWGNzZTlUVENWa1pFeVhlN055QU1kMVZtSnNRR080dFZHck16L2JUamhNS0lKSnBHR0RLYnVRQTdXMDBYd29qUEZpeHNrS01ieTM0aHhjaTNUcnBmL1dpdE1rY01VM0NISVpvVVJVYlFOd1ltM0lmM0VMK2RFVnh0akRHa3gxbGQ0TGxTOGhJQlFuVVdON2ZPZ29DQXhoY1hSa0JISmJNcW9UcG9kaTM1VU1iTUxDZ0dPOGFSS2pGUTQ1dDVqdytzRUhUYy9WUXRaa0U3WTd5T0pHaUpDaU1EbGNjckRpeDA0azl0NmltbUVGZFlpWEUxbU1ZSU4yTGZTQ1ZQeXFoWk9KSVNxU0FsMzRXczNJamo5UkpIMDBRUnk1TU9TY2xJZldoUnlrU0tiY2piVmVMSFh4b05lS3NPVUdsZUlvMXlYczNJRy9sdWIyc0J0UVpwSFJNZ3h3SDBuQTVOS1NOUWcwRjdiSHJRUmp4aktXVlA1TlY5T1lBaTVrRnlVR3RsdnQzb3E2ZVQzQWlSZzByOFVLODkrTnRDcHYwTzlFWkpSUEhONnBqL0FKOUJZMnNBZW9BMjFvT3Y3WkQ5eVhqc1ZjcC81SmtOaVFwdmN0ZStwcWkwWUF6VHJFc1laaXpzQnVSOVBId1dnNTh2dDd4WkRSRjJWMEpSQUJ5TGNUYzJQVGVpSUxBcnkydmYxU3lGcldBRGZRWXdPcDZWRlF6c1NURlJzZElrTVVSV01LekJpSkdGK2EvN2lwdlJYUUlXT2FPQ0p4TThSV1FTQW02QWdrb1JiVWs2MFJSbDU0Z1AzSVpYa0toTE45QURHeE9tNUM5YXBFNGN6S3hzRGt4SXh5L0pGY2MrVEhRbHJhbGRhQ3pPOTdLWTR4b29ZNU1ZZ2tURWMyR284clcrbmtlblNpSE5uWnlLbVpBa2FxTENPUFJnUVI1aXEwTVNZeWVqR1RZSk5kbUJJOHpQdTdrYWdEKzJncEJ3NFpQVXh3M2xBQmFRVzg1RmlRQjAwb0xjUlZna2Q1V1Vobkg4YmtjaUdVM2ErMWgyb0VySTZ5T3NwYU14Y3dwdXRwZ0R0YjZyVzNOQlg3Y2l3KzJ0S0c1UEtPZG1JNStWK1NsU1IrNXR4MW9ObWJDRGpyblpNcU5LcDRncWdOamEvd0NQeEZCbm5BKzR4NVl6Nk1qb0NnTEVGbS91STJVOUxVRFZ4RVNnTGlRTTBrREtQNHk0T3dOLzI2MFJoamtsZjNWMzlNU0tSeWxaVjBidUQvZGZyZWl0a1dla00vb1NRL3dCaWZUQ2hqeUExRit2NkNnNlB1SHVPSGsrMjN4UUl6R0x5bGxES3ZoSXUydEJ6MnhNWGpobVJ5UVBLMFlON0VFZjNVRldWS1ZFeUlPZUxGS2VNWlVXVHpmVXA3RW5hZ3o0ZUxORk1KVlVpUXZmazR2WmpzdGwwMUhmYWdzaVlPem9aRjVBbDNzTFB4djFBMHRjV0ZCREF4czZSNVlqSnppa0Z1QTg5d3h2WW5kYjJ0UWRiMnVLVEFMTmtRY1lISlVNU0xoaCswcVAzSURyVlRFY3QvWGtrRVNGbzFIRnREeDlQWTN0NDlhaXNYL3RWZ3lKWVpZbzVrU3lYMVlLdS9JZHpRWEpKaXJrU0pudkpKanhvV2pKQTRIVHlodjhhVUdMQ25YSGYwMGtaQ0NES3Q3RjdHOWxQVVVIUXo4YkVNRWM4VTVqV1VsbFlYNUJqdDRocjZVRll4azlBWkROSTVrOGtwQjY3ZVluKzdlZ3B5Y1crTDl3L25rQlBwalJpSkxmMm5YNDBFTVRKaDVOam5ITXVVOGRvcm0zbjB1V0czd0ZSV1BFa2pYSmQwVzRtdkNVYXpEbnk0a0JUdnZwVlNzZWY3ZG1pVDdFd3N5Ri9VWGtlTHRxUXBCRzIxcjFGMFNKREI3VEdNYytwTThucHlTRWl5OGJCN2dFY3I5S0d1ZGc0ME9SbFJTVEVMb1VsallzcU0vSzZOcGZtQisyb3RyZjdpelBpV2c1UnJFaEFzUXdMMy9rQ1gxdVZGZ0wwSEt4YzZIUHk1eE1KQm5PbC9VbGNSQmVPakJqNWw4eVd0MTdVTUh0MGVmSExsWkN4dWtFb1dLY1BkbExCQ0xoN2o2aGF3NjFZbGEweXN0U3NlSjVJWmhhYWFRTklVWkJ3dEdCWTJ2MTNvWXZsek1wc1RIa2praWsvd0R3cE9XamNDZUFBdmJVRWZVTmFvNnVSN0poWnZ0cis1eFRSSE5BTWNzVGtOS1RmNmxBL2Qyb3pLOHpQa1Q0ZVVxbUZBMlBlS1NaRnMwYXNvSG5Kc0diK25qVWFkYkxnanlmYmdCZ3JBVlFOOXdHWmZLQmN2WmhiakovYjMxRlE5WXZiZjhBd0pXV1ZXaUUyT0RqUEc5NDNzeEJ2L2Fhb2dnU0xPRHBOSXZ1RWdZWTBKWUw2VGxmTSt1aEREYnZVV3NpdEtrSmhFM3FxRzVESjhvMVhXeU1OZFAzRGUrbEI2ckE5L2tZY0dkK1RFR1JCcnc0aTNMdld0WnhzOTM5d0dXZ1hIWDFvZzZwSzdFWEJWYmh1T21uWTBNWXJ4ZXUwa3lJZ2Y2VTNJdWJHemQrdXRFUXlNZk95cDVEZGVQbWplNmhTMGFpeXE5LzNIZWlrMkVrTURUQnVDUkpjTzMwOFU2RzJoc1Q0VU5XZXA3Yk5CSEdzaGhsSjVPQXZxSVdJK3RiMklzbzcwSG41L2RIRXJwSkdzNGRqNXVQSjdBV3ZlNEJXMnBIZW9vaGIyNUZhWEVEVGFKNnhUNkkzdjB2djVSUWJzLzNCSWlZMGg4cXNHNWFjSEIyTHNQS3UrcHFwRUlaTWhwVFBsTWtPS29kWWtacmMzQzNLSnVlUFVCdmhVVlZoWTFwSTNNeXp3U1c1eG02OG1hNUhKVDFBb3NycXh5bDVVa2xLdkp6RVVxb1FEeEFzcFVuL2JwYzdVQ3hVbGZPeU1JUHdqSko1UHF5MkJ2NXRMMUlWb1RBbWtqbEloREZFdGtDYTJvYTFtSVBVL3RJcW9yazltblI1SlBWQldCRktxN0ZXYVBiamI5dzZVR2VhYjNERlZzekZWUWVQb1NTcllhTWIyMTJQRVVCQm5aV2ZselpyeUNKWFpZMnh3UE8xdnBjWEZ1Skk2VUIvd0NxeW1saDU4STNjczJQR3JlZENvT2x6YTlCaWs5cnhCS0laRkFsZVRrWndRQ3JHNVlYMnNlOUJzeHM3Q2dVNG1USEltVkliU1N4TmJsSC9hNkhSalFQR09KSm16K2lWaGkrbXhHbGwyRnU5Q3JjdjNLU0RHWEU0SytPekx4a0NqMVZCMEEwcW9vOXNoZ3pvL1d4cGthY3JKRkZDaFZaT0tBL1VyRFR4dlE1YXBqN2djT0hFekZKalVoRmtGbENBQ3d2L25RMUdCOFdWbU0wb1lyRVJCSXlGaUxIV05RTnoyTzFCSTVIcHJLL3F5U0p4TmdGK2xsMjA3ZkNnNGZ1T1FyeGhuS3pZeWdzMWd3YU81QU9nMTVkYWk0elorSE1aZnVQYm1NNXhvMWFTM2xhRnIzNUhVaGdQQ2l4cDl1aWIzYVZzak1sR080SG1JYmdOTm1zZk0xK3ZqVUU1WVBkTUJta3hBa2FTcTVBY0EyanNGWWxXdnZWU3FQYjhxZkZsWVI1REo2NitrcEFCUTN2YTVJT3RCUEVtbmtqV0RKWkZNYkZHc0FITjlEZTJwRGVOUmNSOXg5dmFIS1NBcXNFTWdGeENicUZVYStXL3dCUU9vNzFVYmNISm14dmJXOU9UMHN1VWxES3pEa1kyRmdySzQ0Y1QrSW9Wa2premxqYUgzSTJpUitQcUlvWndiMzlOanNSKzZnTTFzcEFIaXlvcEZqMVNRTVl3dzN0WTliYWFVRVZueGN1UXp5d0RHTW9DUnNpMlJwRlAxM0pBdU8xUlVJakZJc29JYVNTVmdrMFNpM0xpTkpZK0kzNWRhQS80OUJMRGtUSW9TVG1HSEdaZWZMWFd6SDZHVTd0ZWhVZmNobkRGWjVNYkhseXNkdU1yY3JNZzhRcDh3c1BxRlZJaGtTeFpBaTlLQjBZSjUzVTNzd0FQcWkzNGZwVVZPWW5Da0xKa0NWY29MR1NqRnVFWDd3NUpKQnZxS0swUVJObVJ0RmpwSkJNMy9jZ012a21QLzRiRTdYQTZVUkwybjIyYVNadlJqL254MlpwMTJQQkJkdVg3YjlyVkZkQlpqa0x3Zm1nQjV4b3k2OGpwYS93cW9tOHVQRk1CQ3k1Rng5UXVMRWJnQnUzYXFrYzdQelhsTFJSQSttRGRGTnJpK2grWnFWWTQyWm01WHRxbG9KeUl3L0pXUG1aR0FJdHc2ZzdYb3FPTkZuWmNaek1MRGlRd0lKSnNjUG95WDFZSytwdWRUYWhjYS9hY3lNdjZPVmpyalk2am1ab2JNVVVrc2RIMHRldzN2UktxaVgzRDFIa2pEeUtJMlF6QmJsa1kzVlNCZldoaVVCWlk1U1VSbzJBNElGNUx5QnNWWUN4VTZVRTFYTWtTU1RrdktPeEt2Y2pnMmdXL1phaXFjSEZmT3kxaUxoSkhKVjQzWUttbTFpYW9vbXlaY1dLWDI3TWtLTDZ2a3N4NG9TYk1VRjlLQnpZK1d2OENIMVdsVnlqUForU25xcC9hM0hyUTFMR2dRUlRRVDJhVWk4VTF0T080NUE2MGhVNVQ3ZEhFSXBZbVRKNDgvVWo4eEJVV0JzRDM4TDBTT0prd2Vrck5DNG1lZXlsbFhrcGJjdFkvUzJsUnFOWndnWm80ek5iRnVGalpUd2IxRDVtREwrMjFEVzdPOW95L2EvY2pEbnd2NklVTkZIS3Qxa0JGaFlYc08vNjB4SmRhY3ZBV0RIWExqZEd1UzB5Uk5Zb0dGZ2pJZjdxcWF2dzhHZWJIRTBNQTlNRTg0WDBDMkcxejFQUTBYcEJzZHN5T0tCVy9nSmJoRXpGdUZ5TnI5ZkdvTmt2L0g4VnZiWllKSGFPY2VaQkxiaTNIczNUNVZjUzE2S1BHVkkwa2g1bVNNZVIyUFQ0YkMxTVhWRDRjazBpbHRXQnVFNjNJdHQwdjFxTHJueUlWa2xpbmpBaXNTd0RXVlc2dXhHcDQ5aFFjbkpCUlZYMVNSYmhDOGkzVlFUcllianZRWEJHancwZ2hZeXE3QnliWFppbzZjaGV3b0xqRzBVWjU4cnZkdVQvQUZCd1BNTktVaWpIYlBFdWpsR24xTDdlWHhBMXFERjdvendIbktJN0lwYmd5amh4ZnVGMTV0L3VOU3JFZitPckhrTzB1VmxTd3JHQW9ZSzBrYXIvQUc2N2ZLcWZUMEdSSkxnbVJzUjR3RUhKWGNnUHdBdmRsc1RkdkdtcEdQSGxseUkvdldrZFZkZUxUc0J4NW01SUZ1cDZhVTBzWTQ4MUdrbWFNQlRBVlhIZ2pYeU4vY1hQVTk2TGpYTm5nUlJ2Sy9QTWxVSElrVUd3SjFzQjNIaHZSTVlWbnljaklPVmpzNURoaG1yMlFXdHliOXZnYWl4MDhLSDJySnlJNE10bUVvVzZKR3ZFOGJYUEs5dHZHdEpkV1JrVHp2andwSEdxbTBVYmpscVBwdllYTi9DaU9aN3A5aGl2RmpSTU11VlhReXV3SUFjbTdLZXRoMnFMSFI5dTl1aWx6SG1XSlBUQTBsVTJVY3Y3Q1BxcElXdTFON0ZGRmhrY3JxcEx0eXNRcEl2Y2VPbExFbjA4dmxybHljNDBpV1FLM09WTGk1YTl4ZFIwcU5vWkhvTVROam9xSzdYZU1LYnJjZVp4R2R4NDBRNDBtaHgyelBLaWtoUzhhZ2hRdlNPK2hhMjVxb2NIdGJ4WlVjenluME1wUVM1VXM0WHExbFBsTnRxTHJxWXpZWUdYWUtSSW5HRnlMc0NORkFCMEYrdDZJNHlJMk1raTRjNnpQT2VNanJxYmZ1MTJzUENpbVhqbW5oeFZqT1JIR0M0VmlJemY5dzE3bmFvVjFvZnNIeFZnbGhtbXlTR2ZJOUlYOU5WK2dGbTArTjZxYlhNeXNuSHlJQXVKRElFNTNMT3hJSFFjbW9weSs1aUNPWEdJalo1Q0ZsZTFndHRWTi9IZTRxRWRQMmpFU0tIMTN2NndQS1NkVzUzVS9UeEozUDdRQlZoYXNnbnlGT1U0NDRZbEJqZXptL0FEektSMVA1MVVhUFRnTG5HaWk4aW9wa1llVWk1MExIOTE3OWFyS3Q0OERsSXJFdElnYjF1WThwVUh5YUczbVBZVUUrRE5ESS9BRDBiQ0ozQkRvdTl2RVdxS245NWtCNU1XUDFKRms0R1dCVGU0dDVtUCtWVkduS1RCWlpuRW9BZ1lLQmJpNUZyOXpZaWhGUzR5L3dBUmloWXlCdVdWTUxLWFkzNHI1dEZBdnJRWFk0bTllV1NCQ0JHckxaQ1d2L2E0YzducHBWTllseVpNUjJsams0RnJLeTM4eWpzUVJwOEttbU5XVzZ5TVdtUmlBTHZOSGE5aVI5SGJmclFadnNlSE9XWjBIcGtySHpIbTRnZlVvMXY0bWlwcEZpd3hveXhIN21RcVk0d1M2Z0hVaHVvTzJsVkxYUmdnTUMrc3FlcFBLbkJuSTVxMTFQa0tuWXFUVEVZb1k4UEdobWJNRXVSRndKZEZZcC9MYnlqbWVpYjZWRkpzZklkZld5VlJvZUJTSXRvU3RyaHdCK0Y3VlJqeFkwUmtNaThva0J1bDdBRmlBVjhOS0kyWmZ0UEJBWVNJdVNnb0ZZa1d2OU45VFNyQ3dJY3Q0L1RsWGdBR2VLU3cySTFZZEdQVzlCYThSVExqamNHVEdqdE82cHhJZG1HcFpnTysybEVTNTQ4ZkZZc1ZrRWhKbGxOaTdqWFJQL2owTzlGWnBjakt5RVNHVmZPQTNwd29QMjJ1dG0zdUIzb0lZcGhsVUVUR1VLdDRWY0ZRU2RRR0Z4YlU3MFIwSkpKVGlwbXpUQ1Y0enhYbG9SeFBsQXNOKzFCampjWmM0aEdRVFpydGUvRUZyZjIzTytob3E2WVNaVjRWVVF5UUpkZ3pBcTkyc1dGckhUUzlxRFN1TkwvNjkxamxOZ1ZQQmYzZ2VVdHJyeG9tczB5dmtaaEVxWGlKOU8reGE5anhzYjhiZjNVQmtaY1N1OXRYWkRjY1Q1Ykd4NFczQkF0UWFNZk9SY1Y4UXVoWW9sbFlIY2VZV0s3VUUwaHdpY2N4dUFXdkpLV2NscE9RMmI4TFdxaHhzc3l0Q3lCWkhabURnMllJTDZTSDkxdjJpZ3V3Sk1neDZPdkVramk1Q2ppbzFBSjhOYUlwa3paSWpPa1pJa210Rk5JRzVXVzl4eDdEUzFGVnpaQ0pPQnhTT0t4WkZmbDZia0N3WWNkZkwwN21vTUdTdVRrWThVVWVUZWNqMURrbTZBSWRPVjdmU291S0tXQzBhNWNLUlhaZVRSNU1xbm1CY1dSQ1RwWXR0clJLNmd3Y1gwSDlaUk5Lb1ZBVk4xQUd4L0dxalJIN2dzdUtUUEtoQ2tuN2NlVm1ISGh5TERzZGhSVmNoZ1hGV0NPSlVuWWVWVzZscmxmd3R1YUlwd2g2YXkrcktRSkNEY3FHYnk5K3dOQmxreG5qbGViSmhiSWlRaGZTUmdoMXV3SWJYVy9Tb3JXNi9heU0wYXJPVGI3WTJ1b0kxWXNwT3R4M3FvcXlvc2kzTnVMeUphMFhKVjVLN1dIRk9vU2dsblF5NHNVTTdjdi9BQzA0dElCWWwwT3kzdmZiV2lveExNb1JjZ1hqeUhIcHgyRnlHTjdnRGJseHFEcHpaaVpFSXg0K01jeWptNmFJQUFMRXRwNFZVVWVtQ2p5VE9DVVlQd1lnaHJBZ0c0OFB4b09ia1orUVVFa1FWRUxGM1poeEFCT3BDSFcyblNnRExGUEttQ3p0RXBEU2pLUStXUlh0eHVSdFJFcGNHWVNNSTBsUWNiUlRBMlp4ZlVBRDZkZERRMUNXSjFuYU5rY0tXQm5KRmx0cGU2SFFuUzlGYVVWWUZtYWVkbmduREphd2R0clhDNzJDN2k5QTRZNURKakJqSC9OSW9qallXRGpqZGU1UHc3MEd1V2FPREhsa2laNDhpZCtNcUVXS2hUeDhnSDdqMm9Nck5oZ3JOQkdaMVp5azJnR3FqUzdqOGFBQ3c0L29laVhPUXhMTEpmUUcyaHVOemZlZzJUQmNtQkowY0QzQ3hFa0xFZ01iZldqYkcrOXFHc1JsTUNlbThmb3NWUHFPeHViOUwyMHQyb01RamdsaDRTQXhMSWJjMFBQbG9SWnVvMTZVR3BwWnBvWTBqeHk4WUJCakpJa1pZMStzbnc2MEdjZWtzdnBvWGpoUndURXdGN0cxaUNkVDEwb05rdnB6eXljSnpKanlBT1FTQU9RK0F1dkhlOUJSZ3luS2l1MDJ1T2hqQ2tIUWg3V0JIMUZScnk3VUU4alBhZUxJRHhweUw4UzhkenoxdHlCNkg1VUJqcW9qaVZZMDRFOFhPdk95dGZYNUcxQlJuNHVNa2J2Q0dXS0lFbGwva2JreHRjRGEzNTBWVjdoa0dQTFdCNWY1VEV2SnBMRzdFYW01MDJPbEJkaCswZTI1SHRjOGZxcmw4M0phQ0lqZ0FkcEEyOXc0K21vVmw5M3hXZ1hIbnlPQ3hsV2lXSUZWTHVpMnZhK2xXcEhDaXg1TWlONFhrakJMUm1KSk9RVGhjL3VCSElqL0FQU3JMVWRiRzl1eGNtQ0xEV0NTOFVqR1Y3TGFXS01XL2piUmJnNjJiYXFsYThISDlwVDJ6STlTU1dMSm1JV0tObExnSXB0eEpHeHQrSFNpZXVGN3BtWjhPYTdZMG5Kc01xcWVoWmtzVkk0OEY2a2Q5anJUVnhMSGd5UHZHYVhGKzRsbUFiZzZDTlFlTm1LZ25TMXp0UXgxY3Q4ZUdDREhqWVkyZTUxa2V4RFAyOHV0aU5LSk8zRnczeEpjbGw1U1pLTEl2cXM5MDlPUlQ1VlFzVGZrVGJ6VkdyR3haTWVXR2ZHbk16WkNxMGNVTEFzQjZSOHFxVk93dHZUVXhseGZ0TVlJN01nYkkxazlROHJDNVd5cHN1ditkRlcrKyszUnd6WUxRd1J5YzFNL0tTNnV5TUNGVXZld1VHaEhPT1ZDMG1PeHd3TU1zd2x4ZzNHOGovOEE0a1ozSGM5RFJXL0dYN1hMeUVtOVdOeVNGVy9MYzM4N0FmVWFJM1E1ZUJsWkRNcDlNeGowNWlxa3hzcHNQTVQxR2x3S3FObUtaSm5rSmtqUEcvTXNPSVVxZUlBSjNGVkYvcFNzWGpRc0FiU0hsdDIwYnJlaUhNc1NsK1ViR09WT0JSU09Ca0gvQUd5UWRPTjk2Szh5OHZwSkcwSllaUVl1eEtsd3BrMEp1UDJiNmRhaXRZR0tqaUZaVlZGUW1RT0FYV1I3SGd0dFZ2dU54UVZ0bTQrRGt5dkhpcEx4S282YUV4RjExWjBPbkU2ZkEwQzl6OUhNd0o0dlhXRnNjaU1pSWtSNUhJQ3c4MjV1Znc4YUl5UVF4UGpQTmtQSW1VcXFaa0Nsa0tuUVNNUmEzYTFGMTEvYkFmYjg2TC8ydHA4ZDdGT0htTEJqZmtGSDFBK05BWjJWaXdTekNDUlpRemxzWkF2SzNLNTRjaHBvZWhxTEpyTGorNTQrUWZ2NDI0a3B6eW9nVlhpNmFYQzlZLzYwaTJPbHlJUlBYQWtrUG1qYmx5QkZyM05yNlhOWFdjVndlN1NZOEp3c2hZNUk1MlBudmRpeUcram5WQmFnb2c5eEdISlBMa1I4TWFaUUpJcGZPanIreGlGMThwYjQwRW9zcVVMRGtSM2tpRHRGaXpJRjhnWmV3Nkt4MEJvak5Ka3l3WWlGb2Z1aEU0NW1VbmlRYjlOOStvb3E0ZStZc1RDYVJWSXNHQ1d1dXVnVUU3MDB4dHdwRjl3ZVNJdXkrbHlZdUlWNXVMOVNkTERyUkZVUHRPRjk2a3pTK2xDZ3RJV0lKNUUyR20ybFVsVlpzRWVWOXppWTh3c3ZramNzUWozTi9MY0RqcjBOUlk1ZUttUUhTUEhpQWxjdDVGV3pzWVJxZjlSUWRITzkyem53ZzFpOGlJTHJFZk1BRFkrcXAzK1ZWRmVCN3RFWVVTV05rOWJYc0dDN0c5UmE3Qjk1d1hoWjVjZlFXSHFBZ2FIWUVDd3NldFZJd0dQRXpwbmJIUkZreG5XUU5PM3BCb2o5VjFQMWZFVkJ6Wk1XTDI3TG5oZUl4enkya1Vra3J5WTN1dkhweDc3MFdMa21oQ3ljZ3grNXVwc0x5S1FQMlgwNHNUclFYd1hMTWNtVUJMY0ZoTi9UYmtPTEJHL1lWdDFvSXplMVJac2FNUDhBd3NpRUVTNURFR0tRRStYallhTzIydEJ6UGF3bnRXWmo1T1FoUUxMd2ZWaTl1amRSclFkYk45cm0rNGtlVEppSG9naEhNdkpuOVJ1U2NMWHZZOVJRY2JNeko4cklraDh3akhKNVlwV0JXV1FlVXNyVzdhL0dsV2NHSUREakxlWlkwaUtNc3V2Tmd2aHNkYURmSmppWmNhYktQcVFNVGN4cU9LOG01YUtiZk9pYXhaVDQrRmsrbm14RExqZExSdzQ3MlZnV0lCUW00QkhqVVZrSi93RFBSOFNhUVJ6c3BqTDNROExXWVcvTFRlaXVvak5INjBoa0NaQ054UUlWSURiMkkvY0xiMFJrbFRQenNnUkEvd0FPcEZsRnhwcVZzTDJOdHFCUGtaZU9VTXRuaEhHT1JqcmRVSUlVSGRkS0NjV1ZoU3pYWVJZd2VFbDQzNXNrOWlXNDh3TEFnZERRdXNveVk0aEltTkQ2MFBNa1JKS1daQmJSMXVCb2ROYUdJdzVza1NnbzgwYzA1QWNlY0lTR3RvZHZuUlhkKzQ5c1o1SlB1eXN4dWhoSVBKT081MEpCVStGRXhUa0pJdU42eVdkRmIrTmdSYm1kYmQyTnZ3b0tvODM3V1FMUEtBSDBtNGk3alQ2dmhSV2FmTXhGaW5oZUwxckVPdVNtaWtqKys0TnYwb00rRXp1WmNiSTlNaXdQSmdBMGZMUUtqRFFxZW9vT3BqZXpJa1pHYmt0SkNHc3dqSE1FZ1dVZ0czSUNpYXhwUDdqN0xsb21QbHFJcG00ZXVoQjRxVHB5QnZ3TkNjc2YzLzJmdUdROGdSRUJLK25abVFOdmNDNWJYdlNxNmVMa0RLekZtd1lrUXpnOHNVUGRRWXh5TytwSFg4cUpqTGt5WUVHVWhadnV1WEdXVDBmcFlNU2JYc0NyZHdhREljZUxMeW5ueVo1RnhPRFRSdXFpUndxL1ZwL2NOcjBxemhaZ3ZQa2xwMDQ1bVprRGlJU3dWaHIvQUdDMjZqOXRESFVQdk9CQk5JK2ZFMEttSUt1SEtvOHBKNHFDNEIxSFFtaVk0R2VNWEV5WmdSY3JjbVJKZWZUeXFyZFI0NzBWbXhaY0g3Z09rSjRQY0pESVNTV0krb1dJMjZWRngzOHIyQ2RZWXNuR0tuM0lqMVlXaUlZdkVSWWNvamV4dnBydlZrUzFrbndmZDJ3MWdrbWt2RXdlT0oxRmxJMFBuT3c4S1liR0RFaE0rWEt1Vmtxc3NkMllTUHh1VjZqb3g3Q29ycVpCeThjc0JsUE1rNVJiRGJtZGVNdXU2L0MxVkRqa2s5dG5Vem8xMzBZV0JXekhUaTNlZzd1VC93QWh3NHNiMGkzcnpBV2xRcVF5RTZCYjdFaXJyT2N0MGZ1Y0FBRHk4dExrV3FLbFBtU1pjMzhiaFN3R214NC8zSHZVVnk4NXpGTlpFNXljUTBFVGJHNTFMTDQxR2hpUnhaRXZwektsMlBIMWQyVWczc2dyV00ydGVUbVltRGxQSHlEbVBpVmljRGxaZHJsZHQ2bWs1ako3dDdoQytTbm8zQVlnbUVXTEFFWEo3WHFIek9ITm45d1NFK294OUozRjdQdTNZZk9pNDUzdURTWmp4VFpVYng0N0c4WEpRT1ZqczN4c2JWR21tUE9hZUtLQ09IME1ZdmRPY2dTTlNmM05iNnZLTFVFNDBuamhlUjI5V05wRGNCbWNzZkE5Zm5SRTNTU1BHZ2tVR0tHUjJFbnFhSUFtdDdnNzk3YjB4ZE4vYkpjSXBNeUVya1drRFIrWmw2MllLYmVic2RxSnFPVm1aY3NPcGpNYmVtNFdGUWtVTEZpZUwzRjJaZmpRUEhUSnpwOGhvdUl3M0lkNHg1VmVSRGZrNFczazViWG9WVzNHUEpUTE1sbmxiMUM1M3VCWmdQbDNvdUJzbjNLU1pNcUV0RENxQXhvckFTY0RxYkhUWHYyb1lpY0Zwd2hzME1oYmt6R3d2MnYxNWRLRHR4ZmNlM3hFTmpzcGlXL3BTTVZDbHRMa0d4cTZreFo3aG1UeTRzY1prOHJxUzRmUnVQWW5YZTNTZzVuL0FMUnNaMW5YSFZZbEphVklSY3VTTkVCdG9BQmUxREdPTEx5dmNKeWtCa2p5cDVRaUVDNUE2Rm0rbGRkQU5xRmRqSTltaFhCbHh6S0JKRUJ3alpybVI3MllKYnRSTlV3d0QwMFNSWGlVQ3p4SWJUanBlNUEzb01rRXFZMlpMQVNFZGl5dW9KWXgvd0M1citVajUwWE5hZmF2Y2ZaY2ZJSW1pTWtUQXFIZGdwTDlQS05VUVVMTFdXVEhuZksrNzhzT0xlMEx5RW5SdE5MZEw3ZU5SV21iM1dLTEE5TVpqZmJ5WFVZNnFWMEIvZmEzTTM2VldjWUlmY3NabzVKSmk4MDJpNHNZSVJ1UTBFamdEaHhYclJxczMzNkdXWXltN0JXNFJqekl5a2NXL2tPdmorbEIydmFUeFhHSllTekxHR2pndm8zSFlzQWQ2SlU1WUdtOHpuV1JyczE5UmMrRzlxcU9ta1h0bUhBcGtQM1VrYk15bU8vRitSOG81SGV4cW9iUTVBeEpNK05SSkVEeG5Kc3prMjVNQW5meE8xQlQvd0MybFp5ODhERjFqRHhMb0JJMjNOaC9qU2d1eEMyT0k1bzRqSE1HdkhLUUYxYlZ2SWRUcWJWQlU2SUMvckZTem0wVEFFcGNhOG03NjZHOVVReGZjY2xNS1dQSTR4UERLV2tqdUhCS2pZRWZsMHBDOXRLKy93Q1RqemlXRU5MTEtDcGVRRUVFZlNGUWZScDNwcVdNT1JQbCs1RXh3eFJ0SlBmMTlEelczOXRxbUtrclQ0dUswYzAzcHhxL0hpQjlmRVdKYmxmVFdycGpma1RZZDRaY1ppMHpXc2wrUzhrMFlYSUZ3RjJKb2lPSDZpQ1hNRHJ5a0pVcmU3TGNuaXdBR2pYNjBIU0h2TFkwS21jUEs4cVhZazZCbUgrV3RWRVhHT3VManRHd2FYbDlWOVdadjJoVG9QRTlLSzV5ekxCTTh5UElVTEZaaVRmMGtRZ2FLYmxyMzBOUWJjV1BIbGtrRXZraUNlcUNWTnliMlVOYmZUdjFxalZObFl1UXFZbVBHR2pzR2RpM3BncU55ekhmd3RTcEhKbHlzNlV2SGpIaEJEY2dOZC9UaTNBQUdpL09pcm92ZlpjZVFIRWpUSlVodWNoQlF1RGJZaS9XaU51UEZLLzBvclpXTGVaajBaVzZBRTYrSGVneTVIdk1UemhqRUhkRkk1S2xyTGUxeU43MzBvcXRzYklETTg2Y1BVczZ4QTNVQWdYTjl1SUdscUl1bGtFVEdXSnZUaEJKU09jaXdLNmNsSDBzUU5kS0t4NC91T01JN3NucXE1WXExaWdMWHVaQU5ML09nYnp4NHVlczJLU0hadVFaL05xQmZsWTdjYUk2MkI3cGxLSklBUTdUV0NramZrTDNCTzErbE5NYk1iRngvc0hrTUpkMHR4UzU1RVg4eDBIZlNoWE1uaFI0NTVvWkVqVkFiS1dLOGxBOG9YbHZZNzlhQmUxNGNqNGpObG9XalptaWdTT3hia0Y4eFBVRHgvQ2dsSmlGTXRmc3dURXU4ek41UncvYUw2aldxalZnUlJTWWNreUFGVUpNbHRTRHkvWVRRVXlpYkt5VDl0R1BJYm83V1VuaXQ3SFRlZ2IrM3hKSDl3SElJSURTT05TYmVhNDFxS295SnZ1SklsU1JIQ2dwQVhGbzFYdm9mTDN2UldiRXlURGVKVUVvaFlPdDJFZzVDLzFwb0pEeC9DaUwvWU1JU3FrMDcrbWpzWm9vaGV5eW5VR1d3RmlmeW9OK2EwUWtNVWNZZ1NJbU5BckJ5N2RTN2JIVTZVV09ROGs4K1BNQXdYSVdMZGw4MTBQRmVMYmEwR2pGeFo0NUZacEZ5RUNLL01na2NuRi9OMThyYVVnMXdUNGVQSTAyV0RNcUcwOWxJSU43QWdlTlZsSE56TUdYTWNJT0VMVzlJQzVaVGJ6YmIrTkFMaVpNUWVQR0t5Z3R4bFpQN2dOQUNkYkZkNkNlZmhER3g0SkZ4Vmxka3NidXdKc2JjK1BUanRRWjQzamhnTE1QdWtjdEVqaDdyR3g0a3RjWCtYSFdvclBodkhIT01uRmw0bm42MEo0M0Y0aVBJTG0rbmMxVWRMRndJTTJUS3lKV1ZwQzVkbTFXNEo1V0hRYTBGUkRUUlNZOGFwSHF3amkxWUVqWS93RHlHMTZCZTF3U2k3WlpES3llbkk3anlLaC9jcDM1TFFZb29SamU0SmpHUkpSSTVSRUd6QUFsTDI4ZHFEMFB0OFVFMGlTU3QvTENMejNPOWlWOGgzNGlneDVXTnp5Y2hJQVRIR0ZQcUtXTExiWWcrTkJod1VNa2VRQUVFbzVNcUVnRUZTRnViZlZvZGhRV3dLc0lCemVVVm95MGFCYkR5SDZnZWg4S0NEUE5rNE0wVUpOM055QjVaRjRrYld2OVZCVEhrcmlUUW84YmZiMklETDVoSXEyS2xrTnRqZnpDaXRxSmhTWXFaWjRsRE0zcW9DeWdFZzI0ait5M1VVUm1ueVd5STQ1SjJabmlWVWh4MVFLcEMvM0U5aDFvTThrclNzOHp3Y21qUDhrTEJpektkZk50OUFvTlM0c1BFVExkSUpDcGFFbXdZR3g0bHJjZ0JwOGFDSHRPWkxockZrd1l5ZnhPOGFGeWVQRmp4YTRCdnJRYXAwamtFOHp1dkFFeG9SeWE3WDF0MVlmR2cwWks0V1hpUXNrQzQxZ1k4aGhvcEdnVTkvRzFCNS9GOXdFR1ZIaHpYT0RGTDZabERXSUd0d3ZodlFiODZGbzQ0Wk1iK1hHdVZqUkxoamV6WEhIWFkzOEtERmtTUEJpU0o2bm96bFRMSEZlNVVIOXBicXpBM29IN2Q3eEZGN2FqUlRpVnBTUm5xYnNzZkVYWGdSb3lzT2xSYTV2dWZ2VVhOY2JQeHpJc2hDVFJqVlF4RjBLc1AyMjFJTkRDd2N6RjlpRWlHUVNGeXh4akY1eTdpMTEvMjJCK0ZSYnpGN1pNL3ZPUEprVzVHS05uZ2gwQ2hoWUVXUDFYUHpxcDB4WVVXYk43dEdTRlVCQUkxTnJjd3VnWC9NME5Idkh1bUxsNURTWjB2Q2JISEFSUXFWNXZ4MDhxV0dwM3ZVV1JveEk0cE1SNW9NdHA1RUFzRkJFaGxCc1ZZRzkvSnJWUmd4cllVSC9zVW1EekZ1S1JPekpMRVNTQ2ZLRG9WNjk2aXRlRE5qZTVaaXFJbWdtaExOZ2dsbVVOb1ZJN3A1ZFFkNnNMd2o3MVBsVDVlT0VoYUtkSWI1SmJnWTNEWGFTekMvQWRxaVJqOXJUSmRUSUlsKzI0RzVLbXpnQzVWYjY2WEJwRnJJVm54dmNNZUQ3bDRDMFhKbmY2dlgxR3kvc08xeHZSWFV3TWZJV0F6dEc2TklwOWJMOHBVUnlYdHlRNzh0ZGFJbkxIQk5neDQ4Y3NuMlRSa1E1R1NHWkFOZ09PcHNObEFvbGNxWmtPTmpjMEtXaUNMTW91Vlg5N1MzMUhQdHVLTk4yTExQTGtQaTRqbWZEQ2g0MVppdmxERGx4NWErSjYwUjAvYlpjYWFiTGJBZmxqcmYwY1p4LzNISzJMaTJnSkkxdlZUVDl0OXd3c2oyMzBaZk83T2lUN2VvT0J1V1ZkcWxXT3JsSlBpTS9PVU9pc0NFWFRTMmh2OE9sYVlRbjRaV2tzYXVzMFlPaFBFRnROYmJYTzlGWUh3em15bkdJOUZjU05sRWNUaitRUkVtOTkyc3gwOEtGcmduQ01XZDZxeGhIOU1Jd1c0akxBMkJERzlSZGJTZmJ6RUdqUDI4NVZvek9mL3dBU1JHQjR1RytvZ1gwQm9NV0prZTRwem0wYjIrYVVyT2dRTy9DTTJCNDIwOEtHYTZLcElUbFQ0eU0wRVBDRXUzOGc0azdrRGZpTmJtaC9yVkhqeVJYdXB5b21oLzhBRHlZemNnQTM1ZExBcnVsTU5jNXZjc1RJSzR3akNSck9KQWlzV0RvUUFWVWFNU0xYQjNGWnJVY3hNNktIM3Q0b1Z2QWpxMXBTSDlOVU43TTF0cmJpaXV1R3lNejFzdm1NYWE2bU9CTG96UmttN0lCK0pCMkZhak40ZHVHS05zVUNXR05vNXVIb3NQSTZCUllobDF1VzcwVFhJOTF3SmZ1RVN4YVpMb2lzYkFNZFFCMEI2MzYxVWxaY1gyZjNHQ0FUcGN3TkovNXlSc3EzNUczRXBld3VPb3FMcTMzWk1TRndjQ0Y0QlprTHlhTUEzMUZ4cmUxOWw2VUdZV2VDT09TUW1PTmJCTERrNkFkUDZXK2RGZGJFeUpDelRvV1hHVlI2YXMxOUd0dVAxdFNKWFF6SnNOY1hsTEVDQnBvUG5mdTNhcWpoU1pHQXl1K1BDNGJTU1FoaWJFSDZSMEJ0MU5SVnNoZk16STQ4cU44Y0VjaUZUZ3pXMVQwMkduem9PblA3WXVaRUQ2WkJnUnRZenhaaUZ2cmY4Nkk0d2lkb2xtbGdiN0w2T1F0Y0hqNUxnYUJqNFVWdmtqbVgybVRIRDhsZXl4QUFCaEdiYksydHI2azNvSk15WXVDOHJPSldpS3hScXlFTXlnZWEvTFJiM29pbk1td2NvSmt4eGVpWmIvYkFXQzNYWUcrb1U5YUVWUjVjMEVMY1VIcmFTQ1lhOE80c2Q2TFkwdDdnWEFrYUpJU3kyVzZob24wMWV3MmE5VkdlYkthR0V3WkRxcXV2bWpBdUdUcHlPMmg3MUZXWVgyckJPTEhDU1NNYzFsNG56S0NEeC8ydDBGRXFpUEYrNW5pamlnaVhnZ1JwRkRBbmUwaEkxdXRGY1hMeHBZTTVaQzZUT09aZEdheWtkci8zSGVvcXozSkUvd0RIU0F1djNLcXpMTGJpREdMbmlleE5WSFFrU010QXNzRXNZWndHZUtUK093SDBoRGNxMTlkYURseTQyWEhNR1ZEanhSU1hPUVJ5a0ZyZ0JlbHJHbzAyNU9KRGx4bytma3h2SlllbkRqS0F3VUh5MkF0eGJ1YVltcVI3TWtQQ1NDU1JvdWZPUDFBdkptR2pDdzFHbmVocXhNaG84cGtQcXdSU01XRExiMUl5TkFBUWV2aFFhMkNtWnZ1Y1l5QUp4RnI2S0JveEk2M29LeEg3VzN0VFkrUkdXbUxyTmpUeHZmankzVW93ODIydFJXYkVPTTBmMmMzcHBBMGxseUdGZ2c3YjcrRjZxSG1MajRudkgyWnlGek1jRlk4ZklpdW9GeGNwWTk5S0xIVXl2WjQ0SWt5WThpT2VKd2VTeDZNcEdubXVOYlVTVnlzaU5lSnlJSXBNbUNJTkk2c2VMOFYrclFYNC9HaXN2dDJVTW1lWXVpVG8wZklJUndleTN0eEs5dnpxTFkwNGVWazRzaS9ienREa1NBbVNJS3JGZ3d1eXR5OHRFYzBrQnJ4NC9LT1VnTncraG4zQkYvcE42SzZFV1RuSkcwVWNoa2tRdnl4WDNBRmlYRExlaVdheWU0dERsd012b05qTXdVc1NiY05iK1k3TXBHeHFpNzBNVDdOZmNKa09kR3NnamtVMzJ0WW5udnJ0OGFnc3pzci9BSSt2cVBDV3huWDZZd3A4MGJXNUkxOU9TZHh2VlJrZ1BxNDgwSzVhQ09SMTRHVmVNak1UNVJ6STh2anJSVVB1WmhLMk5JQW51RUxtTWxPSmo0Z0FOcU5DTlBoUWREQTl0ZUtPWEl4SEVidUFHQlVNQUwzNUl3K253b2F6dkdyQXhUeXY2MGdCRTg2bmd4TjI4NTFKQzlPaG9pckt2aU9aNDRJWjRNbFRFc0oyWHk4UkpZQ3hOOVJVVlUwS3I3WkdQUmFYTlVxSXBYRmlJVjFzQ0Q4ZnFwaTd5bmdlMSs2WkVBemNPU1YwaGJsT0xoVEdDYmg3OVFMWHAybHNqdjhBczByeU55a25SeHpKU1IySDh0cm5pM1B5NitPOVZLNFh1ZjhBNmViM1AwcFVhRmc1MUNoZ1diWHpydFlmN2FWWTEvOEFvcytIQmlrZ2YwOFoyTGxyaml4QjBaT1g3ckMzR2lXdGVYbVI1ZnQ4VWN6UjQweUo1VEtwNHZJRDJGeFR4TXl1QkxDSi91ZWFPbnVPTnFxNDdCb1h0YTNMVyttcHVLamV1cStlaU03VHVHYlcwTWVseU5MRHdIVTFGeEZQZEFJUzdzWTJkdEF1NDAwSGV5ME1hc1RFbG1MTTdNeE5tVmlTUVRiNmJDK3ZXcWk2REhuU2JqdE5IdEhjWEF0Y21pTXVVRUNTU294VlZJTEc5d0dhOTk2alRuc3ZPZFdoRGJEZ1NiOCtoRnowcWF1QmZhUGN2Y0prOUpmVm5sSktSZ2tnS205bEY3QlJRSWUzcWtvaW5acEhkaWlDeGRBby9jZXQrMUpUSGI5cjl2eEpNZ3BtamdrS0V4eVBkbFFBWEk0amNWVXZUQjdqeEVqd3dTaDRlQWYxbUlWVVJUWStVYnNiNkRlb3NZZmNjZFMzTEpuTDNSZnRwd0MyMWl2SWZ0MDBzS0VxMzJwNTVNR2RzbWFPMElWVmpaanlhNVAwZ2RkYkVVS0NrSHV1WU1SbmtXQkpGV1NRdDUvcE5sS255aTF0S0F4WVBRbGpqYThXT3pjV2JucVk3L1VRUEhwU0RRWnNVNWs4cXFjcElFWkRieW92TFJTVDRVSFN3OFdPYkRpTWpxM0ZSZGJra0t1MXI3TFZUZVZmM3J4bUdhRytabjVEY1pvV1VLcWxUNUFwNjZmdXFMaUUzdlUyVE96eWxGa3UxMmR4TDV0anlZM29raFFTaVNLT1AxUzUxWGtEeVVlRnp0VkdySnpmU2hXSmNkZlVrWGd1UXdKdEhzTEFmclVNVm1BQ01pWnZ1TjBqalhraFZRRDBBNzFSRTRlVWljOGNFQ0lEMCtJNWtBYmFIcmZmdFFIdCtYNVp2VllTNVZsVkdSajVtSG11Tk5RTnFKVWZjRWtoZVQ3eUJCSm02S1pMQVJwWXNyZCtWK25XaEhER1pPUGNWV0ZCTWlha1A1d0RieThpUnQyQnFOWTBBU2M0Wjg5V0xxcnpORXZJOHVKQlFNbWkyLzhBalFiUFM5dWZIeHNtV1NRY1JKTTYySEc1K2pqcWJMMDFPbFZJcmZDamVHYWJMaU9OREtoT05qb3A0aEhIMWM5MkpiVVhvU3JvUGE4WWV6R2VRSkR4S3dJZ0tuMUcxUE1zNTBmd0Eyb2J5NlB0bjJNdnVIMjBTQ0NJRkNSR3l5ZVVMZmo2dWpFNmFxS0Y2WDVDQzRkVkVTc1BVSksyMHZZQ3gyRjZyTFRsdTNLS1AxbVo0QXF3eFdXeUE3Ry9hL1Nxa0hET2tqNHVra2NLZ3UzcHNGSmM5R0kwc2Ywb01xZTN4UnBFeFpZeVpOQ0R6TGtOb0ZVN2ZDbUxydFErNS9kZTRlcmxRczJNaldMVFdMbTNsODU4TFVUT0dYM1hQaWxuWnNTRUF1eFRHUDBwb1BxczNTMjE2aXlPYmlDVGdxUVJDZEZzWlpKRktsanV3NG5xS0xXMlAyek95SXBKRE9rY2FjNW5TUXF1cjJBdGZVMzdDcWlpUExtd2VVV01lYW5pOHJBaHVRVWZVTDJPL3dDMmtLbXVjdVdzMFBBem9wVDFpUXFqMUpEcHFmTUZBM1doR2pIeHNiMVpGZWFOMXZ1ZktFVzJ2QnY3aWR0S0kzd3c0MG1LN1FjWW9taXVyRWdrdXhKNWE5VGFockY2VW1WaGd5bFpMSHlBV1Z1S0R4OGFLeXE2MlllNFhlRXJ3aTVXVkVjNjdIWDU5cUdMOEhHa3pKNG1oaURZc2FGVmtZOE9VeHVWR3UwZmxKSjdVUm80WkVqbkdCWUxQTGRuZ1lubTV1YktPd0JvTWVYOTVGa0YvVUlLU0FJd1hWUU5CeEg3dWdxbFpQU3lEaytsRkZLa2Npc2t4Y2hDNStveGtycHh2VUhZandKR2hWbDhyTUJIRUxLZ1VOcDZiTnZZQyt0VkdoUGF2UTl0V1dGbURrWFVsdE9DK1FDKytySFNnNU5zcUNGekNpa3NRMGttakhtbmlOTFgxb0g5Mzl6SERoNGFMOXp5THVxTTVsWmIrZmtiOFZCN0RwclFaY3pnV2RveTNsNHFydHFHNEh6aU5kZkwyTkJ2eE1MTmx3aDVoS3ZFcWlnYktwK3BpZW5qMW9OU1J5WjBZeWtDU3pxeGFjTllxV1EzRFc3V0dvb2F3Smt1Y3lTWjRHRWpJYkM5cnlFbml5c09uWmFLdS84QWU1Q1FTUWM1WkNBcXl4SjVWR3Q3c2Q5TjZDYllHVGs0YmlSRk41bGtoeHRDelgwRnIrYTF0NklFaG13Y1JmVXY2aEt4K1UrZEF1dkpiMnZ2clFhY2ozVmhZUVNjaTRDR01kRjJZblMyMVZGenluSG5XSEZDdmpTQldXRUhpb3VMVzExNUwzTlJTeDhuL3dBZHNsTGNBU1NHdmRYOEFMZzNBcW9ya3paQ3JZK0tSSWdpV1IyWmJCMlAxS090MU5SV1JFZVlLL3BpS1B5cUxrOEFwT3FtdzgzUGVncXlmYjA1Q1dOUytUS3pNZ1d3akp2cnhQZnBSWTZJeWNoTWRoRklZd3NkbklPdDJhekFnYnNTUHdvbUs0c3ZISHQ4Y015eHd5R1ZpWnlkN25VTVBqYWd4U3lKa1lFc3NvS0F2d2xhTUZBQURxYjYvVVJmVGVpcjhSVEhpd0tTMGs3RlhXQk9TV1ZkYmkrcjJ2ZjhhSld2Tmh4WG5Wd3hqa1ZQTkd4dVc2bHJEUzNhZ3lOZzUySkhrSzNBczYrb0hROHczSzMwV3Z4T3V0VkZ1RDdkS3VIamw3cXpuaXJMcVN3TmdwMXZ5OGFLZVRQUERsbkh5WkdZUDVRN2JCUU5QT09sOUtDcVhCbHhNbU1JWTFXWmd6M0pDb1NEWXNoMDMyb2hSQ0ZjbVNHRndJeUx5U09TcGxJUDdOTkFRRGNVR3ZNYlB4SUhoaUJnbGNyTXF0eEZsM0RzbzZXb3FyMi9PSmtqalIxbERLN1hQbFlNVGU5aHF4TFVSTEdQcHd2aWw1RkRFdWRibDI2ZVRwNXQ3MEY2NU9La0FPTkhHWnBiT0hXL0pDZ3M1YnRRWmx5UFJpYVNGaksweUc2S1RxRjZFRWFlYldnMVNlNHpSdDZraERPUEswTVpBZFJZWElBMytkQkNJNFVlTXorYUlzVDZaYnlua0dIUGdUZnphL0NocHorN1pXV2tpOFB1SlJHWVI2b0I0bnVHQkg0bWd6d3JIakdPZkZqTHlSLzl5WldCYzh0YktEYmlSUVp4QlBrWkJrZFNtQThsbGlMYXE1M1VYMUc5QjAweFdTTUloZDVGc1RCb0ZVcWV0OXdldHFDdVdhK1c4ZVNVY1NJSkxoaWJPcDFKTnRqdFF4Q1dhQ0lSK1NVVE9wOVZ3ZVMzTGN3ZkVEOTFCYjdrVVNLRTQ2aytzeERLQlpSYmZmNDZDZ3lSNHNuM0xvWWxYS3lMQ05sMFJHMktpNTEwL09nNlVjWW5tSm1KZ1dNaEFSWmJMR05oNDNHOURWS3dldmlUR05pbVl2RVJHVmRBcGEvTkxmdTdrMEhEbm5qd1hiRW1RTTEvUWRrSEpHbUp2eTVIOEw5YWhWV1JQanhObjRxenRGSERFZ3h3dCtmSjl3bHQ3ZGZDaXBlNHg4UFpjSVR1eTVFdk5QdDFRM0RPQnFvUG1HMm5XZ2hpWURyRERqRHp5aFZiSVVEaTBSUW55S1RZTjV0eHJhcWlqL2tYdHJTeFF6SzRRekVpUnBtc3VoOHBMYUc0MXFMSzVtQ1BiWThmR2xTN3pZd3N3VVhqQlZ0UnoxOHpIVUhyVWkydlM0NVRIeFY5d2htV2JFdUVURVpnQTBrclh1UVNHR3VvUGVxakRselRZK1BrTG1xVHlaWStDRUQwK1o4c2x4MThLRE5pWW1Lenp4NU1uSWNQVis0VlNvQ0tDQVZ2cTVKK3JyUVhZMmY3Ymd0aXlSZ1R3aUt5T0pMQnR6eks3cUR0YmNWRnJQbVBLai9kd3FDWFFEMUI1SXdoYTRZcTErWHAvblFUd3NTS09OV1l2S2NWdVR2RmRyTGJselhob1V2ME5WSzZPRk1wUEdVRDE1RHlrRTJySFRsdUFMTHJwUVJ5Y2VMSHc0TW1GbWlsUnlKSmtkZVhHVFJsVk4rSkd0aHFhRGk0ZUxIazVlVk9yRkVrVWhQVXVZd1RvbzU3Mk50TzNhaFZqakx4OHZIeEpRdnFxcnlsNHZKWThiL1FiM3NOcjFGV3dyajVXQWthNUtSU0ZWNWdxVTRXOHVvR2wyK29sYXFYdFg3TkhIN2Q3aE8rZHl5OExNVzB5Z2xwTlRjUFkvVngzcVR0ZnJtTGpndStSRm5RdVB0bzJNY0N0MVFmVmEyOXpxYlVOT0diS3hzZklXZUFqR2xZdVRiaWI4UCszR2RqWUFHMVZFb2NKY3JHU2Q4Y1FTekdPUWVtVGIwYlhCMTF2Y1ZLc3VWM3hCTVlXU01nbENRUUdCc2gxNUwxNDY2azFwbEwyL0pqaGo5VXhtT1FzT0Vwc3lMWTJlNS9ienRZYVVIRmxlUDc2U2N2NkVzYjNSbFlKeGpZM1lnSHZRViszKzZ0RE9iQTU4SytzOFdOT3BDTEhlNWtVSnJjMjBxTFFZc2Q1NDVBREJCUElNaFhsUzZwejh4RGpYWTJBSW9LOGo3NlBMeW54aTBCaHU0a2hKQ1BLZHl3UEx5OVIrRkJwWDNITnlBSnNtRkVEUXJIT3NTbU5iMzhydHg4cE90Tnd4eDh0NUlnOENQeWpKUU95bXluVzk3RC90OFJ2VVZwaGhkVi93RGFRU2NtWml1UkkvRXF6blFJNEFIRW45cEZGY3FDTjhmS3lwV1pvcFplQWFGa0RXS05mVyszSHdxSzZTemU0cDdnN3NTb0o5UVpxMkxIU3dCTnVOMjY5QlZUSGR3TTF2dG9pc2ZEakd4SWJYbHJZcUw3MWRaeG5uYkt5VmFVdUlsaUJWbmNBQTMwNGdIOWFhWXpaWHU1akhERFptdWxrblJTM3Fxd3VFS3Q0ajQwUmtqelhPWERIbFI4NUpvZWNMTWJxbzRtM2lkQWQ5cUs2N3c0WDJpdVZjemxyeHFxM0hwc05UeUZWTlcrMWlDVElrZ2tzSDlNbUp1SUNjdHlsLzd2K2xDcW5HWStSR3JPRzlOR0JpSzNzZ3ZaRnZ1UnZVcXhrVlo3czdneHF3OUkySEV1eDBOZ052TDMwb2hIN3VPVlB1Uy8yaW5pams4dVBEWlN3NjBWMmNablJ1RUdSeGFjY21KSTRsRHArdFZHYkl4Y1BGd3B6SEpISmxjMTVvQTF6SHJ5SlVlVzRQNVVGZVJIRjl4RkpIRzBNUkhJeGdYSU50Z1cwdGZid3FLeFpFSHBSRVNTdUowdTB1UE1wSzJ0NVN6ZDlkS0RMOW5NUGFZWm9wTHR6S3hLVGN4bi93RFdFSFR3N1ZGYm9zZjdyMldacGxBelZ0R3NrYmNpV1hSaXk5UXcrVldKVzMyaC9iTWpGK3o5eWxHTXNKRE1zZ3VzakVhRG5veWpzS0RrKzZaTUN5cU1FaVNGV0szSXVialUzRytsVFZ4Z00wZVEwUnM0NDdxZEJ2NVdERG9UdXBxNlk2ME9JK012M0hubEVEcVVlTnVTaTUyRnJINDBUVmVWakQzR0o1a2lqYmpjU3FpNjNPbnFGUnMxQ00wR0xKbjhjUU1zRXpBcWdsSUVjblVlWTJDR3c4dzcwMHhmRGs0OFUwRVVXWDZnNHlMbFJNZ0lVM0FIaWI5Q05hQ3VIM2IyNk44dE1oV2JreEFzQ1ZJR2wxdjBIalNGbExOT0VNZERobFpta0lmallxZFA3aWRHL3dCcEZESzFaRW1URUZjd1IvYlNIa29SYkgxTEFIem5XdzZqYWdJZmI4YjNDQlZpbGI3bU55RXg1Tml2VmxrQjZIb1I4S0c0clRGOXd4Y2gxeHovQUR4bTBxSWR6MEJWOWRhSGJtcGp5WkdUNjZFWTgrT0pHeU9MY1E0R3ZsRGVYZlR5MWxycFZMTlBKSEhONlNrcUN1UkwxODJnVjArbTNqdmFxaVROUEhtK21JbEVUQVJ4T0JkU1NOMHVOTHNOTDBWcHhzcVdObXZINlZpdk9POTR6eDBQSlRycWRhQlppd0Jac2hUSkJMSXEyaWpISkdGL3B1ZGY2VUdmMnpEdy9jR1FSUm5IeTl4TVhCakxEb1JvVk50Z0Rlb3RyWGtmOGU5eWJIaWZKSmVHUWhZMlVoUTEraWs3N2Q2ck9zZjIzcWU0VHd3UnMvcERtMFRlUndBUE5kYjJPbEZSeS9jWkZpaG1qWkZpUlRGRXE2eW90eVdTVWdBc1BqVVZUSDd0N2laR2lpa1YzeUV0NktvcnFMbXdZYUhqcDA2VU1YdzRrMlJKOXJBakF1UzA1VFdHeXRvVUhRRHJWUlg3M0RtWTQ5U0tKWEVCRWNrMFo1S1hIbUJLdHF2SDg2Skk0OGMrV2thS3JtWUR6U0lSeDRxVzEwMmFwcldPMUJrNG4yNnV5K2w3aHhRNGZDSU5ES0EyejNOd1c2MjNxbzF3ZStORVdpOVNOY2FUazQ5TmVESzRQL2ExMVVHOUVZbnpaNGxPQXJrWW1WWXV6a01UcnlBSExZQTlxTEdYTWYzS1lSaVFKTk01SlQwN0NUaW9zbkpGM0JHMmxRWlpjVElhRmNtSXFEb3J3TTluVXJzM0U5S0szelpLSEFNMHVLK1BsUmVXU2VJbjAyUmh4VFM5cmp3M3FwbkxMRDY4c1R4ak1LaFJ5VWtCeFlFYU91OSsxcWlxR0VnZ1p5cndaQ3pjR0FROFZCMXVMNjY5QlFiL0FIRE85eUx4OEovVlFBU0dKeHdWTEM3WGorbjhLSTFZdVprKzZ4cUpjb0lyUytySkVvUUM2YXJ3QnNXSTdWVE1jdWVhRlQ2NzhvYzh1M0VJbmxaU3BBdmUyL1dvdUs4V2RYZUtOWlZnWndQVm5IN1YydGZmWHFLeTI3aHg0SXZUbGpSV2ppVFNMVzdIcVd2cmFxeTZPRmtEMVFuT09CeGVYZXhPbCtJdjFQUVZVcTMzQ2FLQ0ZXVWV2Sy84cndxcEFYcFpqMzErVkVqaUdXTndxVHFxTno1U2JrTjJ1bzdVYWJYZ2pPSWtPUktyeEZqZEFRb0REUlgxMS9Dc3FxUDJ2dG1Vc3NHWXNuRlFaQXQrTGh2cStqVUt2YmMwMFQ5dnpNVmNnS3lKS0dlL3FBRVNHLzBnL3dCb1BhckM2dTl4bGk5VzBVZ2lXUThXR29GaWZNdDdIdDBxSkVZL2EvYWpCSjl4T0JJOWhIRWdOeWR3T1JCb2FyR0xETEcwTWpjekVWU04xWGlvVTlBRGNua2RLQ3ZQOXF5Y2FSVHpVUW9WSlVjUVk3RzFtOGFMR1NPWEJqZEJER0lZSFBKNTVXSmRyYmpRZDllOUJ1ekk4ZVRGTUt4Y21iektBdm1KYzZNYjIyNlVITWx5a2JOUjRvZzdLdkdKUXdVaVJPcjZlYTF2Z2FLN2VBc0loa2l6Sm84YklpL2tubDNNaFAweHFsclcvS3F6ZFpzNTJsOXRNV1BBVm5uY0QxUVR6a3VOZEFORkZSZlVmYjhLVW9ZNVlnNGgwZVdKUmJhNERiTGY0MExXL0VTSXl2SGtIN2VQanlNcCtrQStIY21pV3FJTWxKWVNKVGRsdkZHam5RaGo5WGRRQnRTTFhydmJRK043WThzUlRuc1pHQUpCTzlyNlZwenZibFFKR3Noays0SmdkdjVHWWlOSElKTjdhYUoxMXFOT0FNakhmUG1raktSeHdTRUl5TVI2Z3Y1ZlQwdUZGRk4zWEtrT1FqWFJTSGV3WmlndmM4aWRic1JhZzFacHZCelhGKzFoSkRSWUVkaUhCMUprYjZyOWRhRVZ2TjdVaUxOSUpZMmpzbnA4ZVl1eHMxeHVTYWd5TUJOaXB5VXBDWmlzU0FXZmlQTHFSb0ZIV2hHdjI1Y3ZNOXpURFNCY2huak1jQ3lGbVZiWElOd1FDVi9DcVhpTGZkZmFZZmI0ZU9jQU1wR0xQelhseUxnZnhxQnZMcnl0c0tFUjl1eFJocGR2STVZSEhjQUVCQ2RmVXQxNjZWWWxiR25uZC9WY05LWGU1ZHdQT3EvVDVlMXhleHBwaE9Nbkp6YlpJV0paazg3WDhrWVU2TUNPd3BhUmJrNWs4ZU1GUkdaQ2ZUSHFmL2lCdDkvTHRzYXFZenp5SzJPcS9iZmFNajhFbTVGdlVKMEp2c29XMTcwR3VEM0NWc1o0V2s5Y1JiRHBwb0R5dHF2aFFXWjhNemVqOXpJcGxaVHhpUWdGRkoyc0xxbjYwRXNmRWhhWVN1VU1laXMvSWdJYjZDNU4ydHVUUkYvdjhHREk4a2tKTFlzUkVhU2NnUTc3RzIzMUVkcUVySFBneFNNb0NwR2hVT25sSWE3ZkhvUDIzcFZpY2Z0VXVPSmNtWEo1TUZFclJnY2hvUXE4bTJHaDFvZ3lmVDlRTHdIRmdHZVVDNFlIeDJBSGpVVkNMT2hjQ0dhWi9VZU8wY1NDeVJ4ZzNXK2xVZW45cGlKaEVVZ2pqaWIrUkozL0FHMlhqYnk2aTlFcnp2dk9OallqZ1N4TklyU0xlTWZRSTc2TVMxeWJub0tpazhrNUpubHRGQVZLY1k5UVRmeWdodW13TlZHODVKZ3g0ZlFObnhpRkFRYWVjRWRObDFvTVllV1R5QlNzakw2Y0RrRWFnM0lYcUxWUjBWd2tIdHltZDJVMkFDS0FHNDZkdHVYU2dsZ3BqTklVS0xHWEE5UVhKNGtuWVgwTEVibWtLMFpxK2dwc3pTUk9DbHdQclViaGI3YTBxUnhKbkJrRVFReU1oNEtsOUZaeG9TbW4wZzlhYXFQL0FHazlOSTQ0OG1IL0FMMlV6RmVkeGN4NmRTdWdIZTlFV1ltRmltS1BLQ3lLb2lDeXlnbGlqWCtsVU5yOGhzQlJVVlhMWEprbG1hMFRnTUx1UVhSZE9LcUtHTnJlejVndzRlWUdQR2x4Q3lpek9YTnl6RWJxTzlFbmJDUGIwZ3pZNG5DWkVhMmNrOGpmVzQySStQd29yZGo0OElSQ1I2N0FOei90QzMwdjQxQklaYnZrSXlNMEVvVmlzeEZ3QzJnOHc4TnFxS1RqTmt6bFZZTXJEeXF3NGs5emZVK2FndHpvOFBHeG9ZNFpESmwzQ3RDRXNpQlJvTC8zZDZCeCtoa1l6TkZpT0pJa0FrbGRnVDZqSDYyNmZJVlNOUEhJajQ0VUNIMVpCNWovQUhmRFR5a1VSZ0lreHAyVUVNeFJsOHEzWmVIUlZIN21xVll5UTVUU3hSbzhUTE1qQUlEcEdBeDBBVWRSVTFjZEV3ekpCbGlOV1lJeXhTU0E4b2ticUZZYjM4S293eVpJZkZRVDgxWlRlTGo1YnFCeExFZkliMEl6K25ON2dFQ2NXa2tWa0NoUVhBQXVaRDA2YU1LRWJZY0FyTGlpVElSNDBIRThtdUY3TWJhYWRiMFJvOXhnbHhwb2N4eXJ5UnhCVlpXTGVvYitWZ1RhM2UxQlg2Z3orQUJLT3JEbnhBTGhpZk0zem9OVWtranhtR0hGL2lkZ0lYUThYNURUelB1Ym5jVUVFRTBFRWF4eXUwYmtTem8yeVNCcld1ZTNhcWpMbUhKeDRWYmdaWUNGYWJ0YmxleEoyM29OV0xtTGxZNEtoZVpqZDR4Y0dWZGVLcWI2SHcvR2dqbnlqMi9FbHRKNnZ1VEdOb0hDbnlKb0xjdGxOOTcwSXhTZisxbm5mR25WWUl5Q3p6b1A1R3Q1ckt6YmhyYWE3VUR3Y0xLRU1FMFJDeUk1ZDJjcXQ0N2EyQjdHZzBPMkxLVHhMU1pHL0VHeW5qcVZhM2Zlb3JSanhaS0s0aGpRQ1pHaWVjM3QvSnFPTjlGUFFXcXNyVmhmQUlrbFdOcEVzc1RJUXc1Sm9FOEtLb1lTeFR1OHNYT0hJRFdDVzBCTnp5YlZqcnRRVXl4T21jK0xBanRFYmVqR3RyRjJGOVQ5TmlPMUJQTGlLTy8zVUVjV0tVQ0IrZXZxVzE0OFJycFFaNG81TVNJNFRvVVdSL1VKSjVLVUFCQkozdTNYcFFhc1BMbVZKSGtqdjZya3ZFU3BVaFRZYmo0RVVGZVJNWWlrTVJMS0J6NU1iRWl4TDNJMytQYWczNFNKTTBNU3llb3hDQ1NZQ3g0T0JhUFhlMUFtaUVHZE5IR3FLc1o0S0pOVmU0UG5JL09nZ2trVEtXeG96d1JHV2VWN09DcTZGbFcraHYyb01NQzVVc0VRUmk4U003cWhGN09mNjJvTnB6TWVkNDFQcUl5dytpcHVWTHNiK1lEcnZhaUk1UHVCaHlsT056VjRJMVFvNHUxN2FnMytwYmEyMm9zY3ozTEpHUmlESWRSNlVqQlhjS0E2K214WU92WVgzTlNrY3lESGdSa3lqSzVNenA5bVFicUVCUHFGN0M5aUQrTkZYbm5MbXc0OG5OR2o1S0xFa3FKTlN3NzhWNkdocnBRUUxqR1QwNWljV1ltT0tjM3VPSXVWc1RjY3REZTlWTysyWE93NGpDWkpITHBwWmsxUEcxeVRiYSsxUlhuRkVtSzBEWk1wWEh5QzhVSlN3QjRrV1ViaTQ1YThxSzIvYVpPVWswa2NxNUs0S2dyd1JiSUdQRkhrWS9oYWlialBQanFNUUdSbmtrRFhNaUd5MllYUndEdVN5OFRlbFdKUmxSN2o2alR5ckc4UHFRUUlucVdMVzlTT3pHdzN2OGFpRjZjVEtqUU9rYnUzOGFNTHBJcVhKWVB4QytYWnFLMXdUNXNXZEZEUGljc1RFUWZjeE1DeU9HVVdVNlgvQUpPbEJweXM2ZkRaSW9ZL3MyeUZZektRQWZRWTNSRkExc3gycW95VDUyWERESEM4UWJNaFZ1VnovSVIreUltNTBBL0Rhb1l4bkhaa1hTM0N3eU1XUWhDWkdIa2tpM0hsMnY4QUtxdlRxWXMyVStORTd3eUJwVzlUa29DeHhxUndzb1hyZlczU2lNMCtQSm1ZN0RoNldRSllvNFlnTElVZHJIbTU4MTJPd0Iwb3JMUEJFNnBMSXJQSUdDT2tkK2NLeHNWdDJLcU52Q29NVCs0d1lwbXhvNUdaSlFWalJWSU5nYkRpVFpoZmUvVVVXelhxZnR6UDdTa1NRb0lmVFZrbVZyaG10NXdMRFJ4MnFzM3R4NDB5c3pNanhua2VmMitBQjQ0V05pQ1R3UGxQN3pwZXBxNHN5bHoweVpIeFh0QkRFUnoxRExZOG1SQmUzbUdsS2ZQYnJlb2hoaXlNZU40c2QxNWF1Q3hXNE5yZ0RyVmlmVVN6OGlLY1NSeE0waEhIV1BpQU9ySHgzcXBITmttbWh5QkxsRlJQR1ZraGxaZlVMRmRBcFBmaFVWcHc4akNreThlU01IRHlJM1lHWnRZMlIvTHJiUzJ0QlZtKzRoQTN0WVpHeGNhY3Fzc2pEaHJxTE1OdzNTbXBpbi8zR1hKSjZMdVljYzNnbUNyZmtkQ1F0cjY2MDB4MmYvYVR3Qkl2Ym94RkZNbm5kUmNoNDlESXVoOGg3YjBYSGsvZHM3QnhzaWR4QktoTWpGSlZma0pMMjBjMjgzSG9BTmFpNXF2Sjl5eElQY0pFeHhHa1RScWt1Rk5lN3ZJUE1VdDFWdjhBOHRGalgveHoyL0M5VEtmTmFSSWpFWklwWkNUeTR0NXloNnF2V2tUNnY0U2s5eVF1RlhKTW1EQjVXUUd5bEFMQW5UVzFCa2d6WlpzejFZb21pZ1lYalptSkREbHhQRWpZdCtWUlhROXk5NCs5a21RSTBqQlZSSXlRZUpVVzRrbXcwQXFwSmhwaFpFbnRqc3JXbFJWblpZK3FMcWZHM2FxS3NVeHBEbFBMQ0RNeWM0bUd2cDgrN050NGlpSERuWjBVNWg1ZXJDb1ZyUmVRa2tHd0crMUIxL2Jzdm5neUZvVmpia1BUc3hCRG51dEVXWTAyVDl5M0JGYm02a04vYXcwQkJOVWJKNU1nUUNETmhZY0hZeHVmcjVIOXYveEZCbTlJS2ZVUW1GV0hCNFNPU01vM0ZxRmMzS2lTRmd5TzZvcmZ5QWdrY2YyZjdnUGhVV0tFeVc5ZFg5TXl0SXZsWU5ZRlA3ZGYzSHhvUFE0aytDeFNQSjlYSDVzSTFXWWN1TWdGK0I3TFkwVEZmdnNNaW8zcjRzaXZIZjFaaHFDdHRHVTlSYXFrY3Rab3drUWMzV2ZpeWNXQVlEd3ZvUTNhbzBXVG5aT0N5TmoyZ1pMc0pkeTd2cnJvYmNRTnFIYXJMeTVjcWRaUGNrWTQ4cW1SSjBVV2NEUzZoZFJhcHBKakl1QzhxNU9RRWtrbEw4RGtjZ1VDYVdjQlJvdzJOOUtMclhmRmdqOVRJY3Y3azhnU1NaeGVLVUN3c09JNkNxbXA1VTB6UXNJUDRTQ1I2ZGl4ZmlOd2dHZ1kwRlh0R0pLODhVOEVrc09TUDVTOFk0TUhYWUFEeXVvZmZyVVhFdmMvYjM1eXQ3aE5lUU56bkF0eFptTjI0aGYyOHUxVkpYUGpteU1uTmpKZ0VvVmh3WkI2TEl3R2plb04ydHZlc3RZM2UyWStQeWVMT2VhUVFxMWxzT1VkejVGVCs5VHVhc1N0bU5nL2NlNFF5dTBTUUxZRjBGMVZRUHJkUis2cWpyUGhSelNHTlhFME1Wd0hPekQrN1NpT2ZsWXNXSXIyQWErb3Rvd0kxRmpWSEt6Y2lmSWhteWpDeThYUXlUZ2tzT2daOWYzR3N0VGhnbXhvNFZUSmd5K1daSUNaNEhUbDZaWGRTclcwUGhRWU1YR3pGbWpZaDBiSXZONlNqU1VSbTRJMXRhNDI2VkduUnh2ZTFNYjQ4N0lzRHNTMlNpbHdTeHZ4VU5iaVYzM29saXdlOUtybjd5VkdrTWFyajVQRWxIUXRvelcyMHFpcWJNR1hMQ3l5OFZWV2pES0NZeGU0QUE2Y2pSR1NQQWtUTkE5WDdabklqV1N4WmZXVWJrankrRlJyWGJuOTl5TWoyODRrc0RKbFFuazY0NXZFZUlJNU5FMzd2RmF1czQ1Q1pCaktaTWtRa2xIOE1tTkpmamNEeTJaVGNOYmVpczB6WmJ4enU4YWNKV1Zna1N0Y1dGaWdZWHNHOGFoaFRZMzJUdys0NHNrMFR5T1RBcmdYQkJGaGNmVXZ3b3NiWXZmRGtTTVpuR05scVg1aUZQVFFCajVoWUg5MjFOVEVJY3g0SkljN0hkR2dqOGhqVWtTZG01QnI4Z1J0Vkd2M01lem5IaHlNZThPUnkvZ1NSYmxXUG1HbzhyTFJKcml6cmtTZXBKa3dxUy9KblNJR0lwTDM0ajZScmZ5MUZkUDJ2R2dhTDBjZEM4d0pXWmlmNHdCOUpEbmJYcWFzS3psdmNXSDIwc2NieCtvZEdSWEtzTGpRalVMYjVVSFB4M3kxeWxuRTZJUDJaRWJjUkNTYmYvVWVGUlduTTk0bWh5WDlHUko4WlZBdVlnVllLTlRjNjY5YlVwR1E1S05HK0tYYmdUY1BFOTBLNzhTclhIbDJXMURGK0RKLzZ2UGVjY1d1dkIxUEdYenVQcUM5YlV3clNaSTBtZ1YzbENxQ3hrVzEzSi91QjdmalJGa2Z0OHN5cXF6eEFTa3F1UW81T1FEcXo2M0Z2R2luOWhtNEVqWXVSbkpIanl5Y0JrTEdwWWxia013M0hLaWF1eHM3Mi9LZ21HWGl5VFo4UUFhT05Rc1lSZGIyMzdWVXo4T2I3Uk1JUGV3Y1pFKzRUelJ0TUEwYXNlcFhieStOWWpyZW5WeUhEenRMbHlwTEw2aHNzZGdDZDdrRHBWakxOQXF1d21KWUcxOGVGbExrbmE5K256b05FUDNrY3l2TklIdmRYUnJrTVNkcmRkVFRUR2lkOGRWa2Q0ZjRGYmlwWFVscmFqcUJyclFqTEkySTh3NW4xcFFDa0l1VnZiVHlsZFBDb3JETEtFVi9iMlNQRWFWN21XUy9KRkdtaHR5cURYL3grRENHUS9NeU5MWi90bVc2cUdBMFk3ZU85V0gwYVkrVGs1S2ZiUnNZb3lCRUF3ZHZPYkRsYmUvaFVWMThsc2JGTEhJd2lWMUNCUDhBdGxqYTJvM3MyOXVsVm50UXJaQWltQ1JpTUVLL3BrY1pDemZTT1Y3MlVEUUNpcFpXREhON2J6bGs1U3lQNVlJN2tpMisrZytldEJ6L0FHM0Rac21PS0MwN0diakZDdm50ZTJxc2RXYmwxb21wKys0emlWWm84ajdnQmlBeWdsdVNieCtRYXQzYllWTmFpR0hqcEovT2NWWTVaRC9Camhnd2p2dTh2Sy94OEtxTStibHI2cVF1R1Qwbk44aU96YzQ5Q0FwMzh4RzdhVU1YUTVEdEtoYmxLc1BGdVFZQlFBYnNxbmJyUVFPVjduTUpSRVhqZ2trTHNoTmtPcDQzdHBwM085Q3hWTjduek1EVEswazBiZnlFZ0dNZzdBZy8xMG9ZNmZ0Y0RaMER6bVNNTkJlU1lsZ3BjRStWSXdCcWFSTFhkSmdURFNSWmVKTzRPcW9UOGZxTlZIbTVQZUlwMGtnbklpNE01ZDVHSVZ6ZjZRbHRDM1NpNE1ZUEtGLzhBcTRCallTa2NrVStieWpmbHA5Um9ZdmppQ1pMVE93aHhZU0kzS25WeVRveERXR2gzSm9PcGc1TW94OHJJanhrT0tvOUdkeVJaemZrUUNOUnk4S0k1ZnVNTDVMTE5PM3BPRTU0Mk9wdSsrbkszMHFWMEY5YWl4UDJIRW1teVBVOVVZNENYWTMwZGRiaFFkTlB6cXdyMFJQdGtHRktNWmxPWHhKazFDa2VBQU42Snk0UHVHSGhZMFJuYWFUS3ltL2xTTStWUWphamtwOHlzKy93MzNvc3VnajNCdmFrdkpFQlBOR1NOQktBUVNCZlpGUFlWVTlhaDdpdUZJMGMwUjVTTHhqQTVlbTZEVXNyV3UxOWdhQ3FBWXVUanl0TGRwVktyQkhaaTI5L0wwMU9tdlNvVnF5SkV5OG9mZE9jZGxYWG0xeWRMSHc1OUFLMHpxcVdHT1dIMHdxUmhXVUVnbTR1TmJmSVVWb3hIUlh4cGx2S01kQ1ZrS2l5blhpTC91MTYvVlFiZnRoOXY2alNsci95S3hQMU01TnliOXQ2R3FaWjRQU1U0NFIrS3NyU3RxSkdPbmx2cDRDZ3g0NGpWR0V5V21nTEVRc2VYSCsxZWxqM29OdnQwT1VERjk0SDRNd2xhRzlnM0krVXM1dnAyb0g3ZEpERGtUZmZ4bVdSM1lRQU9SR3BKL2VQM0xVS2o3NHF3VGhJNVZaTGM0NDQvTkh0czkvQ2l4aFdLYkpZdVdzOGYvNDl2S3lEWWVQd05DdlM0ZnU4VDRzZU1DSkNvSmVTTWFYRjlDZWdBRmExbkdHYWVVU0diaVpIREM5MXZHRjJIRXRvV3FHTEV4Y2hsOVVvcnlqeXdJUmRiazYwRk9Xa25NNktqQmc3V0pBTExwcDMxNlVGYzBPTTBrT09aWkh5NUdKa2YrMjFpUWwvem90VG45dzl3Z25rTndQU0FZdVIwQXNxa0hTOVZFQm1ySFB4VWpKbmt1OHB0eDQ4UnFDQUwzSEs0cUdORDVNOFV2OEFJb1dJcC9HSkNlWEVHeHRiNlNUUUVrdUlNSG13QkxnRnl3WWNTQmZnU2R4NDlhb3FHSG1HRXZNNmpHVUswYVdCdUxhRFRwMUZ6UkZHVmtxWlF1UHlUaXZtTHNPUWJxUXZRZHIwR24yME5rT01SWjBtc2VUem42VC9BTFF4MjQwSzNzY280a1VMeXQ2Sld5c2JYTmpleWpvS3FMSWNiSEN2a1pCK2orTUpxTGhodnkvYVJVWFhER1ZKSE02eDVEckhPeERQWWk5dEFvdnR0UlV6TmppYUIxRWlJVy9qZE5nUU5pQmRUYmVpTFlaT1V2M0tvU3RuTHgyOHJ1cHRjT05mT05hQzJUSW05UlpwV0VjZ1BFSllsMmNXK29EUzFCV01tSjRWbEtoWEQ4ZlRYWmVYMHMvVFNtbU5hejVjMlZFNVVva1hsQmpGaWJmdXRmdFFReThPUVNUeUFQR3NaYnpLYlBmUTNaZENBMURYTmxiS0V1UE01NHFic3VSZmtRekd3c28wWGlLRWR0cDhqRWcrMHpHVVNNQkxxQXBZc0FGZTF4NWFEbVE0MGh6SnljeDNtMWtsbGtBTGVVNmdBM0Z5RHBRMVAzSDIvSHhvMW11RWlGbzFYa0EzSFVrRUR0UlhPeWNqTmt4ZUdPd1hIWHl4NCt6TTVCc2JqWFQ5L1NpTjJHWm53MmxsU0tVc2dWdzExQ1dYNjdIYzNOclVGR0EwRVVVZVJjdUF5T1ZHMXJrT3VtcFBJMEhyTVFyOXBMbEZGajlWL0tGTmlwdiswN2c5elZSNS9MbFZNeWFOWW8vVG1aRE5NZVRYY0g2T3pHd3ZlaW9aZWV4TFJJNSszWmxCRTNsUVdOd3RoYzh1dmFpS3pGTERQSTJHVElJcnM4d0hKUi9haTMyTnFEVE1zbVhpVFN2RVZ1cUpHNm5pU3Ftd0FGeUQ1dCsxRFVvZmFaeEpGanpNVVltOW11Vlo3YTZ0YmJwYWlxc2pGVlZEUUQxU0Q2TGMvTGJRMzh0eWV0RU9HTExpOXZETkN5c0xMTGtFY2JNZGh4Ty82MEcyUEJkbGtpa3Mwb0NpS1FTRlJ0eXZZNlh0cVJRWkpNOFJ3ZWpHQndXUmJPUnFDRFpoYy9pYURlazBzVXF5eHVrdkc4a2hCNWl6MnR0cDVUUldKOFVUT1pITG8wa2pDS0hrU1FyYThpYjczdnZSbXJFbE9ZbVBqUUlqeXhjbFdBc1hKQ2trc2I2RjZDbUYzQmpoeUxwNmtoQTh2OGlnV1BtYlhTL2FnMVpqZTF4UDZtT2prbEFWa0xYdElUWWczOHV0dEtLNXVSbCs0WTJmang0b2o5VnJGRkNoMWVNZzNYNVgxTkRXbi8yUlMwa2NUU1JOeE04a1I0a05janlYK0ZCdHdwcG5ubmtneGJ5TVFnaTVLN0JYdXE4Q2JydnZhaU1veXNlRXllc280eURqQW01Sko0c05PeDYwVmU2U1lCYVdNckZsd3Jaa0JBSnYxWWRTQnZRckNmYmMzM0hKYi8xN09aRkt6QUhRNldOOVAyMEM5eVorUHFTWE1tTEp6azVEaVJHdjd5ZGRMNlZCenZ1WnN1SEpWMk9RZ0phWXA5UlF0cHdVaGZMYnZRWm9NcUdJaEo0dlRqQlBwRzFyZXBxb2I1MFZya3pJMEtaYncyakhNeW9RYnJacmNXQlBJMGxNV3pZZWNmYlZ5a1VOanhjcDFRNkFSRTZJdHlEc2R0NnFPZE5tY29ZNDBsYUlTYVpTT2JMd0gwclk5RDBQZmVvdU9maGV4NVdSaVNrdXNWNWZWWElja1NxcTZBS2pkYjcyM29XNDM0Y0pqd1ErTEkwVThrVHhTcVZJVm9nZFVaUUxQeTFJNmlpdHZ0WHVYc3VQaXRnZTRSUlpFemhmWFMvTG1td0MzOG9DM3V2alJMRTg5Y3NxdVRrc2tPTGhxUjdleXhoSEtnV2IxQnFTL3dEZDQwU1BPQ2ZDbGlPRXN6eGhnUHRUcTl5R3V3NG5TUFRVOGFOWDh2WCsyWlFSWklwNWtSRzRpVUMxNzhiSTE5ZWxWbXVaNzYrTmtGWWhPSjVCRzRjRkNTZlQxYXovQUZhQ3gwMHJMUlMrM0hLQXpKWnJaTWFvVlVFS3JKd0ZpZU5yNmIwVGNWKzMrMXZOUE1zWG01QWNBd1VzNEpKUG1OK0pCNkhjVlZiTVhLemZhSUhoOVFHSkdlVHpHeTJJMDRIVzNKdEtJWHUzdVdUbWUxeCs1ZTRlM2crM3Y1UTZrb0daZERhM1hYUmpUVWt4aGlXYklpaVgyU0lreGVka1UzQlRjODc2c1FEMG9ybVpHRkhObFNlc3JlcXJBcWtSRjFzb0pKR3ZsNDdlTkZkSDI3TnhzZkw5R1RJamp3MFZUak1oTC9XTnlQM04zcUYxcGg5elFSSkpNc2NVdUxLU29ldzliMWRGQTA4eWk5d1NkNnFZNXNtVk5GRmtRcnllV0lQSXN6QXR5SEVvT0pIN1AvbFVhemxkaFQ4bGhIcWtzcWttTWFFUzhRRzVEcmNkS1JQcWN0ZjJ4aW1JV1lIMTBEdHhSbGRkTDhXOFFhcUoraE16bkltWmY0Q0NqeGtGUTdDNFkvM1h0citGQmpXT2RQdUQvd0IzRmU1bGtDM3R6SXY4S0JQN1BHQUMvd0Q0c01xYTVEcjZvOUZ0YmxlakVqWVVWbXl6Nk9ORytJeFhIaWF6bU1sa1pnTGxsTzZNdzBONkM2U1pUeG1MdEhqekh6dXFFbEZJdnNMYWRLaXhWUE1ZWTV6SENzMGJzWXZUWldNWGxGL1VqWWk5Nk0xNW9lenRQRExLbkpaSW5QRm1ZTVlrT3R5ZGYwcU42N0h0R0kwM3RVeWNYeHNqR2hia2tqLzk0RVc4a1pGdmlLSmUyTEN4OGlHUkd5aTBscEZYSWpGZ3hHNnFGQjgxaFJiWGJqeGNXS2VRUmhpamNtaGdqSjBlMzFGdjI2K0ZWbEtUMnlDSEpSSUdTZUYrQmxNd0tzcm5VaTR2OEwwRzNBaHlGeVNNS1k1U2VueW5VTFowSU9xdmI5cTk5dXRVWThxQ2FiM0dUMVpRSnBnM0pRM01BazNCTnREYy9TS0l1YjJlZkR4b0pNaU5XZ040MGJrZjRtLzNFYWs5YXFieTZXSkZqb3hQcURJU1UyRTY2RVNBWFkyTzV0cFJKV3g4WmlOUnBvRjUvVllmU05LSzZQcXRMaUQxM2FXV3dVRGNnTDIvem9PZDdxOFlSR3htWXB2cnBZblVoYURqWldTMHVOSUdZUnFwVkZSalplSjE0a256YTlLRG55NU12RlkxeHI0cEE5UGxjRXlFVzlSYWlyY1lKbGUydkxJN05uWTBnV1JYSkRsZDFJWTNEM3RRUEw5M2w5YUxtNytsYTMyckUyUk9wTk5NZEJNVDJkMjlNWk1jZktNRlFRQ0ZjaS9wQTdYNjNxWXVvZTVlbmdweEVmQ2FVQzBRUElzMzdXRzlDT1hLdVJJc3VSaFRjSVkyRG9Za3VJMlBsUEpPbDk2S2oveHozUDNIMmxrbVVsOFhJOVJNcEkzMWNOcVFVUFcvbW9sbW9ETUh1R1Q2ZXF6U0c4TEVnQXlLMWh5T3lpMjFOV3gxc3VIM0dORmw5V1cwVWpvazExRjJVY1dBQ2svTTlxcktFa2Z0bUErRG1SdTd1d2VTVUtXVXF3SVVvQ05tdHRjVkYwbTl3aXlaWnAzUXpZdC80ZVlKWUtUb1pMYmtVMHhMMnYzSm9JZ0JFbVJGRks1SWRib0l5TlhqZlE4aC9hYUpXYk05MGFUM015UkxJekFBbzZpN3ZHUDd5dHVMZHZEZW1ySndlSDdoQkc0eklPVWVNcmVtUVdCdTMxRlR4K29OUWQvM0RQeUZKemJXZ2tVV2FNZnhrRVhYNmRCVlJ5OHozakhrUkdzcUk5bEtPMmx4OVQ4dWdOTk01Y3ZGaEh1VTBpSVZoV2RtOUZya0E4ZGcxcjNIeHFLNnl4KzEvYWNKUS9yblNmRWZRRW9QclNUNGJWVWNLWEhqNFJ4bDVQU2Rta2ppMExxZFF3VTZuVHRVYWMzT3dtS3l0anlNOEFkR1JaTlk1QmJ6TXgwczE5TFZGaStITWloeGhCUGp4dkM1WVJSTXhWb200M0RjcmFnOXFKV2pDVjU0SUk0MUVidXdEUkpxL0Z0ZmllNDdWUnE5M3hKTWFCVnpoS1pjMno0Y24weE5JcHRlMnFzTkxkNmhPMk16b3VONjhlUUlzOUxmeGkvSXNyWEJKN1g2VlJDS0tmN3NaU0hua1c5U1pDbHdYWHpIa092THVLaGpaN2I3dmg0YzByekNWWTVZL3dEeURqa0JnV3ZkK0xhSGoyb3VNMHVZaVpYcGU0QnZ0VlVIRnlDdG05Tzl3VlU3WC9XcWhTZTNZclM0MDZaQ21kaU9FYmpVaGhjTDJ1T3V0UlZQdUgydU1TaXFrOGNqQld4MEpzcmVIWndhRVEvOVpMa1l6WkdHc2hPSElrZVNESUdaQnFBT0pQZnR0UWVuVDJuN3oyOFJ5VGhuQThxTUx1V1lmVUdIZ0tzWnQ1ZWZ5TWpLeDRaSUdjbk5TVGp6MVhuQ0JZUnNPdXUxRDFvd29zNlFzTVVreU9sM2lqQ2dnVzRrTGV3K05SWEpsd2NXQStsUExLREkzRUlxNkZGQnZxZENlWGFpcmNGOFNhV0Z2VWtoWkRlT0VLR1VFYVgxNkVWVXhQM0wyMCszNUVidENzWHJEbHhMZVVyME9uVzlMQ1ZwdzhlV1NCWjVJQUlZeWZVRVlzVzVHOTJPdFFha09QbEtZMEFhUW55eU5vTmR4NDFVTE54WnNmSUUyTXZwUTJVVEd3TE0zVWdqY2FWRmxic29yTjdXR3ljWld4ZVlMWm9KTWtZUFZSKzRYM3F4SG5aY3FEQ2pnKzNZakpsQlozak55Vko4dklub2JmU2RxTHpXbGNER01jYjRpbU9kK0pjeUx5SHBycHpXMmdGWWIvMXRoa3hwTUJna1R2UGNpNklGUzNlK3V0cXFlcExtUllzb1V6dTdsQjZVREd3S0hRV0p2ODZHSTVVaWNvOGtsSXRSeFRVYjdBalU2MElzbnpzSDNCRXc0Y1dRdmNLVVE4VVlucUFQN2p1VFE2Y2ZKNW5LUnhqZW5qUURqRDZDc0FzZzZIcVNEMTcxRlpaY2FjaHk0dmtwdkU0SmxYa2ZMcTI1djBxTHJSRzBVTFRJeURud0tScHlMQU1iWGZrTno4YXFPNTdkaVpFQ3BPSW1qZU1Gbm1TK2x4WVhZVzArRlZLcTl6OXh5SlpZMWttTXNFYkFScmF4Qzd0YTF3TG5VMnFMRU1HZVRnM3BRaytzeFdDUml6QVcxM081N25wUWJVRXZCUk9GbkVZQmJpdkZGWW0xdGJjcjk2SWhQN2lGdTJCRTJQSUZJeUhVV3VoL0ErRndhRG5NQ1lieFJzdkt5a0tmUHkzMEE2VzZVVlBDOXVqRXpUVHM4U1NLWTJDcVNOVDlBSVBXZ25rUVloeS90VmhFUjVjWG1MY25BQzNZY0Jwc04rOUVUOXFreE1oNHZic2gwWEZBTFJNNldNZXA4MGg2dmJhcVdmaHY5cmhqbGx5WThZdlp3M3BLTlJJZzNkaWRMZnBSTHd4cmhHREpXVm95NXVSQ2RCRVJiZlhYUWplbzAzK3p3bGttaWtsanhtUUdVVE1BcWxDTlcydVRiU3JHYldLTE9ReXpZY1RBc0I2a2VTNjZCUU5SY215TDMwM28xakY3aDdQQzVYTGZWNUVEQkd1QTJ0a1ptMU92UzFFMXF4SjI5anlueXN0aU10bEI5S1FHUm51TlRlLzFlRk5NMkhtZTlRVHorcThmcXhzcXREaUh5QXFkZ2Y4QWQzMHFMSnd6NUJkNXBZeWZUVlFHWVJnaEVQWFM1dnhCb01FR00waGt5Sm5JeFBVdEpLR0laamF5azJGN0FhMEdyR2VUZ0k0cEFGSlZDZFNWVHZicHlxalNjSE53MHlNbUwwM2lkaEhGbFNqVXZ2eVVOcngwK3I1VU5hM3pzMy8xa294WUlKSHlRR3lXNCtwSnl0Wm1FaCtuNGJDbFpuYmt3RjhaVm15dlVRQzR4d0J6TEVDM0FBN2ovZFJwcDl3bHpjMlNEUjRjMWRKeTVBNDh0K0NENkVXak1tTzBva2t4WWJ5RXhveXBCS3c0aFRhN0VLQU5MOTZwUlBKaTVlVTZLNldRRmZXc2IvN2dialFrOWZ3b1pqVEhpNEppUldaakt4NHhxRHhUaW92YnVEZnJWWjFsYkN4a1MvcHZHV2t1aUxjRmRMbS9RaSs5RlFpbFhJU1NBUStweVZpY2dFZ2MxL2FsOUxXMXFEVzJNWGdhUWgvU1FoSTJBMVpoMlA4QWIzMHFrUXpJNG9vSXZVWjFrbWE3emYzbzJqRC9BQ05RVlIrNFI0anJIT3hreG8zQTZncVRxR0JIMWtDbXJpV0I3dzh1U01sclBHT2JJTEI5RHA1eWRPUTNwRXNhMDl3eHNYSWx4NVZEU01BQ2VQTzQwSjhCcDE2VlVEWldJdkpyRXhzck1xTUxLTG5SeFFac3h5a0Vmb0tFVXNCR3BiZ1dZajZRdCtXMnA1YUNpeHBPVVV4b1labk4wc09TZVlGbkp0eEI4TmIycURwWTJYTThVYkNZUkxEeVZpeHRZRTlMYUM2MXBuR0ZzekFjbFVCZVJPVElYK2ducDVpZGRLaXRmdFVzMHNNclk4Q2hRaFdTZklzZXY3UnBZK0FvTXFUUGs1TTBWMTlDT1V0TGtsUUdJWFVoVk9sdTFCRERXUVNHY0EyNW4weXVqRzU4clBjSDhLaXJqT1VremMxNG1sV1VpTlJPQ3JJeTZzQjEwcW81MlZsT3VTSURDSTJtNEZFNW5VSFhpUjB1dXdvT3BpUzRENElnOU5qa3F5dWpjckw5WEVYVTdnZEtxSGs0QWpqVmlzYzJUS3JNQU9oT2lnMjNwU0x2K00rM1lCQlNUanhVMzhubUc5dUwvd0M0NzBoV3ZNa2lFOTRuVWhTVlZUWnVWdFB5cW9xenhKSEMwTHljVnZhUmRDekcxeitGS3NZSHhzY1NoWHRIQzZreE1DVFprK25mKzQ2VkZZcGNXVlY1T2orWkdjRlRmbjQrQUZyYVVIUXdCSGhZWXlNaGw0eVRLWTFhVHpLNmpVTW0vRTJvaWtKa1plYVpJN1RLZk1JaTF1UzlUYy9TTzNXZzNaaWlhUkZ4bFhHVmt1a1pjRW9UY0FNUi90NzBDKzVoeDhhVkpDWmcwZG0wMXNwdVNDT2hvS3BpNk1Wa0xjc2hWQWQvTU5iV3RjN2tkNkNHVGtZOHpuRHdXVUpqOHJrQXN6TmJWbUowSGhRVVplSElFbkdYS0pKd1BUeGdDSkpDYkM1LytNWTAvU2d5RDNDUnNiazZOaXFMTHprWGxkZUo1RUhVblVlV2lycHNYSnpmYkdFRS93RExJeXVpTnhlYitOZDlyamlOZTFRTk1mUGJBaWtrQ3lUcXQ0M1Zidnh2OUJ0YTFWTlNnTXhaeFBBV0RoQVpDVFprNGxpRDRtMnBvTldMQkVjTXBocTVoQUVpbGtBQWExcmdEcGZTaFc1UFZhQ05QcGc0cVNXMEhNNkZ1dWdOVkdPYVBJRS9HZVJXVmVLcEhHQ1NFMnN0dnFQZWlxc21BTXNhOEdhRjVGL2tDZ2p5WE5qZTNtNmIxQlhqU2VrcnR5bFc0SXlGQThoSy9RMy9BTmVncW90ank4aGNPU1NibkpFeHRHWDQ4bEIxSXNOdVoxb1Z2YjNRNVdjb2xqT1cwU3hyREpFVHhPdXAxb01HSGxwUG5TZXJ4amxhVmxTSTM0eGxEcVFUYnpmT2czUGt6UXcvYStxV2xsa0g4QVBKemJZaGFHczAwYzVUMWxTekFOTTBzeHVDRDMvM3JZOFFLRFBIQTYrM1NKWU1DUzBwWnVWbFpybGwwdnFBT1RWRmREMi9oQUJFeWNuS2dzQWYyOGJydG9hRlBJeVEzbWdLSkRBTHNiYXNYMHVBTzFWTVk0ZWNjOFVvOGt5b1pnNVVCMkVtZ0Z4OU54ZWdwdVdNaktEb0F5WXN6SHk4angwZlMzTGVnMUpBVWhHTGtTZnlweGFOWWtIQXF3QjFQOTIxQXMzRldLL3VLcklrb2JnNFZsdXBhNDVGcmJFVUU0dnRaWm12SjZjTU1SVklpU1MxaDVpMXVwNzBGV1RIUGkyTVVaZDJVQXIwV01BWEsvS2dpY243aVdLV2RXYUpYYVFpTUtaSFVDeUtkck50ZnBRVWtPMTNrVWt5dUY1TnF0ckMxMjZhMEk2VXF4T3ZwcXp4WkpjRXZHM0FsUUxQR3Ayb09WazUyVERrRlhsTXNUUnRHbzNCU1RTM21Hem41aW9PUmcrM3hTZTVuMDUyUllnQXFPM0V1ZjdGSitsUWRLSzIvd0RxdnZNR2VXVGs3d3Y2Y1FSZUlDbjZyaTk5UDlhbFdWZ2JNeVJqUzRHUDZiTXhETEpLZVhxSUc4NlhQbVlnMExHNzNySE1lRmlaWm5WR1dWV09ISXBaZ1FtcmNDUllmdEFOYVNLY3hjVk1PRjBWL1N5R2srNlVJRmpaV0FQR055R0lQN3Z5cUN1ZUFOancrM1NCeXdlSjJ5WXpkaEdFSkFESHAvdDcwcEV2YTgwNFV1VmpjbXg0YldVbms4aVNOYnpJQmY4QWx0NWpmUTdVTzJTT1AxOGw0NVRJc2tTTVdLQldNaTh0R1pSOUxjVHB1S2lrbWRuWlNlbGxtVjJ4K1VPT3dMS1VpUWZWcGRRU2ZxQnBwakdXeFpCeHh3d2JHTEQrTjNWakdsanh1YmFrNjNvcnB3TEprVENMSlptaFpGbXhaSlI2UlpSNW1CSjZpMmxFMGo3WEhrNTA4RVl2elZBV2NnbFVkdGR0ZEc3ZEtESk8yWmd5cmdUQXlaY3prc3NqRVJLZ3NzYkMyaEhYbFJYZm14OGhjU0tmUlpaMktoUTlsVHkzTHlGYlhYVFNxeFhCUHZVV0o3aWt1WEUyVmprTmREWm85ZHlGNzIycVZxUnJRM2hrT05udWZiZisrSTViOEdkUUhLQmZwVnhzRGF4b3JISDdzOGtNUng0MWd5TVoza1RnU3J6b1Z2eHR0NUJwUk01YjRzakc5eVRIbmppV0xKZ1ZoSmxLZGI4d2VVcWl4QlFVcEdhR0dacHBuYm5Md01wNXdvb1lvYmMyVnoydlNyTWFNMzJPQ2JDaWdaaVdkRmJHbWNrZzNON0tDUng0azc5YUpWR1hGa3laTFFxQTRWT09TeUF0eWNiU3RjanpEVFFVcXhkSEc2TkpQTXJDVWdyTXlBRHo4TGwwSDdlV2dOSWwvRG9ZMGhUMlp6SWtjcXM2dkU2U0F5eG80MEJ0cTJ1L2JZMVVFT1cwdC9VVkhkZ1RLMXJJdlRRRDRiMjNvT2dXWlBiV3g0b2t5TWZJWWNwQ0Q2aC90K2svdHZSR0REWk15VjhHRlhRcW5Kb2o1bGR3TFh0MFBoMEZCZ2toV0g3cU9LSjFPUXZKTEtERHdYNnpZbnArVkZUdkhoWTZTWStSeTl3bHNyWTVISld0OUt1Zk12V29yazUvdU1tSE1CbU16UXlYa2h4bVMwVEZocUJZMzBQV2hqSGsrOCszaUVlMk1vam44c2NVakN6TGZYaTdMdUZ2WUhZamVvMWxXcDdva0V2MnFPNnRvTWdQWnJsZHZUWWZxS3FaNnpTZTVmY2Vxc2tmbStxSmtDcXFsZHI5ZXZUclVNZWg5bXdvY21JQlovOEF5M1c4bGlHWGlSb0NkQ0hKM0ZWSFJsbVpJZnNVYTNxK1ZsSUZ4cnFPUi9icDhxcU9YTGw1THpNMTFSN2VpbGlJaXNZK284Um8zamVvdkNVa2tPYmtwemZrMlZaV21XMXJvYkJpQjBOdXRWRytDTkpaSm9KTHY2UjRLd0o0NkhkYjl4VlJVa0lpSEJYVkwrYUlEVUt0enl1ZW11OTZEcVpjbnVVZG84Z2N3Z0N4TnBzZk41YmJpMnRBUSs0UkZrV1FGRTh4WUtDMTdmdDAxRnhRWlhFc0dVU0Z1c2lzOFJKdm9mcHNPbFFjR2M1dVprTzVDSm11akU4eFlOdzBBVUQ5elg4b3BWaWMvdVUyVERFdVk3WThDRkl6alh2L0FDcUxYRmhvRFF4YkZtTGpMQWtFQW14UWYvS2o1QXU3UHN5RGNCZGhhZ25tZTVxeUV4WXhqellTUExJb1lnaTNIWTJKL1dnNTZaT05ibExpdW5BNnRDTHQ1cjhsUDdkTjlxQ3lPTlh4M2JIWnBjU0ZSTkpKSG82ZG1JT29Yd291dCtQa3dRU2ZiRjFTTm8wYVo0Vi92MTNGenR2VUYrZERDbGt4dUpUaVJGSWZLYkhXL2phcWpsTmdKQkpGSmtEaGpTc0Ewc1FObUg3dERzMVJXOCs0WUxZd1hGNXROaThraWpGbnZHb05uSFplOUV6bHdYOWRXV1lTbVRIWnJ5UkRrM00ydVhXNEJQYWpVZEwyMy9rVWk1R1c4UVhHZDR2UmhqV01MRTRJdFpsYTl2ajNwRXM0WnljMTBFTThic21DeGVhTEhBWlFHdGRtSDYwWFVzbjNUS2t4bWpDYy9RdW1QUEhjTzF3YkIrNmdYdlJKSEtZNDA4VVNTU0NOb241NUVVZmxJQTBhL1RsYW8wMjRDWkVvbGpobDQ0VHR6UjVHTVNnTHNodWVQK3RWR3liMm4zTjA0NWNjSVNhSnBJd2JxcDQ5ZVF1TDZkS0pxSC9Hc2JLYkxjUEdtUmpSTGVlTFp3cS9VRUdoK1kxcGhhNlF5OEZwNW8vVGt4SUhQQ01OY3NPUFJyamFxbkxQNzZKY2lXSXduMFRBcEVaVThGVUg2aUFOK1hXcFZrWm45dXltZ1RKQ2t4amtPSzZDNEd2THVLS1dka3ZuNDBrYk5DN0tpc2l5cU9hbFJxQTZnQWpUWTBSZ2lnaG5SMHM4V1R6V1ZZaU9Lc3BHaExEVmJucU9sRmRqQWFYTFY4YjNXSGppeUl5Uk93NVJ4NUZoWXFDZVVZYXd1YUpYR1dWRGt4NDhVU1JaY0JFclRhYWhUcXJBL1grdFJXbjdyTmhhU1FaQ1k4Z2NTaU5UNVhZSHpPdDlqZjhBYnRWUkNmM21iSWxlZktpamlrNFdESkdvVTI2bEJvMXR6YXBxeVk1NiszUjVEQ1ZKVmxnVG03TGNqaWk2bGlEb1BDeG9vZ3pCTWtrWGx5SXNqL3R0T3ZHU0pVMVZ4c050cUdKKzFwRU14NEpKR1ZYQldOcGxBNHMybkpnZW45YUt2KzFNa25wWUdMZk5pVGc3RVdVcUQwc2RXOGFJMmUyNUlndGpaTFBGbm9DUTNPNmhnQ1NyQyt3dHBWU3VkTmx5WmVRcEx0TW9BTWJ0c3Y4QWNBVDBvT3RJWW53MUtLa2NpWEF0OVRGdExINFVoVlB0a1dRcXpZeFpjcUtWUWdqNDh3cjMySEx6S3cvMjFCSE16b29wajdlbUF1TkNqbzcrc3RuNUtQTVF4OHlSc1AyMVUvYWVYSmtaR0d5ejQ3QkY4aXVqZXNqZ0M0RWR4OUlKOHh2UXJGSjc1TDdkQU1PUDFNY01WRTBSOHlsTGFzRHVPZldvdmJVdVBEa1pFeVlVekdOMERzdS9GMTFLcVYzWHBlcm83VUdQN3A3ZjdTdWRESUZ4c3BRazVKVjFISnYyalU2L3VCMUZJemUzbDQ4SEx6YzZmMi9HbUJpVm1kVlUrVmoxc052d3FOc2tpZW9SaTVFU0tZazhreER4TVNoUGxKRjlibmVocnVlMTQzdG93NUpoTUpaSkY0TEVWYXlqKzUyQjJIU292S2x2Y3NsZzJQSEVYeGxVaFJiaFpodTR0dnB1S0dLTWQ0VWxFcm81WkZzc1lVWGMzOHdKUFRyM29yWmk1WHQwY1RaR1dyQnBIUEdYL3dEQ1FBR3lxdTdOZnIwRkU1ViswUmU0Tm1TZlk1RExkZ0J4SkJWVDRVaWZWalI3MzdXUGJqRTJPNUV4WWNTQ1Q1Z2JuY1dKUGhVYStlWE1teGN5WXQ3cGtPMHN4Y25jRmdOZ1NiRGExdE90Ri9SZmN4WlB1Q21IRjRSUmtYSEl1ek4xTHY4QVRkdnlxbzYrRDdnUzc4anlXNU12Szdtd1BVYURUcFJGOGl4Wkl2dzBGMkxBOExBOUZOcktPOVFZSmMzM0hEbFdHUjBiN1pHang0OUdWUTNtOG5TMSt0Tk0xVU1tZklqRXBuVlYwdHJ5TFBhNUxKOVh3MHRSVTQ4WEhSaDk0L3FHZVBtQkhKNVZ2dGNEY2c3aWdzYkk5MEVrVUdQTUlJWVU5T1BncEpkbStvZzczdHFlMURJNnllK1lFdnQ4bUVSNllnS3h3TEdvQWFRamZrVG9EMU5PMGt5NndUK3hSdEdHanlvNHA1V0JaVlBMMDFGN3V4UFNocm5ZcVpNMmNycTVraWpZS3FIeUdRS0w4aFlXMXFyWGF3SWt6dmM1SVh2aDRjYURra2NnVDA0WE4yNWYzTDRDa2pPNHA5QkFaTW1ESUFqRFBGanFHSlpsWlNQSW12YjZ0clVWeS9jZytSTUZIS0dLSXhvODhsM2taeU4rVzF1eWphcHF4cHhjTEZ5Y09MSW5Vdmp4TVlRbU9WV1NRZzN1M0x2dDRWVTN4ZkQ3bGxRU0Z2dHdHblZmdGJlWVJsRHhUVnVXbnhvWVh2ZWZrNVpacGxoNVFqazB3QVd3QnZ4WCs0dTMxR29mS2pIaW1XUlJHcVBKTkc4c3JxRXNvTjJaaDFVZkhXaW5EanROaFQ1bVBNUmp4Z0IyYXlxZVI4eUFOcXgyMUZCc3g0cEJDTWFVdmpyeGVSMEtjbEtsZkQ5eEdsVktoRjdmRGp5Qi9jWS9UZ0Z2VEIwTm0yT24xQ2hid243bkk3U0xGQzhqNDlnc25VcXA2NjIyRkVoNHg5dWpnbGdmMUpZMVpsaUtrQzhsK0dvN05zVCtGRldIRmw5YWFlWGhERmlGUVluTmdCYTRqREhVbnNCUVo4R0wzREx5OG1jcmRYczg3bHhmZTVBTnUyaDFvVnV5TXRNdUY0MENyNmpDNm9wRnJEUlVOOXFKT0Z1VERIaVlUTElDcy84QTNVQ1c5TlJvQjF1eEozcW1wNFFaSkJHNGZtd3VaU0FkemR5Yjk5cXJLM0xPZk42azNyWGpSTFJxcWdBczJsbC96cUxGYVR6bkZUQ2lQcGVnQTA3dFlMNm4xV01uZGQ5YW9wSmJPaWprRStnYldSYmdsdGVUbm9SMklvTi91YkdYR2hFaHNzQ2tLaUtkQUxCV0xIdnZhbHBJeG1ORGl3VFNDSXlGbVpqY1hOeUR4WWVJSGxDK05RUVZzVDNXZWFPS0VRUU1qUjQ1SjhvUDd1VnRoYnJWd2xYZTNRckZnWldRRmpra212andySWJPcHRZSGdMQTJHdDZEVkFNV1BGU0F4bFpQKzVQTzJ0amJ5Z0UvVUJRWXNqRmhneVpuZG8za2tJYVNXVXNvUlN0cjh1aHYwNjFCSEJhRVpDZXBJNXhZNHo2eGlGbUpBdEd4QjE0bncxb3JzNGtlTWNVeHhGV2drY3h1cmk3eGttN2ZDOVZseTVJd3huTVMrbENBQmxRRGFSRjFDSUR0eUkxb01tTG41SnhHOU5TMGFPQzdGZ3d0Sm9pcjJJb3Jma1k2ajJWYytQOEFreWkzQ1FOb3lvUHBXdzBBSW9ieml6Tjl3WEp3bHhjZkhmR1ZBclpNN1Bja05Zc2tkcmNiMjYwVEdiMnVlR1NPMERubExLM085NUdVSzNsMU43czNVMFdyOHVMMitEM1pwSnBIeUhVa0NUUldZa2FIWHJmOEJSUER4WkVtTU9KTUZpVUJpN28zSjJZRzl1NDVWVWIzbU1zRVRyRDZVS2dMekkxdWwrUUE3ZU5CVE1ac2JJWkZ2Nk1RNU5ZRldKdDVRZVBYdWFLeW8yVDZiU3BIOXc2bmtOYk5iL081b2pZYzUwTU15TXNjbVB5VnlWRERtUVNDRjE1ZUpOQmt5L1hkWVZabVdaZ0I2WUpKWXFib3h2OEEzYTM2Q2luRjkzbHdxa3A5Q0tKakdvMEpzZGJOYzdhWDBvalNmYUpQUWFTU1QvOEFaMUJkNzM1S0J2cnVlMUJYSEdaSHlKNCtVbUhER0MwaUtiTGJROHJDNEpvTHNTZUJKNDVaRC9HRkNTeklSWmh4MEJQMG05Q3JNdk9FRVJmQmtSeklWQmd0Znk5QzF4c052alFZL2Nzb1RTSWs2OFlKVjlVd0c2N0M2ZzlpdlNneVlPWFBpWXFaQ3lHQ2VjRnBrSytiMDdjZE9nSXZ2MHFMVTVXRWpMSDZnQTRXamNIUmxRbTRiaUF6RTl6VkZNRWhoUmNjUmorUjJhWXNvS0NOeUxxR056WWREMDZVUnZ3QURqNWNKbEdLa1BHWlkzYnpTUHgwT2d1YnJ0NDBDOW16bVdIMXA0cEZ4NHJOSlBjNmxudHgwK25sWXIyb09YN2hsWkUvdVpsUlBzc2RtdThETmRrMTVXWmRDZUMyL085RmVpOXJsd3pqZ3dTY1dLM2x2NVBVNUhRSUQwUGFyR2F1RXMwWHVBU1dJeXFuOGNjVWJBS0dKdnl2dDIrTkNxYzdPbis3KzNpalhIMk1qeEcrNDRsbHZ0NXUxQm54a2VHTnBReHpJR3ViT0dKUmI4YjZHMjUxNjBGMlhQR3FJaGpNc2NTOFVET1J5Wmh5S2dqWGtLRERpejhzNS9VaXRFbk1TS3JDNmNoYzNJMFZyanRyUWFKeml2a3dTUk84Y2g0bzBLVzRpTzF5NWJxUWQ2aW1jUklNb2hrNWdIazhnWU55a2Z6RzRHMTZxTnJ2QjYwaldFTHV0b3BCb0hQZlhZRDhhQnk0clowSUFESUJaR1M1UHFDUDZwU2JlVFcxcjBHSlRtU1BCR3NLcGp3RmhNRzhxc1JyWTl4MW9yTmpIR2lqYVp3WkhZRzZvZFNIdVBLd1B3cUNXRkVaWUE2eVJneGNGZ2dWZ1M1WWtMcHVTT3ZqU0ZXTmxPa2t1UDVPU2tNSXd4K2xqZmk1Rzc2N2RLSXZkakZqeWdSa29BYnhXdXFsUmNnWEoxdHFUVkdaWFd3bGxXVVRUdXBSVkZpVllXQkhkZ1Q4S0kyei9kUlE1Q3ptS0ZPSXRDNURDVGxjS0wzSVA5S0s1MkprSzB0a0FjeEZEa3FwUEVLeDRvV081K1ZSWFRaQ1M4Q0V4eFJEanlZQXFVWmhiVStZaSs5cXFMTVJ2YjhkWkMzbmtJdEVwc2ZJUjVwRDM4TzFGckljbUNPT1FqR1FTQUVDZFQ1ZVFhL25HMjFFVlRmZVM0M3Bsd2haSGVPd0xoUVRxeHZzS0RtNXVOa3N5WTJUSkhEa1k4WWVCcEd1c2d0dGNXOHdHdGhVV01YdGZ2VUl6ZnRNZVBtRGRGbGIrUThkeXgydUN4M3FTclkxNVB2Zm9aZnQ0V0V4U3lpMHpSRVdaVTAzUDd1OXh0VjFKRnVGN3JGN2ZtRDd1T1AwTTFBQ2dVTk5BTGxaQ25RbCs1b1ZWN3ovQU9wbHlpZ0x6SkhDN3haSkpSaHZyelk2OFQrM3JTa1M5cG14M3dzVTNhYkV4VzlLQlJwRTBwOHhFam5adW8vQ2gwdmxseUdteUY5dFpqSGlxVWhsbXNraFpOWFpsM3VDZndxb3g0c3dYSGVLU1FuUGlLejRrYXFDanU1L2tkNWVsdEFiaW9yRk9tU3lObnlTbkhoYVhoTTZweFpKbUJjSWd2b3B0VVZuOW5sa3cvZmVIdXo4VU9vWnRPUmxGeGUzMUN4dWFGNW5Ec1QrMTRlVk5mQm05Q0xMQjVPNkVvYkErZmlQMkJ0cXFheVJaZU5QN1ppNHVVZ09WRDZqbktrdmNxTkR4VmREcUFTVFVWemNIQzkyWEltZHVTU3dJem8wYkZyODdQOEF0UGVpMTFrenNmM2IzR1BORWZMTWtSWWlKZ1dZaFZCSllmU2VScXMxcG13Y2t4eXlaQkNDRXFzaUVzZEhQMGtIWlFLSkt5TFBKOTZzTUUwVG9zWDI2VGtLVmtWUVNBcWtlVWdrNjFGV3BnZTZ6UlpVZUhqQ0QyMGhjdVZsWmJLNDhvWU1mcDVDNDQwV3VmOEE4ZXdKTWIyOXMvSG5UR3o0WnRJSFgxR1lPeFc1UTM4by9NMHczWFp4NFl2Ykl4N2xrRkZmZ2JaRUlCVTN1TGxTTGNyNkVHcWpDY2lReXg1R1hCOXUwWEVRd0wvSHpWemNsd2U0T2xSVS9mUGRjU1diL3dBTWNmUkI5S1VYWnlHMDRJQ0xKcFVxL000Wk1QUGFES2pUS1gxbktMd0JQTHloYnB4NGRHOGV0RmRqM2ozTEdUTWJ5S2hDck1YUzNBbFQ5RDNHdkU3cUsweGxVUS93NDl5Nm9DclR4dklCb0hPdkVqb2Y3VFUxY1krV1ZCTktTREVrVUlkSmJDN0t4QTh0L0E2VlVadi9BR2tzc2tDWko5QXZlWlhJOHJCUnhJdGNIb0RhaTQyU2U3NXNNY1p5Y1pva1J4NmVRdjhBM0FvLzNmdUJ0OGJWQ3hMR2xPVkZQaUlBRXpTdnArb1ZhVUZqYzhHM1VOc1RUVEVtbW05ci93RFk0czBjWnlHSHBxa2lEbmE5N2hocHk3R2lkdlBUNUVtVjdoa1paeGttWnRYaFVjbzFqSUFZanhYZlFVYThjdVRBUmtIdVNzczBvZG9FeDNCTDJVZVJ1MWdOcW1MdmpxNUUwSXhJVGsrM3g1cUxFRVV3RW8wYlMvUzdrZjJ0dDNvaFl1UEsrTksyWEtySmpGVUtJbDJDajl1dzNxbFNqejhZVHhqQUo0Y3VVMFNpNjhqcmErK3RFZXE5aHg0WkltOVdWSVc1R3lpN053YmRiblR5OURWU3NudkUrRDkxTmpDU011bWtQdUZ2SXFMdUhYcHkyMW9NZURMaHFIV1NKMkI0aEdqSXVaTDNJSTM5TWRMVVZiNjd0ayt2anRwcXNxVzRoZG12YTk5RGJwUkhaZHNESXhKSnBHais2UWtaT09BVkxodGVVYkxwOGFxTWFwUENnUUV5QUMrT2wrWXUyL0g1ZEtDdU01VUplWXI2YWZRNmE4ZVkxMzNCcUt4K29zU1Jza3p0d2s0aFd2WU8vVGw5SUJ2UUUwV1JIT3p5U0NOdVJaMVlxZGRqNlpHN0NxTE03SHhac1lSUk16UDZiQ2VVSUJkaS9rRE1MK1cydmNWRVl6TG1SWkN3U0lzeHhrWWhHSU5pQmNoV0ZtczIrOUdsRWZ1Y2srUTNvb3NhSWVjYkVXWUxiektXTzl0cURXTXpHeFpJMmVMN2s1cUgxdlA1eHlGdkovdTdHaU1adzR5dVMyQThvbFN4WG1DakxHd3MwY2x0N2RlbHFLdTRaWW5RdVZpWjF2RVlBRlYyR25sMUhsUGJhOVFkVm9ZQThVTU1nZkpJdnd1SGlQSUUya0JBczkrMmw2cU5nZ3gyaUh0dWZJd1JJekpreGpXTU9EdngzVnJkcUgrT1BBK0ZoNWNyUXF4aG1rNHBFOWdwUzNWNmpTWHVpODBiS3hwUkMwSXRGamczSTY2RGY1MFNPWEVHRGV2RkNSQ2hWaWh1MTlMbTNLMTdOVVZVWGt5TWw1WW1iSFIxTWIra3hFWUJOM1YyM3NmSHJRYjQyOW9obXhNU0xKZWRCeVdXUGlSSDZaODJqalZtNzZhVlVTeVBiWVdmbEV5QkxzWXVha2tSQTNMTVRxYmQ2WWF6KzN6WWVCa1N4WmNVNXhtdkpndEd3STV0OUw4RzBkVDJvcnI0MmI3dDdYOXZsUW04V2ZJOFRNMXZ0cERxZUhtK2cyMzJvbGMzS3dJc25FZjNMR2trRWtKL2w5TmVQRTcyVTN0YSttbERVOGIzeVJtU0RQaldURGx1SkMvTDF6eFd4VG5xM3c4YWF1TFk4WnhDWHhBMG1ES1Vka21zVEU0T2lxOTcyNkdpTzk3Ym40elF2Qk5DV21STDhWRzNIYzJIU3JFc3J6ZVEvdDVtQ3dqMDNKSW1XV3k4bUp1QkV3MkZ1OVJUOXg5dWovOEFaeHh3cElrZmxVQ1ZDamxRTkNDRFpnM2VnNkk5cyt6eUo1MHkzaXdpb0dUQzQ1dVk3NkFxZGZtTmhWeE5jUE54Mnk4cFFDUFhlUm1qaUxLb1lBYUZXc05iYWExR25Tajl0d2Zjb2tVb1U5emwxRXJMWlE2YWNDbXpjdjdyMFJ5UjlsTEF1RG1oNGNtRnlNZUk2S0pBUnk5Uzl2TGZ0clVhMVJuWTJFbVduR1JWam5SRmtFRE1ZWkNUcnlCdHdOdFNLVkloREMrSG1nQlFoaFlTUmV2Wm81RWJTeWpyZTlGMTB2ZTRQdXMxNFRBWXBoR09jYXlDWkZPNUtTZFYvd0J1dHF0WitXUjhMSXdZbzVrbXZHdHpqdEM0SytxbTRYZXhGeGNIY1ZGUUh0M3VQdTBVdnVSQ2xBQU0yWlZGbTEwZmgzK0ZGNGpQaWd3RWVnOGJjVzRpT1VjYkU2bHVCMy8ybWdpMDdwS0k1RmxoRVhuV2RkUUN6WDEvV2lTT3JtTm5MbXc1bUhseHVKV1JWa1FGUzhwRnhMNlIxOG4wc2FFVWU3ZTZlNFplVWN5VlFtWVR5RXNWL1B4TnVmRnIyMjBxMCtZakhuUjQ4a1VzYzdURndSa3c4aXFTRi9NNmkxaW5MWnROS0pqSjdqa3Rsc01lQjFYRWpMRllYczVpSkdnV1ErWjE2TFVyVVovYko4L0hsOVRGeVBSeUlCNTNPbDliZW1MYU40M3FSYTYvdHZ2bWFySDJ6UHlmL3dCMzVFZ2VYaWdMSzUxREpmOEFiVlRFL2NjYkd4TW1JdzVBa0MzSkJBNUxmWUVYNjFXWnkwUlRRL1pReCtrY3JJbTFVekp5alJEczZ1RHlOdDZpdWQ3WGlaZVFKWUl2VjlOdGNwWXp4QlZkU1RmeTZlTlJ1dDZIRXdweEQ2YlRNL0pKQnlBNHFBRDVRTlRxZFJSRzArM1N4eFF5VFJlbVhVdXlrYXFwTzV2YWhLNWsvd0JsTEhQRWNlVG1paFlnUUxOSVRZbi9BR3I0VkZIc251WXh6TERIak5mUWV1YmtveE5tNGpycDBxeFBxTDV4a1R0TzBjalFpSWNtbGxiaVFMMnVMOWU0RlJaV0xBeTNacERKRTg2S0FpemlRaEl4eTZLZER5NkNoV3JJOW8rMHg1R004ZktlenRERTRZTCs3NGJiME5aM3lreDBYTWlYbnFBWW1CVzJuN3Y3cjcwTVdmOEF1Z2NWb0psZVNRTUh1cHRHUmEvSGtOajJGVXhqeTVtZHBZc2lBeHFxY1lVbUJScmJqVCs2eHRyV1ZTeGZhL1ZiMGNYSU5tVVNJZVBIbTZDN0x5SkdnMnVkNkNDSXNrekRHVDA0VlFuMVdVQXMyOTIxMi8wcXdkdVBDKzZ3aTlnMDhlT1o0bURsU0FUYTRBL0tsWjF4amltRXdMRzZ5dkhaNGxjV0EvZXppOXJpNDI2MGFxeVhLemN1SEx6R3VzbVF3OVhJZXd2elA3VkZ0RGJTMUJYRkprZTNwSGtESk1wY0VLRkJJSzJ0WlNmN0NkcUhiZGo0Q05oTmx5NUNzMHpCQ2o2T0dYekU4ZHdPbFZOU3gzOTFlU2FWeTB5T3l4U1RjZEVzTFdqVVcxQ0RvS0hDNzNIR0dSZ3lQaHM4MkNXRVVlU3k4VTVXMUkzODNjMUNKKzFOZ1lVVVJuZ09UREhZc0FRQkpKYXhzdjFXNzFVcS93Qjd6QS9xTjdjaXdLWTFWb1NwTHVXM2YrMWVQYzFLZlA3Y2pJU0tXWEdqbUt4WGRYTmllRWRoWWxtUDd1V3A2VVZveXBmYW15R2RZekdpRkZWVVBPTHpnOHIzc2J0dU8xRGxaayttUFN4cFlpb2pDOFFRQnhJUExTMzdiZDliMVVidi9lUnpISlpJMVF4c0EwV2dWU0I5T3Q3MkZWTVl2Y1pQY2MrYVYya1k0dnBFUnh3cnhWSXlCZXdZaml2bC9Hb3NVcDZFc2N6UmVySERHbDQ1YlhhUzFoNTMvVzFBc0xFeXBNaFpGazlIMjNuenZxc2J5SUxMWTJKdXRCcE9Sa3daYXhoUktaTEpQTE1BQ0E1dXhCYlZUL3VvWTNmL0FPUzhSSmllMm9JOGRnWVV1YnNWQTNKSTBBMStORXo4cko4MkdDREhhQkZ2RUY1RU1TcGNiTWV2eHY4QUtxWTBSNStQa3hMbFpwYVV2eDVTS0FDb3ZzT21vb2hUelk0ZGhpQkJ6S2gydnk0am9DM2Z3b1kxcStNa2NPUENxdFBCSVdsNTNkT0FOd0VINTYxVVVUZTBOTkEyUUZNZU5KSXBWdENXWTMxSDQweGRuVEpnNU1lSThpY1F2cHNxdGJ5cUNBUUJyMWJiNFVHbjFSSmlCakc4bnFlWVIzSVFQOUlDZ2RCMVkxRFZQdUh0c1gyMEt2a0U4NVNzWUFzU0NBVElDZTdhYTFSWm5aYWUyS2NIMjZSd3JvRXlaRlhaZDJUbWRqYmUyOURDOXNkV2h5VVZZNU1kRVZ4c1I2bW9VY3UxamMrTkN1amk1S1Q0OFIrMnNoakppRWhXNUs2RnpiVFcyZzdWV1hLZVdES2llS1NKUXh1UjNlL2o0VkdsdUpsWDVSaUoyamlCWnlHVmZNdHVPdHQvMW9MNVRrZWxIa0NRckszTllRQUZWYjNMRWdmVXh2MXFERk84ejRjRVo0VEJtR2hBQkJVM1lHMXp5djhBS3FNcU9wZ0xXZUxJZm11VktMTjVYYTNCT2dKdHZiZlNnNlB0eGltSmRJU250WlVBSVdQUG1QcEp2OUp2OHFCZTlTNVF4M2xqa01UdTFwT0lEcUNvOGhBMTgvS29SajlxVEkrd2FBRkdWeXJ0NmVraThkU1Flekg2dTlVclZQaXl5WXNieVNxZUtsNFVzVGNNVDlkL3BORWRTS0NDVEhRbzNvcWltVEttQVVNenFBQXNaK3JRMVVTYk5WeXNFY1k5QkJkVGU1ZHJidXcwTnI3Q2dyYWNMd25maklJckM1SXNDZjIyL2RhZ29sOXp5cGhKRDZYR1paUTBVcStVUjhoMkF2YnRRYS9iZ1NKbWZIVzZ4ajFPUjQ4V2MySmNEcFFjMlNML0FQZXNrRWNobWVheVJPNUtKd1BnTlZBL1NnbmtaVXNjUmxtYjBrNUNKVVFmWHgwLy9MZnRRYW81cEVVWXp4czdjYm84ckVCSXdlWElqcGZvS0MzRDkrek1XSnNMR0lqUmxieUFhdVNMQWs2N2s3VU1aYzNFVTRjY0dNVUpJRFJ3QmJxZVE4eGJzVTcwRlJ4RXhJWW9KbTVla3Q0M1kzNDNOenlOdnB1ZXRGVi9iNStQbXh6NUR4K3BrTGVRdXZPNE55QnJwcUJid0ZCWFA3ZGtGaGtTMnRGNTNEc1NzUWJwZnJ5NkxVTmRmR1dkVk41QVl5ZlQ4eWhybVhSQUw2ODlOdWxWSXBsa3lvNDQ4ZTBhdGN5SzUxZm5ZMlZtMklIVFNnVVdMZ3dlMnd6VEFHd2FWck5abUtIaVEvZ3JhNjBBbUtKdUVjSytuRnhWMEk4cWx5U2R0YkwyRi9HZ2w3aW1QSmt4ZXVYbVl4OFVUUUYydnViNjhiWHVSUVpoSS9xR0RIWVBBcnNzYXlxQmV3NGpYdWVsQjAvYnM1NHNkNFpBSkZkakdZbk55eGpGeTZ1dXc4YXFNK05qNEw1UWUwc2MwcXNZQzVHaUJUeVlIcnIvQUoxRlh3WmtXQmhxWWZQSVU1UlNteXhGWDB1MXYzWDJxb3hQRVlsQ0xrdUpRcGE2RFlFMms1WEJZTjFvRkc3aGg2S0lrVWdQT1IvSURiZmJlaXRtWTgrZDdkQXNjU1JyalNGMm1pWGdISUFLamowVnR2R2dpWWhpeEFrRlhMRjRsdm9DYldXNTM4MzBpaUlTNWd5TXhHRTVqSEpTNG00OGczSCt6Y1dJdWFEbzRQdVphR0ZaNUx6T2hBQjJhTWE2L0hzYUF6c2pIeUlaSEp2RXNkbGZRWEEyVUFkZmowb09WRklWbkx5bm5CRWkyQ29BeFF0NUdLblN3SnRVVmt3WW1qYWFaZlRqeUZhNnlDL0pwT1hLeTI2aHR5S1Fyb3ZqeXg1RVgzSXRHN0JaWlFPVE4xWmlBTHNwUDUxVVpjb0Fwd1dTVXhnbVF4dmF6TGZpVzdYNDBHM0x6SVd4ZlFoajR6cTRZeUErYmpxRjQ3a05hZ3pTNXVQZ1lRa2dBbFFnZjk1YkpvUVdqQUJOeWFFWU1lUlV6ZmNKWTQyeDRXUlpwcCtST2xyaEZ0KzFiM0ZSVzdDWjhyZzhicVZZV0ROSjVlNHRmNFhxcGk1VjlUT2V5QU53dEtDYmc4ajEwMDVkS2kxbnpJOFZzVWxaZUxncXBRTGQ3NzhleDdYcW9tMmJrSjdiSDZoNVJ0eEVnQTBIRFFjcjliYVdvTVBwdys0WWM4eThXazVMNkNOcXhCMFk4dGhiU3MxcU9SRjdCbFdqVEdWSlBRZG1TUmlTZHZvWUVEa3FHN0MyOUYxZmo0TWsrRjl5bVlqWmtVcEdTQXQwZHVnaS90Rmh1ZXRFMWJtWm1ablJORGxSOHB3WTJnbUlSZnBVQWNuc0x0eEh3cWlNOCtQT1JpVFMrcEN5K3BjSXJFUFlpNzN0eHZidlJGYkNRWjhDNHlKOXZJdk1jbUlDczFnREp5c3ZMcXRGYndNSE9kWXNySWVFTktXKzVWUUxyM0lISTZOK05FanBSZTNZL3E0d2swKzJUaTAwZG4wWTZteHRiUTJicFZTdU43MUg5M2x4eHl6RVR1dnBFTllSaFl6WlRyMy9BTHFpeGhobHlKc2lIRVpZMk9HeUxBMlNRM0Z4ZlZ2L0FOWW54b0wvQUdlYjMzSDVDV0NQUGh5dlVWOGM4clJnYTg0bVUrVzM5dldvdkNHZkI3Y1BjNEdHTVJpSVJKTmorcDZUS3BHcFp1amNoeXZWUm1oaGl5b2VFU2NTanl5UlR3eW5rV0ozWnV0anVLRHB6akg5c3hNYjJxSCthWFdhTE9JWlhBWUJsWGdiYWR6ZWtMdTZsN3BpKzhaV0FKWkpra3haRis1eUVWeVAyMjFmVTIwMm9USG5KcEh4dmJvSkVqUTQrUklabmpEWGt1djBvVHNMTHJwdlVhZFgzRE9tZkNKNU5BTEI1OGE1Q3Vvc1l3bW5FOGI3YjJxVWkyYjdHR05NMzI0ZmJjb1J6am1jTVpaTGhlU2tEVHpkL2pWU3N1YXZ1TFMvK3ZhUm84ZDQxazl4MTVEVUR6QkJwNWIvQUJwU0xmYWNmSTk0bWk5czl6bENSeGlRdFBKZmxHRitnTTVQbVE2V05DOExtaGl3dlZnRWltU2EzbDQzNU5IcHFiNkMzVWIweFpXQm9Zc2pOOVNFRENWNFpCSkE3Rlk1QUZKdkhKYnZzTjZnbDdWbURKeFZNa0RTeHF3a2hqYS9wSWUvbTFQS3FYaHVRU1pVa1VSSmtLR1NTSXRiaHhPa2wrbkZUc0tZbXRrdUhJNnRIUEQ2WmxSVmdtY2xsVkVHd1BRQ2d3eSt6NGVWUExoSUNYaWtVU3FSeUJMYThsazFGcjY2MVVkS1RCbSt4VXFoa1ZPUjVzM01qMC9MeTR0MjdqcFFZRnpaSThneFkyT0pwRER6VlZYaGEzMUUvd0Q5VlJhcU9OalpHTWp2S1RMT3hNamJBQUR6QldKMzhLREZKN1RMaXdSbWFaaER6YU5RM2tLckwrNjQ4MWlQbFJaWE45MW05cXhjcENmVWxLcDZQQkdDM1ZENVpGNlcrTlNrbGMrYU5VeVZseDVtRUJVdWdaN01BaDVOelJyQzQwUEg4S0xIWjlxenZaOGVDUi9jR2FRU1dSNTR6ZHViZ2tNeDI4MjFqclZac3ZqTGpRU3c1c0dTVTRZbkxqZExsSFFIUjJ0MDQ2YWExR3E5Vkg3aGpaR0h5amhNUHBUTUVTTWNtOU1EVldjOUJmZTE2MXJHRExXTEs5dmlTTkZpbFNSaE1FVUFUQVdLS0QxVTMwNWRhaXhESWlQdDRoUWxZOGg1RnZrRlJ4NHJZMjExdXV4cWpreVRtTFBsOXl4cFFYV1J6TmptMTBEYkMzYiswWG9qczR1WGhaTFpDUGRzdDFRd3hSK1VGZ0xrOExucWJXcXBtSXlaRWNXZWlLVys1Z0Mra0dKTEcvMUh4STZVSXRYTnpKSm1lZVJwMmR2NFpWWGk1MHNMeGJFRHhvZjR4cnl4NVREOW9xNDdrZXJQWm1WaUJjdHhQWHJiOEtpdXlIOXFuUk1ETVJvNTFMQndnNWdMYnlPbkh0dmE5RTVjQ2FUSU0wMFNxN0pBQXJMRTNBRFpESXQvKzVjWDVVVlhrWmFKaDRyWVplWlZrS2VxeWl5aHZvR2d2ejA2NlVGeHdSLzY5WjVabzRSSkt5ckV5a3RkUmRtVUw4Yk1Qd29PVW1ISXNpbUIxa2tNZ2JFbWlKQVFnN0FuWWpvRFV4ZGRURk9kaDVnejU1bGZLeFZIcXFDR3U5L0tKZWhMWHFvbzkweVd5SUlaMTlKM2RtTHVoSEpXdnp0YnRRYmNISFgyeDF5TWhTMzNLaDR5amNndHZxNVgzVTdBVVYyOGpEeHZjWldsNEFxcWdLNkt5cXB0Y0JsUG0rZEdkY2ZJZ3gzbk1PUUhlS01oVUpzd0pVK1cyMTcwYVU1alF0UE1yTXpNZ1VRNUlCRExiVGpicU9sRWdoOTJ5TWJHWlZKYVpqYkl4N0RoNmRyZVhsZXpFVkJkakpqNUI0UjRTeFN5Z3JKR0NRamNocHB2b0twV1dMMmFVT0k0bVpaNHl3aFliRGdMOFZ0cmY5YWk2b215ZmVjN0xEWlhGczJGci9jSzNsY2NiQUlxanJ0cFZNV3d5ZTFQQkpEN2lrMEVrTnZ0NVZ0SXNjaE5pRzZoRDRWQkJnY2pESmJJamJGamtDeUlEY3MyeTJRNkVkUGhReE9UTnlYeG84TlVVUW03U2xiOEZmWVhIUVc4TGlobXVjTUgwVzU1QWxrampCa2NINmpwcHhQZ2FMcVdETDdsbExKQ3N3YjFtVU04bCtKdG9xa2pWYUdMTTdMeklKbGlkbml5WVVhSklGSkRvTDZvcmpmbjBOQ09jSjgvRmxNR2ZISkdteGlZQzR2cUFialRwcUtpdTFuNXo1UzR3OVZnWUkxajVGV0hCQUxpdzE2bnBWWmtaOC8zSEtReFBNN1NoTGMxWWJvZFY1RWZ0WTAxY1lzWjhkY2tUSEVmekVsbFg5cjMwQ2szdU5ibW9PaVo1M3dZNDN5RXgwUm1lT1kzQkJHcXB5SFMrM2pWR0tES2h5cGxHZktyVHptd3ltVnBpYms4bUlHdnhxS3NXWmNISmlnOXdqUnNPTm1saWFNQmpZaXdDdVFDUS9ZN1ZVZFQzTjF5R3hjcUNCVVJEYlVCaXgzc1l6ZFFRdWh0cFJJODVOa3h5ZTRHQ1V0eFJpT1lIQThiM0FVTG9PeEZScWRPdjdjSjhlQXlNL3BDTmI0OFRvR1dSeWRGWmJiK05FVG5NVFF6NU1zOG9sbXVyeHdoUWpoaGZiUzFqMHFvNWFZZUxMRWtjNi95WEI5UlczQUZ6YzlEK2xSclRqOXF5MmtWMGtaL1ZISitaQTVBYWVYbG8ybEJvKzFqeVpjVkpaSTRRaXQ2ZVJLV1JBVkdrWXY5UEdpTkh0dVhoZmR4WStYRHlNVnVUQTNCUkFkWTVQanJZNlZTdEdka2Y4ZXlzV1RMeFpKWXZjWFVqMHBGSEhtZjNCcmR0YUp6MDg5UGg0eFRoRlB6WWNUUEd5MmtZZ1h1aWo2bDhhalNvQ01vRll0SHlZdkhHdXFtdzBJYnYzRkIxSS9kc280NHhwY1NPWVNFRlBMeGxaTkFWNURvYlVNU2pqd011ZWFhT1RsRnhQcFF6OGZWRFcwSGlLSXFta0hxSEVrNW8xZ21QaXQ1UWtzaEZ3akE2ZkhyVk8zV2FiSHdjZENZQzhzcU9TRzBSUDdTTGZVZkNzdE9malJLc25KWUNNcVN4VUhWdEJxQmZZbWc3UjkveGZOOTdFSjVJNHVNQ0VFOFpEb1RJU2RsNlUwa2N5WDNlT0NKb01Uenc2K3JLeUFNekR4YlZSclJjYThmRWVmMG5lUlVsZFI2c2hJUVJpMnpEWVhHMUdkWnMxVWtJaFpoeFFFQUFXRnJiL0U5NkxHYjdGeE5GQ3NZbDUrZjBoY2xpZEJ5dHNhRFMwZU1zZ2duVm9aV0J1QUxvdHRsOGJXcUs2WHVudVB0alFZZU1xc01mSFhqTEp4WG5MS1JlNzM2YlVxU09YUDdkN2ZrU3gvYXUwa2s1TE5CQVY1c0ZPb1JEb3RsRitWNkxyblludW1RdVJOeUNaT0k3TEgvQURBeVNjUzFnTC9WOGJVMWJIUjkwU0RIUVNlajVnQWtVRUp1dmM4ZzEyNDk2SkdSWTVaMFl2R1k0cFhzN0FhZ2FIaXZ5cWpxdysyTExQa2lOaUZJSWpqSElFQUN3QTY4YlVUV2RjVm9KNHIzR1BjdUhrS281NERVNlhKVysxcWkxandzVDIyU1hpN2V0TEsvMERrZVJCdllEWFQ0VU5XNXE0MlU3dEtpeFJ3SURFRmF6cVNlNUd0dXRDUm5SNGpsNDJWNlFrTmd3aURCM2YwL3Fra0hUa2Z4b09uN3htU3pZc0o5WGdNa1hZUktxMkY3UFlqWW5hcW56R1hJeUpSSkJIand1WTBqSDIwWVlEaXpHM3FGRjMyMUJvcTdMaXlCbkRNbnh3V3NJeVZiaFo5cmtyY0FhWHNOcUpPbW5GOTE1KzJpR1NHS2FPVmlvYVI3dUZRZVVXWDZkZGlkVzYwcG5LT1JpNG1PQ3BaWldRQlVrWGtDZVl0WlF1bkVIOGFHdWZIalNJN1R5cjY4c2tuOFVibmliS0xjUW5YV291ckp2dnNySVRIZDFDeFJzWlplQlBEb052M0U2S2U5Vk9HejJ2MkRJeFZYTGxCa1ZpRmdnMHNTRGM4K3V1OTZHcmZ1TUZKV0RrODVGWlRBUE0wajMwNWcyQ3IyTklsWjQvYXNoSVk0NTVJMTV5a2F0NWdOQzdjcjJVVzB2UmRSaVhNWExPVkJJc0NRM2JGaUdrUU93OGh1RGZ2UVVHZkFoOXhCeVdueUp5YnprTjU3RmJzR05qYXpidCtGQjBNTDJXS2FIMTJtT004d2tONU9RQVFBSHlrRFRsMHBpV3BKN2JucEQ5eWtZandMbU5DZENTQjB2cVNmaFZIU3hQWjJKR014OUVBV0NKWjdzUmMrRzI5WEUxVExHdUhJQkM0WUJ4RXNvRjFBdjUyYTE5ZGVsUlFzV1NjdHNmSG1MSXJuMXBsRExkVy9keVBUd3FvMGU2KzVXamg5dmhaNTJDUDZaUVdBMDNBSFM5S2tjekRKaTlTUThjaGdRc3hZM1FGamE2Zy9VZUkzcUs5SDdiTWtxbUtISWZHeHd2RkM2OHJMSU5kQmZROUtwV0NkRlVPaStxckM1R1JZQUtBT0l0Zlc5OTZnaFBMSW1NSWpDSkhWQmFLU3hjYVdZM0gxZUI3YjFVWGUxeHBGTU1hZFJIaW1QMUNpK1ZXNDIxdWRYWFg4YVFySmt6UlJ0TkhCS0hFdDR5d3NVU085enhCNitJb3JUN2FoNFBIR1FZVkhCMnNBd0RIUnlUc2ZoMG9pK0wyOVpVKzRLTzdUekNNSkh1ZUFBNUZDTkNkN25TZ003aEZCSTVkWlNwYUsyaFkyTmxlVGpweVg4NkVZSVpzckg5WElNZ1JvazRHZmdBckJ6WXRlMWhwb1B5cUt6elFZOEdORDZVUmdsQTVIbVEzcStZbmtvM0FWaHRRYm9FNVFFeXNyeU9VNHpBOGRXYTV0L2NiN2RxcVd1dU1USG54cE1KWXpHZVBLSXZvR2I5dGlMZzY2MVUvYkJqWWVOaFJzR0RCVktob2haZVp2cTJtL202VkY3WTgzS255V2NEK0gxR0t4aXcwRjdFV09tKzVvTnpaVHdZOE1FZ1NiMGh5bEFYaTY4U0NUNm5mcFZHZFRtUjVrc3JFREVVZXRHRkk0cXQvS05QR2lOc09ONmtYcnNmdUZqVGxFd1VSb3J0OVRHL1kvdTZtZ2NVdm9TeXRtSTArUTBhcWhWZ3JJVkg4YnR0c08rdHFJeHg0dVhrS1ZqWkl3UWVUVHRibXgwSUJ2ZGdOcU5MZnNaTVhKaldXeHk0eXZHY25RZzZzUUYwUFlVUmY5ampGblNTZitXRUNTQU5KNUNXQkM4UnFmOGExVTBzbkdJNFR4a3luSlFoVEx4dlpqWmlmaHN0Uldsb01UR3hFandtNXl5amc3TUxjU0RjaGlkbXZ0UVljVEk5YU1aRE5MOXhDeFZRQmR6eEZsWFRRZ2swRzdBd1JQa0JQZGJ6UXF6S1VqYTNLVUFBZ25zTDB3MW45MHdtUmtDci80MGJzTHMzTGxZMkFJQkhTd3ZRakljdG9zY0xLbnBlb3hrUXF4Q3RJYmhMZzMralhqUVJ5emxxVXljZy8rdlNWbmtoaklabzBDQWNUeDN1NUgxZk9oR0RFeU01Wmx5TXVZV2tadlF2WThsVDl4QUo4eHZSY1pzdk1ra2tNTElWZVI3cktHS1JnZzJPcDBZZjNhVU1kbkNKYjI2SVNCV3d3Nm1USFV0Y2RwSFlIdnRWWmFzbkZ3K0JtaldhU1ptc09iY2hHdkczSmJkUEFWRjFUN2FmYWZzL3RjaFhsbllzRVp5QTVHd0FXK2x1OUJKWjRZNTNnc3ZOVkk5ZHRFVUpvQUFlbHpRQ3k1dVFWU1owSklNV0xGR3B1VlUyWlFkZkxRU2xna3gzRWVUZUdFaGduRzJvVlI5SS90REhlcWlVRXl3TlBOTUF6WlNsWWI4Z0Y1aXpPV0F0dFFaQ2tyUGtTZXBITEZHNldtVnUzN2JiSCtsQjBKc3ZEeUhXV0gxRklIQmt2NWdlUGtBVURiWHB2UVpCbHRKanJETEVQdm9QVUFtazFWK0ZnTmI2ZHZDZ3FUSWFERGtuYUZKSHlHSktOZGlHWWpWYldQVHZwUWJnM25qelpvMmJHYitKSXpZSUwyMHV1dEJMUGh4ZU1qd21LUEdDaVQ3WjJZTGNHeWtKdmZsMjZWRlFpek16aUZuVWVxT0lXWVdXNlMySjM4dmx0NWFDQ3d0RmYwZzVFTnh3dHhMQUc3SGlQcDQzdWJVR3dlNlpJblpseGZWaUhPUGdRd3NxcjlkenFndWVScW96NG50aitoNmtVcGt5R3NZVWpzNEVWdk41VHRZNzNvYTB4NG1FY2VaNUU0eXhNb0tJM0ZwUFYwSEFnZEQwb09ibXg0ejQvcHdUSEZiR1oybHgzakYxMElhNUYrVngrZFNySExteHNJWU1iSE1FMzNLZWtGaHZ3QmEzRWVhMy8ySFRXb3JvWUdVczJKa2VqRTRmQS9qV1hqY2tBQ3hZZjJpckVxOUh5RVNSZ25xck1CR3BqYmlYSzZrazducHJWU0lvcVlSTFNJSnhLdnBubXBLQWs2OFJmY0EwR3lSb0pNT0V4TGZNVWtMYytRQnZMcmZyMDFvT0J3eHNFenh6UzJSWnVVU3RZY1NRT2R5YmFLYjhhaXhiNitWL0ovNjJSMmhFb0tBYXQ2dHRUZHJHMWoxcUt3bWVQRzl4Qjl1WXMzdUNnU1FzRFlTZzNzZWUvRDl4RzlVLzEwUGZna01Kd3AxY2hJMGVRRFRpWEhsOHV1OXQ2Vkk1T1o3Y0lNV05neUNTSjJETUVKNXR4NXFybHZxRnRkS2l1cmpyajVnYUZKSTVzbUZlWGxOZ3pXNVB2dUVWYjFVcXpJbHhtdzhhVjNBZVNNSGEzbExIUUFkaUtJdm55MlJSQTdDYVZKQklMQUVsbVcycC90cHBqeitjMlJMSmFZaFpGY2VtRDVsVmI2cTNVQS9nS05KNWF0alJZM0JSTGp0S29pOVFBbmlUWjFERHB6NjBPMDNESk5KSkg2djJqRXhTY1hzWXBWRjE1TU9nRk5SaXlJbzhxV1NlR1UzQVVZelNYUFBqdHAyYTUzMHFWWXJ4OGJMT0F5ckFZRlZDVm1Xek01WThyeUlkZ1FEZTIxRnhmN1hpWnN3TTg3TmpaSHBjY0tBZzhKWUNiRDBRZVhFOWFKWFVueUpGd1JBVUs1QktjSlNBZUt2b3lzblU5UldtV2VTUEJFQmd5WVVsbDVjMmxVRUNUZzJoVW0yLzB0NDFGVTVudXpTWStQakJmU2FPVWhpemdyR3JMeFZJMmE0WGxiem5wMHFMR0tPV0tPSEdNaW5OWWhoTGpnSGpDRy9lVzdNZTJ0UlhvdmJzZkFseDJraEhMTmxqZDhYSERoK1BIUnVaRnJFL1VLMHhYbjhiM0dOekJESzZwR1hhS3pHMWxKSG1SeDVySHFHMnFhMWpxVFltTUdiSDl4UEQzR0JDeDRYTERYeVg2YmErTkRmWTVnenNaY2RselE2SXFoYmdYVkF6ZlhjWDNOUnBwekhoVGhqNGN5eTRjaU02eFJEeThndHZWMDFCU3F6Tjlac1BJaWx5NGNnRHpvREhreXhrcXBWUlluMDl3YmJtcVBaVGU2KzF2N0tsbkN6QlIvQ3dzYk52dDNGR2N1dkw1V1Zqd3FFalM4RXR3Z1FrTVIzZGllbjUxRzhkTDIvd0Q1UVJpckN1RXN4WitDekVrUHFMT0x0NWVOcUpZdjl2d216OFBJL21Na1VaYStNdGd3VTZXV1Mydkg4S3NTOE9CN25JeTRTd2JaRFNmK1JIb1U5TmRudWRqUTlUOTd5Y3JJd2hpK3E4TDR0akZHNi90YTFnYjNOaXVvQm9STEY5akh1S3h6cEQvQkVnRGNWNWNTTmJOcHlzYmExRnR4emZlTVFaanhwRWtBeU15NVdXTUJWL2hQN1UxNHMvNWlsaDgxUjdKN1Y5eEpMQkxJa2FxWW9SeE51SkJ1cjYvVnIxNlZGdGF6Z0QyLzNiTTlxUW1WVi84QXc0MzVyeUF1R2picU43MVUzVytLUDI1R2h6Y1ZKWUl3cGp5NGVYTlJKc0dYcVZQWTBHN0w5eG5TVDA0bU1xTEhhT0lqallzQVMxaHRhMmxYRVJneUltaW1kb3preVJnRUtUWlNXSG11cmRqcTF0NkRtRGkwTFRreExDSDV2a0t2Smd1d1J2OEFaZmE5QlJJaVljc1VtSjZpVGp6Q01lV1FmLzNHWWpWZGRLaXRjY0h1aXo0ODArT0dFbC9Vbkk1SGtSWlpGRncxdTFWSFR6ZlpIZ2preWtsSUlBakNpL0ZsSzJZcDFESGE5VWNqL3dCSTc0YkpMbEdMSWpibUlKT1JKakF2ZFNOSDA2RFdvYTBRWURQZ1E1Q3lER0FVQ0NBNk02N095bFRjTnAxb0JDL3FpY3V6c1N5WTBZQkpRRWRWdFpyZGU5QnM5c0dHaVRZc3ZQN2hnYndPT0JXVzNsLzJzRHNSdlFZOGZMWEV5TFN4cktzcWhHbGU1RnhjZ1hOK052Q2hlUmpDR0JVeWNhUkg5YVVya1lURzVVa2dndmYvQVBEYnBhZzBKa2UyeVorWEJpNDRacGxrNEsvbVdQczZ0cG9POUJ6L0FQMStaSGpqQ2tnV09hWlFKREdMdk1RMTFJWVgwSGhRTEh3blFNMEFpRms5UDBKeVFWWlRacklkMlBTZzY4UHVHTW1Nb09SS3VTbjhjOEpGN0l1bHhiNnRkcXFNSXlKdnVXUVpBa2psOHhiKzYreldPeEhhb3JUSENnajlYSjg4VHR6ZHRDMTFIbFU2MEZQdXBta2FISWxLbVZnSERKNVFCcFlHL3dCUThhQ1B0cytURk5PMGN0OGgydE5DQjVsQytaZUxIU3g3aWhUazk0eEx4dVNZNVhrQ0tBYkZXR2pQY0hWZGRSUWtaOHpIWDd4bTl2MGtnbDU0MHFPUXBHNXNEcmJTNC9Db3NYcm5IRnhwWXZjSWhLdVQvS1dieTJibzBaWFZkOXRqVlI1MWlRWTJuaFpNZWR5QklMcVJyYmlRT3gxTlpiZEhId01yTHpHOUNmMTRmTThjbHdnY3JvT1R0YmNuclZSZm1TNWNUakVtVVJTRWNBd0Z1VEN4TWQyNjYwVEd2QndZMW1qU0oyaG1WL081MllnYmc3V0h3cWlyM0wyMFJReUE4NThoaVJGT1R5QU43K1czOTNqdFNrcWxjSENlSVF5NURuTForTFlzZ3ZiYnpoaVQ1ZTRxSzZ5ZjhjNDQvclJ5K2NYODkrbHJlVy9oVnhuZVhtc3VISXhsRFBIeUt1UzVKMEtrNkMzUWQ2bGFqb2V5WnNVTTVnekl2U3dwUVlpWkJzNTEwWmYzTDBvV2NMODVBbVE4RS9HWEhjcmQ5Q0NHRndUYmE5Q09aa2UxcDdVeVp1T2pCRllpU1JpSkU1SFZUR284MjI5UmRTamtiSXhvZ1hWL1RScElvMk4vdHhmazF1WDdUVlp4MFhYR3g4R0hHdkVQWEFaTW4xQzltQXU2NmZRb091bXQ2REtmYlVESmlaYnJqZTR5QWVsSkxmMCtCRnhjanQvMW9hamg1M3VHUEsvcEhsRWc5Rnl3NWpuNDhyZzN0cFJjYnNlYjIyWStsTEh3bE52U2E5bHZ1MXhSR2hNSDI5b3BmWFZuaGRiUlNSRUFodDdNQ05xRjFnOUdmajlxOGpSY1Q1YnJ5VVc2NmEvaFFjak55TW1DTDBKWkduaGNOZENMTHFMRUFINENvMWlQc21QRVFTVlNaSXc2c2ZVNEM1Vy9PeHNiS09nM3BDdGo0V0ZpNDNxK2VTZU1BT0g0dEZadEZZYStiVHBWU3N2dGk0SzVUTVhhTzJpNUJKNWdEci90L3dEaUtpMnVyZyt3NFV1UVlYeUdiR0llUXp4QVMrbUFOM1VXTmoxdHRURS9yaFFudURZL0tBQ0NHRlZab0RNdnF0dzFIcGpyNWpxT29waTZyOXRud2ZUNXo0VExQZmtKd1BLRmJkU2ZBRFNpV0x2ZkQ3WmtRWTArRzdJdHhFN3V2SUlTZE5ScnRWOFNkbDk0anExK0t4ci9BTnRHTitQamZxYXk2WTBveTVHSXJaRXY4MEtsRVd5OG1BMVVJRi8vQUlqUkhGeVh4cDJkNE9SaVN5NUU4bWhEQTl4MHFWWE95OGxXRFJ3a3lLV3VySFRYd0I2L0dvcXpDazl3UnpJN0diR2hzMGc1WFhtMmdMSHdQYXFXTnNYdWtraFVHTVBJSDVGVzFCdDM4S3FZN1hzMlNFeXkzcE84ak5aSWxzaFpyY2hwcWJVaVZQS3ljeWZJazlTWkVSU1ZLS29ZZ045WVVXMDIzcURqeVJ6eHlqMDBERnZNSTM4NnRmYjFOYWpUUmpTcE9qeTVERkpyQ0dCU3ZsZDdXNGdweDQvQW0ydXRWSE93OHNqSkttQVNPdGh4K3BiZ2FxcEdubG9yb1pMWXpyNjEzSjRiSmUyL1FxTDJYcjMycWFqVC93QVlrZEhrbGRQWFRIQmFVc1NZeHkySkkyclVTdFAvQUxXZUU1RDVHUUV5SkFESEZHT2JOeVBsVFRXNTdVMHh6OG4zdWJua1M1NmMrYThCQ2JDenFCWmI2a0t2VUNsV2ZMRGlUNUx1WEUzcDVBQllGZkt3UW5WUnBiWHZVV2tlZVRHWTJCeUpsakxDVG5ZcFlpNGJZV0M5TjcxQjBzRE9FR2JrUll3aGkrNWlDVFNSb0dGaFkrbEdTZE52TnJWU3hkN3JOaTQzdDdZdVEzODJRL09FcXBUaVEyaGEyK20zNFZVam1ZL3QyYjlwL3dDemRKSmNaYndKTzVDRzk3a20yb3NkcUx2amJHODJYaUw2aGN4aEdYMFQvRkdUKzJRTWZydlJFVGpaTWMwY09KbHhlc3k4UmpyWU1yMjh6RzFnalcwRkNWVy91czRSdlRoamhqQ0craGF6V3NXUWpYZlVWR3NaOGZNZkVuWEt5TVlySTVVQ3hJNDJGN3F4NWF1ZFRlaVZyOXBuejgzSngwekp4RGpoejZxc2VSVWp6Y20wMk93MTBxeEwxd2syY3VTc2tza2dZdnkrM1FGaklRRFpTRVVmaWFHSnZCbGUxT1hueDB5cFFWa0N5Y3VCRml2bWJ5K1U5dHpRN1dDYjI0dU9FTGgxaUJkZUJZK29UZXlLRDVnTk42Q2lIM2RKUUVreHVja1JhT0pSb2daOWJrYnNWMTMwb1l2OWVNelNQaUFGSm5TTUJGNVNXUUFXMTZYMXNhRHB6UzVLeUhIU1UrVUJaa0labUJBdXdJdDlOenA0MDFFY1laR1pNcTVVM0lrS3VKQ3AwUWVOdHRLcTQ2YlFwak0wQlpRaWp5aU1sZ1N1OTIvV3F3eVpFbVBEa0syUEdKQVNDM1BVQlJ2Wk50TjcxRldTNXZ0OWhONmpvaTJTUVBjbCtvWUtMV1ZqUVpGa2lHT2NoWTVKTXh3U3JCdlQ4blFMcGV3L09xQVJ4NUVIcHp5S0kyUzdEaDVpUWZwUFg0SGExRWFra21qamppV1F4QUM0SWIwN2s3TU9wc1BsUlJIOTNuTmtxMG5PSjcrckl6QmpaamE2dTJ6TVJ2UVkvZG5PS3hoK3RzVjdjNHhabGV3Q1JGQ2JIWHRTa1N4OGwzbWl5YzVXR0xHcVJTeGwvVFlzdll0Y2k1TzFFWjVWeWxNa0tyeE1ta2lLRG9BeElJNmZLb3JvNEVCaldWOG4xRWo0Z3ZEYmt4Wmg1U05kajF2VkYrRDdzc1FhRjFaWjRWdkV2cWFMcmNsdTVwRXBlNVpEUXlZNnpTTkhKbWVhU1FxQWxocU9JWHJ4M3ZTa1N5c2ZFeWNQSWhTWXl1aFZJZ3JlVXNQTUkwWGE0QkxHbFhXSmZiMFpZMVdSbWhVazgyUE1xRjA0cjEzcVVpdkNFK1d6OHdWZ2oxUU05bTRydVVJSGw1ZmxWR24yL0l5RGtScmk1SEpHWXJIQ3hKNFdQL2JITHFSclNGZWh5MXlmY29raWl4bWh5MDh2cThmNGlkN3FiYlczTlZtT0Q5eGlTZTRnWkY0Z2lFK3FmKzByQWE4ZEwySkh4cUtuRmxHZE1sd2pUWkRzbkNZbGY0MWJjMnZ1U2JBYW1ncWdRWThDWTZoREk0TFNrc29RRzlsTGczNmFucUtvNmNXUXM4THFnKzJJQ2hsWnJLRnQ1UmI2aVNkYUl6NDhlTXVURGs1MGhaWGtacElnTjFBNGd0eXYwMG9KWm5wdGt0UENGaFJTQ21PMzFJbHJYQi9aZTlqVVZ1d1BmY2Q4Zkd4NDRVbXkyUnY1RVVxVUd3YmlkOU8xVkdXUDI5c2lTZE1SMk1zUytuS0dDQlZCL1BlZ3pTZXZJRVZMQXh4dUVQSzZBWHRjciszWTBVLy9BR0VqQ0dIbnpaUCt5eUxxV0pzM3FzZE9OOUJRV2w4aUtiS0M4QjZMQlY5THlLWEFGMlVIYWlLWWNwQkplZUVPeUJ4Y2txcWpYaVh0b1h1YjI2aWdqeXlKWWJSVEljVUgwM2lhNEE0amZiclFTZEVQMnhhTm83QlZlVnVObVlnZ1dVRHk3MnZSRlUrYzB6Y01oNDNTS05oNlFVeVdSZGdoTzk5cm1pNG93TW94ZmRReng4Sk1hRmpjOFhWeElCYUlNUDNyb0w3VUhQeHBKSDlKSGtVZXV6Y1lVdWIyRjNETnNDZjl0RmVneGNxUERiTWVaRlRCS2p5c2pGdUtqUUZQL2w5TkdXSi9jSjh6SlF4S1lvSCttTkxrb2x0YlgvYWxxYXVJL2VQOXdNN0lpUkFrZ1VPcHNiY2RHMStwU05malJXMzI3aG01YWM0Q1pNcVJpck1RdHdnc28xMEt0MW9rV1pnaVNaVWlrVXpSdXdoaHg3a0szOW9PNDQwQkg3aGlZL01URDFNcG9sUlltQll2enZ5QVk2SVZvaTJRTmtZYUdNU0NFeE53UWtLejJQbUxIb3VtbFVaY0tYRml3RXhKSjRrOVIybG1CUDFJUCszR3gwMDBPMjlCMm9jekNqaFJzRXRnWkp0eWVOVlpTMXkxbTVYSXNMQUNockpMa1pXU3pHVm9KQkVRTE9CNmpIOTdJVTdrNjBFSS9iWldQbGo4OEQveG5mMUEvd0M3dzJvUk9PTnBNWjBtdWtrY2w4aTJwS24rMVJwcFFqblpveFZqeDNoSHFTQ1V4enRxV1NYb0d2OEFVaFhVZU5SWTFRWWI1Y2NpRWNmUVRsemtJNEUzOHFqc1RSYWttT2l5R0thMDJRcWhZV0RFcUZHcHVTUmMwUm1obGw5T1JtbHVHL2tLMzh6TTI3RzI0STAxb09saFpHR1lBSWlVaFllbUF1aGRUdUdKMkY2c0t4cE04Y0xZMGVza0VuSU93NGdBaXk4VzdXMHFJamxTNHMwa0VRalNOM0k4MXp4WWFseS9MVFRhcXFDeVFZRUk5YUtQSWpjSGtZUXJDTU5ZZ0t0bTg2azN2MjBxQWl6SWNiSHlna3ZCNVdDWTQxSHEzT29KSXRyeTIvYlFxeEJtWUtKa3lQOEF3eFdWcEI1dWRqWW9nNjJhOVZEOXdtbG04a1BMMVptU1dPY2ppcVB1YkFYMEEvT2dzeUpNV2VPUklvbVhJMGt4K09scEFMTkpjM3Z5MW9NMmJEZ2U0WW4vQUs1WkVNenE4OGpTRmJLZjlyajlLaXh4SWNtS0dhWjR3enZJaGk5U0orUjhxNnV5Ny9Hb3BmOEFzMGx5SXAyeDBqOU0zZ0FZcVFXWHpSamx1ZENiK05BOG1OYlJ5SElsaHpZZ0pGc1M4aks3VzRQcCsxZHIxUS9kdmVFekdpYUNNUlN4OFlwNFFSL0pJUUFIVzIxMTB0VUZhWTh6NFdUQ0lFeFVaVmNQR1N6Y2x1Q3BZNnFHQXZiYWdweHZjWXNUMThkc2RwSlFPY0R6a29ZeWJHNklOd2UxWFV4dTlyekZuU1BIa2orMG1aaEFjbVN3anVvSnZJcHVWN2c3VVZqOXh4Wmt6a2hpaVlaa0NNSkZhMFlaQUM2eU10emNNdXQ2Z3daRTJWbnhZemdJbUc1VVNJR1lMeVBrRmhiZjl4dHBSV2xaTTZHU2ZEaWxIcXFCQkk1UVJxSmZwREwxTFdGcjlhSmVXcjJSVWxnbWd1clpFY2lzMDZncTlyWElMSHlxTGdYMHRmWTFVclQ5MGNuM0RJZkZaSVdsSUFia0NSR1ZGNCtRME92WmFGV2U1WTd5Wk13UXNxVGhCSEtMRXhOeXU2cXFIVFRRQVVHVDdJZXBMaVpLMnl1TFBqT0FRV0krbm1CdmZZZHFCeiszNEhDQlhlZHNJaC9WUWk3alM1S0U2RHpYdnJyUWpObFluczdZY0VEZWRNYTRLT3hqZHcvbThwSXRZVkY5VVpPS1lQZDRzakdobE1CQ3llb1RvZzJOeWVxOU9WTUhkOXo5a0FWU09XUFBGR3BUaVFRM0kySElqb1EzU3JpU3N6ZXd3cDVzNVF1ZXplclpBak80UnVOeXV3VHVCVEQrbG1UalI1SHUvQ0tYbEt5bDQvVlU4ZlNWZVJ0Y2pUUzNlb2J3NStWbFlheUw5NWdndk5KOXUvcHN2cERodVJiWmhlK3U5R3B5MlRSd2UzNVR5TEcwb1ZnRmxsSEVrUDhBdVhpTk9QVVVzVDVyVjdiaHpQZ21ZeElwazV1a3FxT1FPdmwwK28rSm9Xc0F5SXNlSmNwVSs0Vmp6WnBQTXl2MVVOMDVlTkZ4Q2NKalRtYVNBb0psWm95d3R4Qk51QlU5aWJBMUZiTWYvd0JmTjdZTWZPamxqQU5rZ2hzd3NOOXV0dFJWVFZ1TG40c3N1R21BQ3VMSXhpeCtiV2RpbWpjL0h0eTAycEVzWWo3eEkyU3VDbUdzMlJpOHp4a1hsNndVM1lTQWZ1Q2FlWFR0VlN4d3ZkaG41YkpQQXhpd3BIbGx4QnFWTGtBdENyMnZ0OVBMYXBXcGpSamY4d2x4ZmJKOGZFVjRwcEVYN29sN09yalFoUDhBYWZHcEtYNTF6WTg0eTVzWWxpWEhnWlZjUEV4WGt5ZnUxdUM3QzRIUzlGVGQ4WEl6QkhDSkk4YVpPRWZ1RXc5TlZaZFFzaWk2MzZWZFRPR25GTTZTcmpaTVpab3ZLa3Nac0gxdXlHZzd1WmdKRGpRU1lrMXNmSzVoRGNGZ3lXTEk0NmE3WG9pbkRsOTRUMXM2RmY1TVpHZVZnUW9aRzhwREtldERqMXN4Wk1PVDI0Wm5xU0xNSEp5SWxCSVhia3pNZTRwQ3VmbXhDQnNsY2ZIOUxGeVl5NGlSaElHSklzcGtJMXZ2eHFvTU5XaTlRNVV6SkZHbk9Ja0QrTFlCVkIvWjNGRld4K3JBVGt5WktScUVFZ0RYMVpUL0FCaTM3QSt3RkVlendQY3Zic3IyOVV5RkVjMXJGaURZWEd0Vmg1dlB4eW51YnRqU3BGNkg4VWN6c2JOeTJLdnRVcmNZa2dqa2xSY2lWbEhNOG5Da3F1bG5hNmk5cmp5L0dnZVdjbkhqZkJMRitIR1NESVhSbEJGbGZRWE5sT3BvTWFRczc4VEpHRlJOY2drZ2p2SmM3bWcyTjc5N2NaSTBmQzlabVlOTkx5QWVTeTJKVCswZUhXZ1dYaTQ4QmtFTWF1TXNpV0Y1TlpCMFBZQWRDS0NiNGF0aHhadjNUUTVzWjRLa2RoSkhwNVRjYnJiZTlCUmxZV2I3VEpqUG1JWmNXUXJLanF4VnZUWStZaGh0cnJRakxsaktoOTNYSWlQM0xPeFlNN0NWdUpHZ2NpdzFwU1ZJSWszSlpGQ1phbGc1T2prL1VWdURvQnVEUWFraE1VRWd5bll2a1dhQWlNRlc0RzFuMktYNmRPOUJXelNRNFlBUVNBa3ZNZ0lML3dBWjBOajAxdnBRQ2UwNVR3QThoSUpVTThFUEljdUpOanBmYndxS3ZiUGxiSC85WkZqSXF5RVFzc2lxVHQ5U3lHektmQ3FtTXVQaCt5SmpOTDdnZ2xobUxRS1EvQ1dLd3Q2aFVYdUZJMTdpbUJlMnlaZC9SVE1kc1FXQ0I0MWNzbytrT0I1dUovYUtpNHQ5MG15UGNKekptU3hwbGF1OFQyVkJZaFZqWGlQSzdiMElxenZiOE5aNW1tc3J5SnpHS1h1VHBvMXdUZGgvYlExelo4ZkVPQXZwTktIRGgvVTVXWGdOQU9OOWRhbUxwcW1abUs3NURNN0UrZVI3Z0ZVMklvT3JENzFGZ3JKNkVpNVN6UmNXU1ZiOFcySUREYTNlcnFackxsZTRpTmh3bWxUR0tqaEd3SE5UKzRvNDB2MlBhbW1Nc2VRVGs4MzVaSmxJUmNsendrajRYQU1vMnRSY2RBKzlFd3cyOVJDU1VZUkVPdHdiS3kvcmFpWTVzVGpNaWthVGxPOEpZbHIrWWduVWxlcW5yUmN4MHZiNDhlU09LQW00dVRHZGJDK3R1Si9iUWJBZmI4Tng5eEEzMjdXQWVLekd4MzhyYlc3MVdYQnlQY1pzYVZwc1V1a0JrOVJSOVE4cHNvVzkrK3RacmNqTmtuR2ZIaHlGblVTekJvbmhzeGtWZXZOdEFBeDIvR2g2N2NIdE1rWHRzT1RHeUgwT1hxSVdCT3V6QWRWYnc2MVlscW4zS0xMOXdnZ2xFZ2xld0VtSWxoSWgyREJWMUZ4U3BKaU1XTk1NWVI2cENqQVJMLzhBM0NkSGMrRkZXcmlxNUprY0dWemRKZ2JoaURZNm1pT3BqaVdEbXFrQWtDeEl2K0h4b0lTU2xCWVNjWFcvR0pnVmNCdjNBbnl1bmVxam41aVNaM052VjVSdnlMckVBZjVJOUFHSFJtNkVWRmpnZTMrb2trb3grTEl3UHJSeUx5NGdOY2NXOGV0UnF1Nzdia1lsNTQvZGI0Y2MwZkwvQUxSZTdJTHg4R095czI1b3lvd2tpamVKa3gvdU9aWm1qZDFWREhHYnVGYmU1MjErVkZyUkprKzNldU12MjJLVEZneUFVVEdEMlpUZlhtM1VmcUtxT1RrZTRNdVRKS25EMURlTGl2MGtub1FiOGhwdlVhWFluT1BCS3loaEF6QWc4cnJZNk1PSTNJN1VTc3VTeGh0UEZLMnJrbU5Ocmo2VFkzMUFvU05mdVB1R0RIN2ZIaVF4bDhsckxPeWk2M0hWVHZlbzNJekRJeTh6QmxsVXh3MlVvdHhhU1IwRnJMMUFBT3ZTbEpGS1E1WnhteDVveEJESDVrWll3WFpsVzZoeURvRGU1TlFRd3ZhTXpLeUlBSWlrYkVGNU9ZdFk2NkU2RFFFM291ckhmMjlKUFRnL2xoVitJalMvSnpxUzF1dHY5YURvWXZ0T05MSkdXWDdlVjIva0xHMTJZWFZCL2FvNzBUVjJaaXRpWnNiTE5Ia3FvNHZIQkpkZVIwQTVqVW0vYWhxdVNQSk15WWtjckJKRHdtYVFDRWVvbzFGeWYyOWFWRzMybWIyeUNPVTVoc3RpcWhidDY1VTZwWWJBOVNkS0xYSjl5R05rRnMzaUkxYTdmYkMvQWtHNml3OE45S2lzV0hOSThobUE4OTdrcWVBMTA0SXEyMFA0MEs2cjVhdGhFT3ZwWlRzV2VibmNYWStVQlI5SUZ2MjcwVEVNdkxtYUg3SkEyT3pjSS9Tako0RUtkWEo2c1c3MVJ4ODFmY1ZrNVJPT2J1cWhsdUhXUkxnQmI2alFiaWpTN0ZnZE1veFRGTXpJUENRaEdCWHo2a1hYekZqNGJkYUk2YThKczQ1aUtxU041WHg0MUx4cW9GdC8zRzlFTmhqckR4bmc1UHNnRjB1eE4zYVFVSTFSNGtPR24zTThSRFA5TVNyeGpWQ1ByL3UxUFNrUzFtSngvY3NqelNsakVlS0szRVNGMzA0NjZhYjFUcDBzdkZueGNhSEhrU1gwWFVrNHpHd3RZK1lzYkF2NDFVaUNZU0w3TkVTRzlaMGJnWldLUnhxTnd0N2x0cUR6M3RZV1hQYVBPZjdmR2E0bmswWXFEdVJmdjhhalZkYUgzM0I5c2duaHhvSW5NN09jZHB4L09vVFJEcDVWNWJxT3RFeTBZVFk3cDY3b1ZrS0s4bG11Z1RxR1Z0V2Evd0FxUXJvcmg0K043U2N1Q1RqQmx5RkpDVXY2WlpyazZIVWpwYXFrN2MzQ3ptWDNLTEdpNHh3OGlzYk9uRG1raHR5WnhxQTF2bFVhczRac3hQV3owTFppS2swZ1JTamtpTThyam03N0JWb2p1NG4vQUszS3lvbGd6bVQwbytHUklTVHpOejVZMVRVRHJ2UWMzTGlaOHowOE9UMGlWYm1RYnR3QTFPdXhieE5RcnF4KzRwN2RnUTQ2UUZWQ2ptRjlQa1ZrYmtnTGp6RjIzUGhwVkRqTDNBaXlGTXNuSm8yamRSSFp2S0VrTEg5MzdyMEd6MnFmQmtpRW5DVG5FT0RTeGtNalBjaHJhYUtGMEhlckdhMlpPU1ZDUlk1OVdTY2hCQ0Jkd0wvVGJveDYrRldwSEpXWEllWGhJNndDUzZtSmh6OGtaM3Z2M3ZhbzBxWXJtWk1rUlByTEg1aElQSzdBYUx2Mm9pZi9BTFQyK09FcERHOGMwWXVrcmVZeU4vWWRiS2w5YW9xOXBFNTlJNXJJb0VuTDF4cUIrNjRBdjhEU0ZkVUtzOHIrNFprb1NJL3d5ZVZRVkZ2S291U2VJVVZBOG5HaGpDdEZLTWhuSzg0NEZQRkFOUVFEYmxwUTFpVEN3OGlmN2lmVDI5V0psOU1nNUNoU2RBZzA1ZGFxYTUyWWl5KzRSUmxtZEVYbEx1OGhXL0ZiRFl0YWk2N3NVc09KRjl2SzZoRUplVXIvQU53a0N5cVc3VzM4YWdZeXo5czBJMWQzSHJ1VGNjbitrRHdVYVdxaW5LUHQwVThucnY2V05HV1pKQXZOMks3aXc2WDBGVEYxZ0Q4cElwWkJKSTNCMGpqWUdXUWhoeVZSR2JCTmJHL1NxbWw3VDk2eStuRUJGTGRTc2hma29YVzltdDhqcFNGVEdiRkg3ZTBSakFFajhyUmtoMnRvRzA2RFdvT3Y3Ymt2aHd5U0pCNlp5a0Vjc2pXZGd0ckYwUDdqNENxejI1UHVJZUI1NElJMUR5TXJ4dXBMZW1iQzl4cDVtdnFmbFJxT2xsWnZ1a1VLb3VhN1RNUmFRU01vbHRZTXZHLzdUcHBSTVhaWDIzbWpqSG5zcnpPMTE0dmE2Z0ovc3ZwM29ONWdRZTNSa3pRcjZnSmVaa3N5MzEzNk1PbGhWcVJ3OEwwSHlmVGlSSlhkdU1TbTRRWEc1N0MrdFJTZVI0OHdxeXlFcUx5c2ZvNVc0NmR3UHh0VkhVOXF4cHA4MW5jdUhkZUl2eFVXMDQ2dDB0K0ZFcVdTSTJrWWN2VnlTM3B6eXRZb0dYWGpZZlVTbXdvSVpzS1lxNDhqeUNQZ1dMdVl5ckVIVWd0MjQ5QnRRVjQ4dU5ObnZPckdJeHFaUFIzR2lBS0FTMnR5YURWbWU0UlR5enp0RW94bzJIOE1kMUxCUll0OFZQNDBFR3pXVUg3YU15WStyTTdJQVdKRndHQjJOdGFDSzVqSm5Ya2lVU3lrQjRGSElvcko5YXFOK1BVM29LWmhGbFpYRlpIa2drMGtWZ09Lc0ZzRzVBZnRJb1l2eG9IalNURVllcHdsV1NkTEVPeExFZ2N6b1ZBNjBpMWZsWXlyR3NvWUM5Mk1ROHc0ajlOYXJMakNUVkNxZWtYYmhKSWh1QWpFZzJGckRrRDhxaWpJaGppS1kvcUE0K093Q01ORzB0eUFJMDBHMUNOMDBQdDBnbXlZbExGWXYvRmlBUFBsZnpXNDdXM3FwSE95d3FZNjVQSXM5N1pFc3FXREVDNjgxYmR1bGhVcXhmQm1xZmJ3NWlXSnBINHdzdWc5TlFmVVNKaDFZLzNkS0MrSDJ5T1pNaklXMHFKRVVsNWppSXlkMVBUeS9uUlVzR0xIOVpaSFIyZ1JRVXRjM0MvVXhIOXQ5dTFFU0dSblpoa2xoalZHbkpNUlUzOUpUNGdBL1R1eG9JNWtlSkZIR2t5aHM5TFhYa1YwYlppRDE2MVVSOTA5eSszY1FrMkJYZzZpM0Vvd3R4MDNaaWVsQnJ6Y2YyMThhSE1saGFUTDhoTUJJOU14b3ZFQy9ieG9rWWZiNG1nejRzZVJ4a1k0UHFzeU1YQ3hQdU83Y2Q2RGJObFJldVkvYndpNDhya29MZWRFdnhCUGcyOWhSVnN1Uy90YUQxbTlVT1FiSVdEc2lteW0zMGhXT3ZlaTR1bno4TXd6d0kvL0FKVHVyR1IvTTluQkxzTkFkdHFnNGVUZ1pPTWVNa2l6UXpwNnZxaTRVRW0xM0dubXR0UTFyeGM1c0xDK3psUjFoZFZkcjNzQ3gzZFNMM0FQNDBGczhXRThZUU0rUmE3UXZwWU9DZGZCVDQwR2IyNE1JWG52ZEkxa2FTSWl5bGlRQnh0dHZ5dFFkQ1BIbEtSK2lBTElrbkVYSUJYWFk3a05RaWpPTVU4Wm5NcXE4Z2FGZ3hzbG1GMVlIOGFEamU0VDVMWUVHTThadEh5S2pVT2dIMU1XR3VuWTBwR3IyaUhHdzh1T0RMUnd1UkFHWndRRU56ZFNqZEJZM05JVTJseDJpZkVWRE1peWxsbjQyS205dkt5NjlCZTlBcFBjY2lMQ2hqVmVmdDVrZGtXeXMzSlR4WVhCc09wN1VpVktCNHBZT0VUeUJvMjg2czU1S0dObFhUcWV0Rk1TR0xLWmNjczRRa0pJTkIydlk2a1gwdFZSbnlNV1pvR1RHaVU1RVRrM3Vic1crcS9mVFVWQ3NzOFVrbnBBUkxpWmFXVm1YUU81MGE1MzBVMkk2MHJVVVpIdCtMRW5vbHZYWXgrbWtvY3B4ZGJsblZMRy9MWWZuUTFxZksrNGFBenhNOG5wdEhFaXN2S0ZpQnUzVTlibnZSTVhZM3NTeDQyVkVzeGRrVmpDakJlUmlrdHF6ZlRxUmJlaHJqU0YzbkVjTjFYSGdLdVdCNDJHeTMyWW05N25hb3JQREw3c2svM1RSL2M1TUEvbVdRQnVjYW02alE4bi9IUWFVWEd0MndNT2FWbTR5Q1pWeUZuVmkwZm0zeDJJMllNM3lxc3h1OW9seFBlZmRIaXk1L3RNdkhpTWttVk9TeEFDY0dRdUxIaGJVRGFvdTVITHk0M2x4Y2pDajROaFJ5ZXRoNUFCUjJDQUtrVno5S0g2clVVa2YzQjRoamh4YkZzMGhjQU01azJPbm12NWJiMFFUdGpZdUtNcVdSb1B2SXpKalF4Z1NFaGRIU1pyM1h6YTYwSTZMNTN0TTJMalQ0ZU82WkQ4WW9zYXdFaldXeGxGdGJsdHU5Vk11dFVCa2h5by9jT1hKSi80b2k3Y0ZZb09OemNYRHFlbHFDajN2M2ZEeTVEbXhPeVNZeEVVMGF2NWlMa0hqNDlmQ21raS9JOTVpUDhBeDIwbk9YRmR5eXhsZVBxRUFnTUc4RDBwcG5MblEvZk1JOHRaRWxNS3RFSGtzd2pGZ1ZLalhqYSt0K3ZoVVZaNnNFZU1za2wxZVdLUlRrY2o2Yk1uUjB0ZmpyYW1wSXlOOTVOaXk0bWZLdVBrNENDVEcvWjZtTy9tOG9GK1Z3ZmpVYTRhY2IzclhIeHhHOHZBQmpLQ0ZhR0lzVkZtNmc4dXZ6cldzMklaS1lwTW9ZeVQyTElzaEpLQzU4cEo2VzNxTHJTTVhCa3p6RStCR25raktxSFpnQXFpN0J1aGJmWGFtRzhOM3V1ZjdUaVllRmk4WkllTEYzeUM3dDZpV0lhRmIzVW50VnhKWEZ3ZmNSaEVyQUpueFptSjVnOGVJT292dnRzUlVWb3lNR1dLZUtKRlZGalV5U0pHU1dMT2VTOGdkTGo5dmFpNnlZOEVlVmxMQzhqRjNiUnBUeGYxRzZOdmUvZW9OdnVYdHo0L3BQUEpJcmhuVE54MEZwQXk3ZW9nMko2VzZWVWppTmorNFJaUys1NCtGNmVNN2lJTVR4SEhhK3ZodlVhL1N6SnhzN0x4NXBJL3FKUHB5cUxDeWZ1NUR4MHFvMFllTGhuQk9OTzhyTXRwVVlIMHlycUxNcmZ0TituV2lldVZuZXhSU3laVStNM2tSUzhnZHZPVkpGaWU1K0ZUR3BXVEI0dEZEaXo0WUdPOG5BWkIxWlpUcFlqcWdHd3BDdXo3dmpTQlh4ZmI1NWN6bEdoeUl3dkdPRUFXVjdqUngwcXN5Nll3TWpDeHZWWitjVWNpeHlPQ0VqWUZmS3RtOHl0ZlFYb2FzeVArUW1kV2lTRm92dHhyY0FOeHZvV1k3dFF4ejRwWmNoVGt0Rkl4VTNHaDR2R1Rma081dlVYSGY5dDl6V0ZBY3lNeTRzcWptUTRWaFkrWlgwMU8xaFZTcHlaZ2dVNGtFUXVmUGl4eGd5ZW10eWVMOW02bTlOTVlvNGd6bEpWa1BxUDVCS0I2blBpZVNzQnVQN2JVRjgrQkxsZTNSUGtrZ0FlbXNvQ2dvVkZnclczMEhXcWk5Y2RzYVBJRVV6eG5JV1BqQXcvN2pnZnRKTmhjYlVEaVNjU3hORm1la3hEVFJZL0V0Y2p5NjMwRFVIVTl2OUxrWnhDVjQzTWlTRzVJdHNGN1hvVkd5NFU2WklXS1VJTHFreDI1Qytsclh0ZTlxcU9SbTVLd1k4c3hSWGlkMWYwK0pLK2xzUWROTG5hc3RKNGNIc3MyUVpvY09SSmVCa21qTFdWYjdPblhqNFVHUXlQeW5CZG5pTmo2Y2xpUTZqVHg0OGUxTk1hL2JNTEp5WjVKbHlSTHdVV053dklOc3JMdVRmcUtEZDdqOTArSGJNa01oamJqaXduNlltSjh5cGI5RFZSeTRIdzQ1RmpsZ2xVYzdOWmJnTWRINHRyYXk3WEZBU1lRaXoxWVJNb1loVUt0NmwxdGRRVFlhMFZwY1JadUw5ME1oWTVZOU1pQjJZaHJhY0F1dGhZZEtJNW4yTW1WS0RGSWVFalhkUVMzRUU3Qys5anRVcXhmamU2VFlNN1lreStrdUllVU1pcDV5Ui9mZis2cUxmYy9kY2IzTUtzVUhvVHlnUE9PRmcxOXlMOXQ5S1dwSXpyaThwa21Wb254TWxYVldPcEFTd1lPZTVIMDJxTmRPdXZzL3QwM3RReThES1FaT01TR2hJS3lLVG9vWS91SGFySXpheFludHo1WWRaMnZJdHk2RTJMa2FsdkczV29xT05qWWNTc3VRNitpRllSczRJOU9ZNnJyMXZhZzUrUVBaU29NVXJRMlc4OE12bVVPRHNqRCs0YTJvcTFSQ1M4YU1KTVJSeSs0aGJ6QkxmVFkrTkJqOVBIbXpFZUJnZlVmakVBQXA0SUJkajB1RDBOUWROOFhFWDJXYWFDVEhua1dVcStPOTFiemZ2aUhTcW5xckJURHc1QTArTnp4Q1Q2anljdU5pTlEzSFVYNkVVV3RNRVh0bnFUbUNSZlNpUjV4Nm1pOGg5STViay8yK05WT2NjbkdNdUZNTW5EblNRS09WeGRlWFBRL1VMRXJleHJLdHk1cnZseFRvcGdNWUhKNHVoUFd4cW92emNoNTRkd01nc1c5WFpudnVvWFkxZFNSeDN3NThTYUtWQjl4Q1E4Z2dYc2grbzJ2c2R4V1czTnlHbTlaNVpuRnl0dWNZdnpENjY5cUxIVndjWEprSW1NNGd4T0ZzZVIxNHBLeWFtTy9mdlNKUVBic3hqSm13c2h5WUdNc2l4T09TQmJiRVd1TmVsRWRGUGRCWnNpYVNJeUc3ZWd4TWFraTMvYk5pT1pxb3l6KzRaclpFdkNQMDF5QXBqaFh6QUlmTllDMi9lMjlDT3hpZTR4TmpwRjZic1VSUk5LUnF2VzYvdUY5cVFybCs0U1l4bEFTVzc4aGNNVDlQajJXbEpHTDNhTDJVYzVJZWVQbGxpSkl4YVJXVUQ2MUtrV045cUxOWkVWVk1Md1JoMU5sa2lESHpBNmxHOFRVVnJ5ZmNjNldWSGw1cDdlT01XTXNoNWlORVAwS3gvYUNiR2lTTnZ1a2tPQjdwNi9PMEpGdlZWVmNxeFhseEtINnQ5S3VKdW80TXN6UUo3aGllakcwRGlQZ2JYYnIrNjRQNFZGeFltSGdaQ3ZKTEFJNHdHbHlFRmw0c2RBd3R2cjIyb2JqaWU4UGs0dVRGelZWZDQxWkVoUG1OemNFOWpZVXF4ZDdkNzVtbk9sbGVSY2VLZnpUSVlra0RrRHlqZ2V0K29vTUVlT1dneUdBZVJGdU9ZVWhidHQ1aDFyTGJYaHdPR2x5cEFFamhpNHBGSDVVVnlQS1BQcWZIdlZRc295NUdPdkZFaWJoWlFXS2tubDlXbXJOcjFxRElNaWFOVWprSldLUTNtWmRRU0JiNlJiVHBWSFhqang4ZkhMYzRSOXpHSFZ5ZUxXdU5DQnRjalJSclJKVjBPSE43aklnd3kwakd5dHpBWGt4R3RyblFmcFVYU3hNU0VTR0JwMHg4aU5yUnlyZGxkaC91RnJmN1RRYzdJOTF5Y1RPWkhDeXVBOTVIdEx5TGJsU2V2OEF1cHBpT0pGUGxSTTdyNW11UTVJQUlVWElIeW9veVBkRDZpNHVQRW1OaFIvOTFvd1hlUWtmdWtQbVBoMm9Pa1BhSm15VnlYUXQ2ZzVKRzlrc2lqVFZmQ2lhcnhmYThpZHl5a3M2OGpja1dDNzZENFVMVmpTWVVjVCtsWU5HRkJjanpFS2JiazNGK3RCSDNsZVVNVWhJaG04MFBJQU54UWprT0Z0TGtkZDZpeHlzSDJ2S2g5eE9qUlhWdUV4MWZqLzliMmFxdGRsSjhxRDI3N2FCU2tqbjFaQkdlZkdGVGRneE9vODJ0RVhlV09LSExtSWxCUDhBRXRpVzRuZm14QVFXcXNyc3ZPZ3lnRGpJMDRsdDVuNUpIR2JlYXdiNjdBZkNnNEUvdFRvOGJ4WkFPUHpibXlobWFJWEdwVURkdjJqclJYVTlseUdiTFRMejVIZkY1MmhaeUdaUW10aWwvd0FxcVdmaHU5Mzk2d1h5bWtDR1lLTElpTWJzN0FoYlczUWRiVkVuenc1cjRPUEtzbnBZNnk1Q09zcnFwMEpiVGd6NkpZMUdtRDIyS0JjcGNyMG15QkZLaTQwZk8zQWszNHRZRXRidXVsVXJ1WlB0djJzenorNEtaMFpXZkxJdUcrQ1cxdGNyUm1jOU1udlh1SHQ4MkxqWS9vU3daNEhHZUQ2WW9WR3FCVGZWdGRRZFJWcXpZeFJyaVRMTFBrU2dOQzZ4TkhmeWdXMEtOKzVqMnRZVkZhaGduSXpFaUVDSmxUU0ZHZVM0UlZhM0VNTEVlWGJUcnFhSGpYRDdRVWxYR1NVY1lwR1ZuaFh5dGJRamwxNGphaWFwbWp6SmM2UEZoaUNxaExjYitab3lmS2pOMUs3MFdxY3ZGd1BXZG5TU1I0aWhNSkpETXR0UVN0N1hQWGVocTFjWURISVFMQk8wdklwWXNnUzJpcnArM3FUUkhvL2I4U0w3ZWZKZ2w0NDRkREtyTmNGaVAzS05kNkpXWkZiS21NYU16eUtTRmlqQkJJMUxFTUJvMzUxU3MwMzJzc3hqUC9lSEdOUXhzcUlBYmVZZGI3MFJjTVRNUmthRWxKMld5ckdORmpKc0NiOVc3OXFvdHpmYm5tejRranhpVlM0a2NuenVlOXhjSzM5S2hGY2MwVVFDdkt1T1Z1WTJZY1dDL3VzcHZkbVBoUWM3TXlQVWphVkNTZ2ZtNldzZFJaQnB2ZndvcmZpZTR0OWhJemhZQ3pCVkVkek1WTGZ5QzVPbEVzQ3pCUGNaVjl1WjBnbVJrOVpndDNTM1cvN2dkN1ZVVXd4eWoyL05sUXBKSEc2eGxCWXlPQWRXRnVpOVRSVm1IaXVNY3ZLSkhFOWxCMEFWaWIrWTdYSTBvT2pFVGtOYkZiL3hvVjROTVVJU0ZUOVNXdHlMZEExQmpsd1B1c2t3U3Q2T01pODBiZ2J2NmQ3dS9WZDZndHhac1BHOXVmRGxSamtaYnVVblp6YU5YRnJxbzg1NVcwdWFESStUbjQ3RXVRa3NqaUppaDgzR3dBVlFQN2xHMVZLM1M0dUhreHl0Snc5WXNrV1BCSEhZSGlOUXJqeTZEZWhOWVlZby9iOGpIQ1NuVG5FSUpBQ1BVYzI4dkkyc08vZWl1cDdkSkJoWmNtVklnellGREk3WEZ2TnNIZlVYMTJGRXJQTE5NY2oxekhmSm1Oc0piQzZSS1BMYlRXNUExb0w0YzdHemNGWVo4ZTJmemFTVEpaL0kzRTI0ZkVIOGFEUkhqKzQ1RCtsTXluTW1KRVlKQTQ4ZGl4NmNRS3FNWHRzRXMyVTNDWUNKQVd0c0dmaVFlTGVKMnFOTktqMUluRE1HZTRhMzFBa0c3TTF0YnNkS0l0VDNJeTQwa3NnWVpCSmVHRzJyRmw2K0hXOVZJY3o0c2NNTW1EelpQVURNQ0NTSDRnbmpiZTVHaG9OR1FuL21qSTl3bEVyTi9MNlVodmR5UEtHWFlMK1o2MEZzUHMyUVlQOEEycll5aEFlVHhNZnJzTmdvR2kzb09kN2pNMGtpekNIZ2hDYUR5aHdvNWNBdiszZmthR01PWGx0a3Z5allFUkxhTGllVGh5TnowME90K2xGMENjd1R4UmtQSk8wZnB4U09PS1NGckVtKys5RTEwbm1mQ3gybFlobzBVQlVSQ1FYa052d3ZwcFJVSU1uUG5LeEhKUkJMZU9TVzEwdHVRWFlYNDlLSTM0eGhqeW8xeXNsRWptQktST3ZxQWFFZFBqVkduMmFHQ1NVWWJ3TDZLamxFejJCNERyZnNiYkdncS81RGgrM3dZTWdpQmJJYnlncmJrcXNiZVh4cVlTc1gvR29KSkkwaWR2dDNrVmloYlNSZ0RaZzNlOVZLbDdyaSsxTENlZVR5V1cwRVZpZHlmTXpXb09WTTBtRkF4Z2srcTZReFdWZzFqYmtSKzAzNmlvdmJYN2FxcGh6K3JOSzBFZkVjSVJ4dVFMbTk5R0p2OFRSWFNhTEViSGtFT1pMTERqeGtNb2o1RUZ2N3JlWUFkcUl5K3pTTGhPbU84eXh6eUIvVU9oQjJOZ2YyK1gvS2tLb3ljTVRaMDRWM1IxVThHbTNLVzhvQjEvNlZVTnNTS1V4eW1OVXhzVWgvUTFZdEl3dHhaanNEUkZPUTJWNnFxMXBIYU1SK2s1dkhHT29CMEJGdWxGaTFvOHlNeEg3YnlRc3NpVG90eTN4WDRVRzFDeWhNM0xYbUozSmF5Z0c1M0FJNjIwOG9xS00zN2RzZkhtWWtqMUpMSUR5WmIyNC8vVmFVam5wakt5OG5MY0haUTRZYk14dmZtYmNoUmE5SjdyalFUNG1IaXh4WGtZaHBVU3hGdTNMVzVvekhOYjI3SWJKYkhueW9vMWlET1paU2Y1WkZzZlRaenBkQmFpc3Z1R0s4YlJRNGhNbnJNR25qMkpVZVkyNDJ1RDNvSjRrc2NwYjAxTUViU0MwWkJZRGY5eDZKUWFuUnAwdXNucU16RzUxV3h2dUxmM0NxYXplNHBqTkI2c2l2SzRDeGh0RkM2aFZHbTNINFZCekpvSmNSNDRmVFdYbElyTUMzSmx0cHl2ZTVERytsQk9Gc295bkZoS0dBdnlMZ0VQYStnUExheG9heWU4Ulp1SmxESGl5Yk94TW1RMnJFVzAyMkpidFVXWFdkc2IzQmNaYzlJNDBqbGZqbVI2dEdwSi9hQm92TDkzalFrT1hNaGdsYVV4RDFJM1grYzZHTlUwNEFEb0Y2blhyUWRBU3lHVEVuUlRMaHBkeGtXK25ucUl5QnV2THFhcU9yR0lmc2NuTmd5UFJSN05HQWwydnVVVzMwaDc3MVVXU1l1SytHbVV6dy93QXpKSXFNU1h0ZlJnMjIrOUJ5cytXR0l4UzNoeVhSdkxIeE5tQkpWck1Od04vbFVHVDJwY2ZLOVNLT1pJbVJlUmtheXEycEl1Qis0OUJSV24zREt4cGZib01Oc2d2T3pjM2lLbFFDRFoxREQ2bFliZU5Cbnc1VW1neUc5dFZwSS9iMjVsK04yUkRkYk1HMDRpK2w2SCt1V3F2bSs0enA1a2VCQ0kxVWxmSVJlUmRkTHVOUjNxTFRWY3FQRmJEeDRQWFNkVEpEa3RhTW9BTGtNcDNaZHZOcFFabUNTU3dTV01jaDR3elNsYnFHUG1ETjFOMTZVSGI5d1dPRE1sZ1JIWXpJSTFSL09xZ3I1bU5yVzEra0RVVlUzV0o4SEl4WW9ZcFZqays4anNOdEhPZ055YjhoYnBSVU1uQXlNV1ptang0bnlUS1ZseGRTVWpGaUZCMEJ0eEpvYnJiRmlleVpVQkhzY2p2TEl0aUo0dUJqQjEvamNrZlNicURTTTgrcGU0ZTB0akw3ZVBVbHhpbCtjaGN0bzV1VzI4amJzZEtMcm1uMjcyc00wVVU0bjlKeVpYU3lzQnNHVWpWd042alVkcVhFaGRjcEJrV3hGc3J5YWtNdkd3NUEvUVIzNjFXWnJDTTJMSHhmUlJ5Y05GSWFPTWNoWWZ0NWRHMTVYb001bG4vaHhzdTk0YmNwMElqa01iTnlITUhSL01kZkNwcW5Oemk5MHlJUGNnWjRjbnltWVdYaTQxV1NQVDZTTkxiVVJsOTRneWNQMjMxOGVQZ3JLOFR0eERNZGJjUzJ0cmpYYmVvMHhqM1BoRE14eFkwbXlJbGk0NjhDdGdCS2dKMzBOenRlckN4MThHR1dhQmpFeTRPVGloV1oyY01ydUQ1ZUpib1FkYU0yc0dWbGU3WjhVSzVZRVUyUExMSVdLajAzc3VqRHJ5M0JzYlVhNFN4L2NQVVpaRXlGa2pFUmFURlJnL0d6V1p0UU9tL1dpTzk3VjdoQmx5elRLM3Blb0NxMnNmS1JyZlRhM1dxbU1lVThDdTJYaVFJNVNNcTZNNU55TkVrVlIyTzFScHpjdkx6ODNLKzV5R2R4eVQ3aDFQSXJ5VzQ1dnNMbnBUVE1kREYvNUQ3dEo3WGtRejVoZGdDWlk1WTErM0JPbnBnMjBCVzFyRGVyck9jczhlTTgvdFdZa0I5TEt4MWprNHN4Unl6SFVLaCtxdzYxR3R4VGpZanlRU1pNa2wvVFlGNG4zQkp0ejRuVWh2Q2tTdWlzZnRNMlBCTWdDU3dOeGFJZlU2RUVPcXJzM3hiV2c1V1o5aGplejY0N3pBdXhlSHpMd0ExVXYvVGlhRVE5cjkzbWlrUkVBVkVWUks1QnN5Z2N2S28xdXRKU3hEM1gzaWJMemdNcWNMaXhwNmJUTEVRV1k2cWVHNUIzMXBhZlB6akMyVmozNXlQRGtXUENKV1k2SC84QVd0M0Y5aFVheDZLTENrZkhlZkVWbFFMYVNQa0pQVEJON0hiZXF6YWtmYmdZSGxoNGhZN1NDTzkyNFBwZGtBMUtuYzBJak1jZVRLanlJZlVhVlFxQ2NNUUM2RFkyMnVPaDJvYTZNVWNXYVovdXJ0a29BQ1hZcTVaZGdCL3Rxb3FseHhFNFdTTUFIV1JTNXVXQTNidnY4YUxySmhZMFdUZGM3MUV4NGxZUXlxZko2aUM0VzMxRGx0Uks2Mk9tVEkySGp6V2prV011WTNVTmEzY2pWci9sUVNneTBrbDU1TGVlVitLUkliRUFIUzlocGZZVVNxY3lDTEx5VnlvNDdhT0ZWaVZqazRDNElQOEFlUHdxakxGR3FlM05CbHlHU05HODRzT1E1QzRUWHIxdFVWV01YMGNCcElHRENOdUx0ZTBodjVyNm50VVZMTHhjeU5ZSkdVakpkbWNySUF2cUtiZVZEL2kxQmk5djl6eE1OSkJKemt5ZVpBeDVGc0xOcG93MTVLZFBHaFczTS81QjdibGUwejRhd05EblJOYUIzSlpDR1BtT24wMk9nUFdtbU9Malp2MnVURytSNnNNWUM4c21JbVFNQnB5Ty93QWhUVnpYWXpMTDdSSERHUzBVRE5MaTVBWThKbEp1VHhheEFIUzFWR1dPVENteFpUaFpMUVpUQzhwa1hpZ3ZhNmtiRDQ5YWkxWDdMays0cEo2Y1BISHpZeXpySkpZUmtkZERwcDFOSWxpV2ZsWjJkeE1rQ2oxaURMa0FteGEydkluVHpWZE1QUFRIR0hIakNXVEplTFJaRjVJSVF3OG9CSXZZN1dxRE5EeFVoSkdQb1RjUnliNlk5T04yNC9yUWR6N1NQRno1b1RMNlNaRVpYRVZXTHJJNEdoREhXekVkVFZSZ1QzR1hWODJTUlpvNDdSd2kzSkcyRjI3VVZ6cGNvbVlOejRLRzVpQno1dlVBMXZhb3JYSkRnKzlaeEtJSVRrZ0dORTFMeUxvV0s5Q08zV2xTS1Q3UG1JQTBMSk8vck1rTWllVXRJdWhFa1pzZE5yR2l4dGxtdDdrcXpZVWVKa1kwWTlkSVFidVJwNmc1YTJKM1dxeXlaM3VjMlRsTksrSWhRMkRyR3ZCUXY3QjhqODZsV1Jyazl4eTRvMlhEa0s0c3ZHSm5VYXNyYml6M3VPMURQeXplbGdQQjVWSW45VGpGS0g0OFhHdzRuVGpidlJYVDlyaHlzVDFzYkppR1RHRi9tZ1hqY0JoY09oMTFCTnlLSlhHaW4rMnlKSGVKNWNOd1V1cENucllpL3dDZmhSWFJ4WkZlUVJpZFJESXZMMG1UV0pnTmVKN0g4NkpXU2JFeVBiU3FQRUJGbVdtZ25hNExKZXhHaDBxTmF3eXJMSnlsc0RhVHl5Z1hRWEdpeUVEd3RhaGFnbnZlVkhpdmhaVXoraE94YWVOVUhJRWZUeERmVHIwRzlOVEZzMmI3ZmhlM3VaSXVXVzdBQkxNa1RjeGN5T3AxdXVuRzFGY25HQ1R4ckN6ZXJNVjVSTTc2S093SGVpMXNNTW1ObDQ4MHdkQ2poRmFOaXJLRjZoaGNocUltTW1RWkxTUExLMktTeFRKaUpMc3cra3NEMkc0TkJ0OTF3NGtreHpCay9kdE9peU8zSGdZLzdRYmFXTzVxb0RHTHJMbUpETXBQODBnOGpKeEgwbTJsbXFMcnF5ZXlZMFVRVEhkSGxrQU1zSzN2RTFyK1JobzF4VloxemN6MnRUalNhZXFrS0Erb3pjU0dPaFZZeWJGcm1pNnd5NHFXVDdzUHlVRGkwckVsN0R0MnRwZWhyYml4d1JyelpBaFJnT0R0eEp1TDJJL1EwQi83REhpek9Td24wWk5Iak5tUE8yaERXdFVwQ2o5amh5aGFEejVNakswT1R5dUwvd0Q2dHIydHRhaXVTMFVtSUpPY1ZzaEpTanBJcDhyZFR5SGx2NFVFTVRMekNza1NNRmlQSm9rMUoxNkxZZnZxTjF0WDNDQko0NXBjVWVyQndXS0o5VVVqVXN3SG1ielVpTlB1VWdteUVrWW1iMWZOSVRFWTBETnF5S0wzSUhRMUUxVE5sM3lVZ3hzZFlaMkRvRmtzNmxIOHR3ZjlvL09xSXJEaVRSUjRNRUxTNUNFZ01xWExzVGR1Uko4cXF2NDBYcFpObDRlT1pDa2haMUppaVNMekxZTFlua1NOMk5xaEVZWmNDZEVHTnlabzRtT1RKS1FxZy8ycU4yQTZWS01HYmxEMTRvNHlwREo2Y1NBS0FWSXNXWWEyMStkR282V1I3WE9nWEVEeHpaRFJnZW5DL3FBRnRnQ3ZVRHBWck1xcjJuRHdvWkFwYjF5cWt2aWNlZm5YUzdXSXR2cFJYZnhueWZUQVpmTVFWZnNvTzlqdllEU3F6WFVqOXJ3NDhaNXhCNllVQXJhNEZ2bi9BSFVyT3ZNWlp4MnpGbnhGWnBJd1NYS0F4amp1VlhyeEhWcWphbVhJelhsQU9PWnZWalowREcwWVUyL2tzUGhSWTlCN1Y5aEJFeXRGeU1pS1p1Vnd3RnVoR2xqMnFzTW52R1lrcklNZGxoTWEvd0FrVUtCUDRrdHdaais1bXZyZW8xSE95Y3Yzbkloa0dPb2x4OGRBSkZObUNnbXlsdGxESHVONm9vOW9nanlzcUpzMlZZNDRpeW9yc1dIZXd0K3dVU3R2dU9hbU1yUXhxV1UzS3RFUHExdGNEOUNhalVpb2UxNUxZYlpzTUpPTStoSkFZOUQ5Uk8vOTFxRnF6RDlybFZUSUpnZU5pcUM1QzI3azdhVVJrU2YzQnBDOFplV0diazh3akdpa0UyNUtOR2EzZllVWEZrdlBJVDE0NTRZR1Znc09JcHRJT0s4aS93RGFGYnJWWmFQL0FIYVpPSjl2a1hlUkZVSlBCOVV4SG1zVC9jUDd0aFZNeGl4Uk5seVNlMlk4WVpzbHg2ZDE1U0x5TitiUDBmOEF1YnJVd3Q5V0QyTEp3NXpCZFhuamRrZ2FRcjZhT2RTKytwMHZjNkNoczdac1hOZkRqQ1RTZXNPYkZXUEpYYUlHeDR0KzNuMDhOYUxqMGpUUVFaR0hHR1dNeTJuRVRjajVYT2k3L3dCdm1Kb2pObFRRRExrYjIxdWMwaEtBa0VNRWI2WExiQVVocFludHNnaWxueXdDWHNwODFtSk83S1BHcW10c3RuUllvMEFJWHlGbVUrYmNnQWRUMjcxQkNHSGxZTWpZbXRvM05pR1pSZGxKR2w3YjFZVlZQUFBpelF2ZmdSYyttckVYQkZnM0pkZXRFdzE5dXY2VVpqS0pGSnlta2tQRkdjNjJGOWR1bEZkcU9YT0RUWkVza2tyaEFXbkFDY1ZKNHFyR3dGcWFtS0pQZHB2VWxiRms5T0JrQ1NBWE1iM05pT1hlMU5YR1U0ZUJGa1BsYVpjaUpxemhyRXNQMnFkVHhvaWlOSWNmR2FkMWtXQ1JWamhXM0pmVjQ2azYrTjlLb3M5dmh4RlJsRVk1M0R5NUFzYlgvYWczSzlXcEN1dDZjVTZPdk1wcVpYNW9EYzlyYldKTkVpbEV4TWZFWVN0RmtRSzU5VEdoWXBJRkhtSTVBQXV0dE9Sb3FuM1RQd3NuTWlseG96Z1FLcXBCaUdObVlJUi8zR0IwMk9uYmVncXc4cVpwWjhlR1QwOE9INnVOMjVFblZ6eDBQQmFDV055eXMzN1puY0pIR3ljMUlkQUJycmJiVHByUXJYSW50L29STk1xd1JDNGtuZjZpR09sN2FnS0IrMmlLTUxFV2RjbWQwQ3RqMm1PVzRJZDdzQXZGRCs2MzAzb1ZpWExXQ2RwV2tab281bWJtL0ZsODU4d0lHbkw0YUdwcldLc3VTNW1peW91SEV2UEhHOWd6b3kvdkkvdi9BQ29odzQrWEtweHl4a3djTGpKSkh5NEl4ZFJ4UUVXdVJzYXFGTkY3bTJYT1lKREFIVlVrY1c4c2R0QW9Pb0pGRmRUSGtreElZWGpqOVI0QXpjMUFiaWxyTnk2RTBTckpjZkR6SVFtSE8wbVc2ckl3QUNua2IrVXNOdERyK2RDTnErM1R4SzNES2hsbWRWeDdSYUl0d1N5aTQwSGNqNFZSeXBNaDJaMzRwSjZVZ0NwRmZuSTE5R0JHNEIvS29OTXVJbU0wT1ZJeGpCNWdZd2J6QjlWSUlIMG1xSmUzejhJekZIa0txcWRYWWxTRy9hVi91NWRMVVN1amhZcmU1eHpCSlkyeklpV2tEa0lwUURpcHViZ3RlaW11VlBIN1NZTWlWWUJZcGt2Q1RKSXhPaU1PSnNQR2lPVkZCbExuTEZLdjhrQnVseHpqS01MQXNvT2xocWFEQzJNK043a3NVYXJLK1EraFFjdVRKKzliV0ZtWTdVV3UwR2dUSGNTa0Era1ZNYzdCckVrY3JXSGx1ZEFPOUVaUGNzL0toaXhaRmpEaVdOZWNvYTRSV3VnVzMrMEwrRkJibS9iL0FQbzRJb2tDeHhLWlo1dFZCY202cWw3Nm05Z0tEbDRVSWlsOWJQQnlIbUJkWVVKUW91bkYzdGU2NzJBMW9hN1h0L3V6RkpwSFNPS2NxV0RjU1ZYOXFuanA1Z0I4S0NHUWNpWEZra2lWWnA1QVlZbmxVK2NXOHpCZnFEajhLREVJcGx5cElJeS9DTkhKZG44b1lENkZJODNtSjFvS2Z0M2FKRk1LelRhK3F5MzRMSWR1Sy8zV1BUYWc2MDJONk9NRWhLeUZQS2VBQUFON254TnU5TVJubHljT0pBOGg5T0N5a0JkU2pFMjVjZXBCb3EzL0FJMTdrdUI3b1B1dzNvT0RIQk00SUhFNmtnZjdqdmVxTy9nWVhzUHUyZE42QlNPWlNTclJBV0FRM0RBSGZrZDZnemU4ZTA0K1BrQ1I1Rm42RGt3WFViTU90eHRWUmlqeThOY2FXV1NNQVJ6bGdGdGQzYlRnVi9PaGpITEppUmpFTEgxWmxJV1ZHRmdoNVcxL3V2ZmVpdTE3Z21YTDdYa3JBb2hHTWdNa3ZxRG0yNEFYVWFlRlNqazRzczBNQnRHV2tCUmlkd3BBODVzZHVJL2R0UlhQWlRFMFdMbFJqRmR3N3pxV0o4amFxOSs5K2c3MGlKNXpaY2g5ZFlBNnlYamp3YjI5TWtEK1FLTnU5QlAydjNETWZJeDQxWndzU1NmYWxnUUhLYWNtNlhBdmFnZzhrekVnd0JtVndjaU9RM01jbXA4dTl3MmhhL3lvUnRYSWVXZUo1TWlSUS9rcyt5QWpVZ3IreTQxSGFrS1M4NWNyaHBaZ1RKd0hCUUwrVUliK2JTcWplekhFaWFLUHlzaHZQS1JZM08xQnl2ZDhxUlZWSXlIa25Vc1FkQWhXOXk5KzlRV1FlNGtMR25CWlJaSE1yV2ZnNlh1b3Qwc2RMMFU4dDVsZGhIR1paWDhyTURxeDN1RDhEUWluQ3lzYys0WTZTUmZkejd6UlN2WWxDTEtoNC9WeDMrTkJyLzhBRTl3WEx4UXF4VGhsZEJHREdnVmQxNDk5T3RWSEg5eHdTdVcwZWF5dDY2ODVVR2ozRGZVb1c5MnQrVlJYUXdNckt3dmJUSGp6SWdsS0NkR2p2YU1IaU9BOEJvYUl4WTN1djIrUU1kRUFSMmYxSlc4cUFrNkR2eVhyUmFwOXhMdDdaSWhtV1BoSXFSSllobFZ4eUN2L0FMV3NhTEdWZnZUakI0WWxpVzRNY2NUY205SWpuWVg3bi9Lb1loTStOall3angwSzVVL0thV1FLU3F5TVJ3QjZBOWFDejdmTng0NXBmdkJLWWtCam01M2VKbDg3QzIrOVZFY0wzakZpOTlIcEgwWWVLTUNqWHZhekZwTk5ibnZVWE5oeHQ3ZThlYlBLclQ1MHpwSEI2ZHVNVW9rMFhpUDI4TmRPbEtUOEY3bGc1MHNSeWhKL0c3TEU4VE5Zc2x5ZUlZWEhsUGVxYWhqTGlRT2d5WlpCQTBRNXhJUC9BTVFHeWN2OXdKMzdVU3B6KzRZZm9zdnBHVDNOcGJQajZqK05EY0ZXSnRwc1JUU1JSbSs4eERMeHNpTWxrUmVVU09vYWFLUnlWWlp0TEFIcGFtbVZ2dzhTTDNtREl6ZzZ4U2xoRk84aEMzY0M2dHFTZk4xb1c0NTAwV0c4V0Y5c1h4dmNZWmpHczdEK0pBQ1NBVDFCUFhwUlphaG5KN3RMSmwvK2ErUmxSSjY3dWhMbzYyQ2x0QnNPdmhTa3daWHRvaTkweGtlY0FTWFNNaXdLM0FaaTMrMXQxOEtocnZUWXNUZXp0Sks0TWN3VWZianlzYitYa211NFBRMHcvcHMvNDU3SDdjMXNlU1pvRHE4YmdBcVN2KzA2ZUZXSlhOOXlXQ1AzTmNmSEM1cXJkSUZkZGxYNnRELzhpZDlLVWw0VHdZc1dlYWJJek9jNGdDTUlwMnVaWXR2cTBBQUFQMDBITnk4MzJsWjVjbkVrWUtMUGl3SHplVW42WkFiMkkzRlN0U0k0YzJPa2N5dGlCY2dPZnQ4b3lqK09PUWNtVW9SNWtZYmVOQXYrUjVtTEQ3ZGlKaFF3NUtxdGpMZHRYSjFIRWRUc2FYaG41bkxuZjhmOXhNRHJKbWx4RklXQ1k0OHkyYTVLOFcwMEk4MnpVaS9VL0NsWTRrejhxWXI5akVpbVRGWGpmbHowQ3JmUmczV2l6cDZISGI5NmNkVkJjZ2NEeFVmVHg3ZUJvbXBtZDhiRGt5Y01NOFljREttVUQrTkpBZktSMTVmclJLbUpzSk1XQVlhTVo3OEo4YXdDT2QxNWpjMnZZMGFlZTl6OTNPTGhaZUpGaStsRm0vOEE3UkVBUUZWV3Y1Q2V4MnFHS1A4QWowODMvc0lCaVJmZXlJcStyRUxnK21vM0RtL1hjR2tQcnBzbnpYeU0rVmNzeGlPZFQ2UlJoZU1ycGVYc3R1dFdwT2szSDJxd3RFQTJOSTFoSkcxd0pGdVVmZTVGK3UxRlovY3Zlc3BGYkdtOHZxeUFzazFnamhXRGtOYnBTMGsxZ3pNcEZSYnBHazhsNVlZb1dLaU5CZTZuamZqeUJ1dFJaRThCNTI5aW5TWElDTko1b1VrQUVyckdoS24xQ05kN0FkYVErdTNPeFlJbHgzYkl4NUZrYU5aTVlXSWpRcWVKVHFXVXJyNEdvdGVxOXM5NWtoeDRtRW5yWlNxTE1EWVBDRnRhMmgwclVZcmZqKzVaQ1JxRWRreDVtSEdaUUFlUkcvSDRiOUthWWhMRkRqNVQrbmtxa1VyY1F5WHNXWHJZNnFUM29JNGM2UmU0dzN5RzR6WFVSaEMwbTlnd0cycDdhMEhVVEl4cGxJNGZjU2tuMVNnNHVqWHVYNG4rdFZsbXhQYnBHeE1uTGd5T0pWdUJTUzloeTBWaXUrdEZUOXVrenNpS0NUQ1ZGbWl1VWtMRlBPbWdRc2RQRVVNUW1rKzZMTUxqTFZYYVFMNU9NcTZzMm5ic2ZqUW5EblJMbndUUWxNbVF0RHJFU0xJWFk4Z0U2K2J2MXFLNnZ1WHViZTV6eXQ2UWx5Q2lKS3l4QU1raWI4Z3ZZVlV4bGFTRC93QmNmVlJaWkpHQWluWUZaQ0xXMUEwSzBHYjI3M2ZLdzRqUElGeWo2Z3gyeEp3U1J5RjdodHVKOE5xaTVxaWYwSnNpV05FYkh5R1pXbERXc1dBUDRIWHBRY3ZQd2NnWlBxWUpabnhtQ1JoRGZnd0duOVRVclVycmV6WUhxd3pKUEswTFJjUjZUclpIYmMzV3JFdHdzaVpCeWpueGtaNGdWY0M1Qy8yY2RldlcxRWhKQzJOaXorcml1eXFBSmJrSGpKcHVOeXBXa1ZaZ1lPTVpTdnQ4Um5TWmY0MWR5WGpaaDUySUhRWDJvaHRtQ0NGc0NZdENWZGZJVDVIa1VrY3dlakw0MEVHYjNKODVUTEpHRGpvc1F5RzgwVHBxeThtVDl3dllFMFhHNFNZc2tpTklvK3pnc3VSNll0NlRGdDdINmxKcFVqUDd4bFNTSDBmUmp4c1NFQmtTdzVNU2JCazVha2VBcXBqTkFjVEtobWtiS1dHVy9MaTZHN0FmdExEUUthaXNrWmhTUGlZM1NSNUxsMjJhUG9GTzRzYURvbkZrZ1VaT09PTWJBY2p5SHFXdUJ5RGRQalZSa21sU1NleVNDR1FNYjhObzdmU3pOKzhOZlh0VWFkR1RNejhqSngyeVQ5eGt4WHVWdWZVMUI0QzJyWEk3MEpFc3JQZ3lKcFBVa1QyMlNYbEt4UlR4SHByWW9ScmNpKzlFOGNUM1BNeWtneGNhRGhLb2pNcGVNV0l2L2VkajRDaXlJdjdqTGlSOG00dDZ5cXI0NUFLbGw3bGR0VGU5UlcvMjdKZ21CYmtEbGdnakhpNWNncC9lcCtPaEZFeHF4WVkxbVRPa1Zac1Z1WWt4MmNjckVXOHdIMDY5YXFPTDdrK1JoNWdrZGtaVUEvaVlFV0pCSlc0MXVCMnBWZzl1eVp2VEVjN05KaXRkVWxlN21JSHpYUmUxUlFxVGhKRXhYZFljZ1hranNTclhPck1vMkEzdlZSYkZucE9yd1RzTW96dVZnWmtCUEsvRURtMnEyVWFWQlJPMldnbkU3UlRRU1B5ZU5ySGxZRlFWSGRlbEJvdy9aOE9IRGFYRXlFa04xa2ZGeUZDU3NCci9BQjh0eDNJTkpGdFVGSUdaVWFZUFBJRmRpcFppcms4bFhYcUJRUDJOMWhHVmsrc1FpSGc4YkM0S05lN1ZVZXZnd3Y4QWpFNll3Z3kvdDFsVWVvemp5OFR2b05ybnJSbVcrdVo3KzMyT2Fnd01xUEtpOU1oa01ZQ3lBWEFCdG96TGZRMVRkYy9Ga3lreklrU1dOSlVzc3NjaEtOYTNVZjI5S2pScjdpWlBjY2lHT05WZHdWSlgrU003M0FKNkhiWGFpWnd3REtiTWdYSGsvbGxCMGxCdXdVRDZRRDJvdUpaZVZDa3FRdEdIRVJEL0FISEs3Y0FMTXBCM3RRZFNMaGxZRTBrQWtiSmE0WVJLR1RUVU02MkJUaVB4b2E0VFJpTUZGeXlza2lubnVxOFNkU2I3MUZTeDVBK0s4WnpFUjQ1RkN3c1NZWkwrVVBhOTdqclFaRnk4ckZuUXhTTUFDZENSYlhUWWIxblc4ZFhGY21WTWdjQ3dieXlCTHZmclpXMDA2WDBxc3FQYy9jQVlMRDFIbVQ2SlpHMVVkVlh3b3NqbisyZmVwTi9FckxLNURpWlI1MUlPaFUvdG90YjU4YWNDWVE4NUpwUWVjM0svSmJna0FyNDcwWmpLZmE1aWk0Mk80RTA5ekpFNTRrS3R5Yms5clhPdFJwVml3NHQzeUEvT0tGU0JJRkpDa2dnYWI2blkwRlh0K0xMbFRyRkFuS2EvTUxibGV3MStTcUw2MFcxMnNYMnZJeTVIanhTdm9pM0R6S0RKYytmMGpwZTUzdHRSTlN5T2Z0OHlPNkhIYU94eDFGL1VrWS92WnorMm9UbDZXTDNTZkY5cFJaUkNVbVBuYlZwUXAzSHlyVEdjc2FlNFI1T084b3lPYXhNSW80WlR4UWdpNFlXTnpidFJYRmdSWTJiTGFhTUl6bTZFbmNhMkM5YUx1aFBjRk9USkVzU3JpZVV5NmtFOERxUEwxSk5ReHY4QWJzcjNCa25BeG45SkpBcGNXc0F3dXFYSjFZaWhZejQ3cDkxTE5PaXZoeEVlb1VZQmlyZnRWeU90dDdVV3V2RC9BT3VHVGo0TVlhV05yUzVVUmJnUFdOMlMxL3FzUHB2dWFySTlxd3Z1Sk01OGhYSDIvS1JFUlZJVzdmdklBMnBPajZZSjVaSnBITXBCeU9SVXhxUE5JRzE1TXcwVzNZVkdtalA5Njl4a3d4aXhTSjZVQ2NWSEN3UlhIbUpPZ3VLYWtrWll2dDhhS0VTWkhyTktwNUJDZVNvZFBPdlJ1dndvTGptNC9wUnBqTEpIREVyQ2RrM0xFV055YkFBN0VkS1VrWVpjMVlCSk5INmNNTXZGSHhiQjFZazZsZE5yQzVPbmFxVmxnbWVSU2s2c1lJeVJESWpMRXBNcld1QUJjZ2pTaFlnM3ZFM3Q3TEI3Wk03U2VzN0YxVURkZU5yTGNtMnZoVFQrZDdhWkpzeGNkRWFKR25uaVpXZFZiMWVEblVudG9MQ2doalR5NWpKSE53RWtZdVpMV0loUUFMR29PaFBhaVZvbWpiR2hhYUVtU1VOeExFbFFyRVdXTy9nRDlQV2cyZXlDU0RqSkpLVGtTRUkzRUQ2djJtdzZDcWxlb3dvY2NvR2tpdktwSXU1NVhZSFU2K05WaFZuWWFKRkl4NHhPcTNzeDRFc3h0bzNRQ3BXdm12T1N6NWVPSHlHWmZVamtWVWhaVHdSd1ByNDdra0NvMDJ3NCtZYlNXamZJSU1yeUZRNkMvWTkvR3F6YTF3UXZsUS9kTVE3UWVYakl4STFQMXJIMHVPdldoclRIa1JSSXFnQjBEOHlyRGtwc1JaWEdsL2hRUVE0dVJCS3poWWtqZmtJRSt1VWtrOGdQcFhpTktCeS9hdk5GR3Fsb2tVYXgzSEkrT2w3NjBOWU0zQ3dFeno2c2hqVEdRdVZLbTdiQ3lxRHByM3FqU3VWaHpLckV4UXhCT1ViSXQzSVVXc0xmVGZ4b2pwUWU3cTd0aWpoSXA0QkFubUJzRHFXQXZiK3RVYzdGZ1diM0JaNzhaRVBGbzlySjN0MzViQ3BGcTczTEF5WlpueWcwa3BrUHB5SzdYa2tMQzdXdHNCK0ZDVml6Sll2SzhSNVE4RENpSWhRS3ozTE4vdUlPbXVwb1Jtam5tbGtqU0lyaVl4VVJzVTh4c3BCTDhpQllzYWhpdktUM0ozZ2tkeE9BclhNaDVXajFLcTYvdE45YjBPR2daWHVrc1dNL0YyNGNsQytSNUh0b0xKKzdqYlVucFE0WnZ1OGFYS1JHeHdzVVFWSjRrRml6SUMxejhLR09naytJUklNaFpKbEpEaVpoY3llSEhUamJxYXFLOHVmMitWNDhaREo2RVJIcVRhQU5ZLzhBY0NrWHQwVUdpdXRrUXh4eFNRcTdCRzRzc3NxSGs3a1g0Zy9TQVYzdlJJeGUyWmVVUU1kMUxTVGNsVmVJMmJUekJ0anBwUXF6SHgwWkpJQ3NpU3FBWENXQUxrNkpiOXhQNENoclZFdVl1RE11aXh6RHpiQVhIN1IxUCtkVkdOSW80STVWa2x0UEU4WXgxVUFQNWU1MjYycUswNFVFa2o1R1JKZEhsUnh6M0ZqdUdKL2Qwb05HSDdQaXkraGtSUDZnOVM2cHhGMEtqZmorN1RhcWpMbnd6WVVqU1B5T1RNck5GQllGR0JQSGlBdldvcW1hSG1QdW9uV0hIaUNvWWRRU3lqaVNxL1VWR3RWRkdMN3hqcGtHSXpQS1dRSm1PZ0NLaWhqcGUydWxDdDhtWkJnRm53TEkwNjN4d1NodW8vZUcxNG5qcFFZOFNiSHo0dnVjbTNybHdBc1F0WmRtZHI5OXJmT2lyOFhKaHhqSW5xQVEyZEJESU9VZ3NkUmZyY2I5cUl0a2dpaHcvUlFsamhIbDZpN0QxTlFxSWVvNWE5cURFaTVReGpLWkY5VkNaU2Iza1VLUEt2WUwvdG9MWTNtNEdjTjY4c3lpWEpUaGM4bk92RlI5STEvR2cyNHNzbU9ZSmNxWCtPUVBkZ1NzaklnN0R6RFUvT2tLclNKSXNvU1FJc2pFT2dWcmNnVUlaWFVYT3U5QnVFc1RUak9XUWZleCtjcUFkMkhFSUJzVzYzb21NVDVlUE5HWDVlaU9WcERmVlRmejNQajBGTlhDR0ZpdjZPS0prWElXMlJJekM1Q3I1dGZDM1NncVByWkdkempraGhuRHN4eDNKWWoweGUzYXpmMXRRYXZidmNwY0RMaFdETVpKRWNISXhtVlZZUlc1ZW1pOWJzMVZLMmU4ZTRlMzVjcy9xUEpJUnk4Z1FLVUFGMnNUWUhqNFZGY2JGZFpWZVJGQ3lCMllHSy9rQzJDSFc0dGJkdXREVzl2VGxtbUN0ZjFPSW41S05HR3BkRHBxZHFESm00M0tacEVsTG9nWjBoVzVMQlBwVzUwSGU5QkVaT2RoS21Vc2pldklHamFRWDgwYzJoRDdnRTNzUHpvV0tKOGRzcWVNbVp5a1lDeE9iYXFwNGhTeDdIYWhIWDVRWmVHSXBMWXNVU3NqOE9UT3hYVHpIY3NlKzFWR0Y4V1lZeWxWZHdyQ09GRjh2SU0xeXZocHJVVXZiWUlZL2VNZjFHZEFqbU9iblpWQkpObDVINmxBNjBIY3pHZ2d4Z3pJNktRenJxR1p2Tm9kZjNhVzBxb3d3NVdKN25sSXhZNDhnSVp1VEJFVmwrb2xyV0F0MG9jcHd0QkpPOE9TNlJ3UExjTTl5QUQ1YnFUcjVyYVVIQXpjM0puOTBreHhHY2lLTUU0MHk3Mi9aSTF2MmkyMVphYnNCc1dMSWllWVc1T0ROT2dzZ2JiZ0FmcUkvdUhlckVyMG51RS90TVRONVJ3Y2FyZlh6ZDdWY1RYbXNuMnVac3lPU01BQ1E4b1FvdVNSdUFWN0M5UlN4OGJKVjU1NEJOSndqUVNMR1FDUXgvem9PUlBMblR1MlBmakp5WjQ1UXdqZG1RR3kzR3R1MXQ2aXc0U0pNYUpjdFoxOXpSMldhRnZwVXNkT0xnN2Z1Sk5VZWs5dTl1Z2xWWnBIVWdmOXh6Y0RtRGZjL1ZmUUdpYTRIL0pJcG92ZE1kNDNEUnlBQVJYNWlYOXFzQVFRcFViWDJvc2J2WlBmY0wyVnA4Ykp4L1ZsUjFhUEpDMlZTYjNWNzZGdjdyYVVUTk9YS3hQYzh2T3ljUlZoaTlhQlJCRllrS3A1TkoyYmszbEFvZE9WaysyTzJObnRFM0tTUnpQSm9BNFZXdHhkQVFRQmVtR2tWd1lYaFB0Z1FyQ3NuclBsZVdONEpFQXNMZGIzTlFaOHpJWDI5d3lqN0dlT0JvMFZyL3ljZ09Fa0lHemxEdWFhdVBRZXhNcy9za3J4U1J6VDRzZkxJaXNmSnlzUTFpTGVHKzlWSzQzdkdCSVpNYUFURGhMeWtsaEsyQ094TzE5RDRHOUZsUzlxalgyc3ZtejRrZVZQWXh5bHpxcm00VjE4ZEw5cVltdDJMN1pqWnZ1QVhHazRPNExtYTRVQ2JqY0tVUDFXMXBoYnd3NWFCczZYMUZURmtoSVdhVlBLaHV0cnZ1VDMyME5EV0xER1RCOXppUm9QdUdUMHA1MkZ5QnlES3lLdzZnWFZoclVYRmtIdDJjaGd6VnVKME1nbmhkeW5xcXgwMnR4VURXM1dpc2MwVGpKaVNjaVpFa3NSTHlCTE5jY2d3dHBmNlFLVWpvNUdIbFl1TEZrNTBaVjVJN1kwSk5sWGczSFhkdVI3bjZxSnEzMnlmSis3UWNYVWVkNWtObDBYOXRqMk85VkM5N2dFSHVzbWRqczBrU0JXVkdVMmtXMTN1VjIxMHFMT25GeEpNbVdHZEM1TXFhTkdDVHhUY0hYNlV2VWFycyswNUNqS21sbFRIVlRZTk15bjBmTXZIVWdXRitoNzFaR2JYS2VlZUtkeExHUjl1dnA4cmdxSXkxa2E0MU85RmE4bVdERnhZaEhpTExpUytkaXR3WXo5SVpUcmZ2UkxOWVBjL3dEajVoeFFYaWZuR1RLc3drQjlSWFhsYmlQM0FlYTlTeFpXMy9pdVp3OXF5VXkwYkp3WmVKbmV3WjhlVS84QWF1ekFuMHoxNDFZbjEydmc5c255Y1dYTXhuVW5HUlJrNDJQNWp4WFJtSDRpOUJsd0Y5eFNQT3gzV09HSmt1eGxZZ3FMaGxlUFh6RmVnMW9ycFFScWlZekc0bVBranluWUx5UlJiNUUzMXZTRmN6M0wycEpKWjJJQ0RHVkpqR2pCd1FXc0dVbjZ0ZWxEWFA4QWE1c3lYM3IxbGhPTkU2Y2M5b2dJd3lNTDJLamJUWUNvdmpMTmllNFBONmNXSVZXUlNPUlVjL1J2b2UxL0doc2FNUkpNQ1ZzbkNrUlo0d1VDU2d0eTVqNmdqZVFjZjlhSjJwZ3hZVDdoZ3daaExDZXpTTTdBUnNXYjZVMS9PaXVobDRHQkRMay9jUnNrNnVidzJYaUNUYmd4SFExVWwvQy8xV2h4WklIUEdhVGlHamtOaGExZ3ZFZzJaZWg3VUt4WVV4eWMxc1JKMmlTRjJlSm5VSTdQYlVFZmxhb3VPci82TllNSmNpVzhrZ090dExMYlRib0txYnJYN1BsaE1ITHhza01NWEtBTVVhV2F6S1FlUzN1dzA2aWtTcWZjNXZUeTFKY1NZc2lMcVdCbENqUUJyZlNWT2xWSFB4NHN5TEpiSWlqQ0VMeWR5YmhiR3hPdmlhbUxyYkhpWnhrTWsxL3VNazZ2YmlyTUJlM0s5MS8rWFdxamJOa1pyT3JTTklNMHE4TXFCQVFSZlJCYlQ1MFRHU0IzOXZ5c2ViSUxPdHljaUlrcmNnK1JnYmVVaWpUbzU4MHh4SjVBVlF0ZU85eVNTM21QTTkreG9qayt1TWdzckdXRGtWTHd5c2JsMUhsNEMzV2drTXVXRitTdi93Q1FUeGYwN2d0S28yZFBxRng1YmcwVjFVeUYvd0RWUnpUNHhsUXVWa2tUaXhDQTJjY0RZOGdQcG9tc21YQmcrNFlrY09QT0kzT3NMRVc1QzlsV1MzMHRiVzlSZFZuRXpEbDQvcU1yVFJqbXJYSE85K2grbmtiYVhxcHE1ZmJiUlRaMkw1K0Y1TW1JTndsUjNKSERnUHErV3dOVEZsNGN5TEc5MUV2cGxnWW1DdXhkcldVRzZhSHQwb3A1OGs4akpsd1RSeU9TZlZjRHpYdGJpdzZjcVZJNlhzMmI3WmREbVJ2OXdVNU5pc1A0WFpCOUxYc1I0R2g5YWxsWStQaVFSWitGTEVKV2tKbWlqdnlqdVRweE9yV0cxNlVqbWU4NUF5TTQrdThieVNMWm5zQXFxQmNGd3Y3aDFxVlpIT2d6UGNYa0dPTXNwQ1ZFTVpDOGJpNDRnanJjOTZhdU9qZ1pmdUdMblNRWmtSVkZJRWtadW9VZy9POUVkZjNmSzlsemZab1RESEpGbFl6MlZUNTRwWXRiR05qckd3NmpZMVV5dURrNUR5dy9iUnR3OVJsa2FSQnhqSCswMytrM29ycGV5ZTNNL3VFbnR1WktpbVR6UkFPTExLTnRSY0g0VXhOYVBmTVJNVjBjcTBiblNRQmJBMjJLcjJOVkk1UHVNdVVzaVF3U0J1YWNaSTBVRWhXMXRjZUc5UnFKS00vSHhNY1kwM3B5dEk5MFpnb1FSZ1dJUDFLZGRmQ29WWGtQZ3paTFM1VHpTU1NxVlNUeXNRL1VtMzdYT2lrVlJrdjdiS0VnUnBJWXd2bmpjY3VNaDBaMUkzR21sUlZza2VSZ3daWHQvR0xJeDdySk81NCtzcTMwWkxFMzN1UUtDRW4zSkNMSElxUzQ1L2l5STE0ek9yQzRia055QjBvTlB0RU9WaDVEVFk1ZHBmVGIxSElzc2tOd0dKRy9oUVR5NVpQU2FiR1ZKSURwSkRPQXpoaWRQUzZtdzB1YXFSZ0VnVnhFb0VTZ1htRGcyWnIzK21vcnFZZVJuU1NwS2hlSk1jRk9NUTRtQlhPb0ovY3IrTkJkRjdKaWU0ZTVTSUxTT1NmNEcvaExsUmV3L2JjZE85Vk5XWTBNSXhaOEx5TEl4NUtTcXMxbEZqRnkyQzBrUzE1ajNLUnNkVVV4OG1nWWc4dFJaZW5IcXZqVXJVaXYyNk5aY2tTT1dTSUhseVg2OWRicC93REhyUlhVRVVjK2Q2c2JKSEtQcEVubWlkQ0xLT1BTM2MwWmlxRDdpQ0Z6Q3lvRUxDYkVKNUU5T1MzMzAyb3JzWTJJck84K05rcXpsUllTcXFtQlJvMTE3Qy9TcXk1T1RoNVVrYm4xRFBGektDZE5YYmpzU2VxVVZYa1NFeHdSeWdCZ0JGSThaSEl4OWVYYzlyMUIxLzhBME1jWHNUWmdsV0lNYnd5Y2xMY2R1TnZuclZpVzg0OHlrYU5ISkJPcmlTeDR1TlJ2OVhoVWFYNHA5d01HVC81YkxHcEFta1FrQjB2ZjRBOWFGVTQ0KzR5eERJQnppSXV6RzVrQTEwUGlLSFRXdzl2eDhxWm9aTFF1RFp3b1l4bDlrQ0hVa0hTOURsa3lYU1pGZUNCb2xXL3BseUJvdWhZV3NTYjFsMGF2YWZjT01seGptYVFxVURFK1hYVXQ0Y1JWWnNhUGM1WUR4amxnZFUrcGd3czl5T3g4TzlDTk9EN3BOQkNZb2xFYXl4bEVVQU83TmJRM08zYWpOaTJIM0diQmFCSmNjUXdLV0VieG16dTUwWWtuZXgzdlMxY2M0d0o3a1o1WnBoQ3NJWjliaG1KL1l0dGRheTA1d2trVi9UYU1MRXdQckZOQzZ0OU8rbGw2V29LQkM4ZnJqR2N1cmdSQmxKWGx5M0hIKzN2Ulhvc1hLLzhBV3hKSGp2ZDBVRm5WYk9YL0FIUjY2QlZQYXJyT2FmdVdKbk5sTG1aVW4zQVFqVXR6dU9ON0MvUURTb3NZWjVaWGllUlI1c2NnS3NoNWFNZEQySm9Ma2xlRlltbGpVd3lFdk15V1k4UnVGUGZ3cXBqUVBZOHpJUkNpTndaU1VWbHNGUzl6dDEvV2hwcmcraGhHR1FCeXB1cm5SZ3Q3YWp4cWlHZmpDS2RjSkpVYkxsRjNaUzNwb0hBSlJCKzF3Tno4cWxXS0RqUU5oaDQ1QXM2UDZheDNZbDFYNm5zZExMMm9KWkdRV2ppbmhkdFdMU3lXSVlNbmFUNGEyRzFFYS92NWVQT2JJa2dlWFJXakZ4d2JmbWVqY1J0VFRHbjJ1UEhYRkdSejlOR0pOaWJzU2RPU2pjQ2hVTS9IUjg5VHdMcDlQMjBOd2RCYmt3MzhhRVV5WnVWQ3pRcGlKRVhIR04yUElvTCtabWJxM2owb004TWVVWXB1SmthRWFJcitiek93QlpyYVhOci9BQW9ybWU3bG9XaE1JTFJFK281SnVHYSsxcmFEd29ST0pIOXdra3lzcGpFRjV5WDRrRUZUcHlJdC93RFVMUkdpR0JzUExoNHc4WlkwSm5tT3NnYVEzREcxeGZZQ3FWb2VTVEltZ2hoWUFPRUdTQ3hpUXVHNUFNRDB2cDJvSmUyenJCN2prUVRUK25rVE9ibGdCRUZHcStZL1NCc0xVSzA1M3BUQXl2aXQ5c1A0bzVJd2VEU2RDeDZ0YmR1MmxUUlcrWGkrejVjTHhTaWRIdUdtYU1sK0ZyWEFidWRGNjFUTmREQjkyZVlJWXc4Y1lKRE9vNUp5SFM1M3NkN1VUR295UzVwa2dhMHhCRFBPcHVvYTJpWE9oOGFxZE9Ua25MTTh4bEg4aGM4V3NPUFp0enBVVlo3ak9aTVhIeE1WSGk1YzJrbVVtOHFINmJnR3dDQWRhR09sN0dZc1hHbm15QnlpOU1DT0c1RXNqRTNBQkE3L0FKVlVzWjJ6UkRQSERPUUhZZXEwYWk3QUUyODNRVzZrMUREeXZjcjVFc0NSaUNNRG04aGExd28wRjdiZHU5RmRMMnpKeHlra3NwQVdRTFlnbTF3TnYvbHNOSzFHSzVHWGpSR0xpMHJDOGc5V04xc1hpVVhDaDlUcitkRjEwOFhGYVRMV0ZINFFzUE9icTcyWmJEa05BR3FwcXZKOXY5S2FSeWpBWEJ1RHhhLzBodjhBNDYvVFVYV3ZFaWxSbm5XUkxZNzJlSnJGN0VXOHAzWVcvT2lNdWRQa25OZ1dXUjRNTnIrb3lHOGdSallEVHFSUWM3UGRHeklZNEZMeFljbktOWGNvNVZUdnpYeTY2SGxVYWJzT0xPOXdkaEZEemdFaXBMbGtXdHJjaGxHNjk3MVdTeWc4enRpb3Frd0FMNnlYQ0MraWNpT3U5bE5GWjFaWXBwY09DU1E4bVVyWUtoS29kV2R1aWcvMm1nM0RDa3hNbVNmTGtIcGk4aVNBRW5tUjhQTmNVaVdxeDduaHNza09ReGlSN0ZvNDExQ3Y5Skorb2thc1ZvSFBrM2RzdUZvb29rS1I0L1loUnlVT05ianFmOTFCT0xNeC9RRXVYbE02VzlhVWczTXM1YXdTUFRSaDFvSURLUnZSeTJVeDRzaE5zWFJtSkpzWFkzRE15dHNLRHFZUmZNZFlZbzE1VEZTR0NoSENMZTQ4eDE4VFFPUnZ0MzRsbzVTU3pvb3Vic0JZY2hwdFZHS05aSmNneE1yY0hBVURRRWthMkJQWS9uUTEwbDlxeVljVDFKSTNHTEw1WkRlNDhyRUtoWWJiNjBScnd2SkJORGpUckhHM2xMYVhZQWVPbnpxb3llNDR1SkJIRE5kMnlJN3NMSGlyT0xjZHRhaXFKb1JtQlZLcTA2a2xoWWkwbkc1T3RyS2R6YWc0NURMalBpd1F1ODdwNnJaZC9yczI1SFFJQm90UlhTeG9NYUhEYVdTRlk4Ymc2YzJTekxLd0Z5R043VlV5cTRzckQ5dWZJVEdqOVhJMVJjZ3I2Y1lVQy9QL0FHN2Iyb3JMait0azVzaGlqODM3STdhV0lCSkpKL2NLSTJPMEV6SzdzWkN3RXlRYWprUVNEeGYrMEg5S0RBK0ZtcDdtR21Zb1g1UGtLcXNkamZZYUFpb29TZjNCdURLLzIwaEJDcU5USXBOaVhQVGJTL3lxam9lNGU1eW5GZyt4aUw1VWdWYzBuY1cvYkhmekt0dGFKRm1Dc09abDR6NE1uMnYzQ0ZaSmlqU1hIMGxWQTZnN2RhRERMZzVLZTV5WmFNWitETkZFQnA1Mkd2bFUzdHA4S0tuN1JIaUYrZnVVakt2Qm1rVnh5UXN0K0F0L25VaFdSY3JGWEtZR2QvNUxva1JObFM1dnlZNmthNjFZbGpyNHp3dy9hVElxcjZCUVN4Z2FCcjI4N2F2eUgxYURyVlJqend1WkxKbHpCUDhBMkxTK282RlRjeDlCZnByK0ZSY2RHZjJ2T0dONjhzZnFSRldDWTVieStmWG5kYitidFJHYkFSc0RGWU9qcUptc3lyb0ZHNEJIWmV2alJYVGhCeWxBZGV5NldGOWI3ZDJxb3Z6WTRvYm5JaU1jUVVLb2pJRmdUMXY5UnZRWjVjV0JVTXlNc3F4b0xPckJWTEoxVU1OUmY4Nmk2NXNHSytVc2NNU2hwSTd5c3JFS3QydVN2VFk3VzBxbzFScGtSbFpna2t4NWVYMWRtQ2dqekJmMmp4b0p5Wm1kTXJ6T2JzekVrcUxLUjJJLzI5S2hDZVIzdy9YUUZmVkpDTG9XTmhZc1NkdGJHeG9xSDJNaGdGeVp5aUsvSzVaa1kzSlVuc0RxUlZSb2hnbXlNYjBwT0RKRzVraXVBR0lBdWIyQTNPMmxGWlhsYkl3dlV5WURMa3UzT0dZanlHTlR4SVp1aDdWQ29pSk1pWnZTbFZmdFVEUnlvQWwxR29VWDhXTjZETDdmZ3pvSnNmSVZqSEV4a2daL01seTIxeHNMR2tLMWU0NWVPY0ZQVGlMU3J5NHlrZVU4ZkwrT3RCaEdYeWZHVEhSdVVYbWxVbmphNXZZTjE3MDBzYmNaWXBSa0VTR0NVeWtjMVlwb0J5SGxJMUhqdlFjblBYRDl4Y0xqdXpORkdqRUp4REtTZnBEYWFHb3NyWkxKRk43YmlUNWtVY2syT0Q5dTBSM1FHM0dXNTgwZlMvZXFMZlpmZVhjZWxtTDZNajZDM21HaCtvanBUVXNVd1BHZmNHeER3NHptMFVvWGtWYlV4M0c0NVhxS3h4WUVMek5qKzR5K2s4YmttSUE4SENFalVqVkYxdlZTRkRnNHl6cVQvQnpqZm5reHVlRDhSb0Y2bmU5QlAyekhQdHZ1VWtxUi93RHNZcG9uU1F6T1BOR3d1ekRYUTZYUFdpMnFKRmdPU1BjQ3pUU054anlDNitSZ21vQ0Jkd3FhMFJxOTF3dWJ5NWNVaGx4d3lNMld2RndBUUNSenRwMkM5NlVqayszenk0bVc4a3Q1SWNsd0dnVWxRNEhtVDFIR25sL3RBcVJieTYyWGxZZjNIQVJ0a3l2RnhsS2puR09Sc3FyL0FHNmRhcVJMUDlzelU5dldPWDBRMGNwZEhEY3BPTVNEeWFYNUxZaHFFckd4WDIrRThpRExGSllTeGprVUJISzN4WWtVRU0zTXk0L2NQdnBrVnNxVlc5UklndHhHVTRzQ0c2c1BOZnJVV1J6dlpjeWVUM0tMSkJhT2FPTlFveUJaVzVYYjhOTExTSDFIWCs4bGxiN2pHTE81NVg1TjVWV1Jyc21vMURXMk5VYlBkNE1iTml4blJIamZIT2tqc0NvNldLZExYdGVwU1Z5L2VKc3Y3TnhrOHNwVUlZVGhyOEVRV0NLUmY2VFlnOUthWXpaWHVzV1Jod3pPWTVNcEl5a3NrYk1oY2dDd1liRFRYbDFxcGpkaSsrUXpZV1BoTkkzb2hDNXgyTjE1YTgzOVN3WURyYW9yRC80dUpaTW1OMW1qRFBEa3hLYnVEb1laRzJzVlBKVFFZb3ZjVmJFeVpZbkNOQ29UR2paZkpLakVxV2NIVDFGQjNvdUpSOHBmYTVjdG9WZkhIRVNUZ0VsSEMyQmExN0RYcm9hRjdhY2pEKzB3b01pSEtTT1lNc3FRczNKcEk3WEQyMktOc2JVTzJUQm5FcTVxWjQ5TklsVXNvY0lWRXA4b1VIWGdScHByVUtzeU1YMitQREgvQUs1WnpPL0tHSkVhNkdKUUc4d0cvSHNhRlRqdzRvY2VQM1RGeVhIdVpKRFFyZjZSWUYwSzZBZkRyVk44YTQ4SDNUSXhKYzE0dWZ0OExxQk1ibmk5OXlkd05hQXk1ZmRJWTJTU0JjbUtGUmNhTDVDM1E5MjYwRXZiSUpQY2hKSGpRK25OQlowbEZsSHBrYkVQME93OGFzU3NrZnIrMFA2Y0NpV04zRE9yRG5jcnFRYmE2aTRGWmFiUGJjN0VsenlYNVkzb3VaZklwY0pwZFZCUFQvYjBOVm1zY3E1TXVRclo2aVdXZVFreEhReUJqY0U2RGlUM3FWWWhFcHRQSEdxUGpaVW5wUlk4aFdTYUtaZk1QVDYyNmNyK0ZVV0pHY2JKeWNMS2RWbGVEbnlZaVJHTGFyeFpmM2p4Mm9tL2hqanp2dDhpTmZjb0Z5WUkxSHBzV0FIRDl2RjExWS9HaS80UGJ2Y3NOUGNaems0cVRvZ0lpY3lXSUFHbDNIMTc3OWFoam9ON3BsR1VwaFRyTERHVjRTMzFZZENCL3QycW1IaFk4ZWI5MHViSTBVaThwUk1nSEJsSDdEYTNGdTF0TzlFYThYQUdWRHlWVktsQUdERGc4cXIzMzMzUDQxWVdyMWJHaXdYT1JqZXBqT3ZHT2E1V1ZTZDlBT0w4YmExV1dqQ2hlVERqTEtHNWZ4aWJscXpFM1cvKzNUYW9VNWNKMmE2SDA1SWJscE5CNmI3OGdPb3FrYy8zdjNMM09iSEM1a24zbVE0OVQ3aDFIQWhUYTlocXBOdGpVWEVmYnBvc2o3Y3h6cWt3ODRWdFN0dXJYdUdCb0o1SHRyUVBKa0dVbFpRT2NseGNNT2pEVmgzRkJOZmFZbmhPYmd5b1kwajRHT1VjV2J1aXQrNWozM29yYm0rNSszakJIMm1KTGpadkVLWkNSeHRiem5XOXg0ZDZKeTRMUTQ0V1JvY2tpVkFyV1JXOHpYdjVyL0hwUWp1NE9PK2FJY2lSa25kZFpJSTdvM0VIUmg4ZW5Xa0x3MDR2dk9EZ1pHU3VQSWptUkhkUTR1VllHM3B5TWJGVzdFWHZUVXh4SjF5SnNpU2FKWk9McGRRbzVOeDczTjdpbzB3d1lXT3VTaTR3dWhQcHlKYzNNaDJOamJYdFJYVG0vd0NOWkpua2tpSnlERUF3Vm01TXBBRmpiOVJURTF6WTRab1E4Z1J2VzVFU3VOWFVIUStvamVKMG9yVStKaHlRbzBkbzhndVZNb0FWU3gzUTlBS0pxcjdmMjE4RGpMSElKM3Y1NGdDRWtYUlNMbnpLT3RDMUdaY3FGY1owTW5CN3BFRzFERzM4alJ2dGM5ZkdpK3B0N1RFWjVQdFN5UW9BekxMb1FwRjllZ0hlaHJON214aWRFWlBSUXhpU1ZYUDFBblJyamNkUlFHTmppTnVLT25GbFZtNWtBNjdGQ1AzR2czNW51MlZOREZCbU1Ka1JXalFOZThJQkYyQkhYd3BxWXc0eXlRenMwaSttRUliMVgwUEVqeXJjZjNkNmlyNG9KL2MvZElwMHhqUGpPU1pjUjNVU09xaXpFTnBiVHZwU2s0amZQaWV5UWt3eXJMak55SVJwWTdzRVAwcUFEYXFPYy90dUxCakRKaWNUWVVqU0taZnBsQlVXTjB2czEvOEFLb3JtNVVYdFlaUHNtYmhLaFpjWTZsSEFzUVgvQUxkNkJZb1I0MmpMRU5JeTN5WmpvaDIxOExkYUZkdjI3Q3hWT0tEbW9pczVVeXRjaENtb2tEYmhXUFR0VlN0YzJPSmNWWnpHeUx6S1pNd0Z3NUozUWVBb2pJM3QwZk5FblVHTTJaRzNQRnRpd0d1bEYxbnlNVVJaR1FzMHVxVzlIaHJFd0orbSsvSDlLSUZuam5nQmtjUnp4U0V5WkxFM1lzTEFtMzBvUDdxRE5rWUdiQXVVRVlTUXFWVnBnU1ZBNldPNHRlZ2VUOWxreC9hVFlyeVphUjhSNlRXODRBQ2tBanpiM3NLS3k1UHRKeGNOSGRYRXh1UnhQSlZUVDZoOVFOUlU4ek9ua3hNTVBKSDkxaEFpTUluRitGcjJkMTBlK3d2dFJGZnQyUkxPL3JQRkc5M0E4OTdxVytsQXdJT205NkxYZG54ZmI4b3dJdURLMWxaVEpqT3NwTGRlS05ZY1Q4ZGFyTG13eEdCV1NMSkw0eHN4T3BOaWJBTW8yYmU0RzFScFhHSnN1Tm9JNFVsazVGNFpBMTVBcWViaDJOeDNvbUs0L2ZjaFBiWk1QUHdJM2hOM2lJMGtqdWRlUGdleHBLWDU1WVc5NHhta25qR056amNyeGRpYmpqb1FiZC95cHJXSnZreHdZeFgxbktrRytHd3RxMXVCWS91V2lJNU1rZjNVY3NjU1BHMGFHWUtiV1BkTFdvTk9WRjdJbnQwV1NremlXWmo2OExJYlIyK2xPWTF2NDBKMjVMWk9YTEtxWXFHR0YySUxTa0ZleFBOaGUxdDZ5NkxXU0VTUlBoRjJSd1BSVXNHTEhacEdBK25rMnk3MFJ0UDNXU1BTeVpHTTExQ0ZpWFlCdHliNzFVV1F5bjJwNWNOU29WMi9teURZdXBYOW8zNGswS3J6dmNZczNHU0ZsVnBvbU5tT2dWQU92UThqclVwT0czMmZGWi9ValJTR0tsekl5aFFJK0hKbUpZNkRqcURUQ3NFYU1zMHp3QlplSUpETXZLTkZBdHk4M2ErbFJWOGNTWStOeUNONm9DdUF5RzVrSitrbjlxMjExb0tSSzVrRXdoVnVSNUJtMUhLNUxFMlBsdWRoNFVIUjl2OEFkY3lSV2hqeGx5OGpLSll0WWdScXUvRWJDcW1DU0NETGxONVdpanZiZ3RtWjVGRnJXRnVOejFPZ3BpdWg3TDdTY3QxeGVhekJGY0lvQnR6N2FhY1ZOV1JuNnVINy9ENzU3WGtSeHk1Wis3bjRBbG1QRUxvc2ZZYWRxRXNzV3ZqNE9LRys1blhPOXdrSkRPajI0VytvdGZxYjcwd2N3VFI0V1V5WTBrYzJVb2E4dG0vaFluVXFUOVJxTFZ2dDJiZ3llNEJNeEd6REdGamd4Ukh4RGNRYjhtRmlPTzkrdEM3Z3paUUluV0l4SXVYeWtTRUwvd0J0RG9OUmUzY2o4YURDaVk4emVsWjQ0MEhxQlhJRitJc1hjLzNOKzJvcmJpbWFQakpoZ3M2RU1uSVdVa2RpZExyYXFpRFp6cmxoOGtzWVhCZHpHd01yY3dRQmMrSjJvSXdFNDVTV1dRUnhaQ0dXVkVLc1ZLM0FzbXcrZEE4TE1remNLU09ISDlKcGdTT1BJa2NEY3Q4T2pFVU1aSmhBK0s4YnIvSkpaWWVRMEl2NWkybzRyMm9xNkthSEd4WmNpTkhua2pzSFpqNUN4MFljRHNiZlNhSXZ4UGRVZkhoWmJSR0dYaEhBdzVOeHZ5NXlIWm1XZzVxTjU1cEZaMkUwakkyWFpRckt4OHlxcDErSkZCc1B0S25IZGdUTGtxNWFLSmdlTWtTNmNnZkExRFZwa3loQWl6ek9ycXBNTmllQ0YrZ1VhWDZYcWd3UGE1TElrOEpKZHhJeVMzVlNvSGwxR281YmE2QVVMVitDcDl0OTJrbmlBbVFCbVpBdzlNYWtXUmZwNUwwcXhQcWJHMmVSc2VPUkZtV0dHYnp0eDh2SmhicHZmelZVU3hNZjEvNUpJM2tRRU5MSmE0QzlibnA1UlVWWm1QN1Y5eGovQUdRNFF0SUErVE41bEJHdHJEVGgxUFdpVGZVTW5NWE95WnBzcklEUlpFaGpqWWZ4b2VBSG1RS0xDUGJhaXh4cFI2M3ZJeUVqYVNGUjZUb3hJTE5heDVDOTNYVDRXb3Zqbys1elkvdCtFMk54aHlIeUU1akliVWkrdmxBMkpIVGFxek9VY0pKbml4NUk0aEpKSk42a1NCZlQra0FGdVpPdXV4Mm9qb25Ja3g4YVZKNG1rbGxZY2NrVzIyQlVIWHBWR3YyUjhKY2xZWWw4MG5FeXp5a0M1M0p2MEZyYVZZbGFmZnlqQUx4SEltMm1wdDMrRlNuekdESGZ6U2pSNHNQeXp6SXBLaGpvZzAvRHhwRnNZdnNHVlpwOHFRUVE0YUdaSStlOHV4V3d1UmUrdHFDR0xLa21MOTBFUDNZNUNIZ0FZaEdkZUxCcmFQYlMzYldvWHRmN25uTGc0UDhBNHNrb2VTUm84cDM1SVZackUvVHJ2MCtGVkp5b3dzMkdFeVRHS2FVeHlEbEVCeEJQRXFxbGRic2IzdjBvWXF4NFpaUFVubVpralJ2Tkh5QTRnajZOZGRLalNhKzV5bjNCUk5NanhobFZZNUdCampERzlpUnBjRDZ1dzhhcVkyeXY3Um1SenhyTHdaV3RHa2FXREtWdEpNeE4yNGpaZXRFeXJNVDJYRy85UkptbC9TOU1yRkRFVkpERWFFaSt3TzlEZVdOb3J2RkhDckIwQytvUUJ4a21ZMjBVNmZUMW9hcTl3aHc4WXVnWGxMQU9Ra0J1VlpnUTJ2VmdkeFExc3g4aVQwbzhtSUJVbHZGRXkvdVhRRnJicmVnakw2aG5JbGxESmozRWJxYkFnYTJBMTVIa2JDZzZTZTR5NHlST01maVFSSWp5SGY4QWFXNDdhSFM5VkVwdmVNNWxPUEpLUml5U3FaMWNxcmNoNWpvUDJtMnRxQWx5OFpwUFREOFZtQWFOQURvdHRnUDdyL2hRZFBDV0xNeFlZbzBBbWJnK09XYS9LOTFkamZ1QnRRUno4YkM5dHdKWXNsM2o5d2w1Y0k0L01WUTZoVzExRGZHaXVPUkE4Q09MSXNnSUY3OGVMV0RxeFAxY1RVRHlmdlVVUWxlV0p4RWNVazJxeGdHNm1KOWl6QVd1UlRUR1hKamdRckNDelFlbUpjMEVLVUQrUDdqb2R0dHFxYW8rMWxMWTMyb2RjVThseVVaN05JQmNxRXQ5SjdpZzFxMk11VndFYzBXRDZhRkVsVUNWMFc3bnlqWlMzNVVWMFpzYVNYSWdUSzU1RWtvVjhVeE1DUy9SbXQrMjU4M1lVU0lOaiswKzJ5U1JaRWFTU1NzUnlZZVVpUFh5OFQ1Z1cvZDBvS2Zkc3lDZUJKSVZNVWJRaFg1c0FybERjbHJVRU1PZUxCYUZwNzQ4aXVlVEtRcDVFV1BFalhiOHFGYVRrSkl6R09Iamp4NlBrUmtDUUsxNzNYZXpiL0NoSE55STdSSk5ERVpHaVFLUmY2Mk45d2JXQXFLbDdiaTUxb1BWRUtUTVNXRGdMZTV2Ylg5dXRXSlY4ZnRJYktuS3llZ3MzODBVMXY0eWI4U05QMm44YUkzTERBdVVqbG5RTUZjRkNRd2pCdGV4cWpxeXd4WWtvKzNMTmpNd2VRYTJZRFd5N1d2NDBWejMrNHlNYWJMaDRFUldYZzlsVU1EOUtrYjZkZXRFZERHaG1ueEV5U1k0SXl0ek05Z0E5N0VIK2xCejhqM2ljaDhYSGlFdUx6Smt5cFZ1ZlVZQUMxK2x1bEFadUFXaVhnd1gxTnJDL0cyLy9TZzVjT0hMQjdtbVJFL016UDYwS2trdG9lSUJBM3UxOUtsV09ybVpjMDJaa3RKRjl1dklwT3FteGQ5UDI3alRjVTBrUlNPTlkyRTU0SUR5UldOM1luY0tQaDNvSy9ib01hSnpNd0tyWThBTlRvYjhtdWJFV29OUnkwU0thVEdCaWRBV0JZWFJtSkZ1U2tmUWVscXFPYzJKbFplVEhId1ZNbVlyd3gyYmpiWFM3WHQ1anF1dFJTejh6Sjl2ejBraWo1SXhNV1hnM0RJZmlmN3VWVVlacG9NelB5SlJqbU5jZThtVXQ3bTVXN2JmMmpTb0xjVEtoUHR4bkdXSTRDdkVxYmtrazJJTnUxdHhReFprd1FwN1phUFJNa2VwQUNTeStub0dhL2NVR04vY0hpaWRWeDJoeVhZUDZ6QUZXc3ZrNDl0RjcwTWFZUGNFbkFETmFiNjFsVlFaRmtRSDYxK2tMcWFDbkZUQ3g4bEVtU05WbmZncWdGcnR3dXl1dTRIbXZlZ3NoamdiQ254c09Oa21RR1ZHa3NZeEdoc3dDbTl5eDZkNks1bVhpZTZSeTRjU0QxNEhKUk9uRU8xMkljSHlOeS91cUtFOXVua21iSFRLdThjalA2am16WFg2anlGcjJQalJFWUZqaXc4azVlUkljaUZDMEVlckZuSnNTU0xkQlFvY3pUWWNmdHJTSkFKWDRyS3A1YThiZ2N3ZktMMzVDZ3Z3TVZIdzRjZkttamh6b3hKR3NJV3dMUkFsdEJyZlhycGFxV3MrWXFyN2Y2eVJPc1RNc2lJTEJVV3dEM1FmdU5xZ21tZGs0bnR6L2JqMThSTFNTd0h5Z3VmcFlyMkhhZ3F5Zi9UKzRSK3A2bnBubUhnUWFBcUZBZmx4dHdON2tVTXJkZyszKzJ0Z1Rlc1hzaUZtYU43RXNTRmhYais3L2QycXBWc250dVpqKzN3TDVKSnBveTZUUnZjR002Y0RxQmUrbHQ2RGorM1N3NFdIa1BuTVc5Qm1FbUlQKzQzTUZEd1lEWmQ2TFlsOTE3ZC82Mk5KUTh1VTQ1U2w3bFlWUWcyc1BNRy96cUNyM0lROFpJNHVTNFdaNmEvZXpIMVJFQXZMaDVSeUhDOXROalFiL1pzZUxIZUcyUXJ6aDdxYmd4eWFlUXFUdmUzV2hYbzVzUEhueFRKSEFZcGtibElOR0JhLzl2VVZwbU9GazVHZkRpSmo0V01UTEJJekRJSUN0TEdSdHhPbHZBMWxwUEM5c3d2YzVqRGxHRDI4dEZZVDhieFBiWDAyNDdFVUs1bnVHTmd4NGljVlJnMHJSUnVvME1YRTNKTjlCeTB0UTFYRmo1VWl5WXJNOGFUMjlhYVN6cnpqWUtMc1BwVUQ2alZJbjdqN2JsUGt6d1F3cENIa0FNY1J1dkpSWlZIKzM5eS9Hb211US90NnhTSmc1RDVHTTNxZWprcm9xaUkzUG5CSTFHaHNhTlMrdVRMbG91TWNXMHhFY25xb3lOZGtKMFY3SDl2ejYxR3BIWnh2WW55UGFWbHpJMml6TVVNdkFuV3gxSjRkUnJSTmRMMldTT1RBU0ZaaU03Rllvc2FvRC9DUmQzUFhTa1Q2Yk1yMjNEZ3hvNWNTVUI0THNrMGNaS0UvdjQzSjhvTlZOVTRmdTJmbUJtU0JZNGduRDNCZ1NCd3ZjZzYvQW13b1lvZURPKzVzWExobVV4dGZ5TXI5TEhmYmFnNmk0MlY2OGFLbkJrMUxqNlhOd2JHMmdVZHFEbis0ZXh4TEpGS1pKQk5JOXhJckVjQTU4K2c3VU5EdmtOTnl4NFk0M1NQMGMyWUVqN2lJbTZ1NjZnT2JXNUNnZzhPVDdsRkU4V1dHbUMrbWlzVjlUcndqVURVK1g1MEdQM2oyUEF4TXhER1psVVFSeXNvc3pLNVBuMFd4NDlSMXBZZk4yT2I3RzN0azJYajRXUjZrdU1DOTVBM0NSRnVXQlVIUS93QnhIWGFvMVhZOTNnOXNiMmhwY0hLU1NTQi9WYU9SR1RpT1hGSHNSWWlTK241MVdadXVFK0doZjFYaSszaVpnVGhOZGpkeHJJcDZBbjZhamV1eGdSZjhlK3dtWnAzaW5pSVVSZ1g1TVRzUU82NmcxV05xckpTM29OQnlHTytpU2N2cnRlNUkvYTNoMG9ON2U1NVk5dWlpNXMrSXBiakFiRjFmZmRkYkVWUjFmYTB5ODdFV01LRk1WM1ZHOHhDL1A5S0pVM21PSEE2S0NzY292d1lBOEhZNnVsdFJWUTJqeVdDZ3NGNDJJazNHby9Pb3JFY2pLd2N3SjZiZlprbmtZeGZqekZ1U2w3M0RlTkZSaXdzWlZhS1JGYUlYbFRJaXQ2aC9hWXlQMmxmN1Q4YUlXWStha0ttS1g3ZkdoZFBPd0hJcklMWFU3azhkeHRRYUpCN2hoSzBmMnJjQ0U0cy83R0xYRW9DM0RFanAyb0s4WEZseXNwam1EMHdKQzZTQThWMUpKVzM2VkY2V0RDamlWNDRNcjBUeVBwbHRWMDFHdjZDcW1zWWx5UmxvN3R4RW4vY01laFp1cE5yY1ZjVkZXNDdIR3g1c3RGUjRuYTJURklBeElPald2cWJkRFZpVnR3RE5KYU9HNnBMZjdYSVczRmdCOURMUXNMMDNmRm10SUlzbUd3WWNiOG01WDVGdXA2M29FOG1VUUhreVpNYVRIVUpGTWdQOGhROGhkaCs3WGVnNVJ5SllIT2J5bGxlUU1zMG8xVitSdDVqMzExdjFxS3FPUndXWUJTWEExaUI1RmI3a2Q3Q2tLcG5lS2FhSDdhVXJFWWhMWnJCbHRmbWpIYS81MEZobXpIUlpQVS9oa1Fza043cEdDTlNvSDBrMitORlhTVDVLZWxNSjJjc1BUbXVTV2FNN2d0MVd4cUdMTXoybVNaMGFQRGFaZlNQS3pIbThZTjBkeDJBK240VUpXQWpHYkhjS3BzQ2dlTXFWTDIvY245cEhZVVYwTVRNbnlFV0xGbEpJVkdqZ3lBcFZqRjlJRGdia25ydUtxWWpGbVRESVZaY0pCbUl4OWZENDhMWDZJR3ZvTjZnb256NVVXYkZlSVJaT1F4OU5nTGdxTkdUa053ZjFxbUo0MFUwZVZqLytRY3VUS1FMQklINWdhVzlOZ2RtV29PajcxN1RCZ0dOME1rWWV5UzQwdkZsTExyNVA5aGJhcmlhNGttTEdGbGxkZlNUbmRvQmNPVDFzTFgvR29xUHA0LzI2ZW1uOFRrbUJvMnVWSU9wa0hnTzlGZFhCOUhJamppU04yeVMzbnVBVjREYml0Vks2aHlDMTRGVUppcS9MMERjam5heGI1L2xWWjFIS1dCd0daWFUzdHpHb0E3VzYwVmp5NE1iSVpBc1JzRjRlbWh0cjNGNy9BRHFEanZqQUtKSkp3ODEvU1NQYnlycVNUMm9zZExGei9aOEhGZWZFa2xlQ1NOa3ljWElSUjZVMG5sSEJ0VmJ1S1JMTmNxRmNuRGMrNUJHM0RSVHI1U3JiQTZHNnRVVm95UGV2YWcwU2lPU1l1Zys1c2VNamszYXdPekhsdWF1bWN0R1kzc1VmdFVQQkl6blREbHhhNFBGbS9jZFFXUGJwdlVOdXViZ1lPTmxuMDN5RmhaUFZ1WFBFcUZGZ3dZYU40Q2kxT2JDOXc5c3RDMlFqcEtpdmpQRWJpUldISWEvdFBINTBPMmJGZ0tOa1JNRE9Ic1k1b25JSzYzTzIrOXJHZzNESCt5UnBZU1V6SGo0T3JENldKNld1R0JIV2lWandjbjFzeVNMM0wxR2lsSENlVlVFanhsdFFUYlVpbXJpVWZ0N05ueFkrQ1Z5NUE3TGl6S3ZBU2hOZk1qYWpYdlJOYUpjYjJjWXNUVExLdnVDU0ZjdVZ2NDFpMUhJcmU2dFJZeUkyRmplNDVFVXhFL3RreDlTQWtjQ1RzanFWMVgvR2xCSnNRNDBNK0pKblJKbFRoTGpSMWRHODFpdzhvUGhRckg3Z21lMkNNVlprZkhFNWs5RkZHci9SY04xVTFoMFU0RWF4Sklobk1aU1M1aUNIaXgyVWdpNXZ1S3FWdnpueW9zVUxHemM1clNUUW9yRmtHNExPZDJvUmtpeUlRMGNrRVBPVjdpZGNuenhzeFBsQzJ0ZlRlL1dxaXhQYm1TS1I1WFJmVS9rZU5WOHhZTmJndmEyNXFLZU1zc2pSQVJ2SGp4dDUzOHhrZS83VDRlRkN0MllJc3A4bkd4d3FOanI2MHpYNWx1SXVkVjB2MzdWQ09jc3Z1TGhsYU1QQzNEMTFUa2dQRWVYay9YUTNOVldzTkdrTXNtWW5HSUlXaWdpUUxkaTlsTE5lN0RqMW96UjdRejRibk41dnhaV0VDaTNJQTJCdDIrTkZycDQwS3M1Ums1VFdBOU8za1FFa2tFN3VldDZJMlllUVBiaXM4R1NFeVkzRWFwWWtOSHZmdHZWbFM4dVo3cGt6NUdNOHNzeXpTVHkvK1RJemZ5UnNsN2JhQlc2R2l6aG45dVZWOXV6ZmNJMjRtTUJFNWxlYk93MVlxYmtxT3BvWHNseUI2V1JtUWxKMkNpSDcxMlc1WUM3eUpHZk1kUDNXb1ZkaFBFTTlJb2NnQ0ZsLzc0YmtXMHZxUnMzZWlWcTl5aUdMSGtTUk1ucERTVFhWaVNDeS9IdmFvVGx5L1hhYWN5eVNlamt6RUtoa0lDS0xmVTVOOTloUnRPWTVrV0tCR3hjVHNRQnhOMlZmcUtrL1RlMUJYOXZLY2hHS3I2K1E2aU9NQWd4M3R4MHVOaHNhSTdlT3FlMzVDUitpUFdmbTAzcXFvQ2VVaGZPYjM3OGFyR3FmYi9YZU9LTlpXU1hJVjRqWnVBRUhMNlU3aG1QbW8xVXN6MlRmbklvWkd0QXpYNXVBYkVjUmNEVWZ1TlExbHpQYkI5cUkxdTBrcmgrQzNQY0J1STMxNjFGaW5ETW1QRE5ERzlwWnd5cTVYVTYySUpGenR2YWlOMkRoUTRmdFVicXB6VE1SRUE3V2lpWW0vRTIxRFhxbmJYbXc4Y3VMRGw5UEd5Vmo1U2hINXZJeFBMaHBkVmJ3b2E1OCtSN2VnVlVKNUlyY1E4WnVUZmNrSGkzaFJZNjJjd3laWUZXV09DQ09CU3lsMmIxR3RwSEkxdnFPN2Rxck1aSk1lZURHR1ZsSkk4YnNub2lFQy9LSnRDRjE1SnJRY2pObjl6THpUeWcybXU1Rmh3a1ZXMDVEZE5OTFVNZGMrL1o2KzNGQmpHU0dVQXJBamNJeEsrakd3Qko3RFhTcnFmeTQyUm01MlZrUndFckhCRUFMaTRYa2hzM0MzYmJ4cUs3SmZGbXhzU1VNMGtzYUtyeHQ1dU5pUXE4ZW53RktrV09rYzVFdU1QOEF1Rm8zeHd3WGpFbHZPemdmMzcxVFdTVERDV2VTRkJ4ZEFYQmNhYThrMHVOZXJVWFhReE14WTFubGpJR1BDNDlKK05ob3dDS3NkN2djdnFGVm1zN1pHVG0rN1R5VEsyU3pzalpSSjRLV043V0krbEIrMjFReDJZWXdzNm1OVEJHd0t4eXlsV01uVy9oYnBRVmU2ZTZ5UlFvWldWNXBTVk1SWWh1SUZsTEFnZ0RzUlNqRGg1V2EyTDluR0FqRi9VWm1ZaUloUU9KNHJwNWRTQ1RSVHlwSTVvZUxpSklNY08wa2hQRm1IWlZ2cWVxK05FVkxsVEVMR2tUR0VvQkZ4c1N5YUcwaDhOMnRyVkYyY3dDTEdxbHBaQ3JXY0h6dTJnYXh2b085RWk3Snc1SWNZb0c1WkxNUmtUTmNGVHYvQUJqb2I5YUszWkpHTDdkaXdOR3NjYW9aVnlWNHZJM3FYLzdsL3dBNlZJNDN1T0ZpeHhyTUVqR1RKSWZVZ1pqSnpQMUtUMFZSYldvcXlMSm1mSFJNVkVESXBoa1lBbjFMTnlIQU1CYXh2VlMxc3hmY2ZkaGd2QkdxajBsNWlJRGtnREhpN01DQ1BVZnNkclZSU2NZaVIybFBseHVCRVlZQk9VbmNuZnlpNW9pTTJMakprTExFZzRNeGE4Z0JJUmxzV1JiK1M1dnFkZHFqVG56SUI3ZzZ4djZrRUVJZEFCZG5CL2J5SFgvYmFndndwWW5qT1RER3l0QnFpekxxT0p1RDRMWTJ0UWRmT2p5TWxvREt2Qm1qRENkTjNMYXRJUjI3VVNOSVhIWjFuVlkyZmtDVUFzRTQ2QTIxdHRjaWdoN3BIbDVqeVpjcXhsRmYweGtxT0lWVkY5bDcxUmY3ZE0yWkFHVW1PVGtlVWpBSU9BMFVMYlRVYjBSUElsOUkyYUpKRko4bWh2NVJZM0pOMkZ1Z29yanQ2RStPWndyR0NPeEYwSVlIWDZsRzJvM3FDLzd2M0NEMjh2S3pTdEphWDdXU3dZcTk3SGlmMi9EclFQRTlwOXp6eEpMRkNSQ0FKSkFMY2lPaUxjK2EzNlZSZmg0K1F1UEZBakZJWTVDeXd2YmtFYlEvN3ZqZWlMR2o4cnlSM2poVC91c3JYa2VTeFZlRjlldGdCb0tDR0V1V3NTeXN6aFhrVU13TnVDcmNwWnQ5enIwTkJqeXNXYVNHRDA0L0tPUjlXUWE2NnNJL2gvMG9wUk8wZURERXZISmthYjBJRkxBSzZOb3JsV0ZyanF4MnFzcVBkZlVUS2tiSUpWYk1BbkVXUEVnWFJWT3QyRy96cU5SMUUrNTkwanlHYmhGS0FraThiS3JyRUxjUXQ5ZUowb3owU2U1d1RlM3poQWZ1SjJXSXhFY2lBdWx3MmltMUYxbSs0aG1lVkpGOUM1SUxFRnVRakgwcjJ0Mm9PaGdTaktFbDA0UTQ3V2hXSWFTWEFBSXZlM2MwR2lQTkJJU1N3UERjaXhSbEZpZ3YwN21xaUdmN3JFNlI0VVFQSitMZXB2YXdJdGJhOUJsaWxHRmtjTWtNdUZFd09RYjhsWTJ1RitIOXRSVVBjL2ZKdmNTU0dMcEhLQnhRa1dRL1JkZHV0Tk1aY2ZJaWhaSjR5MFUwWmFQMFNQVVVzekVjN25RK1crOUIyY1BLbk1TeXpOeXg4Ylg3ZDlXQ2pRRnVKOGIxVUllN1kwVWpMTkswT1JBQzhKUkY1SmRkZk4zdVFGdlFZNEZhS1YyWW1UMVNEa1NjbWFSK2YvNFNnZnVCM3FMclI3U1lKR2xiSmpLTVkzOUtZZlNHdm9HdisyM3pvSlljK0JLcGlMcElZN1NRSlpnc3JmdlZqKzBkYUNpTEpFak9zamVuaXNiQzkyQS9zVTliTDRiMEdkM1l5U3FKQkswSkE0cnFyZ2EzNWRHVUMvNVVIT3paODVBckxGeDRPM3FKSllOeG5Ha2h2L1lkYUtNNzNtYVNWOGlPUXdSelJwamU0WFhqd2p1RjV1d0IrcTE5TnhVVEVNVEVseE1uTnhWRFpFSE5SanpFL3dEZUQyNGVYUzMxWHFqcysyZTZwZzVzZUxuNHlaR0s1NFk5anpDQWpoSVV2MTYyMm9NdnVtQ0ZSeEVMNDgwblBIeUxBb0ZWck13VWsyNDl1OUJ6OEhNRFo4aXd5QU8vSkFzS2tCeVY0Z2xlcHQwb1dMOGlIRWp4NGxsUERJVTJZRzdCa1hVMkl0WTBWdEUwTVh1SG95S0NnQ0t4SXRjSFVlUTZqWGFrUll1UDZzOHVNVUs0d1l1T1JGalkzSVVqcVJmZWlUaHB4OGZFbHl3MlAvRUZVbUwxaGNTQlFMQVc3VVY1ci9rcXpMbkFRQms5SnVIR3dDRzRMRGhjYWNUM3FWWWVKa1FRKzRlaEhCOXpCalJuK1JBTmJnTVN0djNGdEdKb1VUbU9ES1JQUVhua1A2bU9WTjFDSHlGUE40bldoQzl3bnk4aVYweUkwRWhqYUdaSWdlSVpkRUZoOFBNYUVIdGNtRWhCekpDWU1pMmhQRDBIaklRdElvRjd0K2xJVjFzekN3a3hJOFNHR0VSdklaWlhVa0pjL1N0enRiZTFWTlo4eGNKSTRuNGVrbHY0aEdoc3pXczMxRTM3MFZuaUptZ2xCNU9RQ0VPcFArMXZBR2lORDRNQ1lZODVYTWhKTWpuaUFMaTlpVG9hR3NIdEVXSkxCSkhQSExIbGlhUlBVUWdxYmtjVnNTRGJvZTlSYVBjU3NuREZtQSs0aEtRTEhEY0lJMUY3V0krcTUzTzlWSlhNbDl0Q2VZU05aSkE0anZxRVlXTmgvZDRWTVhYcVBiL2ZmZU1PYURJZ2tVUldhNWZpd3NvSGxkZGcxaHBWVEllTDdqSk8wY3NxaFljZ3VrOWhja2drM0tuVUg0ZEtGNlpXL3dEVHNnRFNTcEtPYW9zUkRvR1BUaWQxUFNtR3NXT2txKzN0bUwvM1lnRiszZXo4MlFFZWU5dUlBMnRSYXhuM2ViSExFbFk0c29sWVU0NmFXNUpidFVCZ1pFazh2cHBNRmtZMzlZbnlDMXRTZDk2RlM5d2ppdkpMaXpBdk9mUmtrbWJtM3FnWFBJdHJ5MHVwK1ZCazkyOXZrd002YUhLVjh2MTRoSThoSENSL1VzMTdqY2VGRmxYSmVIMEZnY3pXUzRLQXZja0VyR3dHdk9oMnpZMlBLaVBsemNsa0xCOHR4dXF1UEt0d2RWdHZRZHJFOXpiMjh5ckFGbWorbENSY1NnNmYvV2lXYTVFdnVjc09YazVFS2NpNDR5YUZRTDJ1T0lvdU4yUExGUEQ5emx6dkhsT3lPK1BiZ3JBYUczUy9IVUcydEVlamh6OGVPTWxrWklIVUtGSUFrQklPcEcxcXVwam0rNGU3eGM0NGcvbzQ2OGIyUG01MzN1ZkhwUWt4anltanlaWk1uSm1qZ25ia1hWWDlNTTk3QUJWRmhjMUZlYzkzOXRYQzkybEdMeWxoaEt5Q2FKZ0xlVU1RZXpxYWpVdXhyd1BkUGM4Mkg3Sk1wWUlnSjVvSGw0cVhCVGs4VFM3TXpicXQ5NnVwbU9YN2hpNDgrV2xuZFZNSVptNGNTSEF1MTdHemFqZXBXcGNpU0ptWlhzYU1BelBES1ZtY01iQ0pSeVhrT29vZXRudHZ0T2RKQzhuSXVzNnVZMURYTjFISWN5ZGgxL0ttSmF6UisxKzR5d29WQ3ErTXpHNjM1Y2IzNTZENlFhWWJIU2RZTVhHaUtxTXBYWDFBcEJVUXVXMU85bjUvbFZScjltOW96UHRwUzhaTXI2aVpUeVZZd2J0LzlkZDFxUXJhcG54TXNoWkFwWFdKd2RHSk5yS1JvVnJUTHE1SHU4T1I5dko2U1J6RmdrMFpGNUF5YVh2MnQwb2tpL0Q5eHgzeVFKb1NxSFFnYkYvMEdsVXhtOXpMNUVoQVJtZ09pTGZ6TWJhSFQ0ZGFFTEJhSWUxdDZ3S1I0eGEyUllCZWJENkhPNWJ0VVZNd3hOaERHbHhmdUlKeno1QnIyc0NUL3dCUjBvS2ZaMW5paG14U0JrWTJjaFRHVjNLeGlTSWNneXNmcEtEcDFvTldISStSalBpUEw2T1F3RERpYm9WQUpQTlQxTkRYRHpreklKWTgxOFlQZ2MyampWRzVMeWl0eTVXdmFvc0xPbHgzZjFsNWpuNWVBWGc1MDg2RzV0cU5pS3FOR0EyUGxZc2tQcldYL3ZSUk9tdnBnZ1h2dGY4QTIwRWo3ZS90L3VFRWlTRDdjRldrdllyWmplNTZBbmFsSlI3N1BteHUyU2NmMEdtWStSQllFS2VuY1c2aWxwSXhaM3ZxelF4dzVCa2dqSVAyNmNTNVJlM0xTNnMydHpVMWY1WFlNMk9walhJbEVlT09KbGc1Y2xKZmRsWDltblNpdTU3L0FQOEFIOGJGWkhRUjVDT1A0a1U4U1F5M0huSGhZMWNabDhjUEc5dkVFN0lrSWtoWUFsQ3A1RGo5U2E3azFHbFB1bUhHbnVEckV3a3hNa21RSkV3VlM1R2d1ZHVPeHBpU3VZMkZtdkpISkhPelNRcVN4STRsVUJzUUZPOVJwYkgvQU1oeVJFb3ZJaEFFYktwMGRGSnNITzVhMndwcGplUGM0V1NDZkhjY1VISGpLQi8rWGlOdEtSS25tTStQTkJMSmptR0o1YmdRc0xqcnQwYnJyVlNWZjdyNm1kSkI3aEVQdklKWDlNZ2VSallmU2VQNzdVcEppaWVFUVk2NG1WQkU0elZQMmZOL05FQVQ5VHJyZm9WTlJYTk1udGNlTTVqRW85eEZoSEN3OGhmYTZrV05yYTk2S25EN21obCszeXJ2alRxcUZqZWJnUWJjd1RaaDV1M1NtcGliNGpzN1BMT2NnVGs4cEhiemwxUEZIREhVbzF2ODZLc2c5dm54WTFabjRlM3ZlT1JvclB5WW01NEEvQ2hycmUyeFJTamd0b3BVVStsSXBJWnlEZXpId0hhckdhdWFadlFqRHhoblVrais3WGE5VkczSHpzU2FHMHl0SEg5RWtxZ01WTzROcUs1MHBITVBDeW95TmJucUFiZGZuUWMrZGNOMmJJS0lZQ3IyV1ZpbkpnTlZWMTJidFFjTlRrTklxeXhzVlZnRlFEeWJhYTlUV1dsODc1U2N5R1VjSTFNMERFRWxiZlhmc09nM29Nek83WVNNeWNsaEJzUnVPWnVTZjdhQkxMR2tmcThQVW1JRHhrc0N5THNTeTkrM2Fpc2pUWThrWmk0Z0xHNHNDUE9lbHI5cjlLZzZUKzNaT1BIRnpnZUdZY3BST1ZKUW9iQldYbHZZVVRWK0JCUGo1ZGhOR3pLQklTQ0NyaGpmZndxbXV0RDdpTXYzUTQ0ZEpJbFgrS2QvNGw1THF6YytsTlNSeUkwaFQzSXpSdWNLVkhQQ1dMV3diWmlOZWQ5alJXdWJEaGxqTUluOUNXSGxKNjhpa0JtM0EwMVU2MnRSSVRRNUdZa0VFVVN1MGNTcndmekxvZFg2ZDdhMEhQelpZOFNkL2Fwc1pPVFNLODhwMGtqSy90VnRySHJTa3VyTTNEeEpKakhkb1p3M09HTm8xVlhpdHFXMUlHbTFVbFlvcElwTUQwekt2cHdoYmh3d2JrNTg4YWpVc0JhL1NzT2pWZ1RxOEUwZ2dXU1pRSTQwQUFzU2JENFVRcFZ6VldXV2NGbzRnT1FBWWNuK2tLZnhwcTRXUGlpRmtaSlV3NDFqRHZOcTB6QnI4a2lHNExkYmJkNkpXT0RKSm1WSkVrYVZtSVRpNE1hcVR0eTFaajNOQjNmY0RqTGl4WThHVE5EQWRaSldUek16Q3hDMjgxZ0tVanovQUxia3l4bVRHV1pWeDJia1Y0L1ViV0FrUFJiZm5UVnNkckd6ODBZRW50OENwSmozOVdhWWprNUNuU3pIdmFpZWozakhUTXhoa0EzeUp2SklRcDRxdytsRjdraisybElqak5qT1lzTEZBeUpyaEU0clpuWWl4SEc1MUZCNkNISGd4NDJNanE3a0JlZlc5N2Y5YXJOdXFzbFlHNXBFR2xRRHpJQUZMQUFuUW05dmpSWTRjQ3g1Tmh3OUxIR2t6QThtc3pYMk9qRFNpbDc1N2I3ZEJKTmpZVHZtSkhvSFFlVzdMZmg4UWRkS2l4elB0eERrUmN3RXhjcU1NWlpJeHlZS2VRSUMzSUJJdHB2UTFmN2xsNHBkbHdRc0I0OHBvZ05DV3RvdlkzMkFva2JzY1kzQ09LSU5rNWl4azVLTktER3o3K1RUVWdiaWxWejhyUGFUSVJuaURRUnFwZEFvSEpVQkFBL0grdFJaSFRuOWw5N2Yyei8yYldqdzVmb0NNQWltMXJXMzJ2ZXF6Yk54aHc1eEFDY2RDMlJMNlpXZHo5QkJKSkY2TFkwWm1mbHJ3bHpFZVNmSVBuTEVjMlM5bFpCMHZWU1IwT1VtUEhCYkJ0TEllV0xFNTlSVVhhMnVwWWVORUh0U1ljbVh4enAyamdKTDgwVzdEanF4dGJ6L0FOS1JickJuNXNVL3VKYkZrZEVOM0VyL0FQY2F4c3BlMjFURjhXUVJ0SElZb01sWmlRN1NaU2VVQmIzWVJNZXArRkFvSXBabzFXT1NPRzNJdUMvMThCZjZOZk4wdUtKcXBQYThnbVI1cEk0MWFOWnBKWkd1emlUVzZqOXJVVjBiNCtVN1NyQWJFb3VKR2VURVFvdGx1L2ErckcxR2VsVFQrNEpKTTRXS2JIU1JVaWNHM0pnTGx1TzdBRFEwMWNibVRLeno5ekhhQ0Q2aEJ5NDI0NkZ2OUJWVG8zdzhsOGRaVWpWV1o3OFdVS1J4MHVTZGd5OUtJZ1V4c1hFZDUzS1pDWGh3Y2NLeEw5d0Q4OTZFUWc5akNRaDQxNWVReTVVU0d5SWtlOXVvYTUxTlUxbDl6dk0rUytMNmVKRE9pb2Y5cFVjdUFGeXdCL3VxS3Y4QStMUEVHVDdheGtuVmtNY2hGcmJlQU91b3ZWaDlOMlJFd0t1czdmYU14RW9LMkFPM0lpM0VnOUthbUhrZ1JlM1NlbklJNUxxcVFBTFp4WThaQ1RlM0dpZXVYaS8rRE9lQmpuYmtIeW5ISXg4cmViYXg0cjArZEY3ZEpmOEFsSHQ4Mld2a1pJNHd5ZnhxQTc4aG9WdjVWMTA4QlRVeXVTODAyZFBMbTQwUkFVRStrbzVJb1BTL3hxVnFOZUFtVjdZc09VenBPTWdjREhMZlZ5ZEJ4SDl1OXFxTnJTakhtU0o1b0pTWStUdGNlUnhmektDUE5wK2RFYXpqUWUwNE9NMHF5Tk5PdnFRUlIrY0NOL01QTWV0eHJWVHREMjdEKy96WGFjTVlMbmlUNWdTMnJDLzkxOWdLWWEzdmdJWnhGaE1raU1iSTFpWDRMWTMxMnF3cW4zWjhIN2FFc1ZFakRuSzdHK3Q5QUIxVTlxbEk1MmROSlBNczJMaWoxY2NBTkV5K1JsY2Y5MlJyMkxEb3RCSEpXTTUyUDZEUEhLcThIVmlHTFNKcHl1UHFPdDdDZzIrOGpFd01OY2ZCYVo1bU44a200VWxqeHNSK042SCtzR1I3VmpSejRqTk82NUpWWGFLSld2eU4vd0M3UTJHL2FnMCs4WThoZUdHYUQwbmRFbGhJc0c5TWVZc1IwVWdVV011T0dnbmI3WW1HR1JnZ0hLNmxYMUJCT3QvRzlFYlo0WVoxaVVyS2pZK3BHcGpaUVBNQVBHM0ttRnJvWTBUbUQxZ0xYVzhBUElFbnJZTU9vT3RCSEF4WkE4OGFEbElFSkVhMks5ckM1ODFqVkZXT0FJMjlTWXVxc1NFWFVGbDBGN2FHa0xIU3kvOEExOE1jajQ4alBDUXBzcW0zUHIvOXh0VlpZMXgvY1JGeXlvd09Ta3hoOVZVWEIwNDNQS3gwcUt2OXV6T0FzZm94SDV0STlrSVI3Qk9iSDluWmFxS2NyM1NDVDNDVEpYMDVwSW40d0pJZ0s4Qis0MzZYMnFOUmt6cFBlWHc1YzFwRlJqSVZaWEZuanZxVWpRRzJ3MzZDaU5NV2JENkVTSS9xeXprRXVRZVVmZFhZNzY2VVVwM1QxVTlHUDFZeGEzbThvc2RkTjdVRy9MenA3eFJTbEVqaVFvaFhSTFgxWHk3MFp4ekp2Y1p4akNCRmFUN2NTTERJZzRMREcvbGFKaGE1TGJMUmJHZG84eHNUN1JwT1VhcjlxaWVtRktSMnVlTnYzZkUzb0tzZUhLaXhJcDJqQWlTTndveU5BbkUyVUhxZkEwTFVwOGllYkhseUlQTFlLcW9GSEtKUDNXdCswYTIvT2cxakF5c2ZKanhWWlZhUlRLMWxBbFpYMVJyWDFMZGhRWlo4S1A3cWQrZm9aQVZVR09BYkZyNmhSL2NldEJ1aXlNLzIxOHlXU0V0RE5HeUJCNUdhUWdCWFZmMjN2dlZRcHN2TW53eEptQkNwVUNVaFBPRlVkYmJNRHVhZ3p3VG8wRXZDUkV5SXBCd3NQNVpISDA4QVJxT0pOd1RWRldUa1pzSlpKUUpJNUxSUm8vbURNUnlPdlRpdTJ0UlUvYU1yQ2xrenNkMlVLOGFxSFlGUUpnMWxOdHl6YkRwUTFQR213ODNNeVA4QXlYeElvVjR3cXdzNk1GTnRCZFNIL0doWFI5b1ZuaW1DMlpTTld1RFlIVmxIenFvNXE0ODZaRHlSeEFFRDB4RVNHSlpqOVZqYjZUYlNnaG1vK09KeGxvSGtrbEVjOGkzSVIzSGxiUzJoR3RBbjlHV1ZJRXZIZ21QejJZbGZxK3RXUFVhYVVHcHVRai84WnVYb0V4RlgxTEcramdwdjQwR2pFeTU1UGNnMlFpeVpSL2prUWp5QmdDQUN1bm5xS3lpUEpNY3FwQThaZVVoeHA1MlFjMjVGZFJ6Rzl0cUNqM1gzWEZlTkhFMXBrUDBvTGtxZENHWWpYb05lbEtSaTlPYk1SVnhWTTJPMEtpV0tUUlNRTE1iRHRhaXJjaUw3ZkFsTGk4MEtpVkZVRU53SUFMS1JxYlVxUkJJTXJOOXlVUXl2K3d4c1lyYzBjRDZyN2RWMHFMYTFyaFR3NDdScEtEQTdrdnplL3B4bGpvby9ZTlR5dFREVWl1SERneVBFVE5sWXkzeFpndlFtMmx2TU9QYzFVN2NyTnlSREtra2FDWENqSG40ZVZnWHQ1QnpCMTdWRnhMS2t4UHVBMFR0T1lZaXMzTUZYWG1mTHpCMThtbDdhVmRUSGN4MWl5ZmJWZnllbWw1SE55aEJBNFdBN3Q5UUJvaktNaVg3ckd5Qmtxc0RjQ3pHL0t4SkxDd0grM1dpdTdMRjdlY0NQM0JuRWdhN0k4MzBxeC91US9WVEdmNjV4NGpLdzV2YTh3UWdtSmNnck5GSXdJY3F6V3NwQjFVZzFHMmVIMnZLSHVjdUpKRkswRWJqaEtEcXJFa2NpZGZKcmV3cGhycTR5UGpTRElXYjFndHdWWFZtNk1MVzFPbENyb3hoc2syVy9wK3JPcUQ3YVEyYjBpMXdVUFVpMnRWSzY3Wlh0MlhqdzQwWHFCbWZrWGxJYlMvSDZBQ3hJRmh2UkVzdjI1Ukx3aWtXYkhWU3NSNUVyR1crcFJmWTNvYXk1R0k4WHFuR1BESWlTTW1MUzBsdHlSOCtsQ09CN25sU0dPR09DeGhVT0FXQVc1L3RrdnUzYW8wMGV4TlBKN1htR2FmMGpBQXZwT3EveVNLZUtnT1BOYnB5RlZMMm43UThjSHVSOWRUTzBjSU11UElRckIzMmFOaHA5WGVoV1ZjQ2QwSmEyUFBEa0t3aEorb0JUekFKMUh6cUxXNW9YSmo0ckNVVnJuSVM2c2V1djQyTjZxREo5dkdEbEdHUU1XbkJpSlJTZUJZWERlVTZNQjBvczViZmFaUGJjbDN4NXVJblVCWWZUSEVNQU9JWWorODlhSlhHLzVKN00wVTBra1RPaUZ4NmNFbTdFYUUrRlNySEQ5MHhNbVgyMU1wQ1BUaFBvU200WllXSjh2L3hWdjJudlVXZHVIbStrSkRCQ0pNWnVLckxGY204Z0d1M1JqcUtqY1dZL3VDNUdMTjZvUDNrREk1MThySURZK0pZYjBMTWVwOXB6c3JNVEdpbXlQV1BCM0VVaFBsVyt3YjZyTU9sYWpuV1AzcjNUMnhmU2FDT1VUODJmSmNQd1hpTkVXSmhyeVh2U256TFhOZjhBNURLUFFpbi9BUEp4MGpFVWFzQ2pDTmhmaHlHL0VuNTFOYi9scTl0OTdCYVdJSUkzOU1MREUycFpyN0tEc2UxTlpzZWk5cXg1Y2lLUEtNYWVrV0I5TnJFM3Y5TFczK2RhWnRlaHpmYU1hVEhobVNLUDFCY01BQnlRbm92ZGFZU3VRLzhBeC9JbTlXTEhabWVKZlZUa1NGc05TcDhUVVhYR3k1cHBveXlxRmtOMWNzbmt0Zm9RTkRwYTVvckhqT2l3TytOeGp5blU4d1Jjalc0NDM2amVvS3NxSEpnOXZqbnlUSTBiQ3drc0xzMnB1VHZlKzlGWWNQQnlIU1dQSUR3NDhyaHpDd3VDUU4xWWl3K0lwRnRkQ1RHbGc5T2FBSmt4dmRURzF6ZXdzSC8ybFR0UmxKTVpvREF1T2plbnc1VFBZWFV1Q2I5bVVrZGFLMyszeFpzSHQ4ckdNUXk4cnRrSis0bGVRakkyTjdYRldNMUJaTW1mMDh4cFpJWmp5amxqV3lXak8xcmIzSjh5bXFmcEJSN1pnS2NMSmhsWE81aGZTSThoVWkvbkxkdHhVVnU5czkzbndraHgwdGw0Q1NOWlU4cjJtWHpLRHY4QVNQeG9saXFmTGlpei9XeFZBaERjSVZrRnJYLzJuVUg0VUhSKzNsTFM1c2g0eXhSajdoWFBIeTNBOHAzWm1GVkYzdXZ2Y1Q0WXk4ZVRoTkl2b1pVS0FBOFVBVkpDZHJzTk5CUkJoWkN0aXNneC91UkZGZE1oQzNsQk9sd05mTFJhaS90OFUvdHd5bTVQaXlPUHU3MlJnVk5pcTYvL0FLVlZIS2IzSXc0NXcvUElxeU1GRHRvVmNFRDZiTmZ2YXBxNGxqNVVVbWs3T2hieXRFKzNOTm1WdHRCMm9KeG84T1JKa055bGxsRm9vV3ZaMnZxVGZwM0ZCcGx6akhteThsUjRKSWx2SkNoUkluTzkxMkpIWG9hQ2tDV2ZHamhaUkpEajNQMjczVVNKKzB4c1BNRzcwRlhCc2xZMWhjbFdjTlBFUUFZemV3UkRwK1ZCZS9wU0NkWkY0engzYUNJZVVLNkcxcEw5L0RhZ29sYUxJZ2dFanlHQ0ZMZWxJMzhnTDNMSkdQN0w5YUtyeThMT3lzYjdobENSd2dSckU0K3BVRjdlYjlLaHVKZTErejVFL09XT1pHa2lqNXp4V0FjQTdYNWIxWVd0K2Y3amhqR2lRbVNJaGVNcktUNXY5d0JHL2hSR3YySDNLQi9Ud2NxRDBwVlplTWptMTEvM0E5U08xQkQzakR3QmtaY2VMS3laVVlzd0MrUXhuZFFUc2FXRXJrc2NiN1o0bkhxdkd2TEVQTGl5aFQ1cmYzZytOWmFjZU9mQ1NRSktwU0taN2pJQjRnVzFJSWJabE8vZWl0V1JCaEF0bDRrc2J5SVZ2SmUzTlc2K20yN2R3S0F6Y3lHYUlaRUNlalBHQVdpREVwZGRDeXNmTnIyTkJaQkpQTkFKMGsremhYbC9MYzNkMVBMUWJrM29Mc3ozR1hMeFpFYjI5RVdjSmFhTFlGQloyUnJtM0kvVU85TlRHVERTWjh1SnlVa1RIdUp1UUlEb2RCR1IxNzNvbys2bHg4bVdPS0pWeHI4WW8wOHllb3Bzc2x6cURmWHhvTGM2VXlzelpNQ0k3dUJrTEhvbHhZOHh2eHYxQTYwUnBlUEZ5VU1YQmdHZXlSeHR4RjdianBlcVJ2T1hrUlFMTkxsSWNoQUlvd1VBbUtyMUtrY1dCMkxkYUppV080ZkhhVVRySkw2WS9pdlp1TzNGUWR5UENyQ3FzVDBDQ0k1Q3BrSVVvVHg5UzJ2R3g2amVvTml4UnhZeFlTSVVsamRrQVlCa3QvdFAxZnJRY0RMOXlXZVNUbkFvanZIY1Fyd0JLNkU4VGY2dHpTa1FubGdNVThlTmtOSmpYUDhBS2ZJQ3U1WUtkYjMwRkZaTWoybzQwV1BrdEttUmlzNTRUSS9JcVFMbU1wdXBVNjZpbzFLNlB1TTJPdU1xWWtDZ0ZWNHRKWlhaclgvbFVHekMrb3Z2UkhKVE53NUlrT1U1Z2t1UkpLRkJhd3Z5dUJhK3UxQmZuWXVCRFo1aEhLdkgvd0FWVUpET0NkM052cXR0UVZHYkpiRFRFa2xsa1dGV2toZ2xja1FxZFF5azkrMUlCVmZHaFVUUm1LU1ZGbVVFY2hJb09qSWYyZzlhTFhXOXZlT1dkblhHSmd1cGZDYzhvbXNMdU9ZMVc5RXBON2JoNVUwa3NYTERtOVVzaVhMc0J1RnYySGZlcWpiSGxaY2VJWWNsb3M2V1p5a1cwamdqNm0wUG1GOU5ldFFjcURIeS9Ua2FFTEZrcmYxV0owQzIwUzNScjBXcU1hS1JENitZWEVzN0ZRa3Fja2xRRHpndCswNjZVSFd5dlpzRVlKeWNJU1pVYUtHVElqWUdPTzI2T0dzeXNoL2JWWTJ2UFNZUHBRK3BrbE1TY0tFbURzZldMTjVnd0hUa3Y1VnpkMFdYRXhFNHd5TEpNQjFZb3VtMTdqenN4T2dvcmZIbXcvWk1GdEpsejNQQmlTc1lzTGFmM1dvakJtelF1RWl4MEN5SHpNVGZpV0ErbFdZNmkyNTJvSy9hSWNIN3RqTE11TkxFTEl4TFNXZndBQkxmS3FsYXZkZmMwaHk0d0dseXlVS3p5eUVLQ0dGdklGQjRWRmtaY0tPZDRlQUFMVEVrUUpiekxFT1hKNzlBTmFKVzcybklWc3BmdVVkc05WY2owL0t6RlYwSGx1U283VlVMSm53Wno5M0pONk1hcVFzWE55UVRZYUtMZlYzb3JOZ1RSWXEraEVSTHpKYU4xSDBLUjV6MHZwdFJiTmVnOTA5MTlzeWx4RnhJdnRjYUVqaytyeWNiQVhjblF0NFZkWW55b3lwNHZzUkl2cVpQcU95czV1Zzh3dnFScXh0VVdJUW84V0VYQ0s4Wk5qTVdzV0Z0RVZUL0FHMVJrbHk4UDdrSXNFa09FV0tNL0t6K3B4LzI2cUdKMXQwcUx5bG1MRG1RbG81VDZqY0ZXSlFMQUxjQUYvOEFhZGJVSXlZM3R6d1pIcTVGd3lsanlRQW01R3BicHRRRUVHUWtQcnJKekQ4a0JCSXRHUHFRVzJ2ZTlGVnVjaFkrWlFuRVdRS2l0NVdZcU9oNmVOUlduTjk2bmtTTnAxQmdKS2pCNU5ZUHQ1ajM2MWRaL2wwSlp2Ym8vYmNlMGJSdE1XRXo4ZjVHQXR5c28vYUt0WmtyRWZ0L2NRa29QQ1JXRVViYXRJNmN0R1lqKzBhZDZqVVdHZUpmY1dpYVcwWmt1eFVsWXdRMWx1RGMycEVycDV2dW1ibUJJWVlNZGxoWDFFeDhZSG15UjlMalh6QTNPdTFWSTRNT1BsU05relRGM3lNanpScEdBQXZGdGZVSitnYTZXb3JxZTNZZ1RGZDhtZEVibUkxWmZyOG91NUNqOW9HbCtwb2xHUEpqNHBaTWRiTEplODdFamlwRzJubURhM1BoUmNhc0thZVNCK0NLNFhSUW8zUCs1U1BNUGpVU3NHWERtNGtjbVRIT3hsWkZVRUZ0RkduRmdlZzJIZWk3cDQ3U1NSUkYxZjd5ZFY1SGhxU0d1MXV3Mlk5NkRwNE9YSE1rN1pVb2hlNVVDSlBPb0FKS2dFaFZWajEzTlZMSGF4cElJc1NPREpuUVBrSUpDeGJud1RhNXR1YXJOamcrNVBJMlV5SkhMSkFoQWlCMWRFMTQ2QTZjclh0MnFOUml3WlJERVpzaWVWUkJjUnFnUEFLN1g4dzNOenNLQ3pGeEZrbWYzQllpVW41Q0tJdmNnaXdMTUQrM1hZMWNTMTBjVENDUzhZMmpmSEJRVEVnQlhVdHVMNmp6QzFEV2ozUDNqT3paQmlGVmJEeDNQcG9CWU1CKzVXR2hVZEwwTVZZdm9TTTVsTEdOQnlReVdzeGJSQ0FOeU8yMUFTaUQxb29sdUpFanR3Q2dGMVhaamZwYzY5NkNuM0NCQXJ3aU1wQTZzeUFoUmFRNldZOXZHb3B3NVJ3L2FVeEkwNEJoNmt1UUNRRjRualpWRzdsdXUxcXFNVHh4NVRQSkdYVWN1STlTN0UzdVhlNE9oTENtSnJwdThDaFd3b1dsZzlOWTBqa1RueVlhdGZUUlFhRFA3cmtxTVNLSkdjWENza2pIaUM3NkhROUIrQkpxb0l2Y2VNU3drbEk0N2xQVHVUNm8xNEMrMTczYTFGeDJKTXN0aHBPc2dXVjFIRlBNQWlDM2xRVzFxc3lPVkhubzBuQm92VWVVY2ZVY2NPUEwrMGJjdjZWR3NkSlBablJKWlB1VmlYSGRTMENubVc1S1FHVGw5UXNkcUpxY0dIeGw5ZC9LVUo5UEdWUzF0QVdZSDl0N2ExWVYxZllKdmJNeWYzTi9jSS9Ya2lVTWtURGdBcWo5bis2aWRPUjdwUGxaU3U3ZVQxUTFwMmNCZlRIMHhYL2JaZTFSV0NHSEx6cDJ5SkxtV09LTW1RRGpHc1E4cFF1VGV4RktTNDIrMVpTNDhFanZ4aDR6SXVvNW9YWnZLWFRmUUg5dERHcGNWczdJVmI4WGM4eVdIcHFFWDk0VVdDalRpZXRBZit3WnN5WDB5TWg1Q0lvWkV1UFV1T2x6WWJXcWxpakR6OEIzbHlGSVFJNGpSSGV6TTdYL0FQNGV0RVRoejhYRWtqU0NKSnBPYXJIeStnQnp4dVc4T3hxTGkvTVZzaVNSWUY5YVFFM1NNZnhnZFpGdDA4YXFNWHZNdnViTEVQVlp1WVZYbkM4U09JMExXMHNCMzFvTTgwR1ZNQkRKTUdFakFMWVhMOGRGNUwwdnV0NkRURjdZWXpEbHlhc1dKRWtsMnM2TnhrU1lkUVc3YlZGYllzRnNoaVhsNUYyY25tM0VQcDNIaWRLcEhDZVJva1pTMzhLc2VUQzVKNUd5blMxN1dvanB3eGhzQ0V3OFg5UUdSMXNlVWFnMmJhaHAvY0p5a3hseVU0djVVaFFNWE5qeXVMZlRyOVJvTDhBcks3Q1o3cWpBemdhbVI3OUd2MjF2UWFqN2xCeW1YMFBRV1IzRUpzQXFwYlRmVXRlaGpqZTVlM1NyRytSa3NMZ0NCMXZjcTBsaXFhRWdjZGFHdWg3ZkxFc21PMGplcEF3NFN0OVJkSWpaVGZwNGVGVkM5MnlQdDhrWmZ0eFZKSWg2bVB5OHhVV055dSszNFZGY3JIeThqSWFUTlBxaVJlQVNVcXJDemFTQmhxT1J1YUMvaStYT2pTdTV4NGlyUjZrTTBRTnRSMVU2ZkNxanI1bnVYdFdQTkZqd2gvdFkyQnpja0RsSVNUYXlnL3VBMTFvWTg2RWtpbGpmRWxLK3BJN0s3amtpcTdXVXRmNldLaW9yUjdIa2pOVElneWxrUHJCVVNaaXJBa0VsTkQ5UGZRVUtyKzJ5RXpQVGpFWmlra0Y1bjNYZ2x2cDA4dlg0MVVhREREQkZOTmpvSmtaZU1Ca3ZHWkhOZzhuRHBhMmhxS21jWDNHQ0tHYWZnSW51a2NndVZCWTNmaURhMXpyVlIxK1Vrc09OSVp4TTZSOFNMQVNSdnV2S3cyOGFFcm16cVB1di9JeUE2V0k1Z2tIMUQ1aHkwS2x1Z3Ywb0xNYzQ4bnRTUUdPODZ5dXhsWVdpNEZmbzYyMTgzYWc2ZnNjZUZIanJMT3BHTXpubkNUd2RWVVh1R052blFaZmJsd0pUTEkwZjhEYzVZMkRsV0RnWFFPVGZ6S3ZidlVWeS9VeVdreVJFelNvRUxzRGU0NUVLTGFhbnZRWS9ia2lmQXlCazhIaXhKUzd3c2VEdnphMm5HNUZoYmVvdFgrMVpzZVBlNTlLY055dis1a0owNHFScUdIV3JFc2RIM0wwNU1kbzRaV1NRTThiV1h5TERKZCtRZmZ3YWhqbExtem5JeGNmR0x5TllRSzNJM0VhZ0VScTVBUFMrdWxERktaa29NczBYcHNrWWRTc3RqYXpHejhqcG9lOUZxdkY5MWpqRXNpeVdUTFJZOGlRQUJtZmp5c3AzUlRZYWpVVkJkalF6NUVLell5ZXNyb3J2RUI2aGk5TW14Ti9xVXRyYTJtOVZDemNLR0tPTExEOGN2S3Q2cm8zSmx2YytaVFJXckl5K0RKa2d0SVRFUFh4MEFTeFVhU0FmdXR2UkhuejdsbTVCUUFKSmkrbzZHVWFzeUQ2a0ZpQngvY0R2VTFyRnVYN3JLMmJGRERLWmZiWWJjbEE0bEg2K2JydHBUU1IycHNmTmt4WVREayt2anV6TEZQTHhIRmtHbWorYVByMXFzdEVFQ3JDMDJHaEdNM0ZGa2M4aXBBdXdDRDl0eWJVTmFmYmZic0QyL0RrZVptUE9ObXgwQ3RjdXdJUGdCclF0MTViQnlEeGZHeWJCdVFFTXNZNU1DQnFYWGU1R21sUnA2TEl5TU40Y1dURmxYN3hFQ3ZGeDRoQ1JvU3gvY0JyMnFzcE5uZTNPc0t3eHROZ3lJRmFZamd3eUZIbVcreEFZNm1xam5sNUk4aFpad0lmVUY0WlpHSWNBSHpXdGY2dGhlcHE0cGp5Vnk4NUVnV013WXg0TkhJT0tzMStUZW9UdTdEUzlSV1lZeVpHZTBZamVTL0wwVlVCTE8zbU1hS2QrRnZwb0xmWTN4c1BJVlpGL2laSE0wcFM3S3hGbHV3MHVPb3FvNldMR3NXYVk4dkdPakNXWElZOG45TW13Qi91c1JURTFYbFpuRG1oalJKcFN3SlUrVjQyTjlCdU5xdW1EUE1ySkxrNG1Tc2loMFVxMzhiU0N3RitKMTB0WWthMU5YR1QyejNvUXl4UEdzVHptWWh3NDRJNDRFa0hxcDdkNkdLWnYrUVpIdVFrbGtLUnRHWEtjQ1RJRk9nVkFkN0dta21NRCsza3RISElra3VFeldsbmpiVGxibHhLblE4ZHpVYTBsL3dDSlpyd1N6b0EwbVMzR01xTkdKT25IczJtbFREK25tcC9hMEU4NlJOejlKanc1bmlXVmRHVysxeDFGVEc5ZDMyZjJYM041NDh2MnFTZUhLaGpWZ3RyOFVZRzY2N3BhcXhmcU5hKzNUNUtaV2RKNlhwc3BlU05sSEJHSTh3VWFCVGV0WXp1WkZNRW5zMXNYMmpPbVJNU2NGVXk1MU1qWXlYREtnSzJIbU43K0JxTmM5dVQ3dGk1Y09STk5FeGZEeEpGYUtZQ3prQStVQWpZOXIxRitlbnJmWjJlUEFHWGx1dk4rTFk4Z2RmcUE1TUdBMC8xclVZdDhkQ1QzL3dCS0ZKRjh5TmM4bHNkdWh0dFZUR0xPL3dDWFJpRm1EbkdtblBBQUxZQkRveEJxYXVPRjduN2puZW5ISEpETTZnWGw0ZVFTWSs2c1FCNXRmM1ZscGpua2pLSmtZU0dlTnlqTElTVWFOeDljWkYvTXQ5TDlhbzF3ZTUrMWU0Um4yL0tobTQ0L1Avc3NyYzNJNUVpOXI2NkFkcUpsaW5COTRsd0VDU3A2K1BrUkdBSVFTVkF1UnhZOVY3VTFiSFV3ekRoNDVYUGhrTWt4VWVvRjR4aEFOV0hmeEhlaU16UkJKSGp4c2hKc1NOd3F6SVRaaVJkUlp0YkxRZGo3cUgyK0dMMitKaThzOXBjcDJTL3BnQWxDTDk3NjFVNXRWUVpqcnlEc2pMUDVaa1FEVUFEYSszZTlBWjJIN2Y3bGcvZDVFc3g5M2pZY3lVTENTTFpUeTZPdHJhNldxVlpGQ05CaXpQaVpFS2tCK1FKQmpuUXQ5Tnl1aWtiMFZwOXl4V3pKcEo4ckppR1lMSWpScVI2aXNMMzRqUmJiRTBSWmoreloyUVpNaWN6NUdPQUVDWDFLMkhFbGdPaHFveFowUnhKNzJWNTBOeU5UWUhUejMwMTNGQmM1eTRVazRFanl0OXJMR09MS2prZXJjTHY4TnFHbmorNW1mRGFDR05ubWdjUEdWVnJ4cHN3Wk85NkRQbGpFKzJobHhBd1pTMGVTWmdCSXJLYmNWQTExL0dvbzl1bDl3amprZmloZ3VFRWJxRHhrMkhFalVtM2FnNldkSmtGSUV4UXhFd0lsYVJWY281L1lPUDA2NmdHcWgrM3h5d3RPMGpEaXA0endUYUlXTzYvN1RSSGZ4by9hWnZiWXBUblI0NTVNeVljdXZFZ2ZUZTExRFZVY2s0K0hIWi9iZzNQamVaTkdWZVIrcEc2MFZnbXljSmNnTENscEk3YzdteWx6K3hyNi9Hb3ArODRXSms1TWNoQXhpRTVGUytxaFJzdlRpYUVyTGtaT0Zra1ErNFpFbVBJb1VSWkNKNmlPb0Z1YkFia2JYRzlCREtrOUpWeDJrU2FhSTg0TTFmcGRkeVEzWGtPOUZkT1hQWEt4ekI2S3l4Y0FKcHh1TDZtL2ZXcHBpT1RqZ3dGNG9Ea3Q2Z3ZJekFsRnNPbzF2MHZRWkpueWlXQkx0R29BU045VlpRTkl5ZHkxL25ReHcxeDhoY21TWEtXUTR5L1dpYnBmNlFsK3g2VksxRlVzS3p6SklFY0krc3NPaHUxclhVblFnME5UVEZnOWN2TS8yMElVTEN5WFlSWDFGcjY2ZU5CdGs5YU9SWmZTTE9zZkNiUUU1S3Nlb1Awa3Ixb05mb1pucGVxcXVjT0FlcC9Db1pzY2JXZTMxYWFFMFJUaFRaVHl2NkxSUnh5UHkvbC9jVG95OWx1UDI2VlJxeGMwWnJpT2VPTll3NEJ4d0N2SmxCQ3R5RzUvU2cyWlhzMk5peXd0RGtLeGxQR09RV2RlTGl4QlBSbHBpZjB4VDRNNXlNVlJHbDc4ZUtteGsxdDV5ZERVWFdtWEl4VWthSEtpNC9jY2JaRU92b3F1aEhIdnBXbVdRWmFJWUlNdDNmQlF2OXZJVkRsRmJmUTdqd3Z2VWFLUEZMZTJ5RDdyMHhBN01qT2x3L0xRQXN0K05CamRNc1JxRWs0TjZhODJrQUtrdWJMNWhjYTk2RHNSZThlMnhvaXZISE5rdkphM0lpVUFqandIN1FBZGIwRUVpemMvT25MUlJUemhsVEg4eWhkUnhCREN5bFNCdlJHWjh6SndKY3JIeU1OWEJXN1JnZWIvQUg4YmkxNkY1YzFEQkJqeHk1SE9KNVZLT2VLbXl2ZmlRZnkxcU5LOGxzSlkxTUtHYVJPS3JKSXA4Mm1zWkg5YUlJcE1jNGMrSlBqcTJVaEpRcU9YQlcxTGNodngyNDBXclhnVEl4WUljZG1aeXBNdVB1b0s2Q1J1WDBsdkRhZ3FsOVVTUnd6a1QrbWwxdTRETXVvdEg4T3hvakcwYmNGamMzTnJReXRKNVF0dVZpdmZ0YWl2VDRYdlloOXV4WXA1VWVCQXJMSnhCTndmKzFJUjBIUTFZbGlYdWVmaHpnbkVrR1A2MStldHlDQnNMNjYwcVNPTENpU0Y4bFFENlFzU3JjU0VPMGdGNzNIYXN0dFVmdUVlQzhTeWdPaStZUzc4L3dEYzFCdjk4KzJ5aEJseE42Y2s2RjQyZlZYYTlyTGJZM3JXc1NWd0htOXh4TXRNaFQ2Y3dZR1dNSGtIWWErWlQ1U1IxdlVyVVVlMFlDNU1qcks1bTVrcDZ6NmVtcWdzdzg5N2JWbDFTeFpZb0ljdEo4WVpEemhUalNNd3NnM3UyNTVGYWdKV2dtL2xZa0l3RjQwWGdFL3QwMnQxdmVvclppK3daT2FaSnBVVlk3RUNSMnNGSUZoWWI4UnVhckxoeWlXQ0p4QkpId2prUC9rQUZHSjI0cjFzZDZpcFlIdU1wZGdvWm94Wm1pWUtReXFDZk5mc2RoVk1Wdmt6TlA2amhoSmNMSENtaUVmMlh2NWQ5VFFkRXp3Si9GNkxldk0zR0tSWkFCR1FMU2NVRmxGNkppQjV5eHpSeVhsalVmeHB5Q3RyL2NMWDQ5YUMzRE1FQ3hnT290dWJhc0RwWlFkVDg2RGRqUXJKeXlzZ05EQWlxSWlSb3d2NVJZYmxxRFJKN2xKbG4rVkJGSEdGQmxIbGJ0ZEZHN0dxa2lVemtLa1VzSVZGY0NFRFVNbzFDc2VualFWeXllMXJ6T1J5eUxzempIV1FKNXl2MW5RM3RiclF5cnZiNGdKSXpMUEhqSVllTFRScm93ZlFYK0kwMG9VWlVzSlJvMUFraGpJSzhBT0RNaTI0Y3V2KzZneVMrN1lUeENKWVZXU1NNK282WFJRVHNpTGJVcjEvS2lzSHVQcWdKanloa3g0enE2azgyQjFJSzYrWS9IU29SUEV3bW5uNFpFakNZRlFwTmdzWUl1cmNoMStOVXRkWEs5dGJKRmxsZVNMRkhHQUFjN2h2TVY3alc1M296RmVSajR4Y1RHUS9jU0JDc0VhamlMaTJyTFpVUCsybFdNeDlzKzVkNFF6elBFUFdLWTYyWGlwczF6c09JNms3MFMzRHltaHhsVEZ3VjR6dmM4VmU5dExsR1BsNkd4cWtUeEg5eWVXV2FHSDE0RWwxYmtTbjAyS291OXZId3RRUU9ESTU1a3ZHakc3SXBMRnZIajRuOEtnMVhlTEJsZDFKbkJCeHdGWHpBZjhBY0JidUJTckVzUDNOb0FwTWF4a0lYakt0eEtGdHZpMXQ2SmgvZFpIdU1UeFkxeVpaRUYySURrOVd1ZE5UUXFqRUxKN204K1d5U3d3UHhtQ2VXTThkRlVFYWNyZHQ2TG5DM0t5SVpweThVSmpna2RlTEZoZGREdVI1ZmxReDZSY1NQSjl0Y1J4Y3pDRWxjV0FEQzlnM0xjWDNLcnBXbU41Y2IyNldWM1I1b3l6bzVjekFibFR4VTZkT210TkxHcktnNFpQcE5JSHk0UUhZTVBVUE50ZlRSVjh2bDNvZ1RGeXBKSnJPSm9Tbk11RUtYWW00Q2cySUY2b2IrMll6WVprTHZGSkxFRTlPSWl4MXNvN2k1dmVvTXMwT1ZpWS9IaURDOGJGVkxGdC9MWUJkaVBHZ2hsNXNEeVl1UEhFeWxXRUx2Q09ITnpyeXV4NGcyK1ZGVlkyV2tXVE5OSTRXVEZrQ1FzekJ3emNoWmliZVlBNjBnN0RaVStjMGViN2c0VWhuV1ppb0t5U0lialhRRUdnd1R6dkszQ01oNG9QTkpzTEx5MVJTZnA2V29ZaDdaUDhBYmU3UGtzclM0NnJab2xBWVJscml3dU5nMVdKZVhVbCs2eW93MDB3eDhYQUErMUpIQmVNamZUOEdOeWV0VkU4dkF4cy9MYU9QSWlraGpWQ2pKSC9DV1lFV2NuNmV0cWxKWEl3TWZEVElFY3JpTGdXRU1sK1kvd0IxdzJtdmVwR3FxSHZMNDViRWhMUGprTWlDUWtFTDNpR3BTelUweGFtWEk3U0dQSDVZTWFML0FDbGVYU3pPekczWFNxalJqbVV5eEhJSG1JNVJ4TGU3cXd1TDlmaGJwUWVoVExaUUYwYVJvK2JsQ0J4akExM3RmeHFzMTU3M0gzQUxrTEZpUDZVemhtbmtZa0piY1JPdmZyUmM0YmhsNDBZVDIzTUlNOWhOTEt4RFJOZExxTk5MMk5FUXhaOEtiSG1pU1FZNGpVK1ovd0IxbUc5N1czMDBvckRPMlhEaEptck1xUEpKelprdVFXWnJLb0hkT055QnBVVkdHUEluelorRE11Y1FDY2VNT1E1N0tQOEFjZk1RYUZiSnAzRUVrUnh6SFlLczA3V2psaUNtM0VLUDNNV056UkZyZTJ4elR0TGpScDl2alJxanVoNHFXa0ZsNHJZRWEwTllueDV3Sm95L3FzV0FMRUVJMXZMcmI4YUxEOXZ4czBScEJqemhsVGtlYUVIZzQzQllkYmVhMjFDdWxsT1lsZ2VWbGxneWtNUHJnLzhBNGdGd2VLNzcrWW1xalA3ZmpOd256NVo3UDZpUjQ3L3VZeEVGbVJiWDRMMDIxcVFxL0ZsaG5ua2lpbEw1TVROSmk3bERJN0V1OG5QUmIyK21xaXpQbFlPNkNVVHd5TmRpbHdGY0tBL0Q0WDExb01HWktxTkUyVURpU0JnRkVOMkFqMjVhNkhsdGZ3b04yUzRtazlYQUJqd29McDZjckFtUzYzWXFnK090Qm5nYjI2RE94d3pmeFJ4bEhVa3E2SC9jdzMzdlFwbk85WDA0NG0rMmdXVGpFNUlVckdkN2tkVDN0NFUwc2FCb3J3c3ZwSXoza2taZ3kzMkpPdHdEL2cwTlZTd1I4MUVaV2NLYldXL0FqNlZZNkFCcjk2Q3IwY2dSUzVHRFB3WlVCRWFIUm1hd01lb3NkcUM2R2I3aUdWMDV0bUZsamVNQ3dRTmUwUlVuemEzMm9JdG5RUzVNZUNWS2dneHBGQ0NvTWwvTXpuOTJtOXFEVmxuMi9DR05DMDNOZit6elc1TnpieW5iUUMybFZHZUhJanljcytzakZlTHNrWUJXTXlyNVVGdHR0NzFGWHVtWDZHUEpHb1NLVUV4ekZSeURJVGNSa25wMXZWUmc5ckRUWi9HSlZLOGtXTEkwdGMzSllnL2dDTFVWWFB6eEoxaWp6RW14OFdVaDVFVW1ScGZxVnloL2FOdVcxUWRWNThiTktQSzRMUEh6UHFXUWh4dXg0aTNEWFlWVWpKajUwOHMwalRQeXhJenc0TzMxTVI1eWcyQVcxUlZ2M3loSTRjYitRb3VzaTNVc3pIeWh3ZGVLK0ZWTVZ4NTQvd0RZWThhbUpzZk1sV1E4Z3dRU2NiRlpBZFBMVUhZbGt3NDhCNFVuamt6QTRIcElRQXlKY0MyeDJxaWlVd084amVyeFFnSkV3SlZMMjdYSk45ZFRRVjRNS3dMRzY0elRMMWhaaVZZK0hnUnYzcUt6bjNSb0lsT05ablZmVFdCZ3lzRlp5YkJmekJQU2lZNC91MlkyRG5wS3FpRkpBR21GN2lRdHFyZUcybFJxT29YOXZiS1hKeVorRjRFWnBHRzdLZktqRHRZOUtxTHZmZmRXellZSTRJRk9MN2V6TzdRbmtoakZ0U055ZTFFa3hqOTJFT1RDK1krUDlzWkVVeE5FM0c1T25FV3VEeTBQRTFHblBneFBVeCthY0NGa0t5a2pqSVdCQlpTR3VvNDIxNzBHMWNIMitCcDhvUXlaQ29xc2pyNWVFeE5sNGI4bFliOXFIYkJoKzQ1TGpKekk1UkFUSVB1Ukg1TGFjVjRxVDV1V3Q3VTBzZWd5TVNVUnBtS2lmYlJKd1JMQUI0MkhtNW5jNzZWV2Q1Y25Kekd4czh5NXVHY21TU01Kd1Y3QlR0RytuOXE3anFhS3d4Q0NESmFSc2ZrcGlZQlZOdVpZRXExZ05QTjBxS3NraHh6N1VoZkdlTEtpdjVJZFVsYTR0NnBOck5hOStQU2hsYW92Y1JteHlocktSSklzNktyTUhGaFptdmJVV3Fwam93ZTRTNHVGRzBXTUdlRVd5VkJ1QzE3L0FFbTFpQVFDb29tT2RONzFrdmt0aXZrdEQ3ZUprWm9iQXNBQmU2amZpdkxVZDZhc2lmOEF5Ykc5cnhvSUovYk1jaVpYTWNlVG9ESUwzU1lqNGRLbFdWeFdqeVc5MGlLenJqSmtScW9sc1ZGdG5CWFczSTlLTDQ3OE1HQ3NLeFRTQWgxQVU4dWNiU28zSGI0VVJSbnlKNmtmcnh0SktnWmNXUzRZSGlDUmU5dmxRWUlzZU4xVUdWV2RSeW5WMjRGcitaUUJiUWc2VzcwRGxXV0QzNVpobEdXY0U1RUxFYUZtQXVyUjdCdTV2cmFodkRUalowVW52Smh5THhaVUVSNXh1M09PVm4wa1VnRHltelhxalJtKzF5WU1lVDdpa2hTYUc2d3JmbVBUT2ljQXh1MnRFcklNeUtLYkR5OHlQMWpsQkJLRUZtQUREekVkelFhL2U0L2FteU1vWWs1bHhWVm5nUmp3ZFpBTEVjZXcwdjNxRTZjL0NseGZUanloR3o4UVM2TUFHSlZiZnV2eTM4dE1YWE1FTVdROWpLc0U4bkZoR1FSWWN0cmpiVGVnOUJqWk9KaCt5NVhGUXNxc09FZTV0ZTk0cjdqKzZxemVheHRtNGNIdHJobDV6b1EwVTBjakt2TzJ3QnR4SGFtcmpnUWU2SEZ5akZNNnhsV1IwRGdTUXMxN2t5QWFrVmx1eXFmWS9lZmVNWE9kOGFjaU1pUk9SdVY5Ti9yVmUzKzJrcS9VbUpqM0FQbWNJSlRMREs0VzdFZ0VrSFIxMDVkN2o0VVRGSHVqS21LMkY2YXlxckVoMUhuNVBZbGJpOTFGdEtWZmxveDE5d213amhNdnE0dWVrWng4cHp4TVRxZGpZK1pSYTJ0RXVickhpeDVVeC84QVh3U1NITWdXUXhyb1kyVmRXVmJhM0pGeFJiK1hUaXk1Wk1iSHlrY25LamNKTEMydklxUEt4R2dJSTBvbU4yYmhqSllmZndqMFVkbEdUQXgxYzJiamM3VzJxNHovQUYrRlBMMzFjY1JMa3NNV0JaRWhWbjg4YXlmVWdicGZxTnFMa2FHLzQvangrM3BQSE9IeEpMbDhoQi9JR0FCQ3lKdU5kalRFMG4vNGpIT3NUUXkybGtITjFJNDZvTGp6YWEvblRGL3BTc01XTEcyTG5RZXVqVHJ4blVjWDgycjNKMEdtcTBUVzNKZkhnOXd4NElzbjF2YlhqYUNESWt1TEFueWhnMStJRjlmR3FUcHpNeUxJaWxsa3haNHlnYjBwWXhZeHNSOU5oNEViaXBWaXpsZ1pZRFBNMFVrWVVxVkxNcnQrODJQUmowNlVUcDJtK3hnd0lteG9tZklFaHZJZisyNkU3Qy8wL0dnMVk1OVdhU1BHWVFqVUpFemdCMUsrWWVvYmNySFlkYURENmsrREtBMFVjMGtSRHJPK3VqYnAxNUQ0MEZ6WXVDMHZIR21MeXorWTQ2K1cwdS9FSHFPb29SMThXVE5uZzlHSndzeWkxZzVSa1pSMjdXMHF3cm1aUHRzOGpNd1BLY1hjU2phNjY4VzhSdGZhaUpKaXEwTHkrbTNyc3Y4QTJGMEJ0dVJiWTM2VUt5TGtadnR1UkQ3amduaWJjQkxZbmtHRm1TUS9IcFJHWExuelk0cEhuUUF6Z1NlcmNFdnJlNC8rVzFGVWNRWERZY29tc2dlUUVrRkxEa1FDT28yTlJhM1FKeGpNdi82MEIyYUovTGMvVHpUVStYcjFxbzZ1R2lzZ0VwTEc0NU0ycE54UXNhYy8yNzJ3NGJNeEtvQloxVGRqKzBnOWgxcXN2T0xHK0dHRWpTT2dWL1Q0SGlGT3dMVy9iVWF4WDdja2NtU3dnNVNUdHdLS1I5WS9kSGYrNFVWMklwUFo4L0phQmtmR1FYRURxQzBnWWJwWTZIWGVpUmh6c1hLZ21aSTBTV0pYVUdWQ1dUekw5RGRSOFJRVmlISGJDRHo4Vk1ZWmlVMXVMMjVDK2xyYUMxRkdMbXBETzBmTm5oSTRzVHJhUCt3N2RkYUl2eklwMW0rK3hXWlpGWlVPTTVKTWcvMmo2ZHU5UlZvekdmRmtoeG1BU2FRc2l5S0M2RUxaZ0w2Yi9PcWtqSzJSbFplRXNjY2ZLU0FmemdDNGEydkszUzIxUmZXWmNaM1huSVVnaWNlb2p0ZGxGamNJZzZDNW9xVXpRakxiUkhpakhHZUdVRitiSFVsV0ZqciszdFFQRGFhR1N5dDYwaXhrRkF4Y1BGZTVqYTJ2K1ZCa2t6dmM4UElUUGovOGQ1bkttQ01FYzQ3R3dzUEtSNFZDUmI2akw3YXlIRVpFa2RUSExycTZDemhyYmhyNjBHSjhoaTY4eWhZc1dMTGU1djhBc1czV2l1eGpBZWcwRUVxenJJd1Z6eHRZQStYVStORVc1Y3NMUkpqeUpKNmtYTkdqREFoSkw3NmRMZHEwekN6WUplRU9USkkyWGo4ZjRYRjFCWWJ4aTNYU3Bhc2ptSVFJbW1LU0NPSndxYzlJeXJuelJrNjhYYnB5b3EzSEJ6amwraEtjVEZoVzVoZHdyR3gyUDkxaHJRWXNjbVZ2dDN5eEd5bDFUMUFRZzVHd3RiVHhvSlpIdGVRSm9ZR0Vabllla0pkT0w4QnA2VGpjblkxRjF0OWs5MWl3R1dMT3hTaWF3OCtJWlJZZVpoYiszc0tzWnNYSi93QWpHVk1xNHNZeWM2UStrcGwwRExiUWRyZEthZnk1V1Zpbkp5bGprZTJXSkJBOFpZQlZaZGJjZXEyMHZSVVg5cjlPYml6TmpQR1dEbGRVSDl0aWRXTnFZYTI0TU1qelRDT0xsa1JLcXlkVktuWnVJMTgyOVExdnlQWlk4ZkRXZEdJa1lNdVJHQnFBM1VFZlVQQ3RZenJtKzN3UlJMTU1zcklGakxSU0ZCSm9BU3AvL05wVWFReFBidldSNVdqQm5YaXorcXdYUnhkcmVBcURjSS9iNVZXQ0RIU0dlSkMyUklqTThPUUY3aTM4ZWxEdGc5dC85VGxaVXNCbUdHaERHSDFFdUVKL1pmZnc1R3ByV0laa09KanlTK2FKNUZRaElsQmpQTmZMeE8vbTF1TEd4b01udCtWR3NoR1dna1ZncWhKTHFXSjFCMC90cWF1T2xqZThZdUxsU3VWVEloRitXTTkwQWZyeHRmOEFLcWxqRm0rN1MrOCs1Uk1rUmpsaFcvQmRXa1lkcmRmQ3JhaytjaW5OYjNlU0tQMjNMVkJqNFJZckdvQ1h1YnRkaHF4Sk5ZMTF6MXF3VGluR0VjNnNzaGYxRzBGM0E4b1JXSDBqdlJDeUoyazlaQ2hjTHg1SjlJVjcyQVZSOVFINVZHblFtOTRHUEJGRmlPa2tZVlJJdzFabkl0cnQxMHRWWmpnd1liWitUTkNyR09YV1dhU1FnUnBFQmMrUEw0VkY2Y3pMdzBTUkpFaWNvR3M0dlkyR3k5NzIxb3V0eHlzT1JmVmRDMHZNcXNRc0FJZ0xLTGphMVZJMU9zS0lKM0VDTEdxbmdib2RmMkFuVm1zTlRVRm50a3NlUmdaSnhGbUUwUkR1NUtCSTFjMkxDL20xSGx0VlNvd1lBNSt2a0kwY1NOLzJWQnUxaHNXNkUwSFJ3a2VWMmx5UXdoYytta3pHeUlxblpiMnY1ZXd2UWROY2Q4bjFKTVNOV3hZQ1c5WWdBMjZCcjlnTnF1SnBSNXYzbU1veUp4WkFJMHhrVUVJbmZrZE9STkVZdmY0SS9WUUFjWlpBcldXNUZnUHBPZ3ZVYSthMC9ZUXY3ZTAyUVNJckFsVkZqejJBUWZyVlozbkdDVDNMSnhNV1RIVEZrVThROEtPeWhWSkZoSWJBRTZhZ2JkNkxqUGd4WXVMN3E0OTNrTHRDcEVieGZ5SjZoVUZBZUhUWHAxb1hyaG1nOXpTRmpIS3pDV09SMnhrQkQ4R2tBOHgxc0IvV2kxcndseVpwSWd3dGpKZDhrYkN3M0xmN3VORWRTUEpqTWJ6UXp5d3hNOTRsR2p5WHVGMFhiVGVpT1pQN3FtRlBGRzhqU004bDhxUGg1Vkt0WUFOKzdRbS9qUnFScnpmY01HYktta3c3eHhTampIQ0NZa0FGdnJKK29hWElvenl4UjRtWG5aRW1TREMwS3pHMG9BSG5Ub29JRjFPKzFVclg5NXdXWERqS3VaSlNaWjFaZ0MxNzhUYTNsK1ZESFo5b2ZIOVBKa3lKMkMySzgwR3ZKQllDMit0Nk0xd2ZkUGMvdXNnaVZ2VFRIWDBsU05Db1ZRTnROTHQxcU55SmUyNGNFK1FZWkNxeE15bDhnWFVxZzNIWVVMY2RLWEt4SUlreElFV1RpM1A3aU5iSDB3Zk1yQnZob1RSSEpuZzkweTg3SXk0MUlqVnVXMmc1QWhXNGkxN1gzRkYzR2ZNanlzU0xGamFPMHFQY1hCczJ3c1ZPaG91dW9jaG45djhBNUF5enFTNnlzL0ZTQVA4QXRvbzhUZWpONWFIbGFWb3ZUWm5uc2lFWHRHaTJ1Rkp0MDNxcGpYaUpKaXh2bHlZekxia0JKeUlSbllYMzNHbHpjVnBsclRLU0ZJdVZ6RGtXTFQ4eWI4ZCtTbjQwMUxGMlprNEN4dXNNMGJ5QXJ4QXNWTE4wSitGS1JETnh4Smp4UGtmd3hQR3diMHdDNUtEYlEvU2VwTktzZVQ1STd6Y1FJb3NkRExIRzU1czk5T0kwSThmQ3N0TzE3ZGlTWk9OSmlwR3NFY3lsc2lSMlVScUVGeGR6KzQ3RUNyak9zK2FNdWVHUEV4Y2E4R1BNVWdRT1pic1ZCSXNmeEZSV3FiTWhqRVVlTWl4VHhMekQ4UWVjbklBSy9nTjdtaGpiRERGNnJwSEkzcXlweUtSZ0FjbUYrTG5leE91bjYxV2RaTWpsTG5RS3d2S3R2VURFTXFralRndjBraXFWcGc5dll4dml0SFB5VnZVVkZHZ0Y3bDVCY1ZOVnlXekdiTjlUSHhWWkF5eGdPdGtqdDlSSmJhckNqS3g4aklFenpBQ2M3R01meGdBalJtUGxJSzlxR3BQUGlTdzNWSGl5NXBDSFBLOFJqTnJjUU5yV3ZZMFJaUFBsdktHanlBMHdrWXNGVUFBV3NPT3BzQ09nb1JvZ3dzZ2pFS3VPUVkvdDh6ZHI5d2R0S0txbDlyUnZVaURtUm01TEhJcS9VNU4yRGNqY0VkTDBOZFBEL3dDUDUrZkMyVkJoZ2NWWXZDcHNrWjRnSmErcEl0dFJOVVNRNDhrMGNmcUNNUktJbUVwNHFPSjVjVEpiekU2aWc1MG51QVptVERMZW1wQkVOdUo4MXczRy93RGIwb05XTGd6dkxGd01yZ0VySTBkeHpMYXNHWWQxcENycEZhSlRINkJsV1Z2WE9RK3JxV1BEVUg2aDVkRFFkYUxCeTF4bHpsWG5Jdzg5eUdGZ1FQTW8yN1ZVbFZaY0F4UFZiS0xJNURISWpTd0FEcUJ5MTM4dW1sS1RsemNXWXhZS1BHQjYvcU5PcEsyUXhIWGdRTmJrMjNxSzA1R01KY0VsSkFIVnkwb1ljYmc2bFZBK2tmSGFxakl4aHgya2JETHY5d0VXUWsyamQ3Y2xYLzRpMTlONkZiMWp3VlNKOGlSTHVoYWRuQlg0QTJ2YlUwSXp1MGlRSkxCR1Vra2xhK1VXSEErVU1icjF1Tk5LSEErMmp5V2RpcWhkRGR3UnhUcVF1OWdkcUs2Y2ZwKzNOSGhobGVHTldtdXlFRlE5dVJJM0hsMUo2VVRIQXlZdnVwOHU3TERDWElIcUZoWlJZcmZUemNodFJXckp4OFA3QXN6aElBL29lZ0YvbGN0WTM0N2dhM1dwU09YamUxZTVOSWNZODBhYjZVbEJGa3YvQUJFazJ0dFFkL1BpK3o5dlgydS8vd0M4MGRiWlFzMGJJYkZnYlg1SHNONnFPZm5OR3p3Ty9KSWViQ0s1NkwwTnY5eE43YlVJVVVzY251OEVLUnVCSURIb1R5TWdITFE2bldrSzE1T0ptWW1LMlZBcGh5bUFPUEk5a1ZvN2xXc3gvZCt0QkRObnlzc1E1MGhWa0ZoSk1VREtPR2lzZ3RkdjkybFZJbDdmbVpXQkljbGtFeXloWXVENnBHV05oSUFOVitIeXFGNVdzMk5QSTdCQ2NSRUxQaXU3ckZ6T3JIbGEvZmFpc21Malp1VmxyRHlFR016S0o1V05sWGtiS3BBR3k2YlVGMmJqWWNEUVJSTGFTRm1oazlLN3pBQmlHTmpvMXhxZkNtRzZ6UVJGcE1qSlk4OFZGWDdlRjI0aEJyY2NSOVFOdGZDcWlzd3JrZTFtYWF5SmpTSVhWQmNPRHF2Rit3NmpjMUZhbWY4QThHTkFXTXVjUURrY2JFSUNOajh0K2xWTEhROXk5cGppaFRMeDcrVUtHWjJEQmhjQWl5a25rUDBxTHJuTzg4TTdUb3F1WGtCa0RMeUZ3TGNQL2oxdFFQSmptbW1CSHB2S3JFcThZc3BhMzBsZEFwVzJsRmpyWXY4QXlPUEVFREV4eVFqelRSRmRRbWd0cm9XUFNxeTRHZUZ5dmNjajdVY25rUHFOSXpjZU1USHkzWHVPMVJZbS90bWZITmt4NVdJa21TN0g3Y1JxUUVJRjc4RGZvZHRxQ2xjVWZhU3haRWlMbHBJc1BwRkNZekVBQXJwYlM5emMwVm1QdWZ1QzVVbVBJVEhCR09heHhwWXN5TjVaV1VhN2I5cW1tTFBic2wybGl3bm1hVEhtbERIRVFYSWxienJKYmR1dzdVSzIrNXkrMFk4c21KZzNtZ0E5U1NabTRjcExGbUJEYS9QclZSbzlqeTVqalBGQ2lDVUwvR1Z1U09TY2JlYnJ4TklWR0xBKzFST0NJM0orS2dvUEtUY3RmeHRRZHZPeDhQQ2pSaE56d25Da3E5d050Vk52R3JpU3ZNUk9FaXltRVpSc2R4NmFNbDFsSEs0anYzWGZYZW90UnhwWTQ4YkxNTHh6NXdkRElaZktrWUJ1UW9POTlxZ3VrOTBSaXM2NUhMTXg1VE1wV01tQjBDM1VnYmVadktOS0xqUExsNHJZMDJhOGJKUGxNSklwWWRRVC93RGlodE45YjJHZzJxcGhSUTVMNDdlNFF4TUc1eDh3RFpIVTZuUzk5bDFxTHFNN3k1aXljWS90eUhFcjVNWnZycUkwQ3Q1bUJPbHg4NkNndmx6UVF4enlMTE9IU05wQ2JzbGpaUXFkYmQrMUZhL2RUbVRZZVdOVmlSdlV4MEJGMWtSZ0pmS2RoMXQwb3puTERsWkJSVWlUSWpHRGprbVh5bTRERUxZRVhCc0JjMnByVWllZjdxc2tra09LVnljZFZpNFRNcFZneDBVV08xNzNQd29qWEFENlN1cThNcEFQVHkzWVdtWForSXQ1aUtvaGtlMXBteVFJSFhHbnhuS2lYWHozMUpRNzZlTk1UWFNiSDlwUHUyTml6Unh4NUVLSkg5NEFRbVF1bW9VN01EdlJGMy9JSHg4TmxpaklrS1hDUHY4QVYrMGpZcnJWSnZxbk53dlpsaXc1Y3RqQmx6cjUxSThxZ3RjVExib094cUs0THJnbVo1SVVHUnprWUFIUU9BZnExNkhlMVRGMTFjUDJ1U2JMWjJ4UFRKV052UkRIekJkZEQwdU8xRTNnMXdQVmZOREtzZVJCQTd3cHBZUktlU2k1MVkzMG90YzMyNkgzTEx6NHBZUkd4S0xhNU5sazM0bFQ5SkoyRkZ5TThudFB2U1phcE5GNmtNY3dmSmlmUlZaZFc1SGV6RFR3b2NSZzl4dzhLZkFTTXJIZ3lBdk1tUmNFU1dZcXNhNlg4djUxTVdWbmhiSWlpRDRPV01hV0llbklpQzFndytwYjNKNWZ1N1VHdkc5andvOFpHYlY1VjVJQ2VMK3BhOWxiWFNyaWYweFRTTTAvb3hUbFNFRWl5d0tENXI4bUVpL3RLa2RLS2VQa1krTmovZEprTkxNOFovakNrQ09WaVE2OXJjZk1HR2xReHU5aVNlVDNObzhpTlJLd2o5T05GQ0ZtSytSMGE0c1RiWHZTRmJQZXNyMnhSSzJKckJNaWs0OWg2cVBzNFFuNlN2Vys5V3BJNGtrRStUaWg0WlpJbEI1TkxJNTROSU5tYlR5bmpwOGFpeEZ2K1laQWd5TU1valFTTXNpU0pHRVBKZFMzRnI4ZGZxQXBxMzQzbHBoOTU5eWJIQk1ITjVGSHBUV0htWWk5bTF0YTIxTlp2eTd2dEgvSUdIdDVrbHhuNXdNWE1xQXljUTJsblErUFdyS2xoKzV1dnVja3JUcDlsSjZZRVhHN0tHMzAzMVBXOVhVa1pZM3k4amxqKzc0NnNWaDlMSEVSOU4xT2c1c1Z2eUJYb2F6clVqblQ0T1BKTWtHTTdLMXlzNm16ZWZiaW9YVFlWVFhaSHRSZWREaUcrT3FBQkhJTDN0ZGg1ZHJtcWpWanRPc2tjY1FYbUZLcXpBRVhQUWcvdG9Oc1B0V1RDa3VSbFc0cXdWMHNRRHBzbzZHMjFJbG9seG9Yd1dsZ1l6T2VSZU5sMUF2YnpIKzRiME5WeFkrRERFeGFRckx4VWxndDczT3Rqc0NCUVdRWlRKUEN4bEtTaDI1WlJBSTQyc05mM1gvS2l1cytSaFMrM21WaW95QlpVQzZYNmk2OVExVmx6SFJzWEZHUTdORzdNU3JvUEtRTncxL0doWTR6VEtXZU9ISmIwTW9sdlNZV1VNQm9aTDZLUC9qVVU0OGVWTWE4bzVJNXRJMFpCQkRhL1NldC93QXFESzRNZVdweDhVTDVRd1VnMllOcGZUOXQ5cUs3T00rTGl6d3VVSVJ0SkZlMXdiZGJlTzFCdWp6NEdsbEU4SEZIMEVjZWg1Z2FPRzdkeFNGaWNFbVJqZXA5dHhsamxIQm9aQnpWaDBJN0VkNnJMbDVRa1IxeGNnQjNZMkNvb0o0UHIxL1Nvcm5CSFF6bUFzL3BKZDFJQ01wQnQ1YjZuNWEwR3pEbVNOa25tZG9jZDNIcVRNdDdNTGdtMzd1UjBORllwTW5Jd25mSGtDK2xLREtKRmJVeHNiRW9SMUEyRkV4UEFNaytPc0tGamhLV09Na2k4MkwzL3dEMGVYVVVWQjhXZUxKTEhIQWtZOFVScnN2RUhhL1cvYnBRV0RJOXd4c1loNW5hRkpCSkFCWTJrRnhia2JuVHhvaUVCeW9SOTR5Y1BYTjFDOFNXM0JacjNzYWl0V0hOaVQrNHVNZVpvVmxqNHF0cks2bXdma0w3Ym1xaXYzVi9RaHQ5czAzdHF0NUg0Y1ZFbjBuZzNadDdWRmM3S2VESFZFVkdFYk1wbTU2eklyRFRYOUtpdE1XZExGZ01ZdnQyNU15UlpES0JPbC9MNmJmRlRmYXFWQ1NQM0Q3akVnekNHUm05QlNTQUl5blRuL1h0VVdZNldaa3cvYWZhVFFsWnVYQldqUGtOOXl2UVhxczNYRFJzZkg5SlpVaU1DdDZqUzZxNnhrMjRuKzF4YlNvclpORm1lelRzR1JUaFpGcG01SDFPY2Y4QStIelpkdEQwK2RWQXVVeVRTVFlnVVFaaU9pd3lNQnBjRUZHUFg0MEhNZlBrVnJScHhSSFZoRzl3bGhxNHNEYlZ1dFJvU3JrNU9QTG1pTUlqazhvUTdFRS8yRyt2THNEdlZScGh3R3lRaXcrbkkrWUNZUzlrSDhZQWRRekhSbDdkYUZTRW50anhTUVk1YkdEUmtacnV2cVhaRG9GLytWQlAwbG1WSU1uSE9ES1ZBaHlFSkFrQzZxQ0dKNEcydmxxQ09LbUpqdytqN2hPN1JxR2ZEWlZ2RzBpbjZTTi9uVktsZ3d3cG1SUEE3UnRtS3h2TEdyUks0SUhKVlhkYjlxaDN3Si9iTWNaMDhXUUQ5eWozaGxqUE5YYncyM08xVWxhR2JHZjIrU0dRTXMzcWh2VFpUdzh1NDE4eTN2MHFwV0hDOXZuVDNPSTRjYkpNeFlNVWRtVFg2VlhxTER2VVh4M3MyQ2ZHeGVVa2JyQTQ0UW1Wcm4xUDNYdC8raU90RWs1WnAvczF4NG1oZ0V1U1dRemNRUVc0ZlZ4SU81NjZWSXQ3YzczMzNDR1FJbUJGSkhHRlptZDdPeGtjM04yNlZTUlRoNVQ0K0szR1ZrV1pQU2Q0ejVKRkp1WTVBYWl1YjlvdVg3anFaSXNkdVJFOFM4ck1CdW8vY2ROdDdWbXQrT2ptKy9aMHNzVFpxSmtTd3FzYnlxb3M2MnRackRvT3U5RVk4dlBaNHhCTEVpeVNOeXVuMGdEUmZucnZRa09GRmtnZUZrQlpVdEcxeFlFSFU5NzBoUjZHREhnT0ZkOFRMOGhTeEpFalhJYnpicWUxYWlXdFVTK3JoaEdlUTVZWWVtZ0FOMWM2dEk5OU5kaFdNZE5kayswNGVEaHh0UDVzOXdTc2JlVWhlaFVuUWp4cXM2eXVJNGNLWkp2VE1oUU5INlFEdGNtL25jL1Q4cVdMSzVNZUZqeDNsZVJHNGNlQUdwMTEyTnVtNXFMVlVVV1RrWnJUaVVyak5LZWVRUXBaaVFlS3FnM09ud0ZER0hPeXBvbmtEaG5XUzVsQklZc1I5SXZ1UEh2UXhIRHlKVHd4MklrQThvc0FCcnFiRS9WUWRYM2ZIa3hwSWhQd3paSTBIb0tTU2drL2N2UWtyNDZWQ01zZWJESGdSeHBBRmtabmFiSVlXRFhOMDREc3RWSFJ3djhBa0RDS0NETFpteEVPM0VBS1QrOVFMY25IKzQxVXhseVpNakl5SURHV01FanNrQ3RhL2xiUWIyQjJ2VVYyTVdDZWVKc1dNY1dJSElBZ0N3MU52N2liM3FvMG1Nd3hQeGlWRnhsNHVlb0o3anYzTkV4eGZlUGNaODNJSEVXbGc0eGs3YWRONmxha3gxc3JMeU1URWlqblZZMThvTVF1d1A4QWM5eDM3Q3JxWTVlWEJqNWtyOFhQcHFDY2RDQ1hQKzBnYUEyK1FxTk94Z2UyaUgybFpqZVFua1ZTM1VpMXo0MXJITzNhODdCN0kzL3RCRndTOWp5S3NOTCtabUoyOGk3aW8xcS9LOTBqRXNHSEhLWk1PSzdzSlY5TmVUNmtOdmUrbXRDUmY3UkRoUGxlbVFKdWFsWEZ6RkdJM0ZoWTZua0d1TDBMVkF4OFdUS2xMSjY2b3c5UWxqWmlCWlFEMEZaYThkQWUxS1FxVDQ1dUZCWUcvSUM5d3V1MWhwOEsxR2RIMitGQmxxbGovQkd6R0NJbjAyTEM2Z1AydWVsQ0lwN1k4MEFWN3hoUEpPRnNlTEUzdTF0ZEtCaHNhTnBNUERSM2xjQ05HMzVFYXY4QVQwMHFveXZJMEpRcElGbGpacEptUUdSdVFXdzVYSEVEcFVWZjdHc0labHpGRVI5RzZLdHp5YzdjcmJFMFM3NDZ1VGtjL3dDSEhpOUlTajA1WVlWdTdJdXArZWxOSkdISHlZSThmMVpNdGt5Rkhtc1ExMFkyS2tEcUFPdlNxV0tjdkxsejNsa2RtRUdNb0tJMXIzdjVUYmZqNFVUcFROTGtOa1BQbUlxenplY3FsZ29ES0FxUmdYQ2kyOVJwMC9iWXhOQnhseVRESEVmVUVSMFhtZE9RdHFXdDNwRXJSS0ZYRTV4RVNNcmZ4STVZK1JmTnFEcFlkcTB5d21ZTVpQVWtUZ3loeWhOaUF2OEFiZWd1enNkc1RMV2Ixekh3STVKRmJsOU53MXorN1hhZ204cjhQUjlYaXNvNHl4a2NDUTM3bTNOK1ZDTk9SSGg0TUxmYXN1UTMwQmZUdWhZZ0s3TTU3WDBGRGRaYzZPT0NMSGljZ0JKZldXeThXdUw4ZVViSFVYSFhhaEdmMjNLeW55OGdDOTVGTVlUZXpOczVJc0FTZGplZzBaT05OQkJMSkZHWjFZR0JKU0xjYmk3Z24vZFVOMTBQYmZiSlpNS1hNT1VxeXdvQ0l5T2cxWXBzU1IwdldrckxtTE5qTDY0eFdTS0N6dEs0UE4ybDFCTi9OZXd1S2FtQ1BPeVpvWjVIeVM3Q3dZM0laZ2ROVHVCMHRRNkxMeGNlZU1SWTdpVVNxcUp4c2lycmQrU2s5KzlGZExGOXVsOWVQRGpnS3hCQVV4NTVBWUN6ZlU5eDNGRVo4bkNrd29saGVPR1NkWEtYUitYRmVoY0RRLzdSMW9xaFpzT1gwOGIweTdEazBjOXZMelVmeU1RTGRyTFFkTmNpVlkyU0VxWTBzVXVBQ1d0ZTNmaXY2MFJ1OW93UFZhYVNXUVBCR3hma2JNUFZaYjMyM0ZWTnh6bjl5d284ajBnc25waDNhZUV1eUtRQllMY2RXYW91T2MyU3FoVERHUDV5QzZjZWRnMXdXSEx0c0QzMW9LWk11YmtBMGNjUktqR2hIL2NkVlUvVWI2cnBwUWR1YUtMSGt4Y1Y1eXNmQlhtWkc0SGtSeUxjQ1JaYldXcW11ZVpvamsyeHNscHBQVVBxQW5tZ0o4cWxmN2d2U2czNDRkZmI4ckxTWVBrUkJHKzNqSlVnM3RmajRuV2dNRmtHUEV1Y3drKzVsRFRtUWxnRUhWenZZWDBxSzBQaVRacVRQQklrakV1SllrVUwvRnk0Z0xmNnZwdmRlbEtNYzJCUGpRdE1ENm5xOHRYWWdjZ1BwTmpjMlBlcUtTSGo5clJwa1lTU2k4TVJzU1FsZ3hGdEZBdlJJb1hKanlmVFdlVjB4b0gwQVN4OVN3QkRMYmxmeE5SWFV3c25Land2UW14RmxZeUx3bk9peHgySktBZlNwNzFTc0w1SHVZVGlmVWd4R0xKRmtFZ2xsYzNKMnZhNG9WSUJQV2VTR1htK3F5THVQSllYWmowNjNwVVdTNHVTMGdUSUVjYXhNRkxMSnp1U2VZZnJ5SGJ3b0pUKzJLSkxxQk02M1ptWUJoeHNOVGJvU2JBM29MSk02SXUvL3NwaVhVTEVSSDVySW5HeXRiWk9PbHdiMEl3NStWajQ3czhZYUZwcFE4YWtONUl4Y0RVK2JqcnZ2VVZlaVpMZWlra1JueVlwRWVCUUR4V0ppQTFpTmQ3VlVkSEs5eVgxdlVlSkZtSGs5YUpsVmhackJYdU5GSDQwRlluWDNqTEJ5cGhMaXhIMFZRRUJSNlExWlZPcHUxQ05XVGxZYWUwU0xKakhJbTNoa0o1QUhZRzNqMW9ucmlTTlBPc3JRU0dSVXRJL3FIeWl5ZzJOanNEUlZFRXo0NnBpbFN1SzRSczVDd0xNQ1NlTVYvcDhiMFIwNEpjUnNhZjFNWVFaaGF5eGtrTkVyYXF6WDhLTGF1bnlFbWdneVlBQXNSWU9pMmE0VmJCUU5OTFhxczhzV1ZsVFpIcDR3Vm1oVU55QXNuTXV2bGJTOXgvMG8xR0NHR2FUMDRjOWVFZ1ByK3FEWkhGNzJLOURwYlNvWTdhQlpoSHdSWXNkSTdMR3h0NVNQTnRycVRvTjZxTkVTREJ3RmlsVXNyK2FKU1F0NDlqeTB2OEFBMHcxekpQL0FQbmJGQU1yU0F4aXdZZHJnOWR0clVHdkRkWHhEQktxTG1CeVFYMEJBQnVHOGV0RFhFOTM5c01QcW9aRDZyaXp4N0VCZ1Q1ZXdCMXFOUlAyZkd5OEQyeHM5VVNhTEhJa2w5VWs2RWdBbFFMa094MHBDdXRQNzFsWjJaQzZTcXVYSUdjaUlpeXN1bkMvZ3V3cXM0eUQyM0lUK2FPVlovWEliSWprVUJyS0w5VHB4TzFSVXN2MjlaY3RXbE1hdUY5SjFUemk3RDZpeDE4OU1OVi9hTGpaanorM05Jc2pNRmpuc1E2QlY4d1cyeCtPOUJ6czdCTU9YSkdJcjJZaEZCSms4Nkd6bTkvTHFTYlZGMHhLZmJmY0lJZlhNSHFSS3hkaVN4c0FGQXY5UFBvYWFkdTltKzhlM2ZkL2I0VXJSb3FxelNNT0xSdUFRTGtYRnRkVHVhckxtdys0WkVrY2E1WlRJVEt2aklWTm8xa3ZiNmhwZnF0Rkh0TUF6OENlT2VOVVIyNGlZbHVQOGR3UXliTHp0M29ybDVIdFdPSXA1RWxlSEd4ay9na1k4dVVoUE5sSkdnY0RSZTlxaHFmdDdETXo0b2tFaiszVHFZaEZvZ0JJdSt2N2JNTDBLbjk0K0ZEQkNzVVlXQ1ZXY0JTMXdDU1NRZE5ScFFTZWYyMTVSa1JEMG9ISE9OSEpWaWpraGtWUWRDdlNpTkh0R1Y3UGpYeVpJbWFMMU9FRWJrT1FnMTRJZWhiU3FWUFA5cngxOTBHVll4UVRyWU9kU2h2Y3I4UWVvcUtNckQ1eit2bVRzWkpXWlRLRGNQMzhvMTFhMVhFMWl5Y09YSXhjbUdIbGplb3NVelFHMW5rUVhJQkEzdHNvcVZZellMNHJLY2ZMaFgwb1dJZVFuK1JpQ09TZzkrb3BDdExZa3NlRTArSmxYNFJqSmppZHJuenNRcUlUcXJqVy9IZXFrU3hjMmJLaHhwcFd0d0hCa2F4S29PckFXSkRkNmk0b0N5NXNrQ3Z5UjRpNWo5TW02cGU2c2I2QWZ0dGZTcU4yVjdkbWNPQTR0R3E4L1NMK1lhYUFFOU9wRkVhUHNaZi9BRnNjaUdQZ0k3dkZPVHlSeHNMdDNCMEhhZzg3bUxpQ1V4WUtjblpiS2hOaXpGcnRzYmVJNDlONmpUZjdaNzc3aDdXZUVrWW5Ea0dPUy9tVUhRcUNUcnJUVXZ6S2tveWNyM1NQS21JV0dScmV1Q1g0SVFlWEpCWWtBSHpDclVQQ2hYRGFkVUxNNGtFaVNjcmZ4amMrSnZ0UWREM2Zua1lVWm1QL0FIMVA4aXVXTGdOb3hHNm0rNE5SWTVtWmlZdnRjdU5KS2tXWkxMRXhMbCtZQnZweVVhQnRkUlJPM2xadmE4dkZrRXZKMmlRK29BdDI0RW42ajRWSFI2bzRqNUh0YVNtWkpNaG1ZdUZzemh2cThvR3hJcldPVituSXhzcjIvR0dYSEJqUjVQcWpoSGtCdEZjOVFHc2RLa2J2S3A4a3dTc2NiR0RaNlJFeW5SNFZnWVc4NmJjaDFxQ3ZJanhEN1hETkxJQTh6ZVRoeXVoanNQcXZzMzVVVjA0WU1UTnlIbmlzUmhSOG1ibHhFekN4dDFQTzM0MFMzQ2x4Y2FMRFJzYWVPVEJsbFpHOCtxTmE0NWN0VlVFOGZFMVUxeWZjSUkvY01DQ1RGd2J6WTB6Sm1MZmc3bi8vQUZqVkZ0b2Rhelc1VlB0MkRrWUxSVHlsa3h6ejU0N1gxS20vRmJqdFJiZGVuelBjazl1dkFHWm55MURza1lBRXFFZ2dONGJWcHo3Ujl3end1UVpsQ1I0OGdWM0VaSzJ2cHhVSFhmZWdveXM2Y2UxbVdERVpKbGRnSmczSm8wT3hLN2xoMFBqUmM1V2UzKzN0RFBHWGYxWkRFQWswTmdvNWFndnA5UjJvbGRUMmpQalQzT05TQkU2TUxTQmRtSGYrdFVHWGxKRG5aRWo4R1ZpU1NEeFUzMzJvanFZdi9JTUZzTk1DY2t0b1RNUnlaZE5HUGhWVEZudCtYRFBOTElyV2hqVmpJaHN3ZFQ1UTNIY2k5UlhMa2VMRkpnZU1xclh2RU9nT29JSitOQmlsZUtDYVBYMHhZbjFOMUlPNEMrTkZiTVRIUjhoWkEzSERSZ3Bua1BHM0xWZVF2Y1VOZGozWFA5dXk4UVljQXROSWY1UkxzekRiamJZMVdjdXZMUzRHUEtqaVArUm9nT1JmeXJ4QnRiNDNxTk9pMG1EQVZ4aXhTZENwbW1JSVZGL2NIR3ZMNHJURTFteThlSEV6SjRVUEZZNVZBVThnSlltRjczQk5yVUJsWlV5U0tJL05qeUplSjVyR1N3L1lmQlR0VVdSczVKaHJDSkd1MG9acFk3WE1iRFFjaCswbnRSZGI1TW1Gb0k4aU9SRVFnRjQxdXAwUDdmRzlhWWN2M0hKZktqbHlIVUlZamUrNXQrM25iNDBNWm9jU1gzQlBUUkw1Y1FNaG1MWFoxQXViRHdIVVZHbGlpT1dCekJkQ1NHYUFrc3dHeGVQbDlRNm0zV2lLbmZHTVpSOFY0NTlUNnpMY01wMllMc1BsUlYzM2Yyc01TUkNKMWo4Nzh5VmxzZFJlMzd1MXFJc1B1K1ZKakxEa21Oc1lwNm9MQUd3TGFGdGo4dDZhdU1HVmp5NFBPL0l4Q2F6eHFRUWpNTGlWUjIxMHBVa2JNMW9ETDl0anpMa3JGRDZoTW5HQjVMYXNRRCs3WHJxYWk2NHlsMTlSNTc0K01pK29IYU1NZVRhRHk5dnlxS29mUDl5aXdwY0tHUjVNYVZnNFVNU2hJMTFVNkMxTk05S1BNeHN0bVhJSWo0bXkra0RvU056L0FIS1B5b3Byanc0YVl2cTNlT1JuOVJWdHlLNzZYL2Q4YUNUZTU1RW1RRU9SOTNIUEVJMHVMU0pFRFpVZnRidlRUR3hEa3JMUGpaN1NCaWhKS2tNUTRGMExkQ3E5ZkNrSzVNOG1mQzhtUEtWdWJLWFpRUVZZWE9qZDl3YWFZN2ZzWXZqejJsTEVYQzRyTjlCWWVkVVlpMXlOUUtzWnNZWmZid1dkWkFKWTJzVldIUXFxNnF0dHV2bThhalNMeDRxNDhheUx6SEkra3pEaUc0RzdLeHZjQzNXcWpYSEo3WEhtdTBXUlBpKzM1TVprWmdCSXltMm5xcVBIeUJ0eFJPY2N2M09ESlJZbGVVQ05BR0VjaHNRVkZ3Rk50VFp0NmxhamUyWmlaVWtVZUtneHMxWWduSUxhTmk0NGxYVWtqLzRuclZSbXl2Yi9BSEdEQlRNa1YvUWtabFl1M0lDZGRPUExvUU5iR29MTUxId0JERFBJWkdrOC9KQ3d0b0JhMitwM1BTcVd0UnhseElvMlhKSnhSNTQzQ2tORzUxYTZtNXYzdFJOV3llL1NUNUdGa3pKRkc2NmZjeDhmV2VQOXpzcDhvdDBvWW93SlJtKzR1Vk1oeEhabWlWOVFDUmRnYjlXQW9ZOUo3bGorMkxpUlpPTE0wVW1nRVFQRnJEV3cyUGplckl6dGNyTnlzcjNNeFpIcXZsenFBSkV0WmpiL0FHRDZtSTF1S3phNlNZNU9USE0rUUpZVmFKTlJ4ak4yNTdFOFR0UWFseHA1MEN3T3BaRkl2SUFPWnRweVU5YURubU9YRWdQb3dPcGs4MFdSS09hWFg2MTA3OUtneWhwNUN5dXh4V1BHVDA0Mk51WUZtWUwvQUhjVGFpdHNtZDdmZ1NwUDdjaVp1S3lpS1lTcFl1eEd1bDdobDZHb2R1WkV1TkY3aEppWlNIR2RvMnVvSEs1SUxKY0hWU2IwVnR4UGNGeHBDMCtJc2tuRkNrdW4wblRSVnNwTnFKWTZjNlF6WTh2MnlDY3l4QWwvVE40UU5YWGpZM2JzMVdJNHZxVG1GQXNWbEZ2VFpXSEpsLzNCZXZ4ckxvMVNMa0V4cm1PNnhLTG83Qml6QzJnUyt0dmpwV2tiMWt5L3N3TUNKZUFVYzJjclluNEVnVktNT0QvN1l5ekNFcUc0U2VzM2s0K21CNTdnOTlLaFZjNjRBd29QUmZsT1FiY3dBbHlkZVZ0YkNqVWNxNUxvbVlBc0JsQWFSRFlCZ056eEROdDRYcUsyNGNmdHJaaUs4cXhzb0lWM1ZtTERVcVZHbXVsbHZWUmJrbVJ2VE1nUkFUY2lYV3cyQUp2ZnhOUVZaSDIwVElaUFd5TVJZMVBHU3k4ait4VkxXOGw5Nm9YdlV1VkxrenZQREhqbmlyWThVUlJnVFlBS0dRa0JiYTNva1VlMm4yMUpsZklEU2p6QjRveVZON2VVbGlQN3QvQ2c3VVQrOHlUb2lwSkE1dDY4c1pWaUU1RzNwS0R5L0NyRVVlcGtDYUw3ZUV0SzEvclAwazNBdUdPb0EvOEEwcWh3NWtoaWZPQkFNU29GNEt4TE04bytybWYyOHFOT2xNY3VXV0krNEw2RUpYL3hnM21qVTN1M1BqZmtlblNxalJFc2llNEFjMGtqL2F6QUFiSGpjSFRlb1BWUVRaSDJTSXNBTUJRZnk4bEFCUGNYNWFmQ3R1WHJ3bnZReFduNEhpZ1VzVElwYnpQeUJ0WlEydlFYRnF5NlJmayttcERaWTVGRVZRbWdMc1I5VXJiaFIwQnFVaW4yeUF6UEtweVJpb1kzT1E2cXpFSUxhUHdEbXhvMWF1dzRvaTcrclBJR0JQcDhWdmR4cXZLOXQ5dDZSYTlKL3dBZGt5RGpzdVZFVklCYVI1R3U3V0o4aUE3QTlUV25QN2N1YWYzTjJ5Vng4ZFl1VWJjcEF5TTZvTitJdjEvR3N0TVBzcDkwKzRtT0tzb25JSm1DV0tpTGpvRHp0clZLNm50UDM4ZnVNUyswbjEvY3lyY3BIQ0N5MjgzSDFDcDVXOFBoU00vWFhKTkpLSUkyeklZR2dFcmNralpReGxKSll6RTY2RFFiQ2l1RmdrSFBkcGd5d3EvSmsxSWF4MFEydHFSMXZ2U0Zhb1c5emtFb3hrZUZTeDV0R1N6aFNUYmp4dS9FZGVOUnFzK1pGQzBZWjVqSEhIRC9BQngyTE5JUllhbXdzR092bXF4QkFNbHlETVdpeFZIbkNlWm04djdyK0c5elJscm1SVmtYMVpIZjNHNGJJc0FQTnB3U0w5dTF0ZHUxV2thb2huR0ZubU5rVGlQU2JqeWVRN2tzTkJiL0FIVkN1cXJTTjdSSUpsalRFZVFpTXNic2o4Zk1SYTVPbFZLNUtyN2I2aWprTGpSQ2IzTW1saWRLRHNlckd1RTBub2g1U1FNbUFGUW8xK29zVDlYaFFaRU9MTklxNUkrMms1OG5rdXp5YitWUUVCL3pxcHk2WHM4YU0yUWpUQk1QaUFrcFVGdlY1YUczMWN2anJWWlpzbDQxeUdMeHE4ZzlUeXlGQUc4dHYzSGZjbTlScHpjUXF3eUpjb1J4c0JId2dqc2J3ay90WWVRV0hqdlVXdW5NdnVQMjhITmovd0N1RHlIR3Y5QmxJdlp2OXcyMXFzdGJFeWUxeU93V0ZKR0JXS0s3Q0pCc0FkbUIvQ2c1UHUwSnRBTWpJazlYeThDNGt0c0N1NjIyc0IwK1ZCWGl5NDBlUE1HZ00rWXhIb2tNcWhWMlBJTnZycnAxb0xjaDRSalJJSTFaUXFscExqMVNlb1lhRUQ1VlNPcmlTWlBweEpqeE42QnN4bFlnRUpieklBU1cyM05yVVNqSG54MWd5bW14aklibjBVUjBDZXJmeStvU2IydFVLeTQ4M3VKOXdnQmdqVjdwd1pDaFQvN2EyK05XRlpjeHBCbFpTQkhNL0h5ek9kTGZ1NEt2UzlSWFk5a2IzRC8xWHBvamhPSEdTWlNEZGkxK1lYVFlhQVZxTTFDZFlHakxST0k4eTFqR0FHSEMyalgrbm5VYVM0d2VsaXRHNSs1RG4xWS9OcWZFZ2IzMzZWYXpIRnpUSXVMQ1VDT2JzUURiMVRKeUhKU1FRM3cwcU5NZHBHbGM1Wk1jNVlDUVNYTW9UOXgrSGFpT3hpeEovd0N3QXhaMTlibURHM0c1dWRBTkxEVGZTaDR1Z1hKWnBreDJXT1VPT01zTnl4UWY5em1DT1ZqOEtDL08rM0xrdVNJK2EyVWZUYmozR2xJT3ZoVGU1SkpMOXJCSEtURWJlWlFBbC8yM0k4dDk3VllsY3JHREZEOTJZMW5OeWhTNXMzN1ZzMm0rOVJXZjNIN2R4QytQL0VVVGpOR3BabmRnZFdKSXNMdDJvTWZBYzNKa3NWZGZVQkQrZHIrVVBwb2ZqUWQxNWZjRDdkZG9MWWtaSXlGZHdSSk1RQXBCQThxRGNYNjBFV2ZJajl1UTVNYnpvVkJ3MEpDTUY1L3loUzNXL3dEcFZSUjdhMGh3d3N5d3JqOFgrNGRPSmZqcnhEQy93dlFxdEpQZHhDaVlzVWJRSFZwRUszQ0cxbEFjaGpwdnB0UVhSdm1MRXFRSUdEc1RreXJieUowVmd4RnhmYnBSV0lQRjl6RXFwZHVSSWtHaDlUVGdHQVkrWGp0eTA4YUIrNnZJenNtVEdVeXk5M2t1dGhDQlpRZ0JQbElva1Z3ZmRuRGpBOVVZeWhSZVBsemRkZVJXL3dCSnZhOXROcUs2SHZ5WVRZT1FNV1FKQmFNRmdBVzBHaGtGcjNMNzJva1pjUnNaYzNHWExRUEswWE4yUWdPcTI4c2VscjYvdW9yb1N2N3Q2K0Y1QjZiUi93QVlQQUlxNjcySnUzeDBwVVVTeHBKR1dXVVF3SkVEeFVFaDlkQklVQnNPMS8wb01VS1FTYzNEbUhISkpNVW5uSWlEQzRVZ1d1WHRlMnUxQ05VY0xLMlFGbmQ4MXBENlJuVWppeFVYNUJ3UE1CUXBlMk5tcEkzTlZseFBVWG5mUmIvc3ZxTmI5NkZkV2ViRExReCtnb2tSaVpaMVlYZVMyd0NHNEY5dExWVVpmY1ZDdkV5T3J4WFh5V3RwZStoN1gwcUxEaWt5Rjl6YTBYcUtTNThyQlFOYkVKL3U2MWFrVTRzY3Jwa2ZkeXRGa0tITWZxTHlWa0k4b0Yrb1h2VVhobVJjWXd4cmp0eGtWbUR0WUVzTFhWaDJQNTFSZmo4RmhCaER5ZnlCa1VrZ2NnUE1wNVdPbytWRXFXUU1wbzhqN3N6Smo4VjlVNkVXNWZ3L1dMOGVYYW9vOTFrenBHeEZoaFdGQW4vY2phOFpHZzFBNUQ2dGUxQnpjcFY0ckhqT0FQV1V5VFJnOCtZVTZLQnJxZkRhZzM0RWJxckxMS3p5aFR4a1lFWEIrc01DUHFGSVZveVV4aGpLQTVaRHlEa2dnOGdkellFNjBTT1hpK3VjdVZwZVFiakdXUVgraTJvQkYvMi9sVWFYenJQSUdlUi9ReFFyREhqWUZweW5FRXRkZjlsaHFmbFZSdzg1Y2VMM0IvdG5YSXgrQTNCVitQaVhzMisxeFVhZENKWVRybk1RelFqMUZVZVZWdlp1Ukg0MFJqeUVpajlzWTQ4a1UrRDl5b2xWd3ltK2hRM05oYTJtblNvcnNleXlTY3k4a1MyTHVXamlLK2dJeVBNb0pOdEZyVVpxV2I5cXVHUmpXZkZMcVNSeERDVUUrbUd2L2NMNzdVcE5ZdmFGd3BQY0k3bDRJdVg4L3FFc3R6ZmpiZ0wzRGIyb3RSeXNmbHplYktaTTRGakhFNkF3RzJsci9UcXBKSElqVWQ2Si9qaVNpRVpHUEVHWmxGakhPb3NoQUpBRHJjdFk3L2plbzA3cC93RFVqR2dqYmdWVmlCTkY5TEVrSGtWN0E2Q2c2YzR6ZnNaRmNqLzE3Q3p5SFJGYmw1aUIxTjdiVldZelkwMGE0dU0wK09yem1RcTZGaGNJUmJsNWlCeURhZ1VHaUdXUk1TWkpvRmxpZGJTUzNqRXFDNTRzZ0pCUGlGRlF2Ynp1TDltVy93RFA5TVE4ckhiNjdhazJ2KzN2UnFvWnpabnJFT2hJRS9MRWJsNWlMV1pVdU5BVjE3WDJva0xCZktPYm12N1VrUW5LdHppWWcyVFpnQ3g0N2ViNDBoZjI2K0syV252ZU0rRXFTR0lPSGpKQWptQUE1bVF0WUtDT2hxbzczdWttRHhpTU1ROHhISlVJNUlUdnhJT29GRW12Tys3TG1SNXFjSDlmSFFoUnlCV056Y2xXY0cxbTNBQk42alVZdVdFVGpqTVdkY1ZwRDZaaDlNdXIzTjdjRHlPbDc2VUdaY1AyNkY0MWp6NHNtQm1ab0pHamxVcWRiTHhaVldvcjFiTGpIMnFFeHVWOXlVTjZnaUE4eWNQNUFuQzlodytxOWFaLzE1VGxLTTZJeEx5dXB1R0lzQjQ5Q0xiVkZlZ3czakdCa2VxaU1seDlaQWJqYnAxcXMxNWIzQnNnU1FwS2dPSVp3UFVVamtGSTBJQkkwSFRTc3R4My9jc25OYjIrR0hPeEkwalFIMHNxSm83dkh4Ly9BQmtSbVlEanZmcldtUFhsZU1KWjN3V1pjb0lmVmlGeVdqNDY4R0EwZTNiV3N1amtZYVJja003K1F1T0lQUFJiL3dDMGZWZW8xWHFNT01JK2U4a3ZxSU9JeW8wQkRuWCtRc3lqKzN2ODYweDR3NVVVZkRQOUdhVDdSV1V2eFc2TkZjZW1OUURVYWljeVkwUHR6cDZrbVRpdUl2dEpWVUlVOHhMZVg2aWIzSGY1VUVwWVBZbXpVR2ZrS2txb25xTmpCeUcwOHBZY2VJYit0RWE1VzRTekQydFJLalJLdVcweHM2a3Q1SDFzU1IyYlc5Vm5sREpUM2FNU3BOSXMwWU5wWlNDR0syRnpad05iVUpqSG5PM3JMeVJ6SUdIcCtzZk8wVEtMYm00NDlLRG9acis2Q0FISWpMS3NhQWorTWNnRzhwSkp1TGp3djRVQ3dsekkweUdkbW5EOGZVUnVhaER5SERpV0F2Ync2VUZVeis5TDdnNndvWFJaYkY0ckRrMTlTQURZZWFodzYyTWlTUlR5Wk1qUTVTbTA4TERrV2JlOTEwSFkwUm15REVWbTlSVkJDbjBqM2ErbDliM29ySDdUQ3o1cThNajBzbm1QUnNyRVgvQWkxQ3RwOVgxb0ZrdjYvSmpHOE4rVmlkckRTd05CcnltbWFSVmxRcE5iNjczSEczVUhXZ3hLSXpJR3ltSVFueW9iNkMvN1QydjJwU094aERFUmtreFNKRGYvQUxFbHdseDlYSm5DaXgrTklYdG15RGptU1Qxd0JPekVvRGZ5bm9GdHA4TFZRWjdRdVN1UXFSdnJab2lTMWdCdnh2NXU5Qm1tV0lOaitrL0tNcjU3ZzhnblkzdHAzdFVJdnlZb2xaRjlaWFpiZWs2aGdXL3Q2ZnFLQ3VkcHg3YzExQmYxUU1yMUxjK2Q5R1c5amJ1QlVXTXlqSGFXY1piUEhIcndZQXMvTUQ5d1BmcmVrVzlOY0ZoaVFxeExDOTQzc0EzRyt4QU43MVdlRTg4S3NZYWRoSk9EYVNOYnJkVDFZalR5K05VUWpUQzlKTHlFRWx0R0IwMDA0OFBOK0ZHU2lJRXNaWU0wWE1ER0F0ZlRjL0E5YlVVZTVIM0hqS0psZjBSTGNrbmU5OUVBN2ZoUWJzZUwvajdRdEZuVE5HNFJlR1FvTE5lMTA4cEYvQ2h5eVlUUytva2NTRDFoSi9ETkdSeUo0bTF3M2wvL0FEVkduT2hXTXlreE80WDFINUJBT1hMODlQeW9qQk1SOVRoRElXQUtrMmNIdjQrTlJZMHpITk9HcWxXV2JYZzl6eDlLK3ZJTnBhKzFCZjdYNkl4OGxzbXpQR0J6U2F3aWtRank4U05uQitWcUxYUHhTVGtTY0JiRTlSZnVPTmlkYjJ0OEJmYWc2YmpDaERCVDl6Z3RDMzI1eVFJM1ZTMm5IVy9sTzE5NnFLWklQYXpsUUNQSlpaT0o5UXlJZnBBN0RvYWc5VmtLRXhNSmYrUXNzdU9ZaU1kNHJMa2lFaXdMY1J5TmhyNXhWOFQxeE1kdmJJSk1vc3NPWmlYUHBybDNqYi9ZVTF2ZTN5b3ZLVVk5cmt5QzN0cGtoWlVQcklkVlkvSzZnL085RWRIMnRjTmpNeFpZNUFSWkZ1Yi9BUHhORmN2M1NMMmNaSmtXVkRMNmc1eEhsdjhBN2JyNmY1MHBIRm5YSFB1RE1XY1JHeG5UVzRIVUFxRGNVRytkczcwT0dXbzlFeXEwY2t4WG1GNCtWTmRiVzZnZkdnNTJmQjdVY2xMWk5weUJzcmFEcDlJUFhhMVNySGF4b3MyRDI2Tm81bXkvYnVURXBJcGpqRTl0ajZnQUp0dlNKZTFlUEZobkxoTVV5TElkWkJ4UHBnZG4zRy9ZMVJ2OTFzRVpZekV5QzRlUkxnRnU5anJ2VlplVnlWd1M2K1pGbkRxQ0U1RzU2azZiZkRTOVJwdTlwdjYwcEF0RXpqMUI1cnE5OUxYMEpxTEhwL2U3L3dBWXpDM3JGRnNTQnlBNmJiMWF6ODQ0Q05scjZJeEVMeUZqOXN5R3hEZzlBZTlaYnJQTGpxTTVSZ1pjclNteDVQR1IvTGU3QmgyQjBxMUduM2NlNW4zTExYM0FwOTh6RDFIakZpb3RlOW8rUThOS1ZQbjlPak92dThuL0FCOG96aUdCWERZMGdBS3ZMWWVXeWNpTk9wSHhxTDY1a2ttREsrSVlvaGo1M01MbEtoRHQ2Z0JzdzVIanIrNFhvcm1lNHQ3UEpESXVLa2tPU2d2a1NNUTNxYTdBTDlPdEZZc1ljaXE1ekdPWWttSjIxa1hUUVNENml2eHFMVmpmYk5paEVIcHpDUThwVlBKQ3BIbTBzQ0N2aFFlamgvOEFhS2lSdHlreDB4MkVjK0xZY3hiL0FQRUE4d050K1F2VmpQMC8vOWs9XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ltZy9mZWVkX2JnLmpwZ1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jbGFzc25hbWVzID0gcmVxdWlyZShcImNsYXNzbmFtZXNcIik7XG5cbnZhciBfY2xhc3NuYW1lczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc25hbWVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIENBUk9VU0VMOiBmdW5jdGlvbiBDQVJPVVNFTChpc1NsaWRlcikge1xuICAgICAgICByZXR1cm4gKDAsIF9jbGFzc25hbWVzMi5kZWZhdWx0KSh7XG4gICAgICAgICAgICBcImNhcm91c2VsXCI6IHRydWUsXG4gICAgICAgICAgICBcImNhcm91c2VsLXNsaWRlclwiOiBpc1NsaWRlclxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgV1JBUFBFUjogZnVuY3Rpb24gV1JBUFBFUihpc1NsaWRlciwgYXhpcykge1xuICAgICAgICByZXR1cm4gKDAsIF9jbGFzc25hbWVzMi5kZWZhdWx0KSh7XG4gICAgICAgICAgICBcInRodW1icy13cmFwcGVyXCI6ICFpc1NsaWRlcixcbiAgICAgICAgICAgIFwic2xpZGVyLXdyYXBwZXJcIjogaXNTbGlkZXIsXG4gICAgICAgICAgICBcImF4aXMtaG9yaXpvbnRhbFwiOiBheGlzID09PSBcImhvcml6b250YWxcIixcbiAgICAgICAgICAgIFwiYXhpcy12ZXJ0aWNhbFwiOiBheGlzICE9PSBcImhvcml6b250YWxcIlxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgU0xJREVSOiBmdW5jdGlvbiBTTElERVIoaXNTbGlkZXIsIGlzU3dpcGluZykge1xuICAgICAgICByZXR1cm4gKDAsIF9jbGFzc25hbWVzMi5kZWZhdWx0KSh7XG4gICAgICAgICAgICBcInRodW1ic1wiOiAhaXNTbGlkZXIsXG4gICAgICAgICAgICBcInNsaWRlclwiOiBpc1NsaWRlcixcbiAgICAgICAgICAgIFwiYW5pbWF0ZWRcIjogIWlzU3dpcGluZ1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgSVRFTTogZnVuY3Rpb24gSVRFTShpc1NsaWRlciwgc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfY2xhc3NuYW1lczIuZGVmYXVsdCkoe1xuICAgICAgICAgICAgXCJ0aHVtYlwiOiAhaXNTbGlkZXIsXG4gICAgICAgICAgICBcInNsaWRlXCI6IGlzU2xpZGVyLFxuICAgICAgICAgICAgXCJzZWxlY3RlZFwiOiBzZWxlY3RlZFxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgQVJST1dfUFJFVjogZnVuY3Rpb24gQVJST1dfUFJFVihkaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gKDAsIF9jbGFzc25hbWVzMi5kZWZhdWx0KSh7XG4gICAgICAgICAgICBcImNvbnRyb2wtYXJyb3cgY29udHJvbC1wcmV2XCI6IHRydWUsXG4gICAgICAgICAgICBcImNvbnRyb2wtZGlzYWJsZWRcIjogZGlzYWJsZWRcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIEFSUk9XX05FWFQ6IGZ1bmN0aW9uIEFSUk9XX05FWFQoZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBfY2xhc3NuYW1lczIuZGVmYXVsdCkoe1xuICAgICAgICAgICAgXCJjb250cm9sLWFycm93IGNvbnRyb2wtbmV4dFwiOiB0cnVlLFxuICAgICAgICAgICAgXCJjb250cm9sLWRpc2FibGVkXCI6IGRpc2FibGVkXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBET1Q6IGZ1bmN0aW9uIERPVChzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gKDAsIF9jbGFzc25hbWVzMi5kZWZhdWx0KSh7XG4gICAgICAgICAgICBcImRvdFwiOiB0cnVlLFxuICAgICAgICAgICAgJ3NlbGVjdGVkJzogc2VsZWN0ZWRcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvY3NzQ2xhc3Nlcy5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgYXhpcykge1xuICAgIHZhciBwb3NpdGlvbkNzcyA9IGF4aXMgPT09ICdob3Jpem9udGFsJyA/IFtwb3NpdGlvbiwgMCwgMF0gOiBbMCwgcG9zaXRpb24sIDBdO1xuICAgIHZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2xhdGUzZCc7XG5cbiAgICB2YXIgdHJhbnNsYXRlZFBvc2l0aW9uID0gJygnICsgcG9zaXRpb25Dc3Muam9pbignLCcpICsgJyknO1xuXG4gICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wICsgdHJhbnNsYXRlZFBvc2l0aW9uO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvQ1NTVHJhbnNsYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydleHBvcnRzJywgJy4vcmVhY3Qtc3dpcGUnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJy4vcmVhY3Qtc3dpcGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1vZCA9IHtcbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgfTtcbiAgICBmYWN0b3J5KG1vZC5leHBvcnRzLCBnbG9iYWwucmVhY3RTd2lwZSk7XG4gICAgZ2xvYmFsLmluZGV4ID0gbW9kLmV4cG9ydHM7XG4gIH1cbn0pKHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBfcmVhY3RTd2lwZSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG5cbiAgdmFyIF9yZWFjdFN3aXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0U3dpcGUpO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG4gIH1cblxuICBleHBvcnRzLmRlZmF1bHQgPSBfcmVhY3RTd2lwZTIuZGVmYXVsdDtcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1lYXN5LXN3aXBlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIgX3JlYWN0RG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0RG9tKTtcblxudmFyIF9wcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7XG5cbnZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbnZhciBfY3NzQ2xhc3NlcyA9IHJlcXVpcmUoJy4uL2Nzc0NsYXNzZXMnKTtcblxudmFyIF9jc3NDbGFzc2VzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc0NsYXNzZXMpO1xuXG52YXIgX2RpbWVuc2lvbnMgPSByZXF1aXJlKCcuLi9kaW1lbnNpb25zJyk7XG5cbnZhciBfQ1NTVHJhbnNsYXRlID0gcmVxdWlyZSgnLi4vQ1NTVHJhbnNsYXRlJyk7XG5cbnZhciBfQ1NTVHJhbnNsYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NTU1RyYW5zbGF0ZSk7XG5cbnZhciBfcmVhY3RFYXN5U3dpcGUgPSByZXF1aXJlKCdyZWFjdC1lYXN5LXN3aXBlJyk7XG5cbnZhciBfcmVhY3RFYXN5U3dpcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3RFYXN5U3dpcGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUaHVtYnMgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhUaHVtYnMsIF9Db21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gVGh1bWJzKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaHVtYnMpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUaHVtYnMuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaHVtYnMpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMudXBkYXRlU2l6ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG90YWwgPSBfdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBfdGhpcy53cmFwcGVyU2l6ZSA9IF90aGlzLml0ZW1zV3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIF90aGlzLml0ZW1TaXplID0gX3RoaXMucHJvcHMudGh1bWJXaWR0aCA/IF90aGlzLnByb3BzLnRodW1iV2lkdGggOiAoMCwgX2RpbWVuc2lvbnMub3V0ZXJXaWR0aCkoX3RoaXMucmVmcy50aHVtYjApO1xuICAgICAgICAgICAgX3RoaXMudmlzaWJsZUl0ZW1zID0gTWF0aC5mbG9vcihfdGhpcy53cmFwcGVyU2l6ZSAvIF90aGlzLml0ZW1TaXplKTtcbiAgICAgICAgICAgIF90aGlzLmxhc3RQb3NpdGlvbiA9IHRvdGFsIC0gX3RoaXMudmlzaWJsZUl0ZW1zO1xuICAgICAgICAgICAgX3RoaXMuc2hvd0Fycm93cyA9IF90aGlzLnZpc2libGVJdGVtcyA8IHRvdGFsO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLnNldE1vdW50U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGhhc01vdW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5oYW5kbGVDbGlja0l0ZW0gPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gX3RoaXMucHJvcHMub25TZWxlY3RJdGVtO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGluZGV4LCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5vblN3aXBlU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc3dpcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMub25Td2lwZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzd2lwaW5nOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMub25Td2lwZU1vdmUgPSBmdW5jdGlvbiAoZGVsdGFYKSB7XG4gICAgICAgICAgICB2YXIgbGVmdEJvdW5kcnkgPSAwO1xuICAgICAgICAgICAgdmFyIGxpc3QgPSBfcmVhY3REb20yLmRlZmF1bHQuZmluZERPTU5vZGUoX3RoaXMuaXRlbUxpc3QpO1xuICAgICAgICAgICAgdmFyIHdyYXBwZXJTaXplID0gbGlzdC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlSXRlbXMgPSBNYXRoLmZsb29yKHdyYXBwZXJTaXplIC8gX3RoaXMuaXRlbVNpemUpO1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gLV90aGlzLnN0YXRlLmZpcnN0SXRlbSAqIF90aGlzLml0ZW1TaXplO1xuICAgICAgICAgICAgdmFyIGxhc3RMZWZ0Qm91bmRyeSA9IC1fdGhpcy52aXNpYmxlSXRlbXMgKiBfdGhpcy5pdGVtU2l6ZTtcblxuICAgICAgICAgICAgLy8gcHJldmVudCB1c2VyIGZyb20gc3dpcGluZyBsZWZ0IG91dCBvZiBib3VuZGFyaWVzXG4gICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID09PSBsZWZ0Qm91bmRyeSAmJiBkZWx0YVggPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVsdGFYID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJldmVudCB1c2VyIGZyb20gc3dpcGluZyByaWdodCBvdXQgb2YgYm91bmRhcmllc1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA9PT0gbGFzdExlZnRCb3VuZHJ5ICYmIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAgICAgICBkZWx0YVggPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBjdXJyZW50UG9zaXRpb24gKyAxMDAgLyAod3JhcHBlclNpemUgLyBkZWx0YVgpICsgJyUnO1xuXG4gICAgICAgICAgICAvLyBpZiAzZCBpc24ndCBhdmFpbGFibGUgd2Ugd2lsbCB1c2UgbGVmdCB0byBtb3ZlXG4gICAgICAgICAgICBbJ1dlYmtpdFRyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnTXNUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICd0cmFuc2Zvcm0nLCAnbXNUcmFuc2Zvcm0nXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zdHlsZVtwcm9wXSA9ICgwLCBfQ1NTVHJhbnNsYXRlMi5kZWZhdWx0KShwb3NpdGlvbiwgX3RoaXMucHJvcHMuYXhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5zbGlkZVJpZ2h0ID0gZnVuY3Rpb24gKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgX3RoaXMubW92ZVRvKF90aGlzLnN0YXRlLmZpcnN0SXRlbSAtICh0eXBlb2YgcG9zaXRpb25zID09PSAnTnVtYmVyJyA/IHBvc2l0aW9ucyA6IDEpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5zbGlkZUxlZnQgPSBmdW5jdGlvbiAocG9zaXRpb25zKSB7XG4gICAgICAgICAgICBfdGhpcy5tb3ZlVG8oX3RoaXMuc3RhdGUuZmlyc3RJdGVtICsgKHR5cGVvZiBwb3NpdGlvbnMgPT09ICdOdW1iZXInID8gcG9zaXRpb25zIDogMSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLm1vdmVUbyA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xuICAgICAgICAgICAgLy8gcG9zaXRpb24gY2FuJ3QgYmUgbG93ZXIgdGhhbiAwXG4gICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIDwgMCA/IDAgOiBwb3NpdGlvbjtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIGNhbid0IGJlIGhpZ2hlciB0aGFuIGxhc3QgcG9zdGlvblxuICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA+PSBfdGhpcy5sYXN0UG9zaXRpb24gPyBfdGhpcy5sYXN0UG9zaXRpb24gOiBwb3NpdGlvbjtcblxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGZpcnN0SXRlbTogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgYSBzbGlkZXIsIHdlIGRvbid0IG5lZWQgdG8gc2V0IHBvc2l0aW9uIGhlcmVcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW06IF90aGlzLnN0YXRlLnNlbGVjdGVkSXRlbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgICBzZWxlY3RlZEl0ZW06IHByb3BzLnNlbGVjdGVkSXRlbSxcbiAgICAgICAgICAgIGhhc01vdW50OiBmYWxzZSxcbiAgICAgICAgICAgIGZpcnN0SXRlbTogX3RoaXMuZ2V0Rmlyc3RJdGVtKHByb3BzLnNlbGVjdGVkSXRlbSksXG4gICAgICAgICAgICBpbWFnZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGh1bWJzLCBbe1xuICAgICAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudChuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXR1cFRodW1icygpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuc2VsZWN0ZWRJdGVtICE9PSB0aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW06IHByb3BzLnNlbGVjdGVkSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RJdGVtOiB0aGlzLmdldEZpcnN0SXRlbShwcm9wcy5zZWxlY3RlZEl0ZW0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcy5jaGlsZHJlbiAmJiB0aGlzLnByb3BzLmNoaWxkcmVuICYmICF0aGlzLnN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cFRodW1icygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVRodW1icygpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXR1cFRodW1icycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFRodW1icygpIHtcbiAgICAgICAgICAgIC8vIGFzIHRoZSB3aWR0aHMgYXJlIGNhbGN1bGF0ZWQsIHdlIG5lZWQgdG8gcmVzaXplXG4gICAgICAgICAgICAvLyB0aGUgY2Fyb3VzZWwgd2hlbiB0aGUgd2luZG93IGlzIHJlc2l6ZWRcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMudXBkYXRlU2l6ZXMpO1xuICAgICAgICAgICAgLy8gaXNzdWUgIzIgLSBpbWFnZSBsb2FkaW5nIHNtYWxsZXJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCB0aGlzLnVwZGF0ZVNpemVzKTtcblxuICAgICAgICAgICAgdmFyIGltYWdlcyA9IHRoaXMuZ2V0SW1hZ2VzKCk7XG5cbiAgICAgICAgICAgIGlmICghaW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbWFnZXM6IGltYWdlc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCB3ZSBuZWVkIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgLy8gdGhlIGNvbnRhaW5lciBzaXplIHRvIGFkanVzdCB0aGUgcmVzcG9uc2l2ZSBiZWhhdmlvdXJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveVRodW1icycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95VGh1bWJzKCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZpbmcgbGlzdGVuZXJzXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLnVwZGF0ZVNpemVzKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCB0aGlzLnVwZGF0ZVNpemVzKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW1hZ2VzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEltYWdlcygpIHtcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSBfcmVhY3QyLmRlZmF1bHQuQ2hpbGRyZW4ubWFwKHRoaXMucHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBpbWcgPSBpdGVtO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaXMgbm90IGFuIGltYWdlLCB0cnkgdG8gZmluZCB0aGUgZmlyc3QgaW1hZ2UgaW4gdGhlIGl0ZW0ncyBjaGlsZHJlbi5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS50eXBlICE9PSBcImltZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZyA9IF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi50b0FycmF5KGl0ZW0ucHJvcHMuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbi50eXBlID09PSBcImltZ1wiO1xuICAgICAgICAgICAgICAgICAgICB9KVswXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWltZyB8fCBpbWcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBpbWc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGltYWdlcy5maWx0ZXIoZnVuY3Rpb24gKGltYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGltYWdlICE9PSBudWxsO1xuICAgICAgICAgICAgfSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyBpbWFnZXMgZm91bmQhIENhblxcJ3QgYnVpbGQgdGhlIHRodW1iIGxpc3Qgd2l0aG91dCBpbWFnZXMuIElmIHlvdSBkb25cXCd0IG5lZWQgdGh1bWJzLCBzZXQgc2hvd1RodW1icz17ZmFsc2V9IGluIHRoZSBDYXJvdXNlbC4gTm90ZSB0aGF0IGl0XFwncyBub3QgcG9zc2libGUgdG8gZ2V0IGltYWdlcyByZW5kZXJlZCBpbnNpZGUgY3VzdG9tIGNvbXBvbmVudHMuIE1vcmUgaW5mbyBhdCBodHRwczovL2dpdGh1Yi5jb20vbGVhbmRyb3dkL3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwvYmxvYi9tYXN0ZXIvVFJPVUJMRVNIT09USU5HLm1kJyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGltYWdlcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0Rmlyc3RJdGVtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpcnN0SXRlbShzZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG93QXJyb3dzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmaXJzdEl0ZW0gPSBzZWxlY3RlZEl0ZW07XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEl0ZW0gPj0gdGhpcy5sYXN0UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBmaXJzdEl0ZW0gPSB0aGlzLmxhc3RQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkSXRlbSA8IHRoaXMuc3RhdGUuZmlyc3RJdGVtICsgdGhpcy52aXNpYmxlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEl0ZW0gPSB0aGlzLnN0YXRlLmZpcnN0SXRlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkSXRlbSA8IHRoaXMuc3RhdGUuZmlyc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RJdGVtID0gc2VsZWN0ZWRJdGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmlyc3RJdGVtO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXJJdGVtcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJdGVtcygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pbWFnZXMubWFwKGZ1bmN0aW9uIChpbWcsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1DbGFzcyA9IF9jc3NDbGFzc2VzMi5kZWZhdWx0LklURU0oZmFsc2UsIGluZGV4ID09PSBfdGhpczIuc3RhdGUuc2VsZWN0ZWRJdGVtICYmIF90aGlzMi5zdGF0ZS5oYXNNb3VudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdGh1bWJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcmVmOiAndGh1bWInICsgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogaXRlbUNsYXNzLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBfdGhpczIuaGFuZGxlQ2xpY2tJdGVtLmJpbmQoX3RoaXMyLCBpbmRleCwgX3RoaXMyLnByb3BzLmNoaWxkcmVuW2luZGV4XSlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGltZyA9IF9yZWFjdDIuZGVmYXVsdC5jbG9uZUVsZW1lbnQoaW1nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkxvYWQ6IF90aGlzMi5zZXRNb3VudFN0YXRlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgICAgICAgICAgdGh1bWJQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgaW1nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5jaGlsZHJlbiB8fCB0aGlzLnN0YXRlLmltYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2hvdyBsZWZ0IGFycm93P1xuICAgICAgICAgICAgdmFyIGhhc1ByZXYgPSB0aGlzLnNob3dBcnJvd3MgJiYgdGhpcy5zdGF0ZS5maXJzdEl0ZW0gPiAwO1xuICAgICAgICAgICAgLy8gc2hvdyByaWdodCBhcnJvd1xuICAgICAgICAgICAgdmFyIGhhc05leHQgPSB0aGlzLnNob3dBcnJvd3MgJiYgdGhpcy5zdGF0ZS5maXJzdEl0ZW0gPCB0aGlzLmxhc3RQb3NpdGlvbjtcbiAgICAgICAgICAgIC8vIG9iaiB0byBob2xkIHRoZSB0cmFuc2Zvcm1hdGlvbnMgYW5kIHN0eWxlc1xuICAgICAgICAgICAgdmFyIGl0ZW1MaXN0U3R5bGVzID0ge307XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50UG9zaXRpb24gPSAtdGhpcy5zdGF0ZS5maXJzdEl0ZW0gKiB0aGlzLml0ZW1TaXplICsgJ3B4JztcblxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVByb3AgPSAoMCwgX0NTU1RyYW5zbGF0ZTIuZGVmYXVsdCkoY3VycmVudFBvc2l0aW9uLCB0aGlzLnByb3BzLmF4aXMpO1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvblRpbWUgPSB0aGlzLnByb3BzLnRyYW5zaXRpb25UaW1lICsgJ21zJztcblxuICAgICAgICAgICAgaXRlbUxpc3RTdHlsZXMgPSB7XG4gICAgICAgICAgICAgICAgJ1dlYmtpdFRyYW5zZm9ybSc6IHRyYW5zZm9ybVByb3AsXG4gICAgICAgICAgICAgICAgJ01velRyYW5zZm9ybSc6IHRyYW5zZm9ybVByb3AsXG4gICAgICAgICAgICAgICAgJ01zVHJhbnNmb3JtJzogdHJhbnNmb3JtUHJvcCxcbiAgICAgICAgICAgICAgICAnT1RyYW5zZm9ybSc6IHRyYW5zZm9ybVByb3AsXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IHRyYW5zZm9ybVByb3AsXG4gICAgICAgICAgICAgICAgJ21zVHJhbnNmb3JtJzogdHJhbnNmb3JtUHJvcCxcbiAgICAgICAgICAgICAgICAnV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uJzogdHJhbnNpdGlvblRpbWUsXG4gICAgICAgICAgICAgICAgJ01velRyYW5zaXRpb25EdXJhdGlvbic6IHRyYW5zaXRpb25UaW1lLFxuICAgICAgICAgICAgICAgICdNc1RyYW5zaXRpb25EdXJhdGlvbic6IHRyYW5zaXRpb25UaW1lLFxuICAgICAgICAgICAgICAgICdPVHJhbnNpdGlvbkR1cmF0aW9uJzogdHJhbnNpdGlvblRpbWUsXG4gICAgICAgICAgICAgICAgJ3RyYW5zaXRpb25EdXJhdGlvbic6IHRyYW5zaXRpb25UaW1lLFxuICAgICAgICAgICAgICAgICdtc1RyYW5zaXRpb25EdXJhdGlvbic6IHRyYW5zaXRpb25UaW1lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IF9jc3NDbGFzc2VzMi5kZWZhdWx0LkNBUk9VU0VMKGZhbHNlKSB9LFxuICAgICAgICAgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6IF9jc3NDbGFzc2VzMi5kZWZhdWx0LldSQVBQRVIoZmFsc2UpLCByZWY6IGZ1bmN0aW9uIHJlZihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5pdGVtc1dyYXBwZXIgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJywgeyB0eXBlOiAnYnV0dG9uJywgY2xhc3NOYW1lOiBfY3NzQ2xhc3NlczIuZGVmYXVsdC5BUlJPV19QUkVWKCFoYXNQcmV2KSwgb25DbGljazogdGhpcy5zbGlkZVJpZ2h0IH0pLFxuICAgICAgICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZWFjdEVhc3lTd2lwZTIuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgdGFnTmFtZTogJ3VsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW06IHRoaXMuc3RhdGUuc2VsZWN0ZWRJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogX2Nzc0NsYXNzZXMyLmRlZmF1bHQuU0xJREVSKGZhbHNlLCB0aGlzLnN0YXRlLnN3aXBpbmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3dpcGVMZWZ0OiB0aGlzLnNsaWRlTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN3aXBlUmlnaHQ6IHRoaXMuc2xpZGVSaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN3aXBlTW92ZTogdGhpcy5vblN3aXBlTW92ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN3aXBlU3RhcnQ6IHRoaXMub25Td2lwZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU3dpcGVFbmQ6IHRoaXMub25Td2lwZUVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogaXRlbUxpc3RTdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLml0ZW1MaXN0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckl0ZW1zKClcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicsIHsgdHlwZTogJ2J1dHRvbicsIGNsYXNzTmFtZTogX2Nzc0NsYXNzZXMyLmRlZmF1bHQuQVJST1dfTkVYVCghaGFzTmV4dCksIG9uQ2xpY2s6IHRoaXMuc2xpZGVMZWZ0IH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUaHVtYnM7XG59KF9yZWFjdC5Db21wb25lbnQpO1xuXG5UaHVtYnMuZGlzcGxheU5hbWUgPSAnVGh1bWJzJztcblRodW1icy5wcm9wc1R5cGVzID0ge1xuICAgIGNoaWxkcmVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmVsZW1lbnQuaXNSZXF1aXJlZCxcbiAgICB0cmFuc2l0aW9uVGltZTogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG4gICAgc2VsZWN0ZWRJdGVtOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgICB0aHVtYldpZHRoOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlclxufTtcblRodW1icy5kZWZhdWx0UHJvcHMgPSB7XG4gICAgc2VsZWN0ZWRJdGVtOiAwLFxuICAgIHRyYW5zaXRpb25UaW1lOiAzNTAsXG4gICAgYXhpczogJ2hvcml6b250YWwnXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gVGh1bWJzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9jb21wb25lbnRzL1RodW1icy5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSAmJiB3aW5kb3cuYnRvYS5iaW5kKHdpbmRvdykpIHx8IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idG9hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRFdmVudCA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgSUUgOC85IENPUlMgc3VwcG9ydFxuICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiZcbiAgICAgICAgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIGxvYWRFdmVudCA9ICdvbmxvYWQnO1xuICAgICAgeERvbWFpbiA9IHRydWU7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge307XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdFtsb2FkRXZlbnRdID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0ICYmICF4RG9tYWluKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzIwMSlcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgdmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xuXG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLndpdGhDcmVkZW50aWFscykge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0IHsgSGFzaFJvdXRlciBhcyBSb3V0ZXIsIFJvdXRlIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XHJcblxyXG5pbXBvcnQgY3NzIGZyb20gJy4uL2Nzcy9tYWluLnNjc3MnO1xyXG5cclxuaW1wb3J0IExheW91dCBmcm9tICcuL3BhZ2VzL0xheW91dCc7XHJcbmltcG9ydCBIb21lIGZyb20gJy4vcGFnZXMvSG9tZSc7XHJcbmltcG9ydCBDb250YWN0IGZyb20gJy4vcGFnZXMvQ29udGFjdCc7XHJcbmltcG9ydCBQZW9wbGUgZnJvbSAnLi9wYWdlcy9QZW9wbGUnO1xyXG5cclxuUmVhY3RET00ucmVuZGVyKFxyXG5cdDxSb3V0ZXI+XHJcblx0XHQ8TGF5b3V0PlxyXG5cdFx0XHQ8Um91dGUgZXhhY3QgcGF0aD1cIi9cIiBjb21wb25lbnQ9e0hvbWV9PiA8L1JvdXRlPlxyXG5cdFx0XHQ8Um91dGUgcGF0aD1cIi9jb250YWN0XCIgY29tcG9uZW50PXtDb250YWN0fT4gPC9Sb3V0ZT5cclxuXHRcdFx0PFJvdXRlIHBhdGg9XCIvcGVvcGxlXCIgY29tcG9uZW50PXtQZW9wbGV9PiA8L1JvdXRlPlxyXG5cdFx0PC9MYXlvdXQ+XHJcblx0PC9Sb3V0ZXI+LCBcclxuXHRkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJylcclxuKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy9jbGllbnQuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7dmFyIG09cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIiksbj1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIikscD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlGdW5jdGlvblwiKSxxPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSxyPXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyx0PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuY2FsbFwiKTo2MDEwNCx1PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucmV0dXJuXCIpOjYwMTA1LHY9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsdz1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LHg9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO1xuZnVuY3Rpb24geShhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGU9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsYz0wO2M8YjtjKyspZSs9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tjKzFdKTtiPUVycm9yKGUrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fVxudmFyIHo9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319O2Z1bmN0aW9uIEEoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en1BLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9O0EucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIiE9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmbnVsbCE9YT95KFwiODVcIik6dm9pZCAwO3RoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcyxhLGIsXCJzZXRTdGF0ZVwiKX07QS5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGEsXCJmb3JjZVVwZGF0ZVwiKX07XG5mdW5jdGlvbiBCKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9ZnVuY3Rpb24gQygpe31DLnByb3RvdHlwZT1BLnByb3RvdHlwZTt2YXIgRD1CLnByb3RvdHlwZT1uZXcgQztELmNvbnN0cnVjdG9yPUI7bShELEEucHJvdG90eXBlKTtELmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwO2Z1bmN0aW9uIEUoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en12YXIgRj1FLnByb3RvdHlwZT1uZXcgQztGLmNvbnN0cnVjdG9yPUU7bShGLEEucHJvdG90eXBlKTtGLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudD0hMDtGLnJlbmRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLmNoaWxkcmVufTt2YXIgRz17Y3VycmVudDpudWxsfSxIPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksST17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gSihhLGIsZSl7dmFyIGMsZD17fSxnPW51bGwsaz1udWxsO2lmKG51bGwhPWIpZm9yKGMgaW4gdm9pZCAwIT09Yi5yZWYmJihrPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGc9XCJcIitiLmtleSksYilILmNhbGwoYixjKSYmIUkuaGFzT3duUHJvcGVydHkoYykmJihkW2NdPWJbY10pO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZilkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGYpe2Zvcih2YXIgaD1BcnJheShmKSxsPTA7bDxmO2wrKyloW2xdPWFyZ3VtZW50c1tsKzJdO2QuY2hpbGRyZW49aH1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoYyBpbiBmPWEuZGVmYXVsdFByb3BzLGYpdm9pZCAwPT09ZFtjXSYmKGRbY109ZltjXSk7cmV0dXJueyQkdHlwZW9mOnIsdHlwZTphLGtleTpnLHJlZjprLHByb3BzOmQsX293bmVyOkcuY3VycmVudH19ZnVuY3Rpb24gSyhhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09cn1cbmZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCJcXHgzZFwiOlwiXFx4M2QwXCIsXCI6XCI6XCJcXHgzZDJcIn07cmV0dXJuXCIkXCIrKFwiXCIrYSkucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfSl9dmFyIEw9L1xcLysvZyxNPVtdO2Z1bmN0aW9uIE4oYSxiLGUsYyl7aWYoTS5sZW5ndGgpe3ZhciBkPU0ucG9wKCk7ZC5yZXN1bHQ9YTtkLmtleVByZWZpeD1iO2QuZnVuYz1lO2QuY29udGV4dD1jO2QuY291bnQ9MDtyZXR1cm4gZH1yZXR1cm57cmVzdWx0OmEsa2V5UHJlZml4OmIsZnVuYzplLGNvbnRleHQ6Yyxjb3VudDowfX1mdW5jdGlvbiBPKGEpe2EucmVzdWx0PW51bGw7YS5rZXlQcmVmaXg9bnVsbDthLmZ1bmM9bnVsbDthLmNvbnRleHQ9bnVsbDthLmNvdW50PTA7MTA+TS5sZW5ndGgmJk0ucHVzaChhKX1cbmZ1bmN0aW9uIFAoYSxiLGUsYyl7dmFyIGQ9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWR8fFwiYm9vbGVhblwiPT09ZClhPW51bGw7dmFyIGc9ITE7aWYobnVsbD09PWEpZz0hMDtlbHNlIHN3aXRjaChkKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmc9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIHI6Y2FzZSB0OmNhc2UgdTpjYXNlIHY6Zz0hMH19aWYoZylyZXR1cm4gZShjLGEsXCJcIj09PWI/XCIuXCIrUShhLDApOmIpLDE7Zz0wO2I9XCJcIj09PWI/XCIuXCI6YitcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgaz0wO2s8YS5sZW5ndGg7aysrKXtkPWFba107dmFyIGY9YitRKGQsayk7Zys9UChkLGYsZSxjKX1lbHNlIGlmKG51bGw9PT1hfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/Zj1udWxsOihmPXgmJmFbeF18fGFbXCJAQGl0ZXJhdG9yXCJdLGY9XCJmdW5jdGlvblwiPT09dHlwZW9mIGY/ZjpudWxsKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZilmb3IoYT1cbmYuY2FsbChhKSxrPTA7IShkPWEubmV4dCgpKS5kb25lOylkPWQudmFsdWUsZj1iK1EoZCxrKyspLGcrPVAoZCxmLGUsYyk7ZWxzZVwib2JqZWN0XCI9PT1kJiYoZT1cIlwiK2EseShcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PWU/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhhKS5qb2luKFwiLCBcIikrXCJ9XCI6ZSxcIlwiKSk7cmV0dXJuIGd9ZnVuY3Rpb24gUShhLGIpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJm51bGwhPWEua2V5P2VzY2FwZShhLmtleSk6Yi50b1N0cmluZygzNil9ZnVuY3Rpb24gUihhLGIpe2EuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyl9XG5mdW5jdGlvbiBTKGEsYixlKXt2YXIgYz1hLnJlc3VsdCxkPWEua2V5UHJlZml4O2E9YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKTtBcnJheS5pc0FycmF5KGEpP1QoYSxjLGUscC50aGF0UmV0dXJuc0FyZ3VtZW50KTpudWxsIT1hJiYoSyhhKSYmKGI9ZCsoIWEua2V5fHxiJiZiLmtleT09PWEua2V5P1wiXCI6KFwiXCIrYS5rZXkpLnJlcGxhY2UoTCxcIiRcXHgyNi9cIikrXCIvXCIpK2UsYT17JCR0eXBlb2Y6cix0eXBlOmEudHlwZSxrZXk6YixyZWY6YS5yZWYscHJvcHM6YS5wcm9wcyxfb3duZXI6YS5fb3duZXJ9KSxjLnB1c2goYSkpfWZ1bmN0aW9uIFQoYSxiLGUsYyxkKXt2YXIgZz1cIlwiO251bGwhPWUmJihnPShcIlwiK2UpLnJlcGxhY2UoTCxcIiRcXHgyNi9cIikrXCIvXCIpO2I9TihiLGcsYyxkKTtudWxsPT1hfHxQKGEsXCJcIixTLGIpO08oYil9XG52YXIgVT17Q2hpbGRyZW46e21hcDpmdW5jdGlvbihhLGIsZSl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgYz1bXTtUKGEsYyxudWxsLGIsZSk7cmV0dXJuIGN9LGZvckVhY2g6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7Yj1OKG51bGwsbnVsbCxiLGUpO251bGw9PWF8fFAoYSxcIlwiLFIsYik7TyhiKX0sY291bnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/MDpQKGEsXCJcIixwLnRoYXRSZXR1cm5zTnVsbCxudWxsKX0sdG9BcnJheTpmdW5jdGlvbihhKXt2YXIgYj1bXTtUKGEsYixudWxsLHAudGhhdFJldHVybnNBcmd1bWVudCk7cmV0dXJuIGJ9LG9ubHk6ZnVuY3Rpb24oYSl7SyhhKT92b2lkIDA6eShcIjE0M1wiKTtyZXR1cm4gYX19LENvbXBvbmVudDpBLFB1cmVDb21wb25lbnQ6Qix1bnN0YWJsZV9Bc3luY0NvbXBvbmVudDpFLEZyYWdtZW50OncsY3JlYXRlRWxlbWVudDpKLGNsb25lRWxlbWVudDpmdW5jdGlvbihhLGIsZSl7dmFyIGM9bSh7fSxhLnByb3BzKSxcbmQ9YS5rZXksZz1hLnJlZixrPWEuX293bmVyO2lmKG51bGwhPWIpe3ZvaWQgMCE9PWIucmVmJiYoZz1iLnJlZixrPUcuY3VycmVudCk7dm9pZCAwIT09Yi5rZXkmJihkPVwiXCIrYi5rZXkpO2lmKGEudHlwZSYmYS50eXBlLmRlZmF1bHRQcm9wcyl2YXIgZj1hLnR5cGUuZGVmYXVsdFByb3BzO2ZvcihoIGluIGIpSC5jYWxsKGIsaCkmJiFJLmhhc093blByb3BlcnR5KGgpJiYoY1toXT12b2lkIDA9PT1iW2hdJiZ2b2lkIDAhPT1mP2ZbaF06YltoXSl9dmFyIGg9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1oKWMuY2hpbGRyZW49ZTtlbHNlIGlmKDE8aCl7Zj1BcnJheShoKTtmb3IodmFyIGw9MDtsPGg7bCsrKWZbbF09YXJndW1lbnRzW2wrMl07Yy5jaGlsZHJlbj1mfXJldHVybnskJHR5cGVvZjpyLHR5cGU6YS50eXBlLGtleTpkLHJlZjpnLHByb3BzOmMsX293bmVyOmt9fSxjcmVhdGVGYWN0b3J5OmZ1bmN0aW9uKGEpe3ZhciBiPUouYmluZChudWxsLGEpO2IudHlwZT1hO3JldHVybiBifSxcbmlzVmFsaWRFbGVtZW50OkssdmVyc2lvbjpcIjE2LjIuMFwiLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntSZWFjdEN1cnJlbnRPd25lcjpHLGFzc2lnbjptfX0sVj1PYmplY3QuZnJlZXplKHtkZWZhdWx0OlV9KSxXPVYmJlV8fFY7bW9kdWxlLmV4cG9ydHM9V1tcImRlZmF1bHRcIl0/V1tcImRlZmF1bHRcIl06VztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4yLjAnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9DQUxMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5jYWxsJykgOiAweGVhYzg7XG52YXIgUkVBQ1RfUkVUVVJOX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKSA6IDB4ZWFjOTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbmZ1bmN0aW9uIEFzeW5jQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgYXN5bmNDb21wb25lbnRQcm90b3R5cGUgPSBBc3luY0NvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXN5bmNDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24oYXN5bmNDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIG5vIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pO1xuICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuJCR0eXBlb2YgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVmYWN0b3J5XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xuXG57XG4gIC8vIENvbXBvbmVudCB0aGF0IGlzIGJlaW5nIHdvcmtlZCBvblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHJldHVybiBpbXBsKCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG52YXIgUE9PTF9TSVpFID0gMTA7XG52YXIgdHJhdmVyc2VDb250ZXh0UG9vbCA9IFtdO1xuZnVuY3Rpb24gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gdHJhdmVyc2VDb250ZXh0UG9vbC5wb3AoKTtcbiAgICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbWFwUmVzdWx0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgICByZXR1cm4gdHJhdmVyc2VDb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IG1hcFJlc3VsdCxcbiAgICAgIGtleVByZWZpeDoga2V5UHJlZml4LFxuICAgICAgZnVuYzogbWFwRnVuY3Rpb24sXG4gICAgICBjb250ZXh0OiBtYXBDb250ZXh0LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KSB7XG4gIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmIChpdGVyYXRvckZuID09PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBjb21wb25lbnQgIT09IG51bGwgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIGVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGQoYm9va0tlZXBpbmcsIGNoaWxkLCBuYW1lKSB7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG51bGwsIG51bGwsIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IGNsb25lQW5kUmVwbGFjZUtleShtYXBwZWRDaGlsZCxcbiAgICAgIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgIGtleVByZWZpeCArIChtYXBwZWRDaGlsZC5rZXkgJiYgKCFjaGlsZCB8fCBjaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkobWFwcGVkQ2hpbGQua2V5KSArICcvJyA6ICcnKSArIGNoaWxkS2V5KTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gobWFwcGVkQ2hpbGQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIGFycmF5LCBwcmVmaXgsIGZ1bmMsIGNvbnRleHQpIHtcbiAgdmFyIGVzY2FwZWRQcmVmaXggPSAnJztcbiAgaWYgKHByZWZpeCAhPSBudWxsKSB7XG4gICAgZXNjYXBlZFByZWZpeCA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShwcmVmaXgpICsgJy8nO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQoYXJyYXksIGVzY2FwZWRQcmVmaXgsIGZ1bmMsIGNvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0LCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogTWFwcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4udG9hcnJheVxuICovXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHtcbiAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbntcbiAgdmFyIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcblxuICB2YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcblxuICB2YXIgZ2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnI2VtcHR5JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnI3RleHQnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnR5cGU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHJldHVybiAnUmVhY3QuRnJhZ21lbnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7XG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lcikpO1xuICAgIH1cbiAgICBzdGFjayArPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIFZBTElEX0ZSQUdNRU5UX1BST1BTID0gbmV3IE1hcChbWydjaGlsZHJlbicsIHRydWVdLCBbJ2tleScsIHRydWVdXSk7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50UHJvcHMuX19zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50UHJvcHMuX19zb3VyY2U7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICdcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmZvO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgIGNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyKSArICcuJztcbiAgfVxuXG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgdmFyIHByb3BUeXBlcyA9IGNvbXBvbmVudENsYXNzLnByb3BUeXBlcztcbiAgaWYgKHByb3BUeXBlcykge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSk7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGNvbXBvbmVudENsYXNzLlByb3BUeXBlcyAhPT0gdW5kZWZpbmVkICYmICFwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bikge1xuICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgbmFtZSB8fCAnVW5rbm93bicpO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBmcmFnbWVudDtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmICghVkFMSURfRlJBR01FTlRfUFJPUFMuaGFzKGtleSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4lcycsIGtleSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3JbJ3JldHVybiddKSB7XG4gICAgICAgIF9pdGVyYXRvclsncmV0dXJuJ10oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4lcycsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHR5cGUgPT09ICdudW1iZXInO1xuICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShwcm9wcyk7XG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICBpbmZvICs9IGdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcblxuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnICYmIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuICB1bnN0YWJsZV9Bc3luY0NvbXBvbmVudDogQXN5bmNDb21wb25lbnQsXG5cbiAgRnJhZ21lbnQ6IFJFQUNUX0ZSQUdNRU5UX1RZUEUsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24sXG4gIGlzVmFsaWRFbGVtZW50OiBpc1ZhbGlkRWxlbWVudCxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gICAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgICBhc3NpZ246IF9hc3NpZ25cbiAgfVxufTtcblxue1xuICBfYXNzaWduKFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELCB7XG4gICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiBwcm9kdWN0aW9uLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWU6IFJlYWN0RGVidWdDdXJyZW50RnJhbWUsXG4gICAgLy8gU2hpbSBmb3IgUmVhY3QgRE9NIDE2LjAuMCB3aGljaCBzdGlsbCBkZXN0cnVjdHVyZWQgKGJ1dCBub3QgdXNlZCkgdGhpcy5cbiAgICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuMC5cbiAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rOiB7fVxuICB9KTtcbn1cblxuXG5cbnZhciBSZWFjdCQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0XG59KTtcblxudmFyIFJlYWN0JDMgPSAoIFJlYWN0JDIgJiYgUmVhY3QgKSB8fCBSZWFjdCQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdCA9IFJlYWN0JDNbJ2RlZmF1bHQnXSA/IFJlYWN0JDNbJ2RlZmF1bHQnXSA6IFJlYWN0JDM7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3Q7XG4gIH0pKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLypcbiBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiovXG4ndXNlIHN0cmljdCc7dmFyIGFhPXJlcXVpcmUoXCJyZWFjdFwiKSxsPXJlcXVpcmUoXCJmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudFwiKSxCPXJlcXVpcmUoXCJvYmplY3QtYXNzaWduXCIpLEM9cmVxdWlyZShcImZianMvbGliL2VtcHR5RnVuY3Rpb25cIiksYmE9cmVxdWlyZShcImZianMvbGliL0V2ZW50TGlzdGVuZXJcIiksZGE9cmVxdWlyZShcImZianMvbGliL2dldEFjdGl2ZUVsZW1lbnRcIiksZWE9cmVxdWlyZShcImZianMvbGliL3NoYWxsb3dFcXVhbFwiKSxmYT1yZXF1aXJlKFwiZmJqcy9saWIvY29udGFpbnNOb2RlXCIpLGlhPXJlcXVpcmUoXCJmYmpzL2xpYi9mb2N1c05vZGVcIiksRD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIik7XG5mdW5jdGlvbiBFKGEpe2Zvcih2YXIgYj1hcmd1bWVudHMubGVuZ3RoLTEsYz1cIk1pbmlmaWVkIFJlYWN0IGVycm9yICNcIithK1wiOyB2aXNpdCBodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudFxceDNkXCIrYSxkPTA7ZDxiO2QrKyljKz1cIlxceDI2YXJnc1tdXFx4M2RcIitlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2QrMV0pO2I9RXJyb3IoYytcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCIpO2IubmFtZT1cIkludmFyaWFudCBWaW9sYXRpb25cIjtiLmZyYW1lc1RvUG9wPTE7dGhyb3cgYjt9YWE/dm9pZCAwOkUoXCIyMjdcIik7XG52YXIgb2E9e2NoaWxkcmVuOiEwLGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiEwLGRlZmF1bHRWYWx1ZTohMCxkZWZhdWx0Q2hlY2tlZDohMCxpbm5lckhUTUw6ITAsc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiEwLHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzohMCxzdHlsZTohMH07ZnVuY3Rpb24gcGEoYSxiKXtyZXR1cm4oYSZiKT09PWJ9XG52YXIgdGE9e01VU1RfVVNFX1BST1BFUlRZOjEsSEFTX0JPT0xFQU5fVkFMVUU6NCxIQVNfTlVNRVJJQ19WQUxVRTo4LEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOjI0LEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6MzIsSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFOjY0LGluamVjdERPTVByb3BlcnR5Q29uZmlnOmZ1bmN0aW9uKGEpe3ZhciBiPXRhLGM9YS5Qcm9wZXJ0aWVzfHx7fSxkPWEuRE9NQXR0cmlidXRlTmFtZXNwYWNlc3x8e30sZT1hLkRPTUF0dHJpYnV0ZU5hbWVzfHx7fTthPWEuRE9NTXV0YXRpb25NZXRob2RzfHx7fTtmb3IodmFyIGYgaW4gYyl7dWEuaGFzT3duUHJvcGVydHkoZik/RShcIjQ4XCIsZik6dm9pZCAwO3ZhciBnPWYudG9Mb3dlckNhc2UoKSxoPWNbZl07Zz17YXR0cmlidXRlTmFtZTpnLGF0dHJpYnV0ZU5hbWVzcGFjZTpudWxsLHByb3BlcnR5TmFtZTpmLG11dGF0aW9uTWV0aG9kOm51bGwsbXVzdFVzZVByb3BlcnR5OnBhKGgsYi5NVVNUX1VTRV9QUk9QRVJUWSksXG5oYXNCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19CT09MRUFOX1ZBTFVFKSxoYXNOdW1lcmljVmFsdWU6cGEoaCxiLkhBU19OVU1FUklDX1ZBTFVFKSxoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpwYShoLGIuSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6cGEoaCxiLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpLGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTpwYShoLGIuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFKX07MT49Zy5oYXNCb29sZWFuVmFsdWUrZy5oYXNOdW1lcmljVmFsdWUrZy5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlP3ZvaWQgMDpFKFwiNTBcIixmKTtlLmhhc093blByb3BlcnR5KGYpJiYoZy5hdHRyaWJ1dGVOYW1lPWVbZl0pO2QuaGFzT3duUHJvcGVydHkoZikmJihnLmF0dHJpYnV0ZU5hbWVzcGFjZT1kW2ZdKTthLmhhc093blByb3BlcnR5KGYpJiYoZy5tdXRhdGlvbk1ldGhvZD1hW2ZdKTt1YVtmXT1nfX19LHVhPXt9O1xuZnVuY3Rpb24gdmEoYSxiKXtpZihvYS5oYXNPd25Qcm9wZXJ0eShhKXx8MjxhLmxlbmd0aCYmKFwib1wiPT09YVswXXx8XCJPXCI9PT1hWzBdKSYmKFwiblwiPT09YVsxXXx8XCJOXCI9PT1hWzFdKSlyZXR1cm4hMTtpZihudWxsPT09YilyZXR1cm4hMDtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgXCJib29sZWFuXCI6cmV0dXJuIG9hLmhhc093blByb3BlcnR5KGEpP2E9ITA6KGI9d2EoYSkpP2E9Yi5oYXNCb29sZWFuVmFsdWV8fGIuaGFzU3RyaW5nQm9vbGVhblZhbHVlfHxiLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6KGE9YS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsNSksYT1cImRhdGEtXCI9PT1hfHxcImFyaWEtXCI9PT1hKSxhO2Nhc2UgXCJ1bmRlZmluZWRcIjpjYXNlIFwibnVtYmVyXCI6Y2FzZSBcInN0cmluZ1wiOmNhc2UgXCJvYmplY3RcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiB3YShhKXtyZXR1cm4gdWEuaGFzT3duUHJvcGVydHkoYSk/dWFbYV06bnVsbH1cbnZhciB4YT10YSx5YT14YS5NVVNUX1VTRV9QUk9QRVJUWSxLPXhhLkhBU19CT09MRUFOX1ZBTFVFLHphPXhhLkhBU19OVU1FUklDX1ZBTFVFLEFhPXhhLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLEJhPXhhLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsQ2E9eGEuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLERhPXtQcm9wZXJ0aWVzOnthbGxvd0Z1bGxTY3JlZW46Syxhc3luYzpLLGF1dG9Gb2N1czpLLGF1dG9QbGF5OkssY2FwdHVyZTpCYSxjaGVja2VkOnlhfEssY29sczpBYSxjb250ZW50RWRpdGFibGU6Q2EsY29udHJvbHM6SyxcImRlZmF1bHRcIjpLLGRlZmVyOkssZGlzYWJsZWQ6Syxkb3dubG9hZDpCYSxkcmFnZ2FibGU6Q2EsZm9ybU5vVmFsaWRhdGU6SyxoaWRkZW46Syxsb29wOkssbXVsdGlwbGU6eWF8SyxtdXRlZDp5YXxLLG5vVmFsaWRhdGU6SyxvcGVuOksscGxheXNJbmxpbmU6SyxyZWFkT25seTpLLHJlcXVpcmVkOksscmV2ZXJzZWQ6Syxyb3dzOkFhLHJvd1NwYW46emEsXG5zY29wZWQ6SyxzZWFtbGVzczpLLHNlbGVjdGVkOnlhfEssc2l6ZTpBYSxzdGFydDp6YSxzcGFuOkFhLHNwZWxsQ2hlY2s6Q2Esc3R5bGU6MCx0YWJJbmRleDowLGl0ZW1TY29wZTpLLGFjY2VwdENoYXJzZXQ6MCxjbGFzc05hbWU6MCxodG1sRm9yOjAsaHR0cEVxdWl2OjAsdmFsdWU6Q2F9LERPTUF0dHJpYnV0ZU5hbWVzOnthY2NlcHRDaGFyc2V0OlwiYWNjZXB0LWNoYXJzZXRcIixjbGFzc05hbWU6XCJjbGFzc1wiLGh0bWxGb3I6XCJmb3JcIixodHRwRXF1aXY6XCJodHRwLWVxdWl2XCJ9LERPTU11dGF0aW9uTWV0aG9kczp7dmFsdWU6ZnVuY3Rpb24oYSxiKXtpZihudWxsPT1iKXJldHVybiBhLnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1wibnVtYmVyXCIhPT1hLnR5cGV8fCExPT09YS5oYXNBdHRyaWJ1dGUoXCJ2YWx1ZVwiKT9hLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIitiKTphLnZhbGlkaXR5JiYhYS52YWxpZGl0eS5iYWRJbnB1dCYmYS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQhPT1hJiZcbmEuc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK2IpfX19LEVhPXhhLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxNPXt4bGluazpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIix4bWw6XCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIn0sR2E9e1Byb3BlcnRpZXM6e2F1dG9SZXZlcnNlOkVhLGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6RWEscHJlc2VydmVBbHBoYTpFYX0sRE9NQXR0cmlidXRlTmFtZXM6e2F1dG9SZXZlcnNlOlwiYXV0b1JldmVyc2VcIixleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOlwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZFwiLHByZXNlcnZlQWxwaGE6XCJwcmVzZXJ2ZUFscGhhXCJ9LERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6e3hsaW5rQWN0dWF0ZTpNLnhsaW5rLHhsaW5rQXJjcm9sZTpNLnhsaW5rLHhsaW5rSHJlZjpNLnhsaW5rLHhsaW5rUm9sZTpNLnhsaW5rLHhsaW5rU2hvdzpNLnhsaW5rLHhsaW5rVGl0bGU6TS54bGluayx4bGlua1R5cGU6TS54bGluayxcbnhtbEJhc2U6TS54bWwseG1sTGFuZzpNLnhtbCx4bWxTcGFjZTpNLnhtbH19LEhhPS9bXFwtXFw6XShbYS16XSkvZztmdW5jdGlvbiBJYShhKXtyZXR1cm4gYVsxXS50b1VwcGVyQ2FzZSgpfVxuXCJhY2NlbnQtaGVpZ2h0IGFsaWdubWVudC1iYXNlbGluZSBhcmFiaWMtZm9ybSBiYXNlbGluZS1zaGlmdCBjYXAtaGVpZ2h0IGNsaXAtcGF0aCBjbGlwLXJ1bGUgY29sb3ItaW50ZXJwb2xhdGlvbiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMgY29sb3ItcHJvZmlsZSBjb2xvci1yZW5kZXJpbmcgZG9taW5hbnQtYmFzZWxpbmUgZW5hYmxlLWJhY2tncm91bmQgZmlsbC1vcGFjaXR5IGZpbGwtcnVsZSBmbG9vZC1jb2xvciBmbG9vZC1vcGFjaXR5IGZvbnQtZmFtaWx5IGZvbnQtc2l6ZSBmb250LXNpemUtYWRqdXN0IGZvbnQtc3RyZXRjaCBmb250LXN0eWxlIGZvbnQtdmFyaWFudCBmb250LXdlaWdodCBnbHlwaC1uYW1lIGdseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwgZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwgaG9yaXotYWR2LXggaG9yaXotb3JpZ2luLXggaW1hZ2UtcmVuZGVyaW5nIGxldHRlci1zcGFjaW5nIGxpZ2h0aW5nLWNvbG9yIG1hcmtlci1lbmQgbWFya2VyLW1pZCBtYXJrZXItc3RhcnQgb3ZlcmxpbmUtcG9zaXRpb24gb3ZlcmxpbmUtdGhpY2tuZXNzIHBhaW50LW9yZGVyIHBhbm9zZS0xIHBvaW50ZXItZXZlbnRzIHJlbmRlcmluZy1pbnRlbnQgc2hhcGUtcmVuZGVyaW5nIHN0b3AtY29sb3Igc3RvcC1vcGFjaXR5IHN0cmlrZXRocm91Z2gtcG9zaXRpb24gc3RyaWtldGhyb3VnaC10aGlja25lc3Mgc3Ryb2tlLWRhc2hhcnJheSBzdHJva2UtZGFzaG9mZnNldCBzdHJva2UtbGluZWNhcCBzdHJva2UtbGluZWpvaW4gc3Ryb2tlLW1pdGVybGltaXQgc3Ryb2tlLW9wYWNpdHkgc3Ryb2tlLXdpZHRoIHRleHQtYW5jaG9yIHRleHQtZGVjb3JhdGlvbiB0ZXh0LXJlbmRlcmluZyB1bmRlcmxpbmUtcG9zaXRpb24gdW5kZXJsaW5lLXRoaWNrbmVzcyB1bmljb2RlLWJpZGkgdW5pY29kZS1yYW5nZSB1bml0cy1wZXItZW0gdi1hbHBoYWJldGljIHYtaGFuZ2luZyB2LWlkZW9ncmFwaGljIHYtbWF0aGVtYXRpY2FsIHZlY3Rvci1lZmZlY3QgdmVydC1hZHYteSB2ZXJ0LW9yaWdpbi14IHZlcnQtb3JpZ2luLXkgd29yZC1zcGFjaW5nIHdyaXRpbmctbW9kZSB4LWhlaWdodCB4bGluazphY3R1YXRlIHhsaW5rOmFyY3JvbGUgeGxpbms6aHJlZiB4bGluazpyb2xlIHhsaW5rOnNob3cgeGxpbms6dGl0bGUgeGxpbms6dHlwZSB4bWw6YmFzZSB4bWxuczp4bGluayB4bWw6bGFuZyB4bWw6c3BhY2VcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoSGEsXG5JYSk7R2EuUHJvcGVydGllc1tiXT0wO0dhLkRPTUF0dHJpYnV0ZU5hbWVzW2JdPWF9KTt4YS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhEYSk7eGEuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoR2EpO1xudmFyIFA9e19jYXVnaHRFcnJvcjpudWxsLF9oYXNDYXVnaHRFcnJvcjohMSxfcmV0aHJvd0Vycm9yOm51bGwsX2hhc1JldGhyb3dFcnJvcjohMSxpbmplY3Rpb246e2luamVjdEVycm9yVXRpbHM6ZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiIT09dHlwZW9mIGEuaW52b2tlR3VhcmRlZENhbGxiYWNrP0UoXCIxOTdcIik6dm9pZCAwO0phPWEuaW52b2tlR3VhcmRlZENhbGxiYWNrfX0saW52b2tlR3VhcmRlZENhbGxiYWNrOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrKXtKYS5hcHBseShQLGFyZ3VtZW50cyl9LGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcjpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGgsayl7UC5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcyxhcmd1bWVudHMpO2lmKFAuaGFzQ2F1Z2h0RXJyb3IoKSl7dmFyIHE9UC5jbGVhckNhdWdodEVycm9yKCk7UC5faGFzUmV0aHJvd0Vycm9yfHwoUC5faGFzUmV0aHJvd0Vycm9yPSEwLFAuX3JldGhyb3dFcnJvcj1cbnEpfX0scmV0aHJvd0NhdWdodEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIEthLmFwcGx5KFAsYXJndW1lbnRzKX0saGFzQ2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gUC5faGFzQ2F1Z2h0RXJyb3J9LGNsZWFyQ2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtpZihQLl9oYXNDYXVnaHRFcnJvcil7dmFyIGE9UC5fY2F1Z2h0RXJyb3I7UC5fY2F1Z2h0RXJyb3I9bnVsbDtQLl9oYXNDYXVnaHRFcnJvcj0hMTtyZXR1cm4gYX1FKFwiMTk4XCIpfX07ZnVuY3Rpb24gSmEoYSxiLGMsZCxlLGYsZyxoLGspe1AuX2hhc0NhdWdodEVycm9yPSExO1AuX2NhdWdodEVycm9yPW51bGw7dmFyIHE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDMpO3RyeXtiLmFwcGx5KGMscSl9Y2F0Y2godil7UC5fY2F1Z2h0RXJyb3I9dixQLl9oYXNDYXVnaHRFcnJvcj0hMH19XG5mdW5jdGlvbiBLYSgpe2lmKFAuX2hhc1JldGhyb3dFcnJvcil7dmFyIGE9UC5fcmV0aHJvd0Vycm9yO1AuX3JldGhyb3dFcnJvcj1udWxsO1AuX2hhc1JldGhyb3dFcnJvcj0hMTt0aHJvdyBhO319dmFyIExhPW51bGwsTWE9e307XG5mdW5jdGlvbiBOYSgpe2lmKExhKWZvcih2YXIgYSBpbiBNYSl7dmFyIGI9TWFbYV0sYz1MYS5pbmRleE9mKGEpOy0xPGM/dm9pZCAwOkUoXCI5NlwiLGEpO2lmKCFPYVtjXSl7Yi5leHRyYWN0RXZlbnRzP3ZvaWQgMDpFKFwiOTdcIixhKTtPYVtjXT1iO2M9Yi5ldmVudFR5cGVzO2Zvcih2YXIgZCBpbiBjKXt2YXIgZT12b2lkIDA7dmFyIGY9Y1tkXSxnPWIsaD1kO1BhLmhhc093blByb3BlcnR5KGgpP0UoXCI5OVwiLGgpOnZvaWQgMDtQYVtoXT1mO3ZhciBrPWYucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7aWYoayl7Zm9yKGUgaW4gaylrLmhhc093blByb3BlcnR5KGUpJiZRYShrW2VdLGcsaCk7ZT0hMH1lbHNlIGYucmVnaXN0cmF0aW9uTmFtZT8oUWEoZi5yZWdpc3RyYXRpb25OYW1lLGcsaCksZT0hMCk6ZT0hMTtlP3ZvaWQgMDpFKFwiOThcIixkLGEpfX19fVxuZnVuY3Rpb24gUWEoYSxiLGMpe1JhW2FdP0UoXCIxMDBcIixhKTp2b2lkIDA7UmFbYV09YjtTYVthXT1iLmV2ZW50VHlwZXNbY10uZGVwZW5kZW5jaWVzfXZhciBPYT1bXSxQYT17fSxSYT17fSxTYT17fTtmdW5jdGlvbiBUYShhKXtMYT9FKFwiMTAxXCIpOnZvaWQgMDtMYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKTtOYSgpfWZ1bmN0aW9uIFVhKGEpe3ZhciBiPSExLGM7Zm9yKGMgaW4gYSlpZihhLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD1hW2NdO01hLmhhc093blByb3BlcnR5KGMpJiZNYVtjXT09PWR8fChNYVtjXT9FKFwiMTAyXCIsYyk6dm9pZCAwLE1hW2NdPWQsYj0hMCl9YiYmTmEoKX1cbnZhciBWYT1PYmplY3QuZnJlZXplKHtwbHVnaW5zOk9hLGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczpQYSxyZWdpc3RyYXRpb25OYW1lTW9kdWxlczpSYSxyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOlNhLHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6bnVsbCxpbmplY3RFdmVudFBsdWdpbk9yZGVyOlRhLGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTpVYX0pLFdhPW51bGwsWGE9bnVsbCxZYT1udWxsO2Z1bmN0aW9uIFphKGEsYixjLGQpe2I9YS50eXBlfHxcInVua25vd24tZXZlbnRcIjthLmN1cnJlbnRUYXJnZXQ9WWEoZCk7UC5pbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IoYixjLHZvaWQgMCxhKTthLmN1cnJlbnRUYXJnZXQ9bnVsbH1cbmZ1bmN0aW9uICRhKGEsYil7bnVsbD09Yj9FKFwiMzBcIik6dm9pZCAwO2lmKG51bGw9PWEpcmV0dXJuIGI7aWYoQXJyYXkuaXNBcnJheShhKSl7aWYoQXJyYXkuaXNBcnJheShiKSlyZXR1cm4gYS5wdXNoLmFwcGx5KGEsYiksYTthLnB1c2goYik7cmV0dXJuIGF9cmV0dXJuIEFycmF5LmlzQXJyYXkoYik/W2FdLmNvbmNhdChiKTpbYSxiXX1mdW5jdGlvbiBhYihhLGIsYyl7QXJyYXkuaXNBcnJheShhKT9hLmZvckVhY2goYixjKTphJiZiLmNhbGwoYyxhKX12YXIgYmI9bnVsbDtcbmZ1bmN0aW9uIGNiKGEsYil7aWYoYSl7dmFyIGM9YS5fZGlzcGF0Y2hMaXN0ZW5lcnMsZD1hLl9kaXNwYXRjaEluc3RhbmNlcztpZihBcnJheS5pc0FycmF5KGMpKWZvcih2YXIgZT0wO2U8Yy5sZW5ndGgmJiFhLmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7ZSsrKVphKGEsYixjW2VdLGRbZV0pO2Vsc2UgYyYmWmEoYSxiLGMsZCk7YS5fZGlzcGF0Y2hMaXN0ZW5lcnM9bnVsbDthLl9kaXNwYXRjaEluc3RhbmNlcz1udWxsO2EuaXNQZXJzaXN0ZW50KCl8fGEuY29uc3RydWN0b3IucmVsZWFzZShhKX19ZnVuY3Rpb24gZGIoYSl7cmV0dXJuIGNiKGEsITApfWZ1bmN0aW9uIGdiKGEpe3JldHVybiBjYihhLCExKX12YXIgaGI9e2luamVjdEV2ZW50UGx1Z2luT3JkZXI6VGEsaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOlVhfTtcbmZ1bmN0aW9uIGliKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7aWYoIWMpcmV0dXJuIG51bGw7dmFyIGQ9V2EoYyk7aWYoIWQpcmV0dXJuIG51bGw7Yz1kW2JdO2E6c3dpdGNoKGIpe2Nhc2UgXCJvbkNsaWNrXCI6Y2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpjYXNlIFwib25Nb3VzZURvd25cIjpjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlXCI6Y2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlVXBcIjpjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOihkPSFkLmRpc2FibGVkKXx8KGE9YS50eXBlLGQ9IShcImJ1dHRvblwiPT09YXx8XCJpbnB1dFwiPT09YXx8XCJzZWxlY3RcIj09PWF8fFwidGV4dGFyZWFcIj09PWEpKTthPSFkO2JyZWFrIGE7ZGVmYXVsdDphPSExfWlmKGEpcmV0dXJuIG51bGw7YyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGM/RShcIjIzMVwiLGIsdHlwZW9mIGMpOnZvaWQgMDtcbnJldHVybiBjfWZ1bmN0aW9uIGpiKGEsYixjLGQpe2Zvcih2YXIgZSxmPTA7ZjxPYS5sZW5ndGg7ZisrKXt2YXIgZz1PYVtmXTtnJiYoZz1nLmV4dHJhY3RFdmVudHMoYSxiLGMsZCkpJiYoZT0kYShlLGcpKX1yZXR1cm4gZX1mdW5jdGlvbiBrYihhKXthJiYoYmI9JGEoYmIsYSkpfWZ1bmN0aW9uIGxiKGEpe3ZhciBiPWJiO2JiPW51bGw7YiYmKGE/YWIoYixkYik6YWIoYixnYiksYmI/RShcIjk1XCIpOnZvaWQgMCxQLnJldGhyb3dDYXVnaHRFcnJvcigpKX12YXIgbWI9T2JqZWN0LmZyZWV6ZSh7aW5qZWN0aW9uOmhiLGdldExpc3RlbmVyOmliLGV4dHJhY3RFdmVudHM6amIsZW5xdWV1ZUV2ZW50czprYixwcm9jZXNzRXZlbnRRdWV1ZTpsYn0pLG5iPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFE9XCJfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSRcIituYixvYj1cIl9fcmVhY3RFdmVudEhhbmRsZXJzJFwiK25iO1xuZnVuY3Rpb24gcGIoYSl7aWYoYVtRXSlyZXR1cm4gYVtRXTtmb3IodmFyIGI9W107IWFbUV07KWlmKGIucHVzaChhKSxhLnBhcmVudE5vZGUpYT1hLnBhcmVudE5vZGU7ZWxzZSByZXR1cm4gbnVsbDt2YXIgYz12b2lkIDAsZD1hW1FdO2lmKDU9PT1kLnRhZ3x8Nj09PWQudGFnKXJldHVybiBkO2Zvcig7YSYmKGQ9YVtRXSk7YT1iLnBvcCgpKWM9ZDtyZXR1cm4gY31mdW5jdGlvbiBxYihhKXtpZig1PT09YS50YWd8fDY9PT1hLnRhZylyZXR1cm4gYS5zdGF0ZU5vZGU7RShcIjMzXCIpfWZ1bmN0aW9uIHJiKGEpe3JldHVybiBhW29iXXx8bnVsbH1cbnZhciBzYj1PYmplY3QuZnJlZXplKHtwcmVjYWNoZUZpYmVyTm9kZTpmdW5jdGlvbihhLGIpe2JbUV09YX0sZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6cGIsZ2V0SW5zdGFuY2VGcm9tTm9kZTpmdW5jdGlvbihhKXthPWFbUV07cmV0dXJuIWF8fDUhPT1hLnRhZyYmNiE9PWEudGFnP251bGw6YX0sZ2V0Tm9kZUZyb21JbnN0YW5jZTpxYixnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlOnJiLHVwZGF0ZUZpYmVyUHJvcHM6ZnVuY3Rpb24oYSxiKXthW29iXT1ifX0pO2Z1bmN0aW9uIHRiKGEpe2RvIGE9YVtcInJldHVyblwiXTt3aGlsZShhJiY1IT09YS50YWcpO3JldHVybiBhP2E6bnVsbH1mdW5jdGlvbiB1YihhLGIsYyl7Zm9yKHZhciBkPVtdO2E7KWQucHVzaChhKSxhPXRiKGEpO2ZvcihhPWQubGVuZ3RoOzA8YS0tOyliKGRbYV0sXCJjYXB0dXJlZFwiLGMpO2ZvcihhPTA7YTxkLmxlbmd0aDthKyspYihkW2FdLFwiYnViYmxlZFwiLGMpfVxuZnVuY3Rpb24gdmIoYSxiLGMpe2lmKGI9aWIoYSxjLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW2JdKSljLl9kaXNwYXRjaExpc3RlbmVycz0kYShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz0kYShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKX1mdW5jdGlvbiB3YihhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzJiZ1YihhLl90YXJnZXRJbnN0LHZiLGEpfWZ1bmN0aW9uIHhiKGEpe2lmKGEmJmEuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpe3ZhciBiPWEuX3RhcmdldEluc3Q7Yj1iP3RiKGIpOm51bGw7dWIoYix2YixhKX19XG5mdW5jdGlvbiB5YihhLGIsYyl7YSYmYyYmYy5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiYoYj1pYihhLGMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkpJiYoYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9JGEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9JGEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSkpfWZ1bmN0aW9uIHpiKGEpe2EmJmEuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmeWIoYS5fdGFyZ2V0SW5zdCxudWxsLGEpfWZ1bmN0aW9uIEFiKGEpe2FiKGEsd2IpfVxuZnVuY3Rpb24gQmIoYSxiLGMsZCl7aWYoYyYmZClhOnt2YXIgZT1jO2Zvcih2YXIgZj1kLGc9MCxoPWU7aDtoPXRiKGgpKWcrKztoPTA7Zm9yKHZhciBrPWY7aztrPXRiKGspKWgrKztmb3IoOzA8Zy1oOyllPXRiKGUpLGctLTtmb3IoOzA8aC1nOylmPXRiKGYpLGgtLTtmb3IoO2ctLTspe2lmKGU9PT1mfHxlPT09Zi5hbHRlcm5hdGUpYnJlYWsgYTtlPXRiKGUpO2Y9dGIoZil9ZT1udWxsfWVsc2UgZT1udWxsO2Y9ZTtmb3IoZT1bXTtjJiZjIT09Zjspe2c9Yy5hbHRlcm5hdGU7aWYobnVsbCE9PWcmJmc9PT1mKWJyZWFrO2UucHVzaChjKTtjPXRiKGMpfWZvcihjPVtdO2QmJmQhPT1mOyl7Zz1kLmFsdGVybmF0ZTtpZihudWxsIT09ZyYmZz09PWYpYnJlYWs7Yy5wdXNoKGQpO2Q9dGIoZCl9Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKyl5YihlW2RdLFwiYnViYmxlZFwiLGEpO2ZvcihhPWMubGVuZ3RoOzA8YS0tOyl5YihjW2FdLFwiY2FwdHVyZWRcIixiKX1cbnZhciBDYj1PYmplY3QuZnJlZXplKHthY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOkFiLGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OmZ1bmN0aW9uKGEpe2FiKGEseGIpfSxhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6QmIsYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6ZnVuY3Rpb24oYSl7YWIoYSx6Yil9fSksRGI9bnVsbDtmdW5jdGlvbiBFYigpeyFEYiYmbC5jYW5Vc2VET00mJihEYj1cInRleHRDb250ZW50XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/XCJ0ZXh0Q29udGVudFwiOlwiaW5uZXJUZXh0XCIpO3JldHVybiBEYn12YXIgUz17X3Jvb3Q6bnVsbCxfc3RhcnRUZXh0Om51bGwsX2ZhbGxiYWNrVGV4dDpudWxsfTtcbmZ1bmN0aW9uIEZiKCl7aWYoUy5fZmFsbGJhY2tUZXh0KXJldHVybiBTLl9mYWxsYmFja1RleHQ7dmFyIGEsYj1TLl9zdGFydFRleHQsYz1iLmxlbmd0aCxkLGU9R2IoKSxmPWUubGVuZ3RoO2ZvcihhPTA7YTxjJiZiW2FdPT09ZVthXTthKyspO3ZhciBnPWMtYTtmb3IoZD0xO2Q8PWcmJmJbYy1kXT09PWVbZi1kXTtkKyspO1MuX2ZhbGxiYWNrVGV4dD1lLnNsaWNlKGEsMTxkPzEtZDp2b2lkIDApO3JldHVybiBTLl9mYWxsYmFja1RleHR9ZnVuY3Rpb24gR2IoKXtyZXR1cm5cInZhbHVlXCJpbiBTLl9yb290P1MuX3Jvb3QudmFsdWU6Uy5fcm9vdFtFYigpXX1cbnZhciBIYj1cImRpc3BhdGNoQ29uZmlnIF90YXJnZXRJbnN0IG5hdGl2ZUV2ZW50IGlzRGVmYXVsdFByZXZlbnRlZCBpc1Byb3BhZ2F0aW9uU3RvcHBlZCBfZGlzcGF0Y2hMaXN0ZW5lcnMgX2Rpc3BhdGNoSW5zdGFuY2VzXCIuc3BsaXQoXCIgXCIpLEliPXt0eXBlOm51bGwsdGFyZ2V0Om51bGwsY3VycmVudFRhcmdldDpDLnRoYXRSZXR1cm5zTnVsbCxldmVudFBoYXNlOm51bGwsYnViYmxlczpudWxsLGNhbmNlbGFibGU6bnVsbCx0aW1lU3RhbXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEudGltZVN0YW1wfHxEYXRlLm5vdygpfSxkZWZhdWx0UHJldmVudGVkOm51bGwsaXNUcnVzdGVkOm51bGx9O1xuZnVuY3Rpb24gVChhLGIsYyxkKXt0aGlzLmRpc3BhdGNoQ29uZmlnPWE7dGhpcy5fdGFyZ2V0SW5zdD1iO3RoaXMubmF0aXZlRXZlbnQ9YzthPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO2Zvcih2YXIgZSBpbiBhKWEuaGFzT3duUHJvcGVydHkoZSkmJigoYj1hW2VdKT90aGlzW2VdPWIoYyk6XCJ0YXJnZXRcIj09PWU/dGhpcy50YXJnZXQ9ZDp0aGlzW2VdPWNbZV0pO3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPShudWxsIT1jLmRlZmF1bHRQcmV2ZW50ZWQ/Yy5kZWZhdWx0UHJldmVudGVkOiExPT09Yy5yZXR1cm5WYWx1ZSk/Qy50aGF0UmV0dXJuc1RydWU6Qy50aGF0UmV0dXJuc0ZhbHNlO3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9Qy50aGF0UmV0dXJuc0ZhbHNlO3JldHVybiB0aGlzfVxuQihULnByb3RvdHlwZSx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITA7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5yZXR1cm5WYWx1ZSYmKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPUMudGhhdFJldHVybnNUcnVlKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUMudGhhdFJldHVybnNUcnVlKX0scGVyc2lzdDpmdW5jdGlvbigpe3RoaXMuaXNQZXJzaXN0ZW50PUMudGhhdFJldHVybnNUcnVlfSxpc1BlcnNpc3RlbnQ6Qy50aGF0UmV0dXJuc0ZhbHNlLFxuZGVzdHJ1Y3RvcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlLGI7Zm9yKGIgaW4gYSl0aGlzW2JdPW51bGw7Zm9yKGE9MDthPEhiLmxlbmd0aDthKyspdGhpc1tIYlthXV09bnVsbH19KTtULkludGVyZmFjZT1JYjtULmF1Z21lbnRDbGFzcz1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9dGhpcy5wcm90b3R5cGU7dmFyIGQ9bmV3IGM7QihkLGEucHJvdG90eXBlKTthLnByb3RvdHlwZT1kO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWE7YS5JbnRlcmZhY2U9Qih7fSx0aGlzLkludGVyZmFjZSxiKTthLmF1Z21lbnRDbGFzcz10aGlzLmF1Z21lbnRDbGFzcztKYihhKX07SmIoVCk7ZnVuY3Rpb24gS2IoYSxiLGMsZCl7aWYodGhpcy5ldmVudFBvb2wubGVuZ3RoKXt2YXIgZT10aGlzLmV2ZW50UG9vbC5wb3AoKTt0aGlzLmNhbGwoZSxhLGIsYyxkKTtyZXR1cm4gZX1yZXR1cm4gbmV3IHRoaXMoYSxiLGMsZCl9XG5mdW5jdGlvbiBMYihhKXthIGluc3RhbmNlb2YgdGhpcz92b2lkIDA6RShcIjIyM1wiKTthLmRlc3RydWN0b3IoKTsxMD50aGlzLmV2ZW50UG9vbC5sZW5ndGgmJnRoaXMuZXZlbnRQb29sLnB1c2goYSl9ZnVuY3Rpb24gSmIoYSl7YS5ldmVudFBvb2w9W107YS5nZXRQb29sZWQ9S2I7YS5yZWxlYXNlPUxifWZ1bmN0aW9uIE1iKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhNYix7ZGF0YTpudWxsfSk7ZnVuY3Rpb24gTmIoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKE5iLHtkYXRhOm51bGx9KTt2YXIgUGI9WzksMTMsMjcsMzJdLFZiPWwuY2FuVXNlRE9NJiZcIkNvbXBvc2l0aW9uRXZlbnRcImluIHdpbmRvdyxXYj1udWxsO2wuY2FuVXNlRE9NJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJihXYj1kb2N1bWVudC5kb2N1bWVudE1vZGUpO3ZhciBYYjtcbmlmKFhiPWwuY2FuVXNlRE9NJiZcIlRleHRFdmVudFwiaW4gd2luZG93JiYhV2Ipe3ZhciBZYj13aW5kb3cub3BlcmE7WGI9IShcIm9iamVjdFwiPT09dHlwZW9mIFliJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgWWIudmVyc2lvbiYmMTI+PXBhcnNlSW50KFliLnZlcnNpb24oKSwxMCkpfVxudmFyIFpiPVhiLCRiPWwuY2FuVXNlRE9NJiYoIVZifHxXYiYmODxXYiYmMTE+PVdiKSxhYz1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxiYz17YmVmb3JlSW5wdXQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25CZWZvcmVJbnB1dFwiLGNhcHR1cmVkOlwib25CZWZvcmVJbnB1dENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOltcInRvcENvbXBvc2l0aW9uRW5kXCIsXCJ0b3BLZXlQcmVzc1wiLFwidG9wVGV4dElucHV0XCIsXCJ0b3BQYXN0ZVwiXX0sY29tcG9zaXRpb25FbmQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvbkVuZFwiLGNhcHR1cmVkOlwib25Db21wb3NpdGlvbkVuZENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvbkVuZCB0b3BLZXlEb3duIHRvcEtleVByZXNzIHRvcEtleVVwIHRvcE1vdXNlRG93blwiLnNwbGl0KFwiIFwiKX0sY29tcG9zaXRpb25TdGFydDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcbmNhcHR1cmVkOlwib25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uU3RhcnQgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uVXBkYXRlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25VcGRhdGUgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9fSxjYz0hMTtcbmZ1bmN0aW9uIGRjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlVcFwiOnJldHVybi0xIT09UGIuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJ0b3BLZXlEb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwidG9wS2V5UHJlc3NcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcEJsdXJcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBlYyhhKXthPWEuZGV0YWlsO3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmXCJkYXRhXCJpbiBhP2EuZGF0YTpudWxsfXZhciBmYz0hMTtmdW5jdGlvbiBnYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpyZXR1cm4gZWMoYik7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoMzIhPT1iLndoaWNoKXJldHVybiBudWxsO2NjPSEwO3JldHVybiBhYztjYXNlIFwidG9wVGV4dElucHV0XCI6cmV0dXJuIGE9Yi5kYXRhLGE9PT1hYyYmY2M/bnVsbDphO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gaGMoYSxiKXtpZihmYylyZXR1cm5cInRvcENvbXBvc2l0aW9uRW5kXCI9PT1hfHwhVmImJmRjKGEsYik/KGE9RmIoKSxTLl9yb290PW51bGwsUy5fc3RhcnRUZXh0PW51bGwsUy5fZmFsbGJhY2tUZXh0PW51bGwsZmM9ITEsYSk6bnVsbDtzd2l0Y2goYSl7Y2FzZSBcInRvcFBhc3RlXCI6cmV0dXJuIG51bGw7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoIShiLmN0cmxLZXl8fGIuYWx0S2V5fHxiLm1ldGFLZXkpfHxiLmN0cmxLZXkmJmIuYWx0S2V5KXtpZihiLmNoYXImJjE8Yi5jaGFyLmxlbmd0aClyZXR1cm4gYi5jaGFyO2lmKGIud2hpY2gpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYi53aGljaCl9cmV0dXJuIG51bGw7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6cmV0dXJuICRiP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIGljPXtldmVudFR5cGVzOmJjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7aWYoVmIpYjp7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BDb21wb3NpdGlvblN0YXJ0XCI6dmFyIGY9YmMuY29tcG9zaXRpb25TdGFydDticmVhayBiO2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOmY9YmMuY29tcG9zaXRpb25FbmQ7YnJlYWsgYjtjYXNlIFwidG9wQ29tcG9zaXRpb25VcGRhdGVcIjpmPWJjLmNvbXBvc2l0aW9uVXBkYXRlO2JyZWFrIGJ9Zj12b2lkIDB9ZWxzZSBmYz9kYyhhLGMpJiYoZj1iYy5jb21wb3NpdGlvbkVuZCk6XCJ0b3BLZXlEb3duXCI9PT1hJiYyMjk9PT1jLmtleUNvZGUmJihmPWJjLmNvbXBvc2l0aW9uU3RhcnQpO2Y/KCRiJiYoZmN8fGYhPT1iYy5jb21wb3NpdGlvblN0YXJ0P2Y9PT1iYy5jb21wb3NpdGlvbkVuZCYmZmMmJihlPUZiKCkpOihTLl9yb290PWQsUy5fc3RhcnRUZXh0PUdiKCksZmM9ITApKSxmPU1iLmdldFBvb2xlZChmLGIsYyxkKSxlP2YuZGF0YT1cbmU6KGU9ZWMoYyksbnVsbCE9PWUmJihmLmRhdGE9ZSkpLEFiKGYpLGU9Zik6ZT1udWxsOyhhPVpiP2djKGEsYyk6aGMoYSxjKSk/KGI9TmIuZ2V0UG9vbGVkKGJjLmJlZm9yZUlucHV0LGIsYyxkKSxiLmRhdGE9YSxBYihiKSk6Yj1udWxsO3JldHVybltlLGJdfX0samM9bnVsbCxrYz1udWxsLGxjPW51bGw7ZnVuY3Rpb24gbWMoYSl7aWYoYT1YYShhKSl7amMmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBqYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlP3ZvaWQgMDpFKFwiMTk0XCIpO3ZhciBiPVdhKGEuc3RhdGVOb2RlKTtqYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGEuc3RhdGVOb2RlLGEudHlwZSxiKX19dmFyIG5jPXtpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OmZ1bmN0aW9uKGEpe2pjPWF9fTtmdW5jdGlvbiBvYyhhKXtrYz9sYz9sYy5wdXNoKGEpOmxjPVthXTprYz1hfVxuZnVuY3Rpb24gcGMoKXtpZihrYyl7dmFyIGE9a2MsYj1sYztsYz1rYz1udWxsO21jKGEpO2lmKGIpZm9yKGE9MDthPGIubGVuZ3RoO2ErKyltYyhiW2FdKX19dmFyIHFjPU9iamVjdC5mcmVlemUoe2luamVjdGlvbjpuYyxlbnF1ZXVlU3RhdGVSZXN0b3JlOm9jLHJlc3RvcmVTdGF0ZUlmTmVlZGVkOnBjfSk7ZnVuY3Rpb24gcmMoYSxiKXtyZXR1cm4gYShiKX12YXIgc2M9ITE7ZnVuY3Rpb24gdGMoYSxiKXtpZihzYylyZXR1cm4gcmMoYSxiKTtzYz0hMDt0cnl7cmV0dXJuIHJjKGEsYil9ZmluYWxseXtzYz0hMSxwYygpfX12YXIgdWM9e2NvbG9yOiEwLGRhdGU6ITAsZGF0ZXRpbWU6ITAsXCJkYXRldGltZS1sb2NhbFwiOiEwLGVtYWlsOiEwLG1vbnRoOiEwLG51bWJlcjohMCxwYXNzd29yZDohMCxyYW5nZTohMCxzZWFyY2g6ITAsdGVsOiEwLHRleHQ6ITAsdGltZTohMCx1cmw6ITAsd2VlazohMH07XG5mdW5jdGlvbiB2YyhhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09Yj8hIXVjW2EudHlwZV06XCJ0ZXh0YXJlYVwiPT09Yj8hMDohMX1mdW5jdGlvbiB3YyhhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHhjO2wuY2FuVXNlRE9NJiYoeGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24mJmRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUmJiEwIT09ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIlwiLFwiXCIpKTtcbmZ1bmN0aW9uIHljKGEsYil7aWYoIWwuY2FuVXNlRE9NfHxiJiYhKFwiYWRkRXZlbnRMaXN0ZW5lclwiaW4gZG9jdW1lbnQpKXJldHVybiExO2I9XCJvblwiK2E7dmFyIGM9YiBpbiBkb2N1bWVudDtjfHwoYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGMuc2V0QXR0cmlidXRlKGIsXCJyZXR1cm47XCIpLGM9XCJmdW5jdGlvblwiPT09dHlwZW9mIGNbYl0pOyFjJiZ4YyYmXCJ3aGVlbFwiPT09YSYmKGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIkV2ZW50cy53aGVlbFwiLFwiMy4wXCIpKTtyZXR1cm4gY31mdW5jdGlvbiB6YyhhKXt2YXIgYj1hLnR5cGU7cmV0dXJuKGE9YS5ub2RlTmFtZSkmJlwiaW5wdXRcIj09PWEudG9Mb3dlckNhc2UoKSYmKFwiY2hlY2tib3hcIj09PWJ8fFwicmFkaW9cIj09PWIpfVxuZnVuY3Rpb24gQWMoYSl7dmFyIGI9emMoYSk/XCJjaGVja2VkXCI6XCJ2YWx1ZVwiLGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxiKSxkPVwiXCIrYVtiXTtpZighYS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2VudW1lcmFibGU6Yy5lbnVtZXJhYmxlLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXQuY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGEpe2Q9XCJcIithO2Muc2V0LmNhbGwodGhpcyxhKX19KSx7Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sc2V0VmFsdWU6ZnVuY3Rpb24oYSl7ZD1cIlwiK2F9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2EuX3ZhbHVlVHJhY2tlcj1udWxsO2RlbGV0ZSBhW2JdfX19XG5mdW5jdGlvbiBCYyhhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9QWMoYSkpfWZ1bmN0aW9uIENjKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD16YyhhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfXZhciBEYz17Y2hhbmdlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ2hhbmdlXCIsY2FwdHVyZWQ6XCJvbkNoYW5nZUNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDaGFuZ2UgdG9wQ2xpY2sgdG9wRm9jdXMgdG9wSW5wdXQgdG9wS2V5RG93biB0b3BLZXlVcCB0b3BTZWxlY3Rpb25DaGFuZ2VcIi5zcGxpdChcIiBcIil9fTtcbmZ1bmN0aW9uIEVjKGEsYixjKXthPVQuZ2V0UG9vbGVkKERjLmNoYW5nZSxhLGIsYyk7YS50eXBlPVwiY2hhbmdlXCI7b2MoYyk7QWIoYSk7cmV0dXJuIGF9dmFyIEZjPW51bGwsR2M9bnVsbDtmdW5jdGlvbiBIYyhhKXtrYihhKTtsYighMSl9ZnVuY3Rpb24gSWMoYSl7dmFyIGI9cWIoYSk7aWYoQ2MoYikpcmV0dXJuIGF9ZnVuY3Rpb24gSmMoYSxiKXtpZihcInRvcENoYW5nZVwiPT09YSlyZXR1cm4gYn12YXIgS2M9ITE7bC5jYW5Vc2VET00mJihLYz15YyhcImlucHV0XCIpJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpKTtmdW5jdGlvbiBMYygpe0ZjJiYoRmMuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsTWMpLEdjPUZjPW51bGwpfWZ1bmN0aW9uIE1jKGEpe1widmFsdWVcIj09PWEucHJvcGVydHlOYW1lJiZJYyhHYykmJihhPUVjKEdjLGEsd2MoYSkpLHRjKEhjLGEpKX1cbmZ1bmN0aW9uIE5jKGEsYixjKXtcInRvcEZvY3VzXCI9PT1hPyhMYygpLEZjPWIsR2M9YyxGYy5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixNYykpOlwidG9wQmx1clwiPT09YSYmTGMoKX1mdW5jdGlvbiBPYyhhKXtpZihcInRvcFNlbGVjdGlvbkNoYW5nZVwiPT09YXx8XCJ0b3BLZXlVcFwiPT09YXx8XCJ0b3BLZXlEb3duXCI9PT1hKXJldHVybiBJYyhHYyl9ZnVuY3Rpb24gUGMoYSxiKXtpZihcInRvcENsaWNrXCI9PT1hKXJldHVybiBJYyhiKX1mdW5jdGlvbiAkYyhhLGIpe2lmKFwidG9wSW5wdXRcIj09PWF8fFwidG9wQ2hhbmdlXCI9PT1hKXJldHVybiBJYyhiKX1cbnZhciBhZD17ZXZlbnRUeXBlczpEYyxfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOktjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9Yj9xYihiKTp3aW5kb3csZj1lLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoXCJzZWxlY3RcIj09PWZ8fFwiaW5wdXRcIj09PWYmJlwiZmlsZVwiPT09ZS50eXBlKXZhciBnPUpjO2Vsc2UgaWYodmMoZSkpaWYoS2MpZz0kYztlbHNle2c9T2M7dmFyIGg9TmN9ZWxzZSBmPWUubm9kZU5hbWUsIWZ8fFwiaW5wdXRcIiE9PWYudG9Mb3dlckNhc2UoKXx8XCJjaGVja2JveFwiIT09ZS50eXBlJiZcInJhZGlvXCIhPT1lLnR5cGV8fChnPVBjKTtpZihnJiYoZz1nKGEsYikpKXJldHVybiBFYyhnLGMsZCk7aCYmaChhLGUsYik7XCJ0b3BCbHVyXCI9PT1hJiZudWxsIT1iJiYoYT1iLl93cmFwcGVyU3RhdGV8fGUuX3dyYXBwZXJTdGF0ZSkmJmEuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWUudHlwZSYmKGE9XCJcIitlLnZhbHVlLGUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikhPT1cbmEmJmUuc2V0QXR0cmlidXRlKFwidmFsdWVcIixhKSl9fTtmdW5jdGlvbiBiZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoYmQse3ZpZXc6bnVsbCxkZXRhaWw6bnVsbH0pO3ZhciBjZD17QWx0OlwiYWx0S2V5XCIsQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gZGQoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1jZFthXSk/ISFiW2FdOiExfWZ1bmN0aW9uIGVkKCl7cmV0dXJuIGRkfWZ1bmN0aW9uIGZkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1cbmJkLmF1Z21lbnRDbGFzcyhmZCx7c2NyZWVuWDpudWxsLHNjcmVlblk6bnVsbCxjbGllbnRYOm51bGwsY2xpZW50WTpudWxsLHBhZ2VYOm51bGwscGFnZVk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwsZ2V0TW9kaWZpZXJTdGF0ZTplZCxidXR0b246bnVsbCxidXR0b25zOm51bGwscmVsYXRlZFRhcmdldDpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZWxhdGVkVGFyZ2V0fHwoYS5mcm9tRWxlbWVudD09PWEuc3JjRWxlbWVudD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50KX19KTtcbnZhciBnZD17bW91c2VFbnRlcjp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VFbnRlclwiLGRlcGVuZGVuY2llczpbXCJ0b3BNb3VzZU91dFwiLFwidG9wTW91c2VPdmVyXCJdfSxtb3VzZUxlYXZlOntyZWdpc3RyYXRpb25OYW1lOlwib25Nb3VzZUxlYXZlXCIsZGVwZW5kZW5jaWVzOltcInRvcE1vdXNlT3V0XCIsXCJ0b3BNb3VzZU92ZXJcIl19fSxoZD17ZXZlbnRUeXBlczpnZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe2lmKFwidG9wTW91c2VPdmVyXCI9PT1hJiYoYy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KXx8XCJ0b3BNb3VzZU91dFwiIT09YSYmXCJ0b3BNb3VzZU92ZXJcIiE9PWEpcmV0dXJuIG51bGw7dmFyIGU9ZC53aW5kb3c9PT1kP2Q6KGU9ZC5vd25lckRvY3VtZW50KT9lLmRlZmF1bHRWaWV3fHxlLnBhcmVudFdpbmRvdzp3aW5kb3c7XCJ0b3BNb3VzZU91dFwiPT09YT8oYT1iLGI9KGI9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCk/cGIoYik6bnVsbCk6YT1udWxsO2lmKGE9PT1cbmIpcmV0dXJuIG51bGw7dmFyIGY9bnVsbD09YT9lOnFiKGEpO2U9bnVsbD09Yj9lOnFiKGIpO3ZhciBnPWZkLmdldFBvb2xlZChnZC5tb3VzZUxlYXZlLGEsYyxkKTtnLnR5cGU9XCJtb3VzZWxlYXZlXCI7Zy50YXJnZXQ9ZjtnLnJlbGF0ZWRUYXJnZXQ9ZTtjPWZkLmdldFBvb2xlZChnZC5tb3VzZUVudGVyLGIsYyxkKTtjLnR5cGU9XCJtb3VzZWVudGVyXCI7Yy50YXJnZXQ9ZTtjLnJlbGF0ZWRUYXJnZXQ9ZjtCYihnLGMsYSxiKTtyZXR1cm5bZyxjXX19LGlkPWFhLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyO2Z1bmN0aW9uIGpkKGEpe2E9YS50eXBlO3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYT9hOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuZGlzcGxheU5hbWV8fGEubmFtZTpudWxsfVxuZnVuY3Rpb24ga2QoYSl7dmFyIGI9YTtpZihhLmFsdGVybmF0ZSlmb3IoO2JbXCJyZXR1cm5cIl07KWI9YltcInJldHVyblwiXTtlbHNle2lmKDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDE7Zm9yKDtiW1wicmV0dXJuXCJdOylpZihiPWJbXCJyZXR1cm5cIl0sMCE9PShiLmVmZmVjdFRhZyYyKSlyZXR1cm4gMX1yZXR1cm4gMz09PWIudGFnPzI6M31mdW5jdGlvbiBsZChhKXtyZXR1cm4oYT1hLl9yZWFjdEludGVybmFsRmliZXIpPzI9PT1rZChhKTohMX1mdW5jdGlvbiBtZChhKXsyIT09a2QoYSk/RShcIjE4OFwiKTp2b2lkIDB9XG5mdW5jdGlvbiBuZChhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYilyZXR1cm4gYj1rZChhKSwzPT09Yj9FKFwiMTg4XCIpOnZvaWQgMCwxPT09Yj9udWxsOmE7Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWNbXCJyZXR1cm5cIl0sZj1lP2UuYWx0ZXJuYXRlOm51bGw7aWYoIWV8fCFmKWJyZWFrO2lmKGUuY2hpbGQ9PT1mLmNoaWxkKXtmb3IodmFyIGc9ZS5jaGlsZDtnOyl7aWYoZz09PWMpcmV0dXJuIG1kKGUpLGE7aWYoZz09PWQpcmV0dXJuIG1kKGUpLGI7Zz1nLnNpYmxpbmd9RShcIjE4OFwiKX1pZihjW1wicmV0dXJuXCJdIT09ZFtcInJldHVyblwiXSljPWUsZD1mO2Vsc2V7Zz0hMTtmb3IodmFyIGg9ZS5jaGlsZDtoOyl7aWYoaD09PWMpe2c9ITA7Yz1lO2Q9ZjticmVha31pZihoPT09ZCl7Zz0hMDtkPWU7Yz1mO2JyZWFrfWg9aC5zaWJsaW5nfWlmKCFnKXtmb3IoaD1mLmNoaWxkO2g7KXtpZihoPT09Yyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9aD1oLnNpYmxpbmd9Zz9cbnZvaWQgMDpFKFwiMTg5XCIpfX1jLmFsdGVybmF0ZSE9PWQ/RShcIjE5MFwiKTp2b2lkIDB9MyE9PWMudGFnP0UoXCIxODhcIik6dm9pZCAwO3JldHVybiBjLnN0YXRlTm9kZS5jdXJyZW50PT09Yz9hOmJ9ZnVuY3Rpb24gb2QoYSl7YT1uZChhKTtpZighYSlyZXR1cm4gbnVsbDtmb3IodmFyIGI9YTs7KXtpZig1PT09Yi50YWd8fDY9PT1iLnRhZylyZXR1cm4gYjtpZihiLmNoaWxkKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIHBkKGEpe2E9bmQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCYmNCE9PWIudGFnKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH12YXIgcWQ9W107XG5mdW5jdGlvbiByZChhKXt2YXIgYj1hLnRhcmdldEluc3Q7ZG97aWYoIWIpe2EuYW5jZXN0b3JzLnB1c2goYik7YnJlYWt9dmFyIGM7Zm9yKGM9YjtjW1wicmV0dXJuXCJdOyljPWNbXCJyZXR1cm5cIl07Yz0zIT09Yy50YWc/bnVsbDpjLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKCFjKWJyZWFrO2EuYW5jZXN0b3JzLnB1c2goYik7Yj1wYihjKX13aGlsZShiKTtmb3IoYz0wO2M8YS5hbmNlc3RvcnMubGVuZ3RoO2MrKyliPWEuYW5jZXN0b3JzW2NdLHNkKGEudG9wTGV2ZWxUeXBlLGIsYS5uYXRpdmVFdmVudCx3YyhhLm5hdGl2ZUV2ZW50KSl9dmFyIHRkPSEwLHNkPXZvaWQgMDtmdW5jdGlvbiB1ZChhKXt0ZD0hIWF9ZnVuY3Rpb24gVShhLGIsYyl7cmV0dXJuIGM/YmEubGlzdGVuKGMsYix2ZC5iaW5kKG51bGwsYSkpOm51bGx9ZnVuY3Rpb24gd2QoYSxiLGMpe3JldHVybiBjP2JhLmNhcHR1cmUoYyxiLHZkLmJpbmQobnVsbCxhKSk6bnVsbH1cbmZ1bmN0aW9uIHZkKGEsYil7aWYodGQpe3ZhciBjPXdjKGIpO2M9cGIoYyk7bnVsbD09PWN8fFwibnVtYmVyXCIhPT10eXBlb2YgYy50YWd8fDI9PT1rZChjKXx8KGM9bnVsbCk7aWYocWQubGVuZ3RoKXt2YXIgZD1xZC5wb3AoKTtkLnRvcExldmVsVHlwZT1hO2QubmF0aXZlRXZlbnQ9YjtkLnRhcmdldEluc3Q9YzthPWR9ZWxzZSBhPXt0b3BMZXZlbFR5cGU6YSxuYXRpdmVFdmVudDpiLHRhcmdldEluc3Q6YyxhbmNlc3RvcnM6W119O3RyeXt0YyhyZCxhKX1maW5hbGx5e2EudG9wTGV2ZWxUeXBlPW51bGwsYS5uYXRpdmVFdmVudD1udWxsLGEudGFyZ2V0SW5zdD1udWxsLGEuYW5jZXN0b3JzLmxlbmd0aD0wLDEwPnFkLmxlbmd0aCYmcWQucHVzaChhKX19fVxudmFyIHhkPU9iamVjdC5mcmVlemUoe2dldCBfZW5hYmxlZCgpe3JldHVybiB0ZH0sZ2V0IF9oYW5kbGVUb3BMZXZlbCgpe3JldHVybiBzZH0sc2V0SGFuZGxlVG9wTGV2ZWw6ZnVuY3Rpb24oYSl7c2Q9YX0sc2V0RW5hYmxlZDp1ZCxpc0VuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGR9LHRyYXBCdWJibGVkRXZlbnQ6VSx0cmFwQ2FwdHVyZWRFdmVudDp3ZCxkaXNwYXRjaEV2ZW50OnZkfSk7ZnVuY3Rpb24geWQoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtjW1wibXNcIithXT1cIk1TXCIrYjtjW1wiT1wiK2FdPVwib1wiK2IudG9Mb3dlckNhc2UoKTtyZXR1cm4gY31cbnZhciB6ZD17YW5pbWF0aW9uZW5kOnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25FbmRcIiksYW5pbWF0aW9uaXRlcmF0aW9uOnlkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25JdGVyYXRpb25cIiksYW5pbWF0aW9uc3RhcnQ6eWQoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvblN0YXJ0XCIpLHRyYW5zaXRpb25lbmQ6eWQoXCJUcmFuc2l0aW9uXCIsXCJUcmFuc2l0aW9uRW5kXCIpfSxBZD17fSxCZD17fTtsLmNhblVzZURPTSYmKEJkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIHpkLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIHpkLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIHpkLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIHpkLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7XG5mdW5jdGlvbiBDZChhKXtpZihBZFthXSlyZXR1cm4gQWRbYV07aWYoIXpkW2FdKXJldHVybiBhO3ZhciBiPXpkW2FdLGM7Zm9yKGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpJiZjIGluIEJkKXJldHVybiBBZFthXT1iW2NdO3JldHVyblwiXCJ9XG52YXIgRGQ9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BBbmltYXRpb25FbmQ6Q2QoXCJhbmltYXRpb25lbmRcIil8fFwiYW5pbWF0aW9uZW5kXCIsdG9wQW5pbWF0aW9uSXRlcmF0aW9uOkNkKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpfHxcImFuaW1hdGlvbml0ZXJhdGlvblwiLHRvcEFuaW1hdGlvblN0YXJ0OkNkKFwiYW5pbWF0aW9uc3RhcnRcIil8fFwiYW5pbWF0aW9uc3RhcnRcIix0b3BCbHVyOlwiYmx1clwiLHRvcENhbmNlbDpcImNhbmNlbFwiLHRvcENhblBsYXk6XCJjYW5wbGF5XCIsdG9wQ2FuUGxheVRocm91Z2g6XCJjYW5wbGF5dGhyb3VnaFwiLHRvcENoYW5nZTpcImNoYW5nZVwiLHRvcENsaWNrOlwiY2xpY2tcIix0b3BDbG9zZTpcImNsb3NlXCIsdG9wQ29tcG9zaXRpb25FbmQ6XCJjb21wb3NpdGlvbmVuZFwiLHRvcENvbXBvc2l0aW9uU3RhcnQ6XCJjb21wb3NpdGlvbnN0YXJ0XCIsdG9wQ29tcG9zaXRpb25VcGRhdGU6XCJjb21wb3NpdGlvbnVwZGF0ZVwiLHRvcENvbnRleHRNZW51OlwiY29udGV4dG1lbnVcIix0b3BDb3B5OlwiY29weVwiLFxudG9wQ3V0OlwiY3V0XCIsdG9wRG91YmxlQ2xpY2s6XCJkYmxjbGlja1wiLHRvcERyYWc6XCJkcmFnXCIsdG9wRHJhZ0VuZDpcImRyYWdlbmRcIix0b3BEcmFnRW50ZXI6XCJkcmFnZW50ZXJcIix0b3BEcmFnRXhpdDpcImRyYWdleGl0XCIsdG9wRHJhZ0xlYXZlOlwiZHJhZ2xlYXZlXCIsdG9wRHJhZ092ZXI6XCJkcmFnb3ZlclwiLHRvcERyYWdTdGFydDpcImRyYWdzdGFydFwiLHRvcERyb3A6XCJkcm9wXCIsdG9wRHVyYXRpb25DaGFuZ2U6XCJkdXJhdGlvbmNoYW5nZVwiLHRvcEVtcHRpZWQ6XCJlbXB0aWVkXCIsdG9wRW5jcnlwdGVkOlwiZW5jcnlwdGVkXCIsdG9wRW5kZWQ6XCJlbmRlZFwiLHRvcEVycm9yOlwiZXJyb3JcIix0b3BGb2N1czpcImZvY3VzXCIsdG9wSW5wdXQ6XCJpbnB1dFwiLHRvcEtleURvd246XCJrZXlkb3duXCIsdG9wS2V5UHJlc3M6XCJrZXlwcmVzc1wiLHRvcEtleVVwOlwia2V5dXBcIix0b3BMb2FkZWREYXRhOlwibG9hZGVkZGF0YVwiLHRvcExvYWQ6XCJsb2FkXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLFxudG9wTW91c2VEb3duOlwibW91c2Vkb3duXCIsdG9wTW91c2VNb3ZlOlwibW91c2Vtb3ZlXCIsdG9wTW91c2VPdXQ6XCJtb3VzZW91dFwiLHRvcE1vdXNlT3ZlcjpcIm1vdXNlb3ZlclwiLHRvcE1vdXNlVXA6XCJtb3VzZXVwXCIsdG9wUGFzdGU6XCJwYXN0ZVwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Nyb2xsOlwic2Nyb2xsXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTZWxlY3Rpb25DaGFuZ2U6XCJzZWxlY3Rpb25jaGFuZ2VcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGV4dElucHV0OlwidGV4dElucHV0XCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BUb2dnbGU6XCJ0b2dnbGVcIix0b3BUb3VjaENhbmNlbDpcInRvdWNoY2FuY2VsXCIsdG9wVG91Y2hFbmQ6XCJ0b3VjaGVuZFwiLHRvcFRvdWNoTW92ZTpcInRvdWNobW92ZVwiLFxudG9wVG91Y2hTdGFydDpcInRvdWNoc3RhcnRcIix0b3BUcmFuc2l0aW9uRW5kOkNkKFwidHJhbnNpdGlvbmVuZFwiKXx8XCJ0cmFuc2l0aW9uZW5kXCIsdG9wVm9sdW1lQ2hhbmdlOlwidm9sdW1lY2hhbmdlXCIsdG9wV2FpdGluZzpcIndhaXRpbmdcIix0b3BXaGVlbDpcIndoZWVsXCJ9LEVkPXt9LEZkPTAsR2Q9XCJfcmVhY3RMaXN0ZW5lcnNJRFwiKyhcIlwiK01hdGgucmFuZG9tKCkpLnNsaWNlKDIpO2Z1bmN0aW9uIEhkKGEpe09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLEdkKXx8KGFbR2RdPUZkKyssRWRbYVtHZF1dPXt9KTtyZXR1cm4gRWRbYVtHZF1dfWZ1bmN0aW9uIElkKGEpe2Zvcig7YSYmYS5maXJzdENoaWxkOylhPWEuZmlyc3RDaGlsZDtyZXR1cm4gYX1cbmZ1bmN0aW9uIEpkKGEsYil7dmFyIGM9SWQoYSk7YT0wO2Zvcih2YXIgZDtjOyl7aWYoMz09PWMubm9kZVR5cGUpe2Q9YStjLnRleHRDb250ZW50Lmxlbmd0aDtpZihhPD1iJiZkPj1iKXJldHVybntub2RlOmMsb2Zmc2V0OmItYX07YT1kfWE6e2Zvcig7Yzspe2lmKGMubmV4dFNpYmxpbmcpe2M9Yy5uZXh0U2libGluZzticmVhayBhfWM9Yy5wYXJlbnROb2RlfWM9dm9pZCAwfWM9SWQoYyl9fWZ1bmN0aW9uIEtkKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYiYmKFwiaW5wdXRcIj09PWImJlwidGV4dFwiPT09YS50eXBlfHxcInRleHRhcmVhXCI9PT1ifHxcInRydWVcIj09PWEuY29udGVudEVkaXRhYmxlKX1cbnZhciBMZD1sLmNhblVzZURPTSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYxMT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlLE1kPXtzZWxlY3Q6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25TZWxlY3RcIixjYXB0dXJlZDpcIm9uU2VsZWN0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbnRleHRNZW51IHRvcEZvY3VzIHRvcEtleURvd24gdG9wS2V5VXAgdG9wTW91c2VEb3duIHRvcE1vdXNlVXAgdG9wU2VsZWN0aW9uQ2hhbmdlXCIuc3BsaXQoXCIgXCIpfX0sTmQ9bnVsbCxPZD1udWxsLFBkPW51bGwsUWQ9ITE7XG5mdW5jdGlvbiBSZChhLGIpe2lmKFFkfHxudWxsPT1OZHx8TmQhPT1kYSgpKXJldHVybiBudWxsO3ZhciBjPU5kO1wic2VsZWN0aW9uU3RhcnRcImluIGMmJktkKGMpP2M9e3N0YXJ0OmMuc2VsZWN0aW9uU3RhcnQsZW5kOmMuc2VsZWN0aW9uRW5kfTp3aW5kb3cuZ2V0U2VsZWN0aW9uPyhjPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSxjPXthbmNob3JOb2RlOmMuYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQ6Yy5hbmNob3JPZmZzZXQsZm9jdXNOb2RlOmMuZm9jdXNOb2RlLGZvY3VzT2Zmc2V0OmMuZm9jdXNPZmZzZXR9KTpjPXZvaWQgMDtyZXR1cm4gUGQmJmVhKFBkLGMpP251bGw6KFBkPWMsYT1ULmdldFBvb2xlZChNZC5zZWxlY3QsT2QsYSxiKSxhLnR5cGU9XCJzZWxlY3RcIixhLnRhcmdldD1OZCxBYihhKSxhKX1cbnZhciBTZD17ZXZlbnRUeXBlczpNZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWQud2luZG93PT09ZD9kLmRvY3VtZW50Ojk9PT1kLm5vZGVUeXBlP2Q6ZC5vd25lckRvY3VtZW50LGY7aWYoIShmPSFlKSl7YTp7ZT1IZChlKTtmPVNhLm9uU2VsZWN0O2Zvcih2YXIgZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaD1mW2ddO2lmKCFlLmhhc093blByb3BlcnR5KGgpfHwhZVtoXSl7ZT0hMTticmVhayBhfX1lPSEwfWY9IWV9aWYoZilyZXR1cm4gbnVsbDtlPWI/cWIoYik6d2luZG93O3N3aXRjaChhKXtjYXNlIFwidG9wRm9jdXNcIjppZih2YyhlKXx8XCJ0cnVlXCI9PT1lLmNvbnRlbnRFZGl0YWJsZSlOZD1lLE9kPWIsUGQ9bnVsbDticmVhaztjYXNlIFwidG9wQmx1clwiOlBkPU9kPU5kPW51bGw7YnJlYWs7Y2FzZSBcInRvcE1vdXNlRG93blwiOlFkPSEwO2JyZWFrO2Nhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6cmV0dXJuIFFkPSExLFJkKGMsZCk7Y2FzZSBcInRvcFNlbGVjdGlvbkNoYW5nZVwiOmlmKExkKWJyZWFrO1xuY2FzZSBcInRvcEtleURvd25cIjpjYXNlIFwidG9wS2V5VXBcIjpyZXR1cm4gUmQoYyxkKX1yZXR1cm4gbnVsbH19O2Z1bmN0aW9uIFRkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhUZCx7YW5pbWF0aW9uTmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7ZnVuY3Rpb24gVWQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKFVkLHtjbGlwYm9hcmREYXRhOmZ1bmN0aW9uKGEpe3JldHVyblwiY2xpcGJvYXJkRGF0YVwiaW4gYT9hLmNsaXBib2FyZERhdGE6d2luZG93LmNsaXBib2FyZERhdGF9fSk7ZnVuY3Rpb24gVmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWJkLmF1Z21lbnRDbGFzcyhWZCx7cmVsYXRlZFRhcmdldDpudWxsfSk7XG5mdW5jdGlvbiBXZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1cbnZhciBYZD17RXNjOlwiRXNjYXBlXCIsU3BhY2ViYXI6XCIgXCIsTGVmdDpcIkFycm93TGVmdFwiLFVwOlwiQXJyb3dVcFwiLFJpZ2h0OlwiQXJyb3dSaWdodFwiLERvd246XCJBcnJvd0Rvd25cIixEZWw6XCJEZWxldGVcIixXaW46XCJPU1wiLE1lbnU6XCJDb250ZXh0TWVudVwiLEFwcHM6XCJDb250ZXh0TWVudVwiLFNjcm9sbDpcIlNjcm9sbExvY2tcIixNb3pQcmludGFibGVLZXk6XCJVbmlkZW50aWZpZWRcIn0sWWQ9ezg6XCJCYWNrc3BhY2VcIiw5OlwiVGFiXCIsMTI6XCJDbGVhclwiLDEzOlwiRW50ZXJcIiwxNjpcIlNoaWZ0XCIsMTc6XCJDb250cm9sXCIsMTg6XCJBbHRcIiwxOTpcIlBhdXNlXCIsMjA6XCJDYXBzTG9ja1wiLDI3OlwiRXNjYXBlXCIsMzI6XCIgXCIsMzM6XCJQYWdlVXBcIiwzNDpcIlBhZ2VEb3duXCIsMzU6XCJFbmRcIiwzNjpcIkhvbWVcIiwzNzpcIkFycm93TGVmdFwiLDM4OlwiQXJyb3dVcFwiLDM5OlwiQXJyb3dSaWdodFwiLDQwOlwiQXJyb3dEb3duXCIsNDU6XCJJbnNlcnRcIiw0NjpcIkRlbGV0ZVwiLDExMjpcIkYxXCIsMTEzOlwiRjJcIiwxMTQ6XCJGM1wiLDExNTpcIkY0XCIsXG4xMTY6XCJGNVwiLDExNzpcIkY2XCIsMTE4OlwiRjdcIiwxMTk6XCJGOFwiLDEyMDpcIkY5XCIsMTIxOlwiRjEwXCIsMTIyOlwiRjExXCIsMTIzOlwiRjEyXCIsMTQ0OlwiTnVtTG9ja1wiLDE0NTpcIlNjcm9sbExvY2tcIiwyMjQ6XCJNZXRhXCJ9O2Z1bmN0aW9uIFpkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1cbmJkLmF1Z21lbnRDbGFzcyhaZCx7a2V5OmZ1bmN0aW9uKGEpe2lmKGEua2V5KXt2YXIgYj1YZFthLmtleV18fGEua2V5O2lmKFwiVW5pZGVudGlmaWVkXCIhPT1iKXJldHVybiBifXJldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT8oYT1XZChhKSwxMz09PWE/XCJFbnRlclwiOlN0cmluZy5mcm9tQ2hhckNvZGUoYSkpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/WWRbYS5rZXlDb2RlXXx8XCJVbmlkZW50aWZpZWRcIjpcIlwifSxsb2NhdGlvbjpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxyZXBlYXQ6bnVsbCxsb2NhbGU6bnVsbCxnZXRNb2RpZmllclN0YXRlOmVkLGNoYXJDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT9XZChhKTowfSxrZXlDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9LHdoaWNoOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PVxuYS50eXBlP1dkKGEpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9fSk7ZnVuY3Rpb24gJGQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfWZkLmF1Z21lbnRDbGFzcygkZCx7ZGF0YVRyYW5zZmVyOm51bGx9KTtmdW5jdGlvbiBhZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9YmQuYXVnbWVudENsYXNzKGFlLHt0b3VjaGVzOm51bGwsdGFyZ2V0VG91Y2hlczpudWxsLGNoYW5nZWRUb3VjaGVzOm51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6ZWR9KTtmdW5jdGlvbiBiZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoYmUse3Byb3BlcnR5TmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7XG5mdW5jdGlvbiBjZShhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9ZmQuYXVnbWVudENsYXNzKGNlLHtkZWx0YVg6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVhcImluIGE/YS5kZWx0YVg6XCJ3aGVlbERlbHRhWFwiaW4gYT8tYS53aGVlbERlbHRhWDowfSxkZWx0YVk6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVlcImluIGE/YS5kZWx0YVk6XCJ3aGVlbERlbHRhWVwiaW4gYT8tYS53aGVlbERlbHRhWTpcIndoZWVsRGVsdGFcImluIGE/LWEud2hlZWxEZWx0YTowfSxkZWx0YVo6bnVsbCxkZWx0YU1vZGU6bnVsbH0pO3ZhciBkZT17fSxlZT17fTtcblwiYWJvcnQgYW5pbWF0aW9uRW5kIGFuaW1hdGlvbkl0ZXJhdGlvbiBhbmltYXRpb25TdGFydCBibHVyIGNhbmNlbCBjYW5QbGF5IGNhblBsYXlUaHJvdWdoIGNsaWNrIGNsb3NlIGNvbnRleHRNZW51IGNvcHkgY3V0IGRvdWJsZUNsaWNrIGRyYWcgZHJhZ0VuZCBkcmFnRW50ZXIgZHJhZ0V4aXQgZHJhZ0xlYXZlIGRyYWdPdmVyIGRyYWdTdGFydCBkcm9wIGR1cmF0aW9uQ2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGZvY3VzIGlucHV0IGludmFsaWQga2V5RG93biBrZXlQcmVzcyBrZXlVcCBsb2FkIGxvYWRlZERhdGEgbG9hZGVkTWV0YWRhdGEgbG9hZFN0YXJ0IG1vdXNlRG93biBtb3VzZU1vdmUgbW91c2VPdXQgbW91c2VPdmVyIG1vdXNlVXAgcGFzdGUgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVDaGFuZ2UgcmVzZXQgc2Nyb2xsIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VibWl0IHN1c3BlbmQgdGltZVVwZGF0ZSB0b2dnbGUgdG91Y2hDYW5jZWwgdG91Y2hFbmQgdG91Y2hNb3ZlIHRvdWNoU3RhcnQgdHJhbnNpdGlvbkVuZCB2b2x1bWVDaGFuZ2Ugd2FpdGluZyB3aGVlbFwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF0udG9VcHBlckNhc2UoKStcbmEuc2xpY2UoMSksYz1cIm9uXCIrYjtiPVwidG9wXCIrYjtjPXtwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpjLGNhcHR1cmVkOmMrXCJDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbYl19O2RlW2FdPWM7ZWVbYl09Y30pO1xudmFyIGZlPXtldmVudFR5cGVzOmRlLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZWVbYV07aWYoIWUpcmV0dXJuIG51bGw7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKDA9PT1XZChjKSlyZXR1cm4gbnVsbDtjYXNlIFwidG9wS2V5RG93blwiOmNhc2UgXCJ0b3BLZXlVcFwiOmE9WmQ7YnJlYWs7Y2FzZSBcInRvcEJsdXJcIjpjYXNlIFwidG9wRm9jdXNcIjphPVZkO2JyZWFrO2Nhc2UgXCJ0b3BDbGlja1wiOmlmKDI9PT1jLmJ1dHRvbilyZXR1cm4gbnVsbDtjYXNlIFwidG9wRG91YmxlQ2xpY2tcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcE1vdXNlTW92ZVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6Y2FzZSBcInRvcE1vdXNlT3V0XCI6Y2FzZSBcInRvcE1vdXNlT3ZlclwiOmNhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmE9ZmQ7YnJlYWs7Y2FzZSBcInRvcERyYWdcIjpjYXNlIFwidG9wRHJhZ0VuZFwiOmNhc2UgXCJ0b3BEcmFnRW50ZXJcIjpjYXNlIFwidG9wRHJhZ0V4aXRcIjpjYXNlIFwidG9wRHJhZ0xlYXZlXCI6Y2FzZSBcInRvcERyYWdPdmVyXCI6Y2FzZSBcInRvcERyYWdTdGFydFwiOmNhc2UgXCJ0b3BEcm9wXCI6YT1cbiRkO2JyZWFrO2Nhc2UgXCJ0b3BUb3VjaENhbmNlbFwiOmNhc2UgXCJ0b3BUb3VjaEVuZFwiOmNhc2UgXCJ0b3BUb3VjaE1vdmVcIjpjYXNlIFwidG9wVG91Y2hTdGFydFwiOmE9YWU7YnJlYWs7Y2FzZSBcInRvcEFuaW1hdGlvbkVuZFwiOmNhc2UgXCJ0b3BBbmltYXRpb25JdGVyYXRpb25cIjpjYXNlIFwidG9wQW5pbWF0aW9uU3RhcnRcIjphPVRkO2JyZWFrO2Nhc2UgXCJ0b3BUcmFuc2l0aW9uRW5kXCI6YT1iZTticmVhaztjYXNlIFwidG9wU2Nyb2xsXCI6YT1iZDticmVhaztjYXNlIFwidG9wV2hlZWxcIjphPWNlO2JyZWFrO2Nhc2UgXCJ0b3BDb3B5XCI6Y2FzZSBcInRvcEN1dFwiOmNhc2UgXCJ0b3BQYXN0ZVwiOmE9VWQ7YnJlYWs7ZGVmYXVsdDphPVR9Yj1hLmdldFBvb2xlZChlLGIsYyxkKTtBYihiKTtyZXR1cm4gYn19O3NkPWZ1bmN0aW9uKGEsYixjLGQpe2E9amIoYSxiLGMsZCk7a2IoYSk7bGIoITEpfTtoYi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKFwiUmVzcG9uZGVyRXZlbnRQbHVnaW4gU2ltcGxlRXZlbnRQbHVnaW4gVGFwRXZlbnRQbHVnaW4gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIENoYW5nZUV2ZW50UGx1Z2luIFNlbGVjdEV2ZW50UGx1Z2luIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cIi5zcGxpdChcIiBcIikpO1xuV2E9c2IuZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTtYYT1zYi5nZXRJbnN0YW5jZUZyb21Ob2RlO1lhPXNiLmdldE5vZGVGcm9tSW5zdGFuY2U7aGIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtTaW1wbGVFdmVudFBsdWdpbjpmZSxFbnRlckxlYXZlRXZlbnRQbHVnaW46aGQsQ2hhbmdlRXZlbnRQbHVnaW46YWQsU2VsZWN0RXZlbnRQbHVnaW46U2QsQmVmb3JlSW5wdXRFdmVudFBsdWdpbjppY30pO3ZhciBnZT1bXSxoZT0tMTtmdW5jdGlvbiBWKGEpezA+aGV8fChhLmN1cnJlbnQ9Z2VbaGVdLGdlW2hlXT1udWxsLGhlLS0pfWZ1bmN0aW9uIFcoYSxiKXtoZSsrO2dlW2hlXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9bmV3IFNldDt2YXIgaWU9e2N1cnJlbnQ6RH0sWD17Y3VycmVudDohMX0samU9RDtmdW5jdGlvbiBrZShhKXtyZXR1cm4gbGUoYSk/amU6aWUuY3VycmVudH1cbmZ1bmN0aW9uIG1lKGEsYil7dmFyIGM9YS50eXBlLmNvbnRleHRUeXBlcztpZighYylyZXR1cm4gRDt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBsZShhKXtyZXR1cm4gMj09PWEudGFnJiZudWxsIT1hLnR5cGUuY2hpbGRDb250ZXh0VHlwZXN9ZnVuY3Rpb24gbmUoYSl7bGUoYSkmJihWKFgsYSksVihpZSxhKSl9XG5mdW5jdGlvbiBvZShhLGIsYyl7bnVsbCE9aWUuY3Vyc29yP0UoXCIxNjhcIik6dm9pZCAwO1coaWUsYixhKTtXKFgsYyxhKX1mdW5jdGlvbiBwZShhLGIpe3ZhciBjPWEuc3RhdGVOb2RlLGQ9YS50eXBlLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjLmdldENoaWxkQ29udGV4dClyZXR1cm4gYjtjPWMuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGMpZSBpbiBkP3ZvaWQgMDpFKFwiMTA4XCIsamQoYSl8fFwiVW5rbm93blwiLGUpO3JldHVybiBCKHt9LGIsYyl9ZnVuY3Rpb24gcWUoYSl7aWYoIWxlKGEpKXJldHVybiExO3ZhciBiPWEuc3RhdGVOb2RlO2I9YiYmYi5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8RDtqZT1pZS5jdXJyZW50O1coaWUsYixhKTtXKFgsWC5jdXJyZW50LGEpO3JldHVybiEwfVxuZnVuY3Rpb24gcmUoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZTtjP3ZvaWQgMDpFKFwiMTY5XCIpO2lmKGIpe3ZhciBkPXBlKGEsamUpO2MuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9ZDtWKFgsYSk7VihpZSxhKTtXKGllLGQsYSl9ZWxzZSBWKFgsYSk7VyhYLGIsYSl9XG5mdW5jdGlvbiBZKGEsYixjKXt0aGlzLnRhZz1hO3RoaXMua2V5PWI7dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPW51bGw7dGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpc1tcInJldHVyblwiXT1udWxsO3RoaXMuaW5kZXg9MDt0aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9dGhpcy5wZW5kaW5nUHJvcHM9dGhpcy5yZWY9bnVsbDt0aGlzLmludGVybmFsQ29udGV4dFRhZz1jO3RoaXMuZWZmZWN0VGFnPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5leHBpcmF0aW9uVGltZT0wO3RoaXMuYWx0ZXJuYXRlPW51bGx9XG5mdW5jdGlvbiBzZShhLGIsYyl7dmFyIGQ9YS5hbHRlcm5hdGU7bnVsbD09PWQ/KGQ9bmV3IFkoYS50YWcsYS5rZXksYS5pbnRlcm5hbENvbnRleHRUYWcpLGQudHlwZT1hLnR5cGUsZC5zdGF0ZU5vZGU9YS5zdGF0ZU5vZGUsZC5hbHRlcm5hdGU9YSxhLmFsdGVybmF0ZT1kKTooZC5lZmZlY3RUYWc9MCxkLm5leHRFZmZlY3Q9bnVsbCxkLmZpcnN0RWZmZWN0PW51bGwsZC5sYXN0RWZmZWN0PW51bGwpO2QuZXhwaXJhdGlvblRpbWU9YztkLnBlbmRpbmdQcm9wcz1iO2QuY2hpbGQ9YS5jaGlsZDtkLm1lbW9pemVkUHJvcHM9YS5tZW1vaXplZFByb3BzO2QubWVtb2l6ZWRTdGF0ZT1hLm1lbW9pemVkU3RhdGU7ZC51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlO2Quc2libGluZz1hLnNpYmxpbmc7ZC5pbmRleD1hLmluZGV4O2QucmVmPWEucmVmO3JldHVybiBkfVxuZnVuY3Rpb24gdGUoYSxiLGMpe3ZhciBkPXZvaWQgMCxlPWEudHlwZSxmPWEua2V5O1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlPyhkPWUucHJvdG90eXBlJiZlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50P25ldyBZKDIsZixiKTpuZXcgWSgwLGYsYiksZC50eXBlPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJzdHJpbmdcIj09PXR5cGVvZiBlPyhkPW5ldyBZKDUsZixiKSxkLnR5cGU9ZSxkLnBlbmRpbmdQcm9wcz1hLnByb3BzKTpcIm9iamVjdFwiPT09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm51bWJlclwiPT09dHlwZW9mIGUudGFnPyhkPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6RShcIjEzMFwiLG51bGw9PWU/ZTp0eXBlb2YgZSxcIlwiKTtkLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGR9ZnVuY3Rpb24gdWUoYSxiLGMsZCl7Yj1uZXcgWSgxMCxkLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifVxuZnVuY3Rpb24gdmUoYSxiLGMpe2I9bmV3IFkoNixudWxsLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifWZ1bmN0aW9uIHdlKGEsYixjKXtiPW5ldyBZKDcsYS5rZXksYik7Yi50eXBlPWEuaGFuZGxlcjtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1mdW5jdGlvbiB4ZShhLGIsYyl7YT1uZXcgWSg5LG51bGwsYik7YS5leHBpcmF0aW9uVGltZT1jO3JldHVybiBhfWZ1bmN0aW9uIHllKGEsYixjKXtiPW5ldyBZKDQsYS5rZXksYik7Yi5wZW5kaW5nUHJvcHM9YS5jaGlsZHJlbnx8W107Yi5leHBpcmF0aW9uVGltZT1jO2Iuc3RhdGVOb2RlPXtjb250YWluZXJJbmZvOmEuY29udGFpbmVySW5mbyxwZW5kaW5nQ2hpbGRyZW46bnVsbCxpbXBsZW1lbnRhdGlvbjphLmltcGxlbWVudGF0aW9ufTtyZXR1cm4gYn12YXIgemU9bnVsbCxBZT1udWxsO1xuZnVuY3Rpb24gQmUoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3RyeXtyZXR1cm4gYShiKX1jYXRjaChjKXt9fX1mdW5jdGlvbiBDZShhKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXylyZXR1cm4hMTt2YXIgYj1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoYi5pc0Rpc2FibGVkfHwhYi5zdXBwb3J0c0ZpYmVyKXJldHVybiEwO3RyeXt2YXIgYz1iLmluamVjdChhKTt6ZT1CZShmdW5jdGlvbihhKXtyZXR1cm4gYi5vbkNvbW1pdEZpYmVyUm9vdChjLGEpfSk7QWU9QmUoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclVubW91bnQoYyxhKX0pfWNhdGNoKGQpe31yZXR1cm4hMH1mdW5jdGlvbiBEZShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgemUmJnplKGEpfWZ1bmN0aW9uIEVlKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiBBZSYmQWUoYSl9XG5mdW5jdGlvbiBGZShhKXtyZXR1cm57YmFzZVN0YXRlOmEsZXhwaXJhdGlvblRpbWU6MCxmaXJzdDpudWxsLGxhc3Q6bnVsbCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMSxpc0luaXRpYWxpemVkOiExfX1mdW5jdGlvbiBHZShhLGIpe251bGw9PT1hLmxhc3Q/YS5maXJzdD1hLmxhc3Q9YjooYS5sYXN0Lm5leHQ9YixhLmxhc3Q9Yik7aWYoMD09PWEuZXhwaXJhdGlvblRpbWV8fGEuZXhwaXJhdGlvblRpbWU+Yi5leHBpcmF0aW9uVGltZSlhLmV4cGlyYXRpb25UaW1lPWIuZXhwaXJhdGlvblRpbWV9XG5mdW5jdGlvbiBIZShhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlLGQ9YS51cGRhdGVRdWV1ZTtudWxsPT09ZCYmKGQ9YS51cGRhdGVRdWV1ZT1GZShudWxsKSk7bnVsbCE9PWM/KGE9Yy51cGRhdGVRdWV1ZSxudWxsPT09YSYmKGE9Yy51cGRhdGVRdWV1ZT1GZShudWxsKSkpOmE9bnVsbDthPWEhPT1kP2E6bnVsbDtudWxsPT09YT9HZShkLGIpOm51bGw9PT1kLmxhc3R8fG51bGw9PT1hLmxhc3Q/KEdlKGQsYiksR2UoYSxiKSk6KEdlKGQsYiksYS5sYXN0PWIpfWZ1bmN0aW9uIEllKGEsYixjLGQpe2E9YS5wYXJ0aWFsU3RhdGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YS5jYWxsKGIsYyxkKTphfVxuZnVuY3Rpb24gSmUoYSxiLGMsZCxlLGYpe251bGwhPT1hJiZhLnVwZGF0ZVF1ZXVlPT09YyYmKGM9Yi51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmMuYmFzZVN0YXRlLGV4cGlyYXRpb25UaW1lOmMuZXhwaXJhdGlvblRpbWUsZmlyc3Q6Yy5maXJzdCxsYXN0OmMubGFzdCxpc0luaXRpYWxpemVkOmMuaXNJbml0aWFsaXplZCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMX0pO2MuZXhwaXJhdGlvblRpbWU9MDtjLmlzSW5pdGlhbGl6ZWQ/YT1jLmJhc2VTdGF0ZTooYT1jLmJhc2VTdGF0ZT1iLm1lbW9pemVkU3RhdGUsYy5pc0luaXRpYWxpemVkPSEwKTtmb3IodmFyIGc9ITAsaD1jLmZpcnN0LGs9ITE7bnVsbCE9PWg7KXt2YXIgcT1oLmV4cGlyYXRpb25UaW1lO2lmKHE+Zil7dmFyIHY9Yy5leHBpcmF0aW9uVGltZTtpZigwPT09dnx8dj5xKWMuZXhwaXJhdGlvblRpbWU9cTtrfHwoaz0hMCxjLmJhc2VTdGF0ZT1hKX1lbHNle2t8fChjLmZpcnN0PWgubmV4dCxudWxsPT09XG5jLmZpcnN0JiYoYy5sYXN0PW51bGwpKTtpZihoLmlzUmVwbGFjZSlhPUllKGgsZCxhLGUpLGc9ITA7ZWxzZSBpZihxPUllKGgsZCxhLGUpKWE9Zz9CKHt9LGEscSk6QihhLHEpLGc9ITE7aC5pc0ZvcmNlZCYmKGMuaGFzRm9yY2VVcGRhdGU9ITApO251bGwhPT1oLmNhbGxiYWNrJiYocT1jLmNhbGxiYWNrTGlzdCxudWxsPT09cSYmKHE9Yy5jYWxsYmFja0xpc3Q9W10pLHEucHVzaChoKSl9aD1oLm5leHR9bnVsbCE9PWMuY2FsbGJhY2tMaXN0P2IuZWZmZWN0VGFnfD0zMjpudWxsIT09Yy5maXJzdHx8Yy5oYXNGb3JjZVVwZGF0ZXx8KGIudXBkYXRlUXVldWU9bnVsbCk7a3x8KGMuYmFzZVN0YXRlPWEpO3JldHVybiBhfVxuZnVuY3Rpb24gS2UoYSxiKXt2YXIgYz1hLmNhbGxiYWNrTGlzdDtpZihudWxsIT09Yylmb3IoYS5jYWxsYmFja0xpc3Q9bnVsbCxhPTA7YTxjLmxlbmd0aDthKyspe3ZhciBkPWNbYV0sZT1kLmNhbGxiYWNrO2QuY2FsbGJhY2s9bnVsbDtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZT9FKFwiMTkxXCIsZSk6dm9pZCAwO2UuY2FsbChiKX19XG5mdW5jdGlvbiBMZShhLGIsYyxkKXtmdW5jdGlvbiBlKGEsYil7Yi51cGRhdGVyPWY7YS5zdGF0ZU5vZGU9YjtiLl9yZWFjdEludGVybmFsRmliZXI9YX12YXIgZj17aXNNb3VudGVkOmxkLGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihjLGQsZSl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZz1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmcscGFydGlhbFN0YXRlOmQsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGcpfSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGMsZCxlKXtjPWMuX3JlYWN0SW50ZXJuYWxGaWJlcjtlPXZvaWQgMD09PWU/bnVsbDplO3ZhciBnPWIoYyk7SGUoYyx7ZXhwaXJhdGlvblRpbWU6ZyxwYXJ0aWFsU3RhdGU6ZCxjYWxsYmFjazplLGlzUmVwbGFjZTohMCxpc0ZvcmNlZDohMSxuZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtcbmEoYyxnKX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGMsZCl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZD12b2lkIDA9PT1kP251bGw6ZDt2YXIgZT1iKGMpO0hlKGMse2V4cGlyYXRpb25UaW1lOmUscGFydGlhbFN0YXRlOm51bGwsY2FsbGJhY2s6ZCxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITAsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGUpfX07cmV0dXJue2Fkb3B0Q2xhc3NJbnN0YW5jZTplLGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnR5cGUsZD1rZShhKSxmPTI9PT1hLnRhZyYmbnVsbCE9YS50eXBlLmNvbnRleHRUeXBlcyxnPWY/bWUoYSxkKTpEO2I9bmV3IGMoYixnKTtlKGEsYik7ZiYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWQsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1nKTtyZXR1cm4gYn0sbW91bnRDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsXG5iKXt2YXIgYz1hLmFsdGVybmF0ZSxkPWEuc3RhdGVOb2RlLGU9ZC5zdGF0ZXx8bnVsbCxnPWEucGVuZGluZ1Byb3BzO2c/dm9pZCAwOkUoXCIxNThcIik7dmFyIGg9a2UoYSk7ZC5wcm9wcz1nO2Quc3RhdGU9YS5tZW1vaXplZFN0YXRlPWU7ZC5yZWZzPUQ7ZC5jb250ZXh0PW1lKGEsaCk7bnVsbCE9YS50eXBlJiZudWxsIT1hLnR5cGUucHJvdG90eXBlJiYhMD09PWEudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50JiYoYS5pbnRlcm5hbENvbnRleHRUYWd8PTEpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxNb3VudCYmKGU9ZC5zdGF0ZSxkLmNvbXBvbmVudFdpbGxNb3VudCgpLGUhPT1kLnN0YXRlJiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZCxkLnN0YXRlLG51bGwpLGU9YS51cGRhdGVRdWV1ZSxudWxsIT09ZSYmKGQuc3RhdGU9SmUoYyxhLGUsZCxnLGIpKSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkTW91bnQmJihhLmVmZmVjdFRhZ3w9XG40KX0sdXBkYXRlQ2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLGIsZSl7dmFyIGc9Yi5zdGF0ZU5vZGU7Zy5wcm9wcz1iLm1lbW9pemVkUHJvcHM7Zy5zdGF0ZT1iLm1lbW9pemVkU3RhdGU7dmFyIGg9Yi5tZW1vaXplZFByb3BzLGs9Yi5wZW5kaW5nUHJvcHM7a3x8KGs9aCxudWxsPT1rP0UoXCIxNTlcIik6dm9pZCAwKTt2YXIgdT1nLmNvbnRleHQsej1rZShiKTt6PW1lKGIseik7XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8aD09PWsmJnU9PT16fHwodT1nLnN0YXRlLGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhrLHopLGcuc3RhdGUhPT11JiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZyxnLnN0YXRlLG51bGwpKTt1PWIubWVtb2l6ZWRTdGF0ZTtlPW51bGwhPT1iLnVwZGF0ZVF1ZXVlP0plKGEsYixiLnVwZGF0ZVF1ZXVlLGcsayxlKTp1O2lmKCEoaCE9PWt8fHUhPT1lfHxYLmN1cnJlbnR8fG51bGwhPT1iLnVwZGF0ZVF1ZXVlJiZiLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSlyZXR1cm5cImZ1bmN0aW9uXCIhPT1cbnR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8aD09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSwhMTt2YXIgRz1rO2lmKG51bGw9PT1ofHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSlHPSEwO2Vsc2V7dmFyIEk9Yi5zdGF0ZU5vZGUsTD1iLnR5cGU7Rz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgSS5zaG91bGRDb21wb25lbnRVcGRhdGU/SS5zaG91bGRDb21wb25lbnRVcGRhdGUoRyxlLHopOkwucHJvdG90eXBlJiZMLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudD8hZWEoaCxHKXx8IWVhKHUsZSk6ITB9Rz8oXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5jb21wb25lbnRXaWxsVXBkYXRlKGssZSx6KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmVmZmVjdFRhZ3w9NCkpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fFxuaD09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSxjKGIsayksZChiLGUpKTtnLnByb3BzPWs7Zy5zdGF0ZT1lO2cuY29udGV4dD16O3JldHVybiBHfX19dmFyIFFlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSxSZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5lbGVtZW50XCIpOjYwMTAzLFNlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmNhbGxcIik6NjAxMDQsVGU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucmV0dXJuXCIpOjYwMTA1LFVlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LnBvcnRhbFwiKTo2MDEwNixWZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKTo2MDEwNyxXZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3I7XG5mdW5jdGlvbiBYZShhKXtpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVybiBudWxsO2E9V2UmJmFbV2VdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9dmFyIFllPUFycmF5LmlzQXJyYXk7XG5mdW5jdGlvbiBaZShhLGIpe3ZhciBjPWIucmVmO2lmKG51bGwhPT1jJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYyl7aWYoYi5fb3duZXIpe2I9Yi5fb3duZXI7dmFyIGQ9dm9pZCAwO2ImJigyIT09Yi50YWc/RShcIjExMFwiKTp2b2lkIDAsZD1iLnN0YXRlTm9kZSk7ZD92b2lkIDA6RShcIjE0N1wiLGMpO3ZhciBlPVwiXCIrYztpZihudWxsIT09YSYmbnVsbCE9PWEucmVmJiZhLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYS5yZWY7YT1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM9PT1EP2QucmVmcz17fTpkLnJlZnM7bnVsbD09PWE/ZGVsZXRlIGJbZV06YltlXT1hfTthLl9zdHJpbmdSZWY9ZTtyZXR1cm4gYX1cInN0cmluZ1wiIT09dHlwZW9mIGM/RShcIjE0OFwiKTp2b2lkIDA7Yi5fb3duZXI/dm9pZCAwOkUoXCIxNDlcIixjKX1yZXR1cm4gY31cbmZ1bmN0aW9uICRlKGEsYil7XCJ0ZXh0YXJlYVwiIT09YS50eXBlJiZFKFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYikuam9pbihcIiwgXCIpK1wifVwiOmIsXCJcIil9XG5mdW5jdGlvbiBhZihhKXtmdW5jdGlvbiBiKGIsYyl7aWYoYSl7dmFyIGQ9Yi5sYXN0RWZmZWN0O251bGwhPT1kPyhkLm5leHRFZmZlY3Q9YyxiLmxhc3RFZmZlY3Q9Yyk6Yi5maXJzdEVmZmVjdD1iLmxhc3RFZmZlY3Q9YztjLm5leHRFZmZlY3Q9bnVsbDtjLmVmZmVjdFRhZz04fX1mdW5jdGlvbiBjKGMsZCl7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKDtudWxsIT09ZDspYihjLGQpLGQ9ZC5zaWJsaW5nO3JldHVybiBudWxsfWZ1bmN0aW9uIGQoYSxiKXtmb3IoYT1uZXcgTWFwO251bGwhPT1iOyludWxsIT09Yi5rZXk/YS5zZXQoYi5rZXksYik6YS5zZXQoYi5pbmRleCxiKSxiPWIuc2libGluZztyZXR1cm4gYX1mdW5jdGlvbiBlKGEsYixjKXthPXNlKGEsYixjKTthLmluZGV4PTA7YS5zaWJsaW5nPW51bGw7cmV0dXJuIGF9ZnVuY3Rpb24gZihiLGMsZCl7Yi5pbmRleD1kO2lmKCFhKXJldHVybiBjO2Q9Yi5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGIuZWZmZWN0VGFnPVxuMixjKTpkO2IuZWZmZWN0VGFnPTI7cmV0dXJuIGN9ZnVuY3Rpb24gZyhiKXthJiZudWxsPT09Yi5hbHRlcm5hdGUmJihiLmVmZmVjdFRhZz0yKTtyZXR1cm4gYn1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9dmUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiBrKGEsYixjLGQpe2lmKG51bGwhPT1iJiZiLnR5cGU9PT1jLnR5cGUpcmV0dXJuIGQ9ZShiLGMucHJvcHMsZCksZC5yZWY9WmUoYixjKSxkW1wicmV0dXJuXCJdPWEsZDtkPXRlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCk7ZC5yZWY9WmUoYixjKTtkW1wicmV0dXJuXCJdPWE7cmV0dXJuIGR9ZnVuY3Rpb24gcShhLGIsYyxkKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPXdlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtcbmJbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB2KGEsYixjLGQpe2lmKG51bGw9PT1ifHw5IT09Yi50YWcpcmV0dXJuIGI9eGUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiLnR5cGU9Yy52YWx1ZSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixudWxsLGQpO2IudHlwZT1jLnZhbHVlO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB5KGEsYixjLGQpe2lmKG51bGw9PT1ifHw0IT09Yi50YWd8fGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1jLmNvbnRhaW5lckluZm98fGIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09Yy5pbXBsZW1lbnRhdGlvbilyZXR1cm4gYj15ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMuY2hpbGRyZW58fFtdLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB1KGEsYixjLGQsZil7aWYobnVsbD09PWJ8fDEwIT09Yi50YWcpcmV0dXJuIGI9dWUoYyxhLmludGVybmFsQ29udGV4dFRhZyxcbmQsZiksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24geihhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9dmUoXCJcIitiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxiO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWIpe3N3aXRjaChiLiQkdHlwZW9mKXtjYXNlIFJlOmlmKGIudHlwZT09PVZlKXJldHVybiBiPXVlKGIucHJvcHMuY2hpbGRyZW4sYS5pbnRlcm5hbENvbnRleHRUYWcsYyxiLmtleSksYltcInJldHVyblwiXT1hLGI7Yz10ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpO2MucmVmPVplKG51bGwsYik7Y1tcInJldHVyblwiXT1hO3JldHVybiBjO2Nhc2UgU2U6cmV0dXJuIGI9d2UoYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYjtjYXNlIFRlOnJldHVybiBjPXhlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsXG5jKSxjLnR5cGU9Yi52YWx1ZSxjW1wicmV0dXJuXCJdPWEsYztjYXNlIFVlOnJldHVybiBiPXllKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGJ9aWYoWWUoYil8fFhlKGIpKXJldHVybiBiPXVlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyxudWxsKSxiW1wicmV0dXJuXCJdPWEsYjskZShhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIEcoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgUmU6cmV0dXJuIGMua2V5PT09ZT9jLnR5cGU9PT1WZT91KGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6ayhhLGIsYyxkKTpudWxsO2Nhc2UgU2U6cmV0dXJuIGMua2V5PT09ZT9xKGEsYixjLGQpOm51bGw7Y2FzZSBUZTpyZXR1cm4gbnVsbD09PVxuZT92KGEsYixjLGQpOm51bGw7Y2FzZSBVZTpyZXR1cm4gYy5rZXk9PT1lP3koYSxiLGMsZCk6bnVsbH1pZihZZShjKXx8WGUoYykpcmV0dXJuIG51bGwhPT1lP251bGw6dShhLGIsYyxkLG51bGwpOyRlKGEsYyl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gSShhLGIsYyxkLGUpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgZHx8XCJudW1iZXJcIj09PXR5cGVvZiBkKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBSZTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09VmU/dShiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTprKGIsYSxkLGUpO2Nhc2UgU2U6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLHEoYixhLGQsZSk7Y2FzZSBUZTpyZXR1cm4gYT1hLmdldChjKXx8bnVsbCx2KGIsYSxkLGUpO2Nhc2UgVWU6cmV0dXJuIGE9XG5hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwseShiLGEsZCxlKX1pZihZZShkKXx8WGUoZCkpcmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsdShiLGEsZCxlLG51bGwpOyRlKGIsZCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gTChlLGcsbSxBKXtmb3IodmFyIGg9bnVsbCxyPW51bGwsbj1nLHc9Zz0wLGs9bnVsbDtudWxsIT09biYmdzxtLmxlbmd0aDt3Kyspe24uaW5kZXg+dz8oaz1uLG49bnVsbCk6az1uLnNpYmxpbmc7dmFyIHg9RyhlLG4sbVt3XSxBKTtpZihudWxsPT09eCl7bnVsbD09PW4mJihuPWspO2JyZWFrfWEmJm4mJm51bGw9PT14LmFsdGVybmF0ZSYmYihlLG4pO2c9Zih4LGcsdyk7bnVsbD09PXI/aD14OnIuc2libGluZz14O3I9eDtuPWt9aWYodz09PW0ubGVuZ3RoKXJldHVybiBjKGUsbiksaDtpZihudWxsPT09bil7Zm9yKDt3PG0ubGVuZ3RoO3crKylpZihuPXooZSxtW3ddLEEpKWc9ZihuLGcsdyksbnVsbD09PXI/aD1uOnIuc2libGluZz1uLHI9bjtyZXR1cm4gaH1mb3Iobj1cbmQoZSxuKTt3PG0ubGVuZ3RoO3crKylpZihrPUkobixlLHcsbVt3XSxBKSl7aWYoYSYmbnVsbCE9PWsuYWx0ZXJuYXRlKW5bXCJkZWxldGVcIl0obnVsbD09PWsua2V5P3c6ay5rZXkpO2c9ZihrLGcsdyk7bnVsbD09PXI/aD1rOnIuc2libGluZz1rO3I9a31hJiZuLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIoZSxhKX0pO3JldHVybiBofWZ1bmN0aW9uIE4oZSxnLG0sQSl7dmFyIGg9WGUobSk7XCJmdW5jdGlvblwiIT09dHlwZW9mIGg/RShcIjE1MFwiKTp2b2lkIDA7bT1oLmNhbGwobSk7bnVsbD09bT9FKFwiMTUxXCIpOnZvaWQgMDtmb3IodmFyIHI9aD1udWxsLG49Zyx3PWc9MCxrPW51bGwseD1tLm5leHQoKTtudWxsIT09biYmIXguZG9uZTt3KysseD1tLm5leHQoKSl7bi5pbmRleD53PyhrPW4sbj1udWxsKTprPW4uc2libGluZzt2YXIgSj1HKGUsbix4LnZhbHVlLEEpO2lmKG51bGw9PT1KKXtufHwobj1rKTticmVha31hJiZuJiZudWxsPT09Si5hbHRlcm5hdGUmJmIoZSxuKTtnPWYoSixcbmcsdyk7bnVsbD09PXI/aD1KOnIuc2libGluZz1KO3I9SjtuPWt9aWYoeC5kb25lKXJldHVybiBjKGUsbiksaDtpZihudWxsPT09bil7Zm9yKDsheC5kb25lO3crKyx4PW0ubmV4dCgpKXg9eihlLHgudmFsdWUsQSksbnVsbCE9PXgmJihnPWYoeCxnLHcpLG51bGw9PT1yP2g9eDpyLnNpYmxpbmc9eCxyPXgpO3JldHVybiBofWZvcihuPWQoZSxuKTsheC5kb25lO3crKyx4PW0ubmV4dCgpKWlmKHg9SShuLGUsdyx4LnZhbHVlLEEpLG51bGwhPT14KXtpZihhJiZudWxsIT09eC5hbHRlcm5hdGUpbltcImRlbGV0ZVwiXShudWxsPT09eC5rZXk/dzp4LmtleSk7Zz1mKHgsZyx3KTtudWxsPT09cj9oPXg6ci5zaWJsaW5nPXg7cj14fWEmJm4uZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGh9cmV0dXJuIGZ1bmN0aW9uKGEsZCxmLGgpe1wib2JqZWN0XCI9PT10eXBlb2YgZiYmbnVsbCE9PWYmJmYudHlwZT09PVZlJiZudWxsPT09Zi5rZXkmJihmPWYucHJvcHMuY2hpbGRyZW4pO1xudmFyIG09XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09ZjtpZihtKXN3aXRjaChmLiQkdHlwZW9mKXtjYXNlIFJlOmE6e3ZhciByPWYua2V5O2ZvcihtPWQ7bnVsbCE9PW07KXtpZihtLmtleT09PXIpaWYoMTA9PT1tLnRhZz9mLnR5cGU9PT1WZTptLnR5cGU9PT1mLnR5cGUpe2MoYSxtLnNpYmxpbmcpO2Q9ZShtLGYudHlwZT09PVZlP2YucHJvcHMuY2hpbGRyZW46Zi5wcm9wcyxoKTtkLnJlZj1aZShtLGYpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxtKTticmVha31lbHNlIGIoYSxtKTttPW0uc2libGluZ31mLnR5cGU9PT1WZT8oZD11ZShmLnByb3BzLmNoaWxkcmVuLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgsZi5rZXkpLGRbXCJyZXR1cm5cIl09YSxhPWQpOihoPXRlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCksaC5yZWY9WmUoZCxmKSxoW1wicmV0dXJuXCJdPWEsYT1oKX1yZXR1cm4gZyhhKTtjYXNlIFNlOmE6e2ZvcihtPWYua2V5O251bGwhPT1kOyl7aWYoZC5rZXk9PT1cbm0paWYoNz09PWQudGFnKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLGgpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxkKTticmVha31lbHNlIGIoYSxkKTtkPWQuc2libGluZ31kPXdlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7ZFtcInJldHVyblwiXT1hO2E9ZH1yZXR1cm4gZyhhKTtjYXNlIFRlOmE6e2lmKG51bGwhPT1kKWlmKDk9PT1kLnRhZyl7YyhhLGQuc2libGluZyk7ZD1lKGQsbnVsbCxoKTtkLnR5cGU9Zi52YWx1ZTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZSBjKGEsZCk7ZD14ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2QudHlwZT1mLnZhbHVlO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSk7Y2FzZSBVZTphOntmb3IobT1mLmtleTtudWxsIT09ZDspe2lmKGQua2V5PT09bSlpZig0PT09ZC50YWcmJmQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm89PT1mLmNvbnRhaW5lckluZm8mJmQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uPT09XG5mLmltcGxlbWVudGF0aW9uKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxmLmNoaWxkcmVufHxbXSxoKTtkW1wicmV0dXJuXCJdPWE7YT1kO2JyZWFrIGF9ZWxzZXtjKGEsZCk7YnJlYWt9ZWxzZSBiKGEsZCk7ZD1kLnNpYmxpbmd9ZD15ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpO2RbXCJyZXR1cm5cIl09YTthPWR9cmV0dXJuIGcoYSl9aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBmfHxcIm51bWJlclwiPT09dHlwZW9mIGYpcmV0dXJuIGY9XCJcIitmLG51bGwhPT1kJiY2PT09ZC50YWc/KGMoYSxkLnNpYmxpbmcpLGQ9ZShkLGYsaCkpOihjKGEsZCksZD12ZShmLGEuaW50ZXJuYWxDb250ZXh0VGFnLGgpKSxkW1wicmV0dXJuXCJdPWEsYT1kLGcoYSk7aWYoWWUoZikpcmV0dXJuIEwoYSxkLGYsaCk7aWYoWGUoZikpcmV0dXJuIE4oYSxkLGYsaCk7bSYmJGUoYSxmKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGYpc3dpdGNoKGEudGFnKXtjYXNlIDI6Y2FzZSAxOmg9YS50eXBlLEUoXCIxNTJcIixoLmRpc3BsYXlOYW1lfHxcbmgubmFtZXx8XCJDb21wb25lbnRcIil9cmV0dXJuIGMoYSxkKX19dmFyIGJmPWFmKCEwKSxjZj1hZighMSk7XG5mdW5jdGlvbiBkZihhLGIsYyxkLGUpe2Z1bmN0aW9uIGYoYSxiLGMpe3ZhciBkPWIuZXhwaXJhdGlvblRpbWU7Yi5jaGlsZD1udWxsPT09YT9jZihiLG51bGwsYyxkKTpiZihiLGEuY2hpbGQsYyxkKX1mdW5jdGlvbiBnKGEsYil7dmFyIGM9Yi5yZWY7bnVsbD09PWN8fGEmJmEucmVmPT09Y3x8KGIuZWZmZWN0VGFnfD0xMjgpfWZ1bmN0aW9uIGgoYSxiLGMsZCl7ZyhhLGIpO2lmKCFjKXJldHVybiBkJiZyZShiLCExKSxxKGEsYik7Yz1iLnN0YXRlTm9kZTtpZC5jdXJyZW50PWI7dmFyIGU9Yy5yZW5kZXIoKTtiLmVmZmVjdFRhZ3w9MTtmKGEsYixlKTtiLm1lbW9pemVkU3RhdGU9Yy5zdGF0ZTtiLm1lbW9pemVkUHJvcHM9Yy5wcm9wcztkJiZyZShiLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiBrKGEpe3ZhciBiPWEuc3RhdGVOb2RlO2IucGVuZGluZ0NvbnRleHQ/b2UoYSxiLnBlbmRpbmdDb250ZXh0LGIucGVuZGluZ0NvbnRleHQhPT1iLmNvbnRleHQpOmIuY29udGV4dCYmb2UoYSxcbmIuY29udGV4dCwhMSk7SShhLGIuY29udGFpbmVySW5mbyl9ZnVuY3Rpb24gcShhLGIpe251bGwhPT1hJiZiLmNoaWxkIT09YS5jaGlsZD9FKFwiMTUzXCIpOnZvaWQgMDtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO3ZhciBjPXNlKGEsYS5wZW5kaW5nUHJvcHMsYS5leHBpcmF0aW9uVGltZSk7Yi5jaGlsZD1jO2ZvcihjW1wicmV0dXJuXCJdPWI7bnVsbCE9PWEuc2libGluZzspYT1hLnNpYmxpbmcsYz1jLnNpYmxpbmc9c2UoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKSxjW1wicmV0dXJuXCJdPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gdihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAzOmsoYik7YnJlYWs7Y2FzZSAyOnFlKGIpO2JyZWFrO2Nhc2UgNDpJKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyl9cmV0dXJuIG51bGx9dmFyIHk9YS5zaG91bGRTZXRUZXh0Q29udGVudCx1PWEudXNlU3luY1NjaGVkdWxpbmcsej1hLnNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUsXG5HPWIucHVzaEhvc3RDb250ZXh0LEk9Yi5wdXNoSG9zdENvbnRhaW5lcixMPWMuZW50ZXJIeWRyYXRpb25TdGF0ZSxOPWMucmVzZXRIeWRyYXRpb25TdGF0ZSxKPWMudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7YT1MZShkLGUsZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkUHJvcHM9Yn0sZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkU3RhdGU9Yn0pO3ZhciB3PWEuYWRvcHRDbGFzc0luc3RhbmNlLG09YS5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLEE9YS5tb3VudENsYXNzSW5zdGFuY2UsT2I9YS51cGRhdGVDbGFzc0luc3RhbmNlO3JldHVybntiZWdpbldvcms6ZnVuY3Rpb24oYSxiLGMpe2lmKDA9PT1iLmV4cGlyYXRpb25UaW1lfHxiLmV4cGlyYXRpb25UaW1lPmMpcmV0dXJuIHYoYSxiKTtzd2l0Y2goYi50YWcpe2Nhc2UgMDpudWxsIT09YT9FKFwiMTU1XCIpOnZvaWQgMDt2YXIgZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxyPWtlKGIpO3I9bWUoYixyKTtkPWQoZSxyKTtiLmVmZmVjdFRhZ3w9XG4xO1wib2JqZWN0XCI9PT10eXBlb2YgZCYmbnVsbCE9PWQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLnJlbmRlcj8oYi50YWc9MixlPXFlKGIpLHcoYixkKSxBKGIsYyksYj1oKGEsYiwhMCxlKSk6KGIudGFnPTEsZihhLGIsZCksYi5tZW1vaXplZFByb3BzPWUsYj1iLmNoaWxkKTtyZXR1cm4gYjtjYXNlIDE6YTp7ZT1iLnR5cGU7Yz1iLnBlbmRpbmdQcm9wcztkPWIubWVtb2l6ZWRQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWMmJihjPWQpO2Vsc2UgaWYobnVsbD09PWN8fGQ9PT1jKXtiPXEoYSxiKTticmVhayBhfWQ9a2UoYik7ZD1tZShiLGQpO2U9ZShjLGQpO2IuZWZmZWN0VGFnfD0xO2YoYSxiLGUpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDI6cmV0dXJuIGU9cWUoYiksZD12b2lkIDAsbnVsbD09PWE/Yi5zdGF0ZU5vZGU/RShcIjE1M1wiKToobShiLGIucGVuZGluZ1Byb3BzKSxBKGIsYyksZD0hMCk6ZD1PYihhLGIsYyksaChhLGIsZCxlKTtjYXNlIDM6cmV0dXJuIGsoYiksXG5lPWIudXBkYXRlUXVldWUsbnVsbCE9PWU/KGQ9Yi5tZW1vaXplZFN0YXRlLGU9SmUoYSxiLGUsbnVsbCxudWxsLGMpLGQ9PT1lPyhOKCksYj1xKGEsYikpOihkPWUuZWxlbWVudCxyPWIuc3RhdGVOb2RlLChudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpJiZyLmh5ZHJhdGUmJkwoYik/KGIuZWZmZWN0VGFnfD0yLGIuY2hpbGQ9Y2YoYixudWxsLGQsYykpOihOKCksZihhLGIsZCkpLGIubWVtb2l6ZWRTdGF0ZT1lLGI9Yi5jaGlsZCkpOihOKCksYj1xKGEsYikpLGI7Y2FzZSA1OkcoYik7bnVsbD09PWEmJkooYik7ZT1iLnR5cGU7dmFyIG49Yi5tZW1vaXplZFByb3BzO2Q9Yi5wZW5kaW5nUHJvcHM7bnVsbD09PWQmJihkPW4sbnVsbD09PWQ/RShcIjE1NFwiKTp2b2lkIDApO3I9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOm51bGw7WC5jdXJyZW50fHxudWxsIT09ZCYmbiE9PWQ/KG49ZC5jaGlsZHJlbix5KGUsZCk/bj1udWxsOnImJnkoZSxyKSYmKGIuZWZmZWN0VGFnfD0xNiksZyhhLGIpLFxuMjE0NzQ4MzY0NyE9PWMmJiF1JiZ6KGUsZCk/KGIuZXhwaXJhdGlvblRpbWU9MjE0NzQ4MzY0NyxiPW51bGwpOihmKGEsYixuKSxiLm1lbW9pemVkUHJvcHM9ZCxiPWIuY2hpbGQpKTpiPXEoYSxiKTtyZXR1cm4gYjtjYXNlIDY6cmV0dXJuIG51bGw9PT1hJiZKKGIpLGE9Yi5wZW5kaW5nUHJvcHMsbnVsbD09PWEmJihhPWIubWVtb2l6ZWRQcm9wcyksYi5tZW1vaXplZFByb3BzPWEsbnVsbDtjYXNlIDg6Yi50YWc9NztjYXNlIDc6ZT1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWUmJihlPWEmJmEubWVtb2l6ZWRQcm9wcyxudWxsPT09ZT9FKFwiMTU0XCIpOnZvaWQgMCk7ZWxzZSBpZihudWxsPT09ZXx8Yi5tZW1vaXplZFByb3BzPT09ZSllPWIubWVtb2l6ZWRQcm9wcztkPWUuY2hpbGRyZW47Yi5zdGF0ZU5vZGU9bnVsbD09PWE/Y2YoYixiLnN0YXRlTm9kZSxkLGMpOmJmKGIsYi5zdGF0ZU5vZGUsZCxjKTtiLm1lbW9pemVkUHJvcHM9ZTtyZXR1cm4gYi5zdGF0ZU5vZGU7XG5jYXNlIDk6cmV0dXJuIG51bGw7Y2FzZSA0OmE6e0koYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtlPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09ZSYmKGU9YSYmYS5tZW1vaXplZFByb3BzLG51bGw9PWU/RShcIjE1NFwiKTp2b2lkIDApO2Vsc2UgaWYobnVsbD09PWV8fGIubWVtb2l6ZWRQcm9wcz09PWUpe2I9cShhLGIpO2JyZWFrIGF9bnVsbD09PWE/Yi5jaGlsZD1iZihiLG51bGwsZSxjKTpmKGEsYixlKTtiLm1lbW9pemVkUHJvcHM9ZTtiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSAxMDphOntjPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09YyYmKGM9Yi5tZW1vaXplZFByb3BzKTtlbHNlIGlmKG51bGw9PT1jfHxiLm1lbW9pemVkUHJvcHM9PT1jKXtiPXEoYSxiKTticmVhayBhfWYoYSxiLGMpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtkZWZhdWx0OkUoXCIxNTZcIil9fSxiZWdpbkZhaWxlZFdvcms6ZnVuY3Rpb24oYSxiLFxuYyl7c3dpdGNoKGIudGFnKXtjYXNlIDI6cWUoYik7YnJlYWs7Y2FzZSAzOmsoYik7YnJlYWs7ZGVmYXVsdDpFKFwiMTU3XCIpfWIuZWZmZWN0VGFnfD02NDtudWxsPT09YT9iLmNoaWxkPW51bGw6Yi5jaGlsZCE9PWEuY2hpbGQmJihiLmNoaWxkPWEuY2hpbGQpO2lmKDA9PT1iLmV4cGlyYXRpb25UaW1lfHxiLmV4cGlyYXRpb25UaW1lPmMpcmV0dXJuIHYoYSxiKTtiLmZpcnN0RWZmZWN0PW51bGw7Yi5sYXN0RWZmZWN0PW51bGw7Yi5jaGlsZD1udWxsPT09YT9jZihiLG51bGwsbnVsbCxjKTpiZihiLGEuY2hpbGQsbnVsbCxjKTsyPT09Yi50YWcmJihhPWIuc3RhdGVOb2RlLGIubWVtb2l6ZWRQcm9wcz1hLnByb3BzLGIubWVtb2l6ZWRTdGF0ZT1hLnN0YXRlKTtyZXR1cm4gYi5jaGlsZH19fVxuZnVuY3Rpb24gZWYoYSxiLGMpe2Z1bmN0aW9uIGQoYSl7YS5lZmZlY3RUYWd8PTR9dmFyIGU9YS5jcmVhdGVJbnN0YW5jZSxmPWEuY3JlYXRlVGV4dEluc3RhbmNlLGc9YS5hcHBlbmRJbml0aWFsQ2hpbGQsaD1hLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLGs9YS5wcmVwYXJlVXBkYXRlLHE9YS5wZXJzaXN0ZW5jZSx2PWIuZ2V0Um9vdEhvc3RDb250YWluZXIseT1iLnBvcEhvc3RDb250ZXh0LHU9Yi5nZXRIb3N0Q29udGV4dCx6PWIucG9wSG9zdENvbnRhaW5lcixHPWMucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxJPWMucHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsTD1jLnBvcEh5ZHJhdGlvblN0YXRlLE49dm9pZCAwLEo9dm9pZCAwLHc9dm9pZCAwO2EubXV0YXRpb24/KE49ZnVuY3Rpb24oKXt9LEo9ZnVuY3Rpb24oYSxiLGMpeyhiLnVwZGF0ZVF1ZXVlPWMpJiZkKGIpfSx3PWZ1bmN0aW9uKGEsYixjLGUpe2MhPT1lJiZkKGIpfSk6cT9FKFwiMjM1XCIpOkUoXCIyMzZcIik7XG5yZXR1cm57Y29tcGxldGVXb3JrOmZ1bmN0aW9uKGEsYixjKXt2YXIgbT1iLnBlbmRpbmdQcm9wcztpZihudWxsPT09bSltPWIubWVtb2l6ZWRQcm9wcztlbHNlIGlmKDIxNDc0ODM2NDchPT1iLmV4cGlyYXRpb25UaW1lfHwyMTQ3NDgzNjQ3PT09YyliLnBlbmRpbmdQcm9wcz1udWxsO3N3aXRjaChiLnRhZyl7Y2FzZSAxOnJldHVybiBudWxsO2Nhc2UgMjpyZXR1cm4gbmUoYiksbnVsbDtjYXNlIDM6eihiKTtWKFgsYik7VihpZSxiKTttPWIuc3RhdGVOb2RlO20ucGVuZGluZ0NvbnRleHQmJihtLmNvbnRleHQ9bS5wZW5kaW5nQ29udGV4dCxtLnBlbmRpbmdDb250ZXh0PW51bGwpO2lmKG51bGw9PT1hfHxudWxsPT09YS5jaGlsZClMKGIpLGIuZWZmZWN0VGFnJj0tMztOKGIpO3JldHVybiBudWxsO2Nhc2UgNTp5KGIpO2M9digpO3ZhciBBPWIudHlwZTtpZihudWxsIT09YSYmbnVsbCE9Yi5zdGF0ZU5vZGUpe3ZhciBwPWEubWVtb2l6ZWRQcm9wcyxxPWIuc3RhdGVOb2RlLHg9dSgpO3E9XG5rKHEsQSxwLG0sYyx4KTtKKGEsYixxLEEscCxtLGMpO2EucmVmIT09Yi5yZWYmJihiLmVmZmVjdFRhZ3w9MTI4KX1lbHNle2lmKCFtKXJldHVybiBudWxsPT09Yi5zdGF0ZU5vZGU/RShcIjE2NlwiKTp2b2lkIDAsbnVsbDthPXUoKTtpZihMKGIpKUcoYixjLGEpJiZkKGIpO2Vsc2V7YT1lKEEsbSxjLGEsYik7YTpmb3IocD1iLmNoaWxkO251bGwhPT1wOyl7aWYoNT09PXAudGFnfHw2PT09cC50YWcpZyhhLHAuc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1wLnRhZyYmbnVsbCE9PXAuY2hpbGQpe3AuY2hpbGRbXCJyZXR1cm5cIl09cDtwPXAuY2hpbGQ7Y29udGludWV9aWYocD09PWIpYnJlYWs7Zm9yKDtudWxsPT09cC5zaWJsaW5nOyl7aWYobnVsbD09PXBbXCJyZXR1cm5cIl18fHBbXCJyZXR1cm5cIl09PT1iKWJyZWFrIGE7cD1wW1wicmV0dXJuXCJdfXAuc2libGluZ1tcInJldHVyblwiXT1wW1wicmV0dXJuXCJdO3A9cC5zaWJsaW5nfWgoYSxBLG0sYykmJmQoYik7Yi5zdGF0ZU5vZGU9YX1udWxsIT09Yi5yZWYmJlxuKGIuZWZmZWN0VGFnfD0xMjgpfXJldHVybiBudWxsO2Nhc2UgNjppZihhJiZudWxsIT1iLnN0YXRlTm9kZSl3KGEsYixhLm1lbW9pemVkUHJvcHMsbSk7ZWxzZXtpZihcInN0cmluZ1wiIT09dHlwZW9mIG0pcmV0dXJuIG51bGw9PT1iLnN0YXRlTm9kZT9FKFwiMTY2XCIpOnZvaWQgMCxudWxsO2E9digpO2M9dSgpO0woYik/SShiKSYmZChiKTpiLnN0YXRlTm9kZT1mKG0sYSxjLGIpfXJldHVybiBudWxsO2Nhc2UgNzoobT1iLm1lbW9pemVkUHJvcHMpP3ZvaWQgMDpFKFwiMTY1XCIpO2IudGFnPTg7QT1bXTthOmZvcigocD1iLnN0YXRlTm9kZSkmJihwW1wicmV0dXJuXCJdPWIpO251bGwhPT1wOyl7aWYoNT09PXAudGFnfHw2PT09cC50YWd8fDQ9PT1wLnRhZylFKFwiMjQ3XCIpO2Vsc2UgaWYoOT09PXAudGFnKUEucHVzaChwLnR5cGUpO2Vsc2UgaWYobnVsbCE9PXAuY2hpbGQpe3AuY2hpbGRbXCJyZXR1cm5cIl09cDtwPXAuY2hpbGQ7Y29udGludWV9Zm9yKDtudWxsPT09cC5zaWJsaW5nOyl7aWYobnVsbD09PVxucFtcInJldHVyblwiXXx8cFtcInJldHVyblwiXT09PWIpYnJlYWsgYTtwPXBbXCJyZXR1cm5cIl19cC5zaWJsaW5nW1wicmV0dXJuXCJdPXBbXCJyZXR1cm5cIl07cD1wLnNpYmxpbmd9cD1tLmhhbmRsZXI7bT1wKG0ucHJvcHMsQSk7Yi5jaGlsZD1iZihiLG51bGwhPT1hP2EuY2hpbGQ6bnVsbCxtLGMpO3JldHVybiBiLmNoaWxkO2Nhc2UgODpyZXR1cm4gYi50YWc9NyxudWxsO2Nhc2UgOTpyZXR1cm4gbnVsbDtjYXNlIDEwOnJldHVybiBudWxsO2Nhc2UgNDpyZXR1cm4geihiKSxOKGIpLG51bGw7Y2FzZSAwOkUoXCIxNjdcIik7ZGVmYXVsdDpFKFwiMTU2XCIpfX19fVxuZnVuY3Rpb24gZmYoYSxiKXtmdW5jdGlvbiBjKGEpe3ZhciBjPWEucmVmO2lmKG51bGwhPT1jKXRyeXtjKG51bGwpfWNhdGNoKEEpe2IoYSxBKX19ZnVuY3Rpb24gZChhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRWUmJkVlKGEpO3N3aXRjaChhLnRhZyl7Y2FzZSAyOmMoYSk7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50V2lsbFVubW91bnQpdHJ5e2QucHJvcHM9YS5tZW1vaXplZFByb3BzLGQuc3RhdGU9YS5tZW1vaXplZFN0YXRlLGQuY29tcG9uZW50V2lsbFVubW91bnQoKX1jYXRjaChBKXtiKGEsQSl9YnJlYWs7Y2FzZSA1OmMoYSk7YnJlYWs7Y2FzZSA3OmUoYS5zdGF0ZU5vZGUpO2JyZWFrO2Nhc2UgNDprJiZnKGEpfX1mdW5jdGlvbiBlKGEpe2Zvcih2YXIgYj1hOzspaWYoZChiKSxudWxsPT09Yi5jaGlsZHx8ayYmND09PWIudGFnKXtpZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09YltcInJldHVyblwiXXx8XG5iW1wicmV0dXJuXCJdPT09YSlyZXR1cm47Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfWVsc2UgYi5jaGlsZFtcInJldHVyblwiXT1iLGI9Yi5jaGlsZH1mdW5jdGlvbiBmKGEpe3JldHVybiA1PT09YS50YWd8fDM9PT1hLnRhZ3x8ND09PWEudGFnfWZ1bmN0aW9uIGcoYSl7Zm9yKHZhciBiPWEsYz0hMSxmPXZvaWQgMCxnPXZvaWQgMDs7KXtpZighYyl7Yz1iW1wicmV0dXJuXCJdO2E6Zm9yKDs7KXtudWxsPT09Yz9FKFwiMTYwXCIpOnZvaWQgMDtzd2l0Y2goYy50YWcpe2Nhc2UgNTpmPWMuc3RhdGVOb2RlO2c9ITE7YnJlYWsgYTtjYXNlIDM6Zj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2c9ITA7YnJlYWsgYTtjYXNlIDQ6Zj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2c9ITA7YnJlYWsgYX1jPWNbXCJyZXR1cm5cIl19Yz0hMH1pZig1PT09Yi50YWd8fDY9PT1iLnRhZyllKGIpLGc/SihmLGIuc3RhdGVOb2RlKTpOKGYsYi5zdGF0ZU5vZGUpO1xuZWxzZSBpZig0PT09Yi50YWc/Zj1iLnN0YXRlTm9kZS5jb250YWluZXJJbmZvOmQoYiksbnVsbCE9PWIuY2hpbGQpe2IuY2hpbGRbXCJyZXR1cm5cIl09YjtiPWIuY2hpbGQ7Y29udGludWV9aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybjtiPWJbXCJyZXR1cm5cIl07ND09PWIudGFnJiYoYz0hMSl9Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9fXZhciBoPWEuZ2V0UHVibGljSW5zdGFuY2Usaz1hLm11dGF0aW9uO2E9YS5wZXJzaXN0ZW5jZTtrfHwoYT9FKFwiMjM1XCIpOkUoXCIyMzZcIikpO3ZhciBxPWsuY29tbWl0TW91bnQsdj1rLmNvbW1pdFVwZGF0ZSx5PWsucmVzZXRUZXh0Q29udGVudCx1PWsuY29tbWl0VGV4dFVwZGF0ZSx6PWsuYXBwZW5kQ2hpbGQsRz1rLmFwcGVuZENoaWxkVG9Db250YWluZXIsST1rLmluc2VydEJlZm9yZSxMPWsuaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG5OPWsucmVtb3ZlQ2hpbGQsSj1rLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtyZXR1cm57Y29tbWl0UmVzZXRUZXh0Q29udGVudDpmdW5jdGlvbihhKXt5KGEuc3RhdGVOb2RlKX0sY29tbWl0UGxhY2VtZW50OmZ1bmN0aW9uKGEpe2E6e2Zvcih2YXIgYj1hW1wicmV0dXJuXCJdO251bGwhPT1iOyl7aWYoZihiKSl7dmFyIGM9YjticmVhayBhfWI9YltcInJldHVyblwiXX1FKFwiMTYwXCIpO2M9dm9pZCAwfXZhciBkPWI9dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA1OmI9Yy5zdGF0ZU5vZGU7ZD0hMTticmVhaztjYXNlIDM6Yj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7Y2FzZSA0OmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2RlZmF1bHQ6RShcIjE2MVwiKX1jLmVmZmVjdFRhZyYxNiYmKHkoYiksYy5lZmZlY3RUYWcmPS0xNyk7YTpiOmZvcihjPWE7Oyl7Zm9yKDtudWxsPT09Yy5zaWJsaW5nOyl7aWYobnVsbD09PWNbXCJyZXR1cm5cIl18fGYoY1tcInJldHVyblwiXSkpe2M9XG5udWxsO2JyZWFrIGF9Yz1jW1wicmV0dXJuXCJdfWMuc2libGluZ1tcInJldHVyblwiXT1jW1wicmV0dXJuXCJdO2ZvcihjPWMuc2libGluZzs1IT09Yy50YWcmJjYhPT1jLnRhZzspe2lmKGMuZWZmZWN0VGFnJjIpY29udGludWUgYjtpZihudWxsPT09Yy5jaGlsZHx8ND09PWMudGFnKWNvbnRpbnVlIGI7ZWxzZSBjLmNoaWxkW1wicmV0dXJuXCJdPWMsYz1jLmNoaWxkfWlmKCEoYy5lZmZlY3RUYWcmMikpe2M9Yy5zdGF0ZU5vZGU7YnJlYWsgYX19Zm9yKHZhciBlPWE7Oyl7aWYoNT09PWUudGFnfHw2PT09ZS50YWcpYz9kP0woYixlLnN0YXRlTm9kZSxjKTpJKGIsZS5zdGF0ZU5vZGUsYyk6ZD9HKGIsZS5zdGF0ZU5vZGUpOnooYixlLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09ZS50YWcmJm51bGwhPT1lLmNoaWxkKXtlLmNoaWxkW1wicmV0dXJuXCJdPWU7ZT1lLmNoaWxkO2NvbnRpbnVlfWlmKGU9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWUuc2libGluZzspe2lmKG51bGw9PT1lW1wicmV0dXJuXCJdfHxlW1wicmV0dXJuXCJdPT09XG5hKXJldHVybjtlPWVbXCJyZXR1cm5cIl19ZS5zaWJsaW5nW1wicmV0dXJuXCJdPWVbXCJyZXR1cm5cIl07ZT1lLnNpYmxpbmd9fSxjb21taXREZWxldGlvbjpmdW5jdGlvbihhKXtnKGEpO2FbXCJyZXR1cm5cIl09bnVsbDthLmNoaWxkPW51bGw7YS5hbHRlcm5hdGUmJihhLmFsdGVybmF0ZS5jaGlsZD1udWxsLGEuYWx0ZXJuYXRlW1wicmV0dXJuXCJdPW51bGwpfSxjb21taXRXb3JrOmZ1bmN0aW9uKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDI6YnJlYWs7Y2FzZSA1OnZhciBjPWIuc3RhdGVOb2RlO2lmKG51bGwhPWMpe3ZhciBkPWIubWVtb2l6ZWRQcm9wczthPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpkO3ZhciBlPWIudHlwZSxmPWIudXBkYXRlUXVldWU7Yi51cGRhdGVRdWV1ZT1udWxsO251bGwhPT1mJiZ2KGMsZixlLGEsZCxiKX1icmVhaztjYXNlIDY6bnVsbD09PWIuc3RhdGVOb2RlP0UoXCIxNjJcIik6dm9pZCAwO2M9Yi5tZW1vaXplZFByb3BzO3UoYi5zdGF0ZU5vZGUsbnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOlxuYyxjKTticmVhaztjYXNlIDM6YnJlYWs7ZGVmYXVsdDpFKFwiMTYzXCIpfX0sY29tbWl0TGlmZUN5Y2xlczpmdW5jdGlvbihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOnZhciBjPWIuc3RhdGVOb2RlO2lmKGIuZWZmZWN0VGFnJjQpaWYobnVsbD09PWEpYy5wcm9wcz1iLm1lbW9pemVkUHJvcHMsYy5zdGF0ZT1iLm1lbW9pemVkU3RhdGUsYy5jb21wb25lbnREaWRNb3VudCgpO2Vsc2V7dmFyIGQ9YS5tZW1vaXplZFByb3BzO2E9YS5tZW1vaXplZFN0YXRlO2MucHJvcHM9Yi5tZW1vaXplZFByb3BzO2Muc3RhdGU9Yi5tZW1vaXplZFN0YXRlO2MuY29tcG9uZW50RGlkVXBkYXRlKGQsYSl9Yj1iLnVwZGF0ZVF1ZXVlO251bGwhPT1iJiZLZShiLGMpO2JyZWFrO2Nhc2UgMzpjPWIudXBkYXRlUXVldWU7bnVsbCE9PWMmJktlKGMsbnVsbCE9PWIuY2hpbGQ/Yi5jaGlsZC5zdGF0ZU5vZGU6bnVsbCk7YnJlYWs7Y2FzZSA1OmM9Yi5zdGF0ZU5vZGU7bnVsbD09PWEmJmIuZWZmZWN0VGFnJjQmJnEoYyxcbmIudHlwZSxiLm1lbW9pemVkUHJvcHMsYik7YnJlYWs7Y2FzZSA2OmJyZWFrO2Nhc2UgNDpicmVhaztkZWZhdWx0OkUoXCIxNjNcIil9fSxjb21taXRBdHRhY2hSZWY6ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZWY7aWYobnVsbCE9PWIpe3ZhciBjPWEuc3RhdGVOb2RlO3N3aXRjaChhLnRhZyl7Y2FzZSA1OmIoaChjKSk7YnJlYWs7ZGVmYXVsdDpiKGMpfX19LGNvbW1pdERldGFjaFJlZjpmdW5jdGlvbihhKXthPWEucmVmO251bGwhPT1hJiZhKG51bGwpfX19dmFyIGdmPXt9O1xuZnVuY3Rpb24gaGYoYSl7ZnVuY3Rpb24gYihhKXthPT09Z2Y/RShcIjE3NFwiKTp2b2lkIDA7cmV0dXJuIGF9dmFyIGM9YS5nZXRDaGlsZEhvc3RDb250ZXh0LGQ9YS5nZXRSb290SG9zdENvbnRleHQsZT17Y3VycmVudDpnZn0sZj17Y3VycmVudDpnZn0sZz17Y3VycmVudDpnZn07cmV0dXJue2dldEhvc3RDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGIoZS5jdXJyZW50KX0sZ2V0Um9vdEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtyZXR1cm4gYihnLmN1cnJlbnQpfSxwb3BIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEpe1YoZSxhKTtWKGYsYSk7VihnLGEpfSxwb3BIb3N0Q29udGV4dDpmdW5jdGlvbihhKXtmLmN1cnJlbnQ9PT1hJiYoVihlLGEpLFYoZixhKSl9LHB1c2hIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKGEsYil7VyhnLGIsYSk7Yj1kKGIpO1coZixhLGEpO1coZSxiLGEpfSxwdXNoSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7dmFyIGQ9YihnLmN1cnJlbnQpLGg9YihlLmN1cnJlbnQpO1xuZD1jKGgsYS50eXBlLGQpO2ghPT1kJiYoVyhmLGEsYSksVyhlLGQsYSkpfSxyZXNldEhvc3RDb250YWluZXI6ZnVuY3Rpb24oKXtlLmN1cnJlbnQ9Z2Y7Zy5jdXJyZW50PWdmfX19XG5mdW5jdGlvbiBqZihhKXtmdW5jdGlvbiBiKGEsYil7dmFyIGM9bmV3IFkoNSxudWxsLDApO2MudHlwZT1cIkRFTEVURURcIjtjLnN0YXRlTm9kZT1iO2NbXCJyZXR1cm5cIl09YTtjLmVmZmVjdFRhZz04O251bGwhPT1hLmxhc3RFZmZlY3Q/KGEubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWMsYS5sYXN0RWZmZWN0PWMpOmEuZmlyc3RFZmZlY3Q9YS5sYXN0RWZmZWN0PWN9ZnVuY3Rpb24gYyhhLGIpe3N3aXRjaChhLnRhZyl7Y2FzZSA1OnJldHVybiBiPWYoYixhLnR5cGUsYS5wZW5kaW5nUHJvcHMpLG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLCEwKTohMTtjYXNlIDY6cmV0dXJuIGI9ZyhiLGEucGVuZGluZ1Byb3BzKSxudWxsIT09Yj8oYS5zdGF0ZU5vZGU9YiwhMCk6ITE7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gZChhKXtmb3IoYT1hW1wicmV0dXJuXCJdO251bGwhPT1hJiY1IT09YS50YWcmJjMhPT1hLnRhZzspYT1hW1wicmV0dXJuXCJdO3k9YX12YXIgZT1hLnNob3VsZFNldFRleHRDb250ZW50O1xuYT1hLmh5ZHJhdGlvbjtpZighYSlyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfSxyZXNldEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7fSx0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30scHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTpmdW5jdGlvbigpe0UoXCIxNzVcIil9LHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7RShcIjE3NlwiKX0scG9wSHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXtyZXR1cm4hMX19O3ZhciBmPWEuY2FuSHlkcmF0ZUluc3RhbmNlLGc9YS5jYW5IeWRyYXRlVGV4dEluc3RhbmNlLGg9YS5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsaz1hLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLHE9YS5oeWRyYXRlSW5zdGFuY2Usdj1hLmh5ZHJhdGVUZXh0SW5zdGFuY2UseT1udWxsLHU9bnVsbCx6PSExO3JldHVybntlbnRlckh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe3U9XG5rKGEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO3k9YTtyZXR1cm4gej0hMH0scmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3U9eT1udWxsO3o9ITF9LHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKGEpe2lmKHope3ZhciBkPXU7aWYoZCl7aWYoIWMoYSxkKSl7ZD1oKGQpO2lmKCFkfHwhYyhhLGQpKXthLmVmZmVjdFRhZ3w9Mjt6PSExO3k9YTtyZXR1cm59Yih5LHUpfXk9YTt1PWsoZCl9ZWxzZSBhLmVmZmVjdFRhZ3w9Mix6PSExLHk9YX19LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMpe2I9cShhLnN0YXRlTm9kZSxhLnR5cGUsYS5tZW1vaXplZFByb3BzLGIsYyxhKTthLnVwZGF0ZVF1ZXVlPWI7cmV0dXJuIG51bGwhPT1iPyEwOiExfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gdihhLnN0YXRlTm9kZSxhLm1lbW9pemVkUHJvcHMsYSl9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe2lmKGEhPT1cbnkpcmV0dXJuITE7aWYoIXopcmV0dXJuIGQoYSksej0hMCwhMTt2YXIgYz1hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWMmJlwiYm9keVwiIT09YyYmIWUoYyxhLm1lbW9pemVkUHJvcHMpKWZvcihjPXU7YzspYihhLGMpLGM9aChjKTtkKGEpO3U9eT9oKGEuc3RhdGVOb2RlKTpudWxsO3JldHVybiEwfX19XG5mdW5jdGlvbiBrZihhKXtmdW5jdGlvbiBiKGEpe1FiPWphPSEwO3ZhciBiPWEuc3RhdGVOb2RlO2IuY3VycmVudD09PWE/RShcIjE3N1wiKTp2b2lkIDA7Yi5pc1JlYWR5Rm9yQ29tbWl0PSExO2lkLmN1cnJlbnQ9bnVsbDtpZigxPGEuZWZmZWN0VGFnKWlmKG51bGwhPT1hLmxhc3RFZmZlY3Qpe2EubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE7dmFyIGM9YS5maXJzdEVmZmVjdH1lbHNlIGM9YTtlbHNlIGM9YS5maXJzdEVmZmVjdDt5ZygpO2Zvcih0PWM7bnVsbCE9PXQ7KXt2YXIgZD0hMSxlPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09dDspe3ZhciBmPXQuZWZmZWN0VGFnO2YmMTYmJnpnKHQpO2lmKGYmMTI4KXt2YXIgZz10LmFsdGVybmF0ZTtudWxsIT09ZyYmQWcoZyl9c3dpdGNoKGYmLTI0Mil7Y2FzZSAyOk5lKHQpO3QuZWZmZWN0VGFnJj0tMzticmVhaztjYXNlIDY6TmUodCk7dC5lZmZlY3RUYWcmPS0zO09lKHQuYWx0ZXJuYXRlLHQpO2JyZWFrO2Nhc2UgNDpPZSh0LmFsdGVybmF0ZSxcbnQpO2JyZWFrO2Nhc2UgODpTYz0hMCxCZyh0KSxTYz0hMX10PXQubmV4dEVmZmVjdH19Y2F0Y2goVGMpe2Q9ITAsZT1UY31kJiYobnVsbD09PXQ/RShcIjE3OFwiKTp2b2lkIDAsaCh0LGUpLG51bGwhPT10JiYodD10Lm5leHRFZmZlY3QpKX1DZygpO2IuY3VycmVudD1hO2Zvcih0PWM7bnVsbCE9PXQ7KXtjPSExO2Q9dm9pZCAwO3RyeXtmb3IoO251bGwhPT10Oyl7dmFyIGs9dC5lZmZlY3RUYWc7ayYzNiYmRGcodC5hbHRlcm5hdGUsdCk7ayYxMjgmJkVnKHQpO2lmKGsmNjQpc3dpdGNoKGU9dCxmPXZvaWQgMCxudWxsIT09UiYmKGY9Ui5nZXQoZSksUltcImRlbGV0ZVwiXShlKSxudWxsPT1mJiZudWxsIT09ZS5hbHRlcm5hdGUmJihlPWUuYWx0ZXJuYXRlLGY9Ui5nZXQoZSksUltcImRlbGV0ZVwiXShlKSkpLG51bGw9PWY/RShcIjE4NFwiKTp2b2lkIDAsZS50YWcpe2Nhc2UgMjplLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaChmLmVycm9yLHtjb21wb25lbnRTdGFjazpmLmNvbXBvbmVudFN0YWNrfSk7XG5icmVhaztjYXNlIDM6bnVsbD09PWNhJiYoY2E9Zi5lcnJvcik7YnJlYWs7ZGVmYXVsdDpFKFwiMTU3XCIpfXZhciBRYz10Lm5leHRFZmZlY3Q7dC5uZXh0RWZmZWN0PW51bGw7dD1RY319Y2F0Y2goVGMpe2M9ITAsZD1UY31jJiYobnVsbD09PXQ/RShcIjE3OFwiKTp2b2lkIDAsaCh0LGQpLG51bGwhPT10JiYodD10Lm5leHRFZmZlY3QpKX1qYT1RYj0hMTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgRGUmJkRlKGEuc3RhdGVOb2RlKTtoYSYmKGhhLmZvckVhY2goRyksaGE9bnVsbCk7bnVsbCE9PWNhJiYoYT1jYSxjYT1udWxsLE9iKGEpKTtiPWIuY3VycmVudC5leHBpcmF0aW9uVGltZTswPT09YiYmKHFhPVI9bnVsbCk7cmV0dXJuIGJ9ZnVuY3Rpb24gYyhhKXtmb3IoOzspe3ZhciBiPUZnKGEuYWx0ZXJuYXRlLGEsSCksYz1hW1wicmV0dXJuXCJdLGQ9YS5zaWJsaW5nO3ZhciBlPWE7aWYoMjE0NzQ4MzY0Nz09PUh8fDIxNDc0ODM2NDchPT1lLmV4cGlyYXRpb25UaW1lKXtpZigyIT09ZS50YWcmJjMhPT1cbmUudGFnKXZhciBmPTA7ZWxzZSBmPWUudXBkYXRlUXVldWUsZj1udWxsPT09Zj8wOmYuZXhwaXJhdGlvblRpbWU7Zm9yKHZhciBnPWUuY2hpbGQ7bnVsbCE9PWc7KTAhPT1nLmV4cGlyYXRpb25UaW1lJiYoMD09PWZ8fGY+Zy5leHBpcmF0aW9uVGltZSkmJihmPWcuZXhwaXJhdGlvblRpbWUpLGc9Zy5zaWJsaW5nO2UuZXhwaXJhdGlvblRpbWU9Zn1pZihudWxsIT09YilyZXR1cm4gYjtudWxsIT09YyYmKG51bGw9PT1jLmZpcnN0RWZmZWN0JiYoYy5maXJzdEVmZmVjdD1hLmZpcnN0RWZmZWN0KSxudWxsIT09YS5sYXN0RWZmZWN0JiYobnVsbCE9PWMubGFzdEVmZmVjdCYmKGMubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLGMubGFzdEVmZmVjdD1hLmxhc3RFZmZlY3QpLDE8YS5lZmZlY3RUYWcmJihudWxsIT09Yy5sYXN0RWZmZWN0P2MubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE6Yy5maXJzdEVmZmVjdD1hLGMubGFzdEVmZmVjdD1hKSk7aWYobnVsbCE9PWQpcmV0dXJuIGQ7XG5pZihudWxsIT09YylhPWM7ZWxzZXthLnN0YXRlTm9kZS5pc1JlYWR5Rm9yQ29tbWl0PSEwO2JyZWFrfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEpe3ZhciBiPXJnKGEuYWx0ZXJuYXRlLGEsSCk7bnVsbD09PWImJihiPWMoYSkpO2lkLmN1cnJlbnQ9bnVsbDtyZXR1cm4gYn1mdW5jdGlvbiBlKGEpe3ZhciBiPUdnKGEuYWx0ZXJuYXRlLGEsSCk7bnVsbD09PWImJihiPWMoYSkpO2lkLmN1cnJlbnQ9bnVsbDtyZXR1cm4gYn1mdW5jdGlvbiBmKGEpe2lmKG51bGwhPT1SKXtpZighKDA9PT1IfHxIPmEpKWlmKEg8PVVjKWZvcig7bnVsbCE9PUY7KUY9ayhGKT9lKEYpOmQoRik7ZWxzZSBmb3IoO251bGwhPT1GJiYhQSgpOylGPWsoRik/ZShGKTpkKEYpfWVsc2UgaWYoISgwPT09SHx8SD5hKSlpZihIPD1VYylmb3IoO251bGwhPT1GOylGPWQoRik7ZWxzZSBmb3IoO251bGwhPT1GJiYhQSgpOylGPWQoRil9ZnVuY3Rpb24gZyhhLGIpe2phP0UoXCIyNDNcIik6dm9pZCAwO2phPSEwO2EuaXNSZWFkeUZvckNvbW1pdD1cbiExO2lmKGEhPT1yYXx8YiE9PUh8fG51bGw9PT1GKXtmb3IoOy0xPGhlOylnZVtoZV09bnVsbCxoZS0tO2plPUQ7aWUuY3VycmVudD1EO1guY3VycmVudD0hMTt4KCk7cmE9YTtIPWI7Rj1zZShyYS5jdXJyZW50LG51bGwsYil9dmFyIGM9ITEsZD1udWxsO3RyeXtmKGIpfWNhdGNoKFJjKXtjPSEwLGQ9UmN9Zm9yKDtjOyl7aWYoZWIpe2NhPWQ7YnJlYWt9dmFyIGc9RjtpZihudWxsPT09ZyllYj0hMDtlbHNle3ZhciBrPWgoZyxkKTtudWxsPT09az9FKFwiMTgzXCIpOnZvaWQgMDtpZighZWIpe3RyeXtjPWs7ZD1iO2ZvcihrPWM7bnVsbCE9PWc7KXtzd2l0Y2goZy50YWcpe2Nhc2UgMjpuZShnKTticmVhaztjYXNlIDU6cWcoZyk7YnJlYWs7Y2FzZSAzOnAoZyk7YnJlYWs7Y2FzZSA0OnAoZyl9aWYoZz09PWt8fGcuYWx0ZXJuYXRlPT09aylicmVhaztnPWdbXCJyZXR1cm5cIl19Rj1lKGMpO2YoZCl9Y2F0Y2goUmMpe2M9ITA7ZD1SYztjb250aW51ZX1icmVha319fWI9Y2E7ZWI9amE9ITE7Y2E9XG5udWxsO251bGwhPT1iJiZPYihiKTtyZXR1cm4gYS5pc1JlYWR5Rm9yQ29tbWl0P2EuY3VycmVudC5hbHRlcm5hdGU6bnVsbH1mdW5jdGlvbiBoKGEsYil7dmFyIGM9aWQuY3VycmVudD1udWxsLGQ9ITEsZT0hMSxmPW51bGw7aWYoMz09PWEudGFnKWM9YSxxKGEpJiYoZWI9ITApO2Vsc2UgZm9yKHZhciBnPWFbXCJyZXR1cm5cIl07bnVsbCE9PWcmJm51bGw9PT1jOyl7Mj09PWcudGFnP1wiZnVuY3Rpb25cIj09PXR5cGVvZiBnLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaCYmKGQ9ITAsZj1qZChnKSxjPWcsZT0hMCk6Mz09PWcudGFnJiYoYz1nKTtpZihxKGcpKXtpZihTY3x8bnVsbCE9PWhhJiYoaGEuaGFzKGcpfHxudWxsIT09Zy5hbHRlcm5hdGUmJmhhLmhhcyhnLmFsdGVybmF0ZSkpKXJldHVybiBudWxsO2M9bnVsbDtlPSExfWc9Z1tcInJldHVyblwiXX1pZihudWxsIT09Yyl7bnVsbD09PXFhJiYocWE9bmV3IFNldCk7cWEuYWRkKGMpO3ZhciBoPVwiXCI7Zz1hO2Rve2E6c3dpdGNoKGcudGFnKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpjYXNlIDU6dmFyIGs9XG5nLl9kZWJ1Z093bmVyLFFjPWcuX2RlYnVnU291cmNlO3ZhciBtPWpkKGcpO3ZhciBuPW51bGw7ayYmKG49amQoaykpO2s9UWM7bT1cIlxcbiAgICBpbiBcIisobXx8XCJVbmtub3duXCIpKyhrP1wiIChhdCBcIitrLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sXCJcIikrXCI6XCIray5saW5lTnVtYmVyK1wiKVwiOm4/XCIgKGNyZWF0ZWQgYnkgXCIrbitcIilcIjpcIlwiKTticmVhayBhO2RlZmF1bHQ6bT1cIlwifWgrPW07Zz1nW1wicmV0dXJuXCJdfXdoaWxlKGcpO2c9aDthPWpkKGEpO251bGw9PT1SJiYoUj1uZXcgTWFwKTtiPXtjb21wb25lbnROYW1lOmEsY29tcG9uZW50U3RhY2s6ZyxlcnJvcjpiLGVycm9yQm91bmRhcnk6ZD9jLnN0YXRlTm9kZTpudWxsLGVycm9yQm91bmRhcnlGb3VuZDpkLGVycm9yQm91bmRhcnlOYW1lOmYsd2lsbFJldHJ5OmV9O1Iuc2V0KGMsYik7dHJ5e3ZhciBwPWIuZXJyb3I7cCYmcC5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nfHxjb25zb2xlLmVycm9yKHApfWNhdGNoKFZjKXtWYyYmXG5WYy5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nfHxjb25zb2xlLmVycm9yKFZjKX1RYj8obnVsbD09PWhhJiYoaGE9bmV3IFNldCksaGEuYWRkKGMpKTpHKGMpO3JldHVybiBjfW51bGw9PT1jYSYmKGNhPWIpO3JldHVybiBudWxsfWZ1bmN0aW9uIGsoYSl7cmV0dXJuIG51bGwhPT1SJiYoUi5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmUi5oYXMoYS5hbHRlcm5hdGUpKX1mdW5jdGlvbiBxKGEpe3JldHVybiBudWxsIT09cWEmJihxYS5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmcWEuaGFzKGEuYWx0ZXJuYXRlKSl9ZnVuY3Rpb24gdigpe3JldHVybiAyMCooKChJKCkrMTAwKS8yMHwwKSsxKX1mdW5jdGlvbiB5KGEpe3JldHVybiAwIT09a2E/a2E6amE/UWI/MTpIOiFIZ3x8YS5pbnRlcm5hbENvbnRleHRUYWcmMT92KCk6MX1mdW5jdGlvbiB1KGEsYil7cmV0dXJuIHooYSxiLCExKX1mdW5jdGlvbiB6KGEsYil7Zm9yKDtudWxsIT09YTspe2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxcbmEuZXhwaXJhdGlvblRpbWU+YilhLmV4cGlyYXRpb25UaW1lPWI7bnVsbCE9PWEuYWx0ZXJuYXRlJiYoMD09PWEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lfHxhLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZT5iKSYmKGEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lPWIpO2lmKG51bGw9PT1hW1wicmV0dXJuXCJdKWlmKDM9PT1hLnRhZyl7dmFyIGM9YS5zdGF0ZU5vZGU7IWphJiZjPT09cmEmJmI8SCYmKEY9cmE9bnVsbCxIPTApO3ZhciBkPWMsZT1iO1JiPklnJiZFKFwiMTg1XCIpO2lmKG51bGw9PT1kLm5leHRTY2hlZHVsZWRSb290KWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZSxudWxsPT09Tz8oc2E9Tz1kLGQubmV4dFNjaGVkdWxlZFJvb3Q9ZCk6KE89Ty5uZXh0U2NoZWR1bGVkUm9vdD1kLE8ubmV4dFNjaGVkdWxlZFJvb3Q9c2EpO2Vsc2V7dmFyIGY9ZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtpZigwPT09Znx8ZTxmKWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZX1GYXx8KGxhP1xuU2ImJihtYT1kLG5hPTEsbShtYSxuYSkpOjE9PT1lP3coMSxudWxsKTpMKGUpKTshamEmJmM9PT1yYSYmYjxIJiYoRj1yYT1udWxsLEg9MCl9ZWxzZSBicmVhazthPWFbXCJyZXR1cm5cIl19fWZ1bmN0aW9uIEcoYSl7eihhLDEsITApfWZ1bmN0aW9uIEkoKXtyZXR1cm4gVWM9KChXYygpLVBlKS8xMHwwKSsyfWZ1bmN0aW9uIEwoYSl7aWYoMCE9PVRiKXtpZihhPlRiKXJldHVybjtKZyhYYyl9dmFyIGI9V2MoKS1QZTtUYj1hO1hjPUtnKEose3RpbWVvdXQ6MTAqKGEtMiktYn0pfWZ1bmN0aW9uIE4oKXt2YXIgYT0wLGI9bnVsbDtpZihudWxsIT09Tylmb3IodmFyIGM9TyxkPXNhO251bGwhPT1kOyl7dmFyIGU9ZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtpZigwPT09ZSl7bnVsbD09PWN8fG51bGw9PT1PP0UoXCIyNDRcIik6dm9pZCAwO2lmKGQ9PT1kLm5leHRTY2hlZHVsZWRSb290KXtzYT1PPWQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGlmKGQ9PT1zYSlzYT1lPWQubmV4dFNjaGVkdWxlZFJvb3QsXG5PLm5leHRTY2hlZHVsZWRSb290PWUsZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2Vsc2UgaWYoZD09PU8pe089YztPLm5leHRTY2hlZHVsZWRSb290PXNhO2QubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGMubmV4dFNjaGVkdWxlZFJvb3Q9ZC5uZXh0U2NoZWR1bGVkUm9vdCxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZD1jLm5leHRTY2hlZHVsZWRSb290fWVsc2V7aWYoMD09PWF8fGU8YSlhPWUsYj1kO2lmKGQ9PT1PKWJyZWFrO2M9ZDtkPWQubmV4dFNjaGVkdWxlZFJvb3R9fWM9bWE7bnVsbCE9PWMmJmM9PT1iP1JiKys6UmI9MDttYT1iO25hPWF9ZnVuY3Rpb24gSihhKXt3KDAsYSl9ZnVuY3Rpb24gdyhhLGIpe2ZiPWI7Zm9yKE4oKTtudWxsIT09bWEmJjAhPT1uYSYmKDA9PT1hfHxuYTw9YSkmJiFZYzspbShtYSxuYSksTigpO251bGwhPT1mYiYmKFRiPTAsWGM9LTEpOzAhPT1uYSYmTChuYSk7ZmI9bnVsbDtZYz0hMTtSYj0wO2lmKFViKXRocm93IGE9WmMsWmM9XG5udWxsLFViPSExLGE7fWZ1bmN0aW9uIG0oYSxjKXtGYT9FKFwiMjQ1XCIpOnZvaWQgMDtGYT0hMDtpZihjPD1JKCkpe3ZhciBkPWEuZmluaXNoZWRXb3JrO251bGwhPT1kPyhhLmZpbmlzaGVkV29yaz1udWxsLGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSk6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1nKGEsYyksbnVsbCE9PWQmJihhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpKX1lbHNlIGQ9YS5maW5pc2hlZFdvcmssbnVsbCE9PWQ/KGEuZmluaXNoZWRXb3JrPW51bGwsYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKTooYS5maW5pc2hlZFdvcms9bnVsbCxkPWcoYSxjKSxudWxsIT09ZCYmKEEoKT9hLmZpbmlzaGVkV29yaz1kOmEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSkpO0ZhPSExfWZ1bmN0aW9uIEEoKXtyZXR1cm4gbnVsbD09PWZifHxmYi50aW1lUmVtYWluaW5nKCk+TGc/ITE6WWM9ITB9ZnVuY3Rpb24gT2IoYSl7bnVsbD09PW1hP0UoXCIyNDZcIik6XG52b2lkIDA7bWEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9MDtVYnx8KFViPSEwLFpjPWEpfXZhciByPWhmKGEpLG49amYoYSkscD1yLnBvcEhvc3RDb250YWluZXIscWc9ci5wb3BIb3N0Q29udGV4dCx4PXIucmVzZXRIb3N0Q29udGFpbmVyLE1lPWRmKGEscixuLHUseSkscmc9TWUuYmVnaW5Xb3JrLEdnPU1lLmJlZ2luRmFpbGVkV29yayxGZz1lZihhLHIsbikuY29tcGxldGVXb3JrO3I9ZmYoYSxoKTt2YXIgemc9ci5jb21taXRSZXNldFRleHRDb250ZW50LE5lPXIuY29tbWl0UGxhY2VtZW50LEJnPXIuY29tbWl0RGVsZXRpb24sT2U9ci5jb21taXRXb3JrLERnPXIuY29tbWl0TGlmZUN5Y2xlcyxFZz1yLmNvbW1pdEF0dGFjaFJlZixBZz1yLmNvbW1pdERldGFjaFJlZixXYz1hLm5vdyxLZz1hLnNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayxKZz1hLmNhbmNlbERlZmVycmVkQ2FsbGJhY2ssSGc9YS51c2VTeW5jU2NoZWR1bGluZyx5Zz1hLnByZXBhcmVGb3JDb21taXQsQ2c9YS5yZXNldEFmdGVyQ29tbWl0LFxuUGU9V2MoKSxVYz0yLGthPTAsamE9ITEsRj1udWxsLHJhPW51bGwsSD0wLHQ9bnVsbCxSPW51bGwscWE9bnVsbCxoYT1udWxsLGNhPW51bGwsZWI9ITEsUWI9ITEsU2M9ITEsc2E9bnVsbCxPPW51bGwsVGI9MCxYYz0tMSxGYT0hMSxtYT1udWxsLG5hPTAsWWM9ITEsVWI9ITEsWmM9bnVsbCxmYj1udWxsLGxhPSExLFNiPSExLElnPTFFMyxSYj0wLExnPTE7cmV0dXJue2NvbXB1dGVBc3luY0V4cGlyYXRpb246dixjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOnksc2NoZWR1bGVXb3JrOnUsYmF0Y2hlZFVwZGF0ZXM6ZnVuY3Rpb24oYSxiKXt2YXIgYz1sYTtsYT0hMDt0cnl7cmV0dXJuIGEoYil9ZmluYWxseXsobGE9Yyl8fEZhfHx3KDEsbnVsbCl9fSx1bmJhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEpe2lmKGxhJiYhU2Ipe1NiPSEwO3RyeXtyZXR1cm4gYSgpfWZpbmFsbHl7U2I9ITF9fXJldHVybiBhKCl9LGZsdXNoU3luYzpmdW5jdGlvbihhKXt2YXIgYj1sYTtsYT0hMDt0cnl7YTp7dmFyIGM9XG5rYTtrYT0xO3RyeXt2YXIgZD1hKCk7YnJlYWsgYX1maW5hbGx5e2thPWN9ZD12b2lkIDB9cmV0dXJuIGR9ZmluYWxseXtsYT1iLEZhP0UoXCIxODdcIik6dm9pZCAwLHcoMSxudWxsKX19LGRlZmVycmVkVXBkYXRlczpmdW5jdGlvbihhKXt2YXIgYj1rYTtrYT12KCk7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtrYT1ifX19fVxuZnVuY3Rpb24gbGYoYSl7ZnVuY3Rpb24gYihhKXthPW9kKGEpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfXZhciBjPWEuZ2V0UHVibGljSW5zdGFuY2U7YT1rZihhKTt2YXIgZD1hLmNvbXB1dGVBc3luY0V4cGlyYXRpb24sZT1hLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsZj1hLnNjaGVkdWxlV29yaztyZXR1cm57Y3JlYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IFkoMyxudWxsLDApO2E9e2N1cnJlbnQ6Yyxjb250YWluZXJJbmZvOmEscGVuZGluZ0NoaWxkcmVuOm51bGwscmVtYWluaW5nRXhwaXJhdGlvblRpbWU6MCxpc1JlYWR5Rm9yQ29tbWl0OiExLGZpbmlzaGVkV29yazpudWxsLGNvbnRleHQ6bnVsbCxwZW5kaW5nQ29udGV4dDpudWxsLGh5ZHJhdGU6YixuZXh0U2NoZWR1bGVkUm9vdDpudWxsfTtyZXR1cm4gYy5zdGF0ZU5vZGU9YX0sdXBkYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYixjLHEpe3ZhciBnPWIuY3VycmVudDtpZihjKXtjPVxuYy5fcmVhY3RJbnRlcm5hbEZpYmVyO3ZhciBoO2I6ezI9PT1rZChjKSYmMj09PWMudGFnP3ZvaWQgMDpFKFwiMTcwXCIpO2ZvcihoPWM7MyE9PWgudGFnOyl7aWYobGUoaCkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn0oaD1oW1wicmV0dXJuXCJdKT92b2lkIDA6RShcIjE3MVwiKX1oPWguc3RhdGVOb2RlLmNvbnRleHR9Yz1sZShjKT9wZShjLGgpOmh9ZWxzZSBjPUQ7bnVsbD09PWIuY29udGV4dD9iLmNvbnRleHQ9YzpiLnBlbmRpbmdDb250ZXh0PWM7Yj1xO2I9dm9pZCAwPT09Yj9udWxsOmI7cT1udWxsIT1hJiZudWxsIT1hLnR5cGUmJm51bGwhPWEudHlwZS5wcm90b3R5cGUmJiEwPT09YS50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ/ZCgpOmUoZyk7SGUoZyx7ZXhwaXJhdGlvblRpbWU6cSxwYXJ0aWFsU3RhdGU6e2VsZW1lbnQ6YX0sY2FsbGJhY2s6Yixpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsXG5uZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtmKGcscSl9LGJhdGNoZWRVcGRhdGVzOmEuYmF0Y2hlZFVwZGF0ZXMsdW5iYXRjaGVkVXBkYXRlczphLnVuYmF0Y2hlZFVwZGF0ZXMsZGVmZXJyZWRVcGRhdGVzOmEuZGVmZXJyZWRVcGRhdGVzLGZsdXNoU3luYzphLmZsdXNoU3luYyxnZXRQdWJsaWNSb290SW5zdGFuY2U6ZnVuY3Rpb24oYSl7YT1hLmN1cnJlbnQ7aWYoIWEuY2hpbGQpcmV0dXJuIG51bGw7c3dpdGNoKGEuY2hpbGQudGFnKXtjYXNlIDU6cmV0dXJuIGMoYS5jaGlsZC5zdGF0ZU5vZGUpO2RlZmF1bHQ6cmV0dXJuIGEuY2hpbGQuc3RhdGVOb2RlfX0sZmluZEhvc3RJbnN0YW5jZTpiLGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOmZ1bmN0aW9uKGEpe2E9cGQoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9LGluamVjdEludG9EZXZUb29sczpmdW5jdGlvbihhKXt2YXIgYz1hLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO3JldHVybiBDZShCKHt9LFxuYSx7ZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGIoYSl9LGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiBjP2MoYSk6bnVsbH19KSl9fX12YXIgbWY9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpsZn0pLG5mPW1mJiZsZnx8bWYsb2Y9bmZbXCJkZWZhdWx0XCJdP25mW1wiZGVmYXVsdFwiXTpuZjtmdW5jdGlvbiBwZihhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOlVlLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fXZhciBxZj1cIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93LHJmPXZvaWQgMDtyZj1xZj9mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX06ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX07XG52YXIgc2Y9dm9pZCAwLHRmPXZvaWQgMDtcbmlmKGwuY2FuVXNlRE9NKWlmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrfHxcImZ1bmN0aW9uXCIhPT10eXBlb2YgY2FuY2VsSWRsZUNhbGxiYWNrKXt2YXIgdWY9bnVsbCx2Zj0hMSx3Zj0tMSx4Zj0hMSx5Zj0wLHpmPTMzLEFmPTMzLEJmO0JmPXFmP3tkaWRUaW1lb3V0OiExLHRpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXt2YXIgYT15Zi1wZXJmb3JtYW5jZS5ub3coKTtyZXR1cm4gMDxhP2E6MH19OntkaWRUaW1lb3V0OiExLHRpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXt2YXIgYT15Zi1EYXRlLm5vdygpO3JldHVybiAwPGE/YTowfX07dmFyIENmPVwiX19yZWFjdElkbGVDYWxsYmFjayRcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixmdW5jdGlvbihhKXtpZihhLnNvdXJjZT09PXdpbmRvdyYmYS5kYXRhPT09Q2Ype3ZmPSExO2E9cmYoKTtpZigwPj15Zi1hKWlmKC0xIT09d2YmJndmPD1cbmEpQmYuZGlkVGltZW91dD0hMDtlbHNle3hmfHwoeGY9ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKERmKSk7cmV0dXJufWVsc2UgQmYuZGlkVGltZW91dD0hMTt3Zj0tMTthPXVmO3VmPW51bGw7bnVsbCE9PWEmJmEoQmYpfX0sITEpO3ZhciBEZj1mdW5jdGlvbihhKXt4Zj0hMTt2YXIgYj1hLXlmK0FmO2I8QWYmJnpmPEFmPyg4PmImJihiPTgpLEFmPWI8emY/emY6Yik6emY9Yjt5Zj1hK0FmO3ZmfHwodmY9ITAsd2luZG93LnBvc3RNZXNzYWdlKENmLFwiKlwiKSl9O3NmPWZ1bmN0aW9uKGEsYil7dWY9YTtudWxsIT1iJiZcIm51bWJlclwiPT09dHlwZW9mIGIudGltZW91dCYmKHdmPXJmKCkrYi50aW1lb3V0KTt4Znx8KHhmPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZShEZikpO3JldHVybiAwfTt0Zj1mdW5jdGlvbigpe3VmPW51bGw7dmY9ITE7d2Y9LTF9fWVsc2Ugc2Y9d2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2ssdGY9d2luZG93LmNhbmNlbElkbGVDYWxsYmFjaztlbHNlIHNmPWZ1bmN0aW9uKGEpe3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YSh7dGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3JldHVybiBJbmZpbml0eX19KX0pfSxcbnRmPWZ1bmN0aW9uKGEpe2NsZWFyVGltZW91dChhKX07dmFyIEVmPS9eWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXVs6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcLS4wLTlcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXSokLyxGZj17fSxHZj17fTtcbmZ1bmN0aW9uIEhmKGEpe2lmKEdmLmhhc093blByb3BlcnR5KGEpKXJldHVybiEwO2lmKEZmLmhhc093blByb3BlcnR5KGEpKXJldHVybiExO2lmKEVmLnRlc3QoYSkpcmV0dXJuIEdmW2FdPSEwO0ZmW2FdPSEwO3JldHVybiExfVxuZnVuY3Rpb24gSWYoYSxiLGMpe3ZhciBkPXdhKGIpO2lmKGQmJnZhKGIsYykpe3ZhciBlPWQubXV0YXRpb25NZXRob2Q7ZT9lKGEsYyk6bnVsbD09Y3x8ZC5oYXNCb29sZWFuVmFsdWUmJiFjfHxkLmhhc051bWVyaWNWYWx1ZSYmaXNOYU4oYyl8fGQuaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUmJjE+Y3x8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMT09PWM/SmYoYSxiKTpkLm11c3RVc2VQcm9wZXJ0eT9hW2QucHJvcGVydHlOYW1lXT1jOihiPWQuYXR0cmlidXRlTmFtZSwoZT1kLmF0dHJpYnV0ZU5hbWVzcGFjZSk/YS5zZXRBdHRyaWJ1dGVOUyhlLGIsXCJcIitjKTpkLmhhc0Jvb2xlYW5WYWx1ZXx8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMD09PWM/YS5zZXRBdHRyaWJ1dGUoYixcIlwiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpfWVsc2UgS2YoYSxiLHZhKGIsYyk/YzpudWxsKX1cbmZ1bmN0aW9uIEtmKGEsYixjKXtIZihiKSYmKG51bGw9PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKX1mdW5jdGlvbiBKZihhLGIpe3ZhciBjPXdhKGIpO2M/KGI9Yy5tdXRhdGlvbk1ldGhvZCk/YihhLHZvaWQgMCk6Yy5tdXN0VXNlUHJvcGVydHk/YVtjLnByb3BlcnR5TmFtZV09Yy5oYXNCb29sZWFuVmFsdWU/ITE6XCJcIjphLnJlbW92ZUF0dHJpYnV0ZShjLmF0dHJpYnV0ZU5hbWUpOmEucmVtb3ZlQXR0cmlidXRlKGIpfVxuZnVuY3Rpb24gTGYoYSxiKXt2YXIgYz1iLnZhbHVlLGQ9Yi5jaGVja2VkO3JldHVybiBCKHt0eXBlOnZvaWQgMCxzdGVwOnZvaWQgMCxtaW46dm9pZCAwLG1heDp2b2lkIDB9LGIse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOm51bGwhPWM/YzphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLGNoZWNrZWQ6bnVsbCE9ZD9kOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfWZ1bmN0aW9uIE1mKGEsYil7dmFyIGM9Yi5kZWZhdWx0VmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpudWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQsaW5pdGlhbFZhbHVlOm51bGwhPWIudmFsdWU/Yi52YWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fVxuZnVuY3Rpb24gTmYoYSxiKXtiPWIuY2hlY2tlZDtudWxsIT1iJiZJZihhLFwiY2hlY2tlZFwiLGIpfWZ1bmN0aW9uIE9mKGEsYil7TmYoYSxiKTt2YXIgYz1iLnZhbHVlO2lmKG51bGwhPWMpaWYoMD09PWMmJlwiXCI9PT1hLnZhbHVlKWEudmFsdWU9XCIwXCI7ZWxzZSBpZihcIm51bWJlclwiPT09Yi50eXBlKXtpZihiPXBhcnNlRmxvYXQoYS52YWx1ZSl8fDAsYyE9Ynx8Yz09YiYmYS52YWx1ZSE9YylhLnZhbHVlPVwiXCIrY31lbHNlIGEudmFsdWUhPT1cIlwiK2MmJihhLnZhbHVlPVwiXCIrYyk7ZWxzZSBudWxsPT1iLnZhbHVlJiZudWxsIT1iLmRlZmF1bHRWYWx1ZSYmYS5kZWZhdWx0VmFsdWUhPT1cIlwiK2IuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitiLmRlZmF1bHRWYWx1ZSksbnVsbD09Yi5jaGVja2VkJiZudWxsIT1iLmRlZmF1bHRDaGVja2VkJiYoYS5kZWZhdWx0Q2hlY2tlZD0hIWIuZGVmYXVsdENoZWNrZWQpfVxuZnVuY3Rpb24gUGYoYSxiKXtzd2l0Y2goYi50eXBlKXtjYXNlIFwic3VibWl0XCI6Y2FzZSBcInJlc2V0XCI6YnJlYWs7Y2FzZSBcImNvbG9yXCI6Y2FzZSBcImRhdGVcIjpjYXNlIFwiZGF0ZXRpbWVcIjpjYXNlIFwiZGF0ZXRpbWUtbG9jYWxcIjpjYXNlIFwibW9udGhcIjpjYXNlIFwidGltZVwiOmNhc2UgXCJ3ZWVrXCI6YS52YWx1ZT1cIlwiO2EudmFsdWU9YS5kZWZhdWx0VmFsdWU7YnJlYWs7ZGVmYXVsdDphLnZhbHVlPWEudmFsdWV9Yj1hLm5hbWU7XCJcIiE9PWImJihhLm5hbWU9XCJcIik7YS5kZWZhdWx0Q2hlY2tlZD0hYS5kZWZhdWx0Q2hlY2tlZDthLmRlZmF1bHRDaGVja2VkPSFhLmRlZmF1bHRDaGVja2VkO1wiXCIhPT1iJiYoYS5uYW1lPWIpfWZ1bmN0aW9uIFFmKGEpe3ZhciBiPVwiXCI7YWEuQ2hpbGRyZW4uZm9yRWFjaChhLGZ1bmN0aW9uKGEpe251bGw9PWF8fFwic3RyaW5nXCIhPT10eXBlb2YgYSYmXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwoYis9YSl9KTtyZXR1cm4gYn1cbmZ1bmN0aW9uIFJmKGEsYil7YT1CKHtjaGlsZHJlbjp2b2lkIDB9LGIpO2lmKGI9UWYoYi5jaGlsZHJlbikpYS5jaGlsZHJlbj1iO3JldHVybiBhfWZ1bmN0aW9uIFNmKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIitjO2I9bnVsbDtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKXtpZihhW2VdLnZhbHVlPT09Yyl7YVtlXS5zZWxlY3RlZD0hMDtkJiYoYVtlXS5kZWZhdWx0U2VsZWN0ZWQ9ITApO3JldHVybn1udWxsIT09Ynx8YVtlXS5kaXNhYmxlZHx8KGI9YVtlXSl9bnVsbCE9PWImJihiLnNlbGVjdGVkPSEwKX19XG5mdW5jdGlvbiBUZihhLGIpe3ZhciBjPWIudmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6bnVsbCE9Yz9jOmIuZGVmYXVsdFZhbHVlLHdhc011bHRpcGxlOiEhYi5tdWx0aXBsZX19ZnVuY3Rpb24gVWYoYSxiKXtudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0UoXCI5MVwiKTp2b2lkIDA7cmV0dXJuIEIoe30sYix7dmFsdWU6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsY2hpbGRyZW46XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlfSl9ZnVuY3Rpb24gVmYoYSxiKXt2YXIgYz1iLnZhbHVlO251bGw9PWMmJihjPWIuZGVmYXVsdFZhbHVlLGI9Yi5jaGlsZHJlbixudWxsIT1iJiYobnVsbCE9Yz9FKFwiOTJcIik6dm9pZCAwLEFycmF5LmlzQXJyYXkoYikmJigxPj1iLmxlbmd0aD92b2lkIDA6RShcIjkzXCIpLGI9YlswXSksYz1cIlwiK2IpLG51bGw9PWMmJihjPVwiXCIpKTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpcIlwiK2N9fVxuZnVuY3Rpb24gV2YoYSxiKXt2YXIgYz1iLnZhbHVlO251bGwhPWMmJihjPVwiXCIrYyxjIT09YS52YWx1ZSYmKGEudmFsdWU9YyksbnVsbD09Yi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1jKSk7bnVsbCE9Yi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1iLmRlZmF1bHRWYWx1ZSl9ZnVuY3Rpb24gWGYoYSl7dmFyIGI9YS50ZXh0Q29udGVudDtiPT09YS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSYmKGEudmFsdWU9Yil9dmFyIFlmPXtodG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLG1hdGhtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIixzdmc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifTtcbmZ1bmN0aW9uIFpmKGEpe3N3aXRjaChhKXtjYXNlIFwic3ZnXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO2Nhc2UgXCJtYXRoXCI6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCI7ZGVmYXVsdDpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIn19ZnVuY3Rpb24gJGYoYSxiKXtyZXR1cm4gbnVsbD09YXx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1hP1pmKGIpOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj09PWEmJlwiZm9yZWlnbk9iamVjdFwiPT09Yj9cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjphfVxudmFyIGFnPXZvaWQgMCxiZz1mdW5jdGlvbihhKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIE1TQXBwJiZNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbj9mdW5jdGlvbihiLGMsZCxlKXtNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbigpe3JldHVybiBhKGIsYyxkLGUpfSl9OmF9KGZ1bmN0aW9uKGEsYil7aWYoYS5uYW1lc3BhY2VVUkkhPT1ZZi5zdmd8fFwiaW5uZXJIVE1MXCJpbiBhKWEuaW5uZXJIVE1MPWI7ZWxzZXthZz1hZ3x8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTthZy5pbm5lckhUTUw9XCJcXHgzY3N2Z1xceDNlXCIrYitcIlxceDNjL3N2Z1xceDNlXCI7Zm9yKGI9YWcuZmlyc3RDaGlsZDthLmZpcnN0Q2hpbGQ7KWEucmVtb3ZlQ2hpbGQoYS5maXJzdENoaWxkKTtmb3IoO2IuZmlyc3RDaGlsZDspYS5hcHBlbmRDaGlsZChiLmZpcnN0Q2hpbGQpfX0pO1xuZnVuY3Rpb24gY2coYSxiKXtpZihiKXt2YXIgYz1hLmZpcnN0Q2hpbGQ7aWYoYyYmYz09PWEubGFzdENoaWxkJiYzPT09Yy5ub2RlVHlwZSl7Yy5ub2RlVmFsdWU9YjtyZXR1cm59fWEudGV4dENvbnRlbnQ9Yn1cbnZhciBkZz17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYm9yZGVySW1hZ2VPdXRzZXQ6ITAsYm9yZGVySW1hZ2VTbGljZTohMCxib3JkZXJJbWFnZVdpZHRoOiEwLGJveEZsZXg6ITAsYm94RmxleEdyb3VwOiEwLGJveE9yZGluYWxHcm91cDohMCxjb2x1bW5Db3VudDohMCxjb2x1bW5zOiEwLGZsZXg6ITAsZmxleEdyb3c6ITAsZmxleFBvc2l0aXZlOiEwLGZsZXhTaHJpbms6ITAsZmxleE5lZ2F0aXZlOiEwLGZsZXhPcmRlcjohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1NwYW46ITAsZ3JpZFJvd1N0YXJ0OiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3BhbjohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZm9udFdlaWdodDohMCxsaW5lQ2xhbXA6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsdGFiU2l6ZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITAsZmlsbE9wYWNpdHk6ITAsZmxvb2RPcGFjaXR5OiEwLFxuc3RvcE9wYWNpdHk6ITAsc3Ryb2tlRGFzaGFycmF5OiEwLHN0cm9rZURhc2hvZmZzZXQ6ITAsc3Ryb2tlTWl0ZXJsaW1pdDohMCxzdHJva2VPcGFjaXR5OiEwLHN0cm9rZVdpZHRoOiEwfSxlZz1bXCJXZWJraXRcIixcIm1zXCIsXCJNb3pcIixcIk9cIl07T2JqZWN0LmtleXMoZGcpLmZvckVhY2goZnVuY3Rpb24oYSl7ZWcuZm9yRWFjaChmdW5jdGlvbihiKXtiPWIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnN1YnN0cmluZygxKTtkZ1tiXT1kZ1thXX0pfSk7XG5mdW5jdGlvbiBmZyhhLGIpe2E9YS5zdHlsZTtmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD0wPT09Yy5pbmRleE9mKFwiLS1cIik7dmFyIGU9Yzt2YXIgZj1iW2NdO2U9bnVsbD09Znx8XCJib29sZWFuXCI9PT10eXBlb2YgZnx8XCJcIj09PWY/XCJcIjpkfHxcIm51bWJlclwiIT09dHlwZW9mIGZ8fDA9PT1mfHxkZy5oYXNPd25Qcm9wZXJ0eShlKSYmZGdbZV0/KFwiXCIrZikudHJpbSgpOmYrXCJweFwiO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgZ2c9Qih7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIGhnKGEsYixjKXtiJiYoZ2dbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0UoXCIxMzdcIixhLGMoKSk6dm9pZCAwKSxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiYobnVsbCE9Yi5jaGlsZHJlbj9FKFwiNjBcIik6dm9pZCAwLFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJfX2h0bWxcImluIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/dm9pZCAwOkUoXCI2MVwiKSksbnVsbCE9Yi5zdHlsZSYmXCJvYmplY3RcIiE9PXR5cGVvZiBiLnN0eWxlP0UoXCI2MlwiLGMoKSk6dm9pZCAwKX1cbmZ1bmN0aW9uIGlnKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX12YXIgamc9WWYuaHRtbCxrZz1DLnRoYXRSZXR1cm5zKFwiXCIpO1xuZnVuY3Rpb24gbGcoYSxiKXthPTk9PT1hLm5vZGVUeXBlfHwxMT09PWEubm9kZVR5cGU/YTphLm93bmVyRG9jdW1lbnQ7dmFyIGM9SGQoYSk7Yj1TYVtiXTtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTtjLmhhc093blByb3BlcnR5KGUpJiZjW2VdfHwoXCJ0b3BTY3JvbGxcIj09PWU/d2QoXCJ0b3BTY3JvbGxcIixcInNjcm9sbFwiLGEpOlwidG9wRm9jdXNcIj09PWV8fFwidG9wQmx1clwiPT09ZT8od2QoXCJ0b3BGb2N1c1wiLFwiZm9jdXNcIixhKSx3ZChcInRvcEJsdXJcIixcImJsdXJcIixhKSxjLnRvcEJsdXI9ITAsYy50b3BGb2N1cz0hMCk6XCJ0b3BDYW5jZWxcIj09PWU/KHljKFwiY2FuY2VsXCIsITApJiZ3ZChcInRvcENhbmNlbFwiLFwiY2FuY2VsXCIsYSksYy50b3BDYW5jZWw9ITApOlwidG9wQ2xvc2VcIj09PWU/KHljKFwiY2xvc2VcIiwhMCkmJndkKFwidG9wQ2xvc2VcIixcImNsb3NlXCIsYSksYy50b3BDbG9zZT0hMCk6RGQuaGFzT3duUHJvcGVydHkoZSkmJlUoZSxEZFtlXSxhKSxjW2VdPSEwKX19XG52YXIgbWc9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BDYW5QbGF5OlwiY2FucGxheVwiLHRvcENhblBsYXlUaHJvdWdoOlwiY2FucGxheXRocm91Z2hcIix0b3BEdXJhdGlvbkNoYW5nZTpcImR1cmF0aW9uY2hhbmdlXCIsdG9wRW1wdGllZDpcImVtcHRpZWRcIix0b3BFbmNyeXB0ZWQ6XCJlbmNyeXB0ZWRcIix0b3BFbmRlZDpcImVuZGVkXCIsdG9wRXJyb3I6XCJlcnJvclwiLHRvcExvYWRlZERhdGE6XCJsb2FkZWRkYXRhXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BWb2x1bWVDaGFuZ2U6XCJ2b2x1bWVjaGFuZ2VcIixcbnRvcFdhaXRpbmc6XCJ3YWl0aW5nXCJ9O2Z1bmN0aW9uIG5nKGEsYixjLGQpe2M9OT09PWMubm9kZVR5cGU/YzpjLm93bmVyRG9jdW1lbnQ7ZD09PWpnJiYoZD1aZihhKSk7ZD09PWpnP1wic2NyaXB0XCI9PT1hPyhhPWMuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIlxceDNjc2NyaXB0XFx4M2VcXHgzYy9zY3JpcHRcXHgzZVwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTphPVwic3RyaW5nXCI9PT10eXBlb2YgYi5pcz9jLmNyZWF0ZUVsZW1lbnQoYSx7aXM6Yi5pc30pOmMuY3JlYXRlRWxlbWVudChhKTphPWMuY3JlYXRlRWxlbWVudE5TKGQsYSk7cmV0dXJuIGF9ZnVuY3Rpb24gb2coYSxiKXtyZXR1cm4oOT09PWIubm9kZVR5cGU/YjpiLm93bmVyRG9jdW1lbnQpLmNyZWF0ZVRleHROb2RlKGEpfVxuZnVuY3Rpb24gcGcoYSxiLGMsZCl7dmFyIGU9aWcoYixjKTtzd2l0Y2goYil7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO3ZhciBmPWM7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKGYgaW4gbWcpbWcuaGFzT3duUHJvcGVydHkoZikmJlUoZixtZ1tmXSxhKTtmPWM7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImltZ1wiOmNhc2UgXCJpbWFnZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2Y9YzticmVhaztjYXNlIFwiZm9ybVwiOlUoXCJ0b3BSZXNldFwiLFwicmVzZXRcIixhKTtVKFwidG9wU3VibWl0XCIsXCJzdWJtaXRcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImlucHV0XCI6TWYoYSxjKTtmPUxmKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtcbmxnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwib3B0aW9uXCI6Zj1SZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpUZihhLGMpO2Y9Qih7fSxjLHt2YWx1ZTp2b2lkIDB9KTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpWZihhLGMpO2Y9VWYoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGQsXCJvbkNoYW5nZVwiKTticmVhaztkZWZhdWx0OmY9Y31oZyhiLGYsa2cpO3ZhciBnPWYsaDtmb3IoaCBpbiBnKWlmKGcuaGFzT3duUHJvcGVydHkoaCkpe3ZhciBrPWdbaF07XCJzdHlsZVwiPT09aD9mZyhhLGssa2cpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWg/KGs9az9rLl9faHRtbDp2b2lkIDAsbnVsbCE9ayYmYmcoYSxrKSk6XCJjaGlsZHJlblwiPT09aD9cInN0cmluZ1wiPT09dHlwZW9mIGs/KFwidGV4dGFyZWFcIiE9PWJ8fFwiXCIhPT1rKSYmY2coYSxrKTpcIm51bWJlclwiPT09dHlwZW9mIGsmJmNnKGEsXG5cIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1oJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09aCYmXCJhdXRvRm9jdXNcIiE9PWgmJihSYS5oYXNPd25Qcm9wZXJ0eShoKT9udWxsIT1rJiZsZyhkLGgpOmU/S2YoYSxoLGspOm51bGwhPWsmJklmKGEsaCxrKSl9c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOkJjKGEpO1BmKGEsYyk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6QmMoYSk7WGYoYSxjKTticmVhaztjYXNlIFwib3B0aW9uXCI6bnVsbCE9Yy52YWx1ZSYmYS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGMudmFsdWUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLm11bHRpcGxlPSEhYy5tdWx0aXBsZTtiPWMudmFsdWU7bnVsbCE9Yj9TZihhLCEhYy5tdWx0aXBsZSxiLCExKTpudWxsIT1jLmRlZmF1bHRWYWx1ZSYmU2YoYSwhIWMubXVsdGlwbGUsYy5kZWZhdWx0VmFsdWUsITApO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGYub25DbGljayYmKGEub25jbGljaz1cbkMpfX1cbmZ1bmN0aW9uIHNnKGEsYixjLGQsZSl7dmFyIGY9bnVsbDtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6Yz1MZihhLGMpO2Q9TGYoYSxkKTtmPVtdO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpjPVJmKGEsYyk7ZD1SZihhLGQpO2Y9W107YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmM9Qih7fSxjLHt2YWx1ZTp2b2lkIDB9KTtkPUIoe30sZCx7dmFsdWU6dm9pZCAwfSk7Zj1bXTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpjPVVmKGEsYyk7ZD1VZihhLGQpO2Y9W107YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5vbkNsaWNrJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5vbkNsaWNrJiYoYS5vbmNsaWNrPUMpfWhnKGIsZCxrZyk7dmFyIGcsaDthPW51bGw7Zm9yKGcgaW4gYylpZighZC5oYXNPd25Qcm9wZXJ0eShnKSYmYy5oYXNPd25Qcm9wZXJ0eShnKSYmbnVsbCE9Y1tnXSlpZihcInN0eWxlXCI9PT1nKWZvcihoIGluIGI9Y1tnXSxiKWIuaGFzT3duUHJvcGVydHkoaCkmJihhfHwoYT17fSksYVtoXT1cblwiXCIpO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1nJiZcImNoaWxkcmVuXCIhPT1nJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ZyYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWcmJlwiYXV0b0ZvY3VzXCIhPT1nJiYoUmEuaGFzT3duUHJvcGVydHkoZyk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGcsbnVsbCkpO2ZvcihnIGluIGQpe3ZhciBrPWRbZ107Yj1udWxsIT1jP2NbZ106dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkoZykmJmshPT1iJiYobnVsbCE9a3x8bnVsbCE9YikpaWYoXCJzdHlsZVwiPT09ZylpZihiKXtmb3IoaCBpbiBiKSFiLmhhc093blByb3BlcnR5KGgpfHxrJiZrLmhhc093blByb3BlcnR5KGgpfHwoYXx8KGE9e30pLGFbaF09XCJcIik7Zm9yKGggaW4gaylrLmhhc093blByb3BlcnR5KGgpJiZiW2hdIT09a1toXSYmKGF8fChhPXt9KSxhW2hdPWtbaF0pfWVsc2UgYXx8KGZ8fChmPVtdKSxmLnB1c2goZyxhKSksYT1rO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1cbmc/KGs9az9rLl9faHRtbDp2b2lkIDAsYj1iP2IuX19odG1sOnZvaWQgMCxudWxsIT1rJiZiIT09ayYmKGY9Znx8W10pLnB1c2goZyxcIlwiK2spKTpcImNoaWxkcmVuXCI9PT1nP2I9PT1rfHxcInN0cmluZ1wiIT09dHlwZW9mIGsmJlwibnVtYmVyXCIhPT10eXBlb2Yga3x8KGY9Znx8W10pLnB1c2goZyxcIlwiK2spOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1nJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZyYmKFJhLmhhc093blByb3BlcnR5KGcpPyhudWxsIT1rJiZsZyhlLGcpLGZ8fGI9PT1rfHwoZj1bXSkpOihmPWZ8fFtdKS5wdXNoKGcsaykpfWEmJihmPWZ8fFtdKS5wdXNoKFwic3R5bGVcIixhKTtyZXR1cm4gZn1cbmZ1bmN0aW9uIHRnKGEsYixjLGQsZSl7XCJpbnB1dFwiPT09YyYmXCJyYWRpb1wiPT09ZS50eXBlJiZudWxsIT1lLm5hbWUmJk5mKGEsZSk7aWcoYyxkKTtkPWlnKGMsZSk7Zm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKz0yKXt2YXIgZz1iW2ZdLGg9YltmKzFdO1wic3R5bGVcIj09PWc/ZmcoYSxoLGtnKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1nP2JnKGEsaCk6XCJjaGlsZHJlblwiPT09Zz9jZyhhLGgpOmQ/bnVsbCE9aD9LZihhLGcsaCk6YS5yZW1vdmVBdHRyaWJ1dGUoZyk6bnVsbCE9aD9JZihhLGcsaCk6SmYoYSxnKX1zd2l0Y2goYyl7Y2FzZSBcImlucHV0XCI6T2YoYSxlKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpXZihhLGUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlPXZvaWQgMCxiPWEuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSxhLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFlLm11bHRpcGxlLGM9ZS52YWx1ZSxudWxsIT1jP1NmKGEsXG4hIWUubXVsdGlwbGUsYywhMSk6YiE9PSEhZS5tdWx0aXBsZSYmKG51bGwhPWUuZGVmYXVsdFZhbHVlP1NmKGEsISFlLm11bHRpcGxlLGUuZGVmYXVsdFZhbHVlLCEwKTpTZihhLCEhZS5tdWx0aXBsZSxlLm11bHRpcGxlP1tdOlwiXCIsITEpKX19XG5mdW5jdGlvbiB1ZyhhLGIsYyxkLGUpe3N3aXRjaChiKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOlUoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKHZhciBmIGluIG1nKW1nLmhhc093blByb3BlcnR5KGYpJiZVKGYsbWdbZl0sYSk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO1UoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcImZvcm1cIjpVKFwidG9wUmVzZXRcIixcInJlc2V0XCIsYSk7VShcInRvcFN1Ym1pdFwiLFwic3VibWl0XCIsYSk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTticmVhaztjYXNlIFwiaW5wdXRcIjpNZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZSxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpUZihhLGMpO1xuVShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhlLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6VmYoYSxjKSxVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpLGxnKGUsXCJvbkNoYW5nZVwiKX1oZyhiLGMsa2cpO2Q9bnVsbDtmb3IodmFyIGcgaW4gYyljLmhhc093blByb3BlcnR5KGcpJiYoZj1jW2ddLFwiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBmP2EudGV4dENvbnRlbnQhPT1mJiYoZD1bXCJjaGlsZHJlblwiLGZdKTpcIm51bWJlclwiPT09dHlwZW9mIGYmJmEudGV4dENvbnRlbnQhPT1cIlwiK2YmJihkPVtcImNoaWxkcmVuXCIsXCJcIitmXSk6UmEuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWYmJmxnKGUsZykpO3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpCYyhhKTtQZihhLGMpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkJjKGEpO1hmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLm9uQ2xpY2smJlxuKGEub25jbGljaz1DKX1yZXR1cm4gZH1mdW5jdGlvbiB2ZyhhLGIpe3JldHVybiBhLm5vZGVWYWx1ZSE9PWJ9XG52YXIgd2c9T2JqZWN0LmZyZWV6ZSh7Y3JlYXRlRWxlbWVudDpuZyxjcmVhdGVUZXh0Tm9kZTpvZyxzZXRJbml0aWFsUHJvcGVydGllczpwZyxkaWZmUHJvcGVydGllczpzZyx1cGRhdGVQcm9wZXJ0aWVzOnRnLGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6dWcsZGlmZkh5ZHJhdGVkVGV4dDp2Zyx3YXJuRm9yVW5tYXRjaGVkVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50OmZ1bmN0aW9uKCl7fSx3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6ZnVuY3Rpb24oKXt9LHJlc3RvcmVDb250cm9sbGVkU3RhdGU6ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpPZihhLGMpO2I9Yy5uYW1lO2lmKFwicmFkaW9cIj09PWMudHlwZSYmbnVsbCE9Yil7Zm9yKGM9YTtjLnBhcmVudE5vZGU7KWM9XG5jLnBhcmVudE5vZGU7Yz1jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFtuYW1lXFx4M2RcIitKU09OLnN0cmluZ2lmeShcIlwiK2IpKyddW3R5cGVcXHgzZFwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPXJiKGQpO2U/dm9pZCAwOkUoXCI5MFwiKTtDYyhkKTtPZihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6V2YoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJlNmKGEsISFjLm11bHRpcGxlLGIsITEpfX19KTtuYy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KHdnKTt2YXIgeGc9bnVsbCxNZz1udWxsO2Z1bmN0aW9uIE5nKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1cbmZ1bmN0aW9uIE9nKGEpe2E9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbDtyZXR1cm4hKCFhfHwxIT09YS5ub2RlVHlwZXx8IWEuaGFzQXR0cmlidXRlKFwiZGF0YS1yZWFjdHJvb3RcIikpfVxudmFyIFo9b2Yoe2dldFJvb3RIb3N0Q29udGV4dDpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVUeXBlO3N3aXRjaChiKXtjYXNlIDk6Y2FzZSAxMTphPShhPWEuZG9jdW1lbnRFbGVtZW50KT9hLm5hbWVzcGFjZVVSSTokZihudWxsLFwiXCIpO2JyZWFrO2RlZmF1bHQ6Yj04PT09Yj9hLnBhcmVudE5vZGU6YSxhPWIubmFtZXNwYWNlVVJJfHxudWxsLGI9Yi50YWdOYW1lLGE9JGYoYSxiKX1yZXR1cm4gYX0sZ2V0Q2hpbGRIb3N0Q29udGV4dDpmdW5jdGlvbihhLGIpe3JldHVybiAkZihhLGIpfSxnZXRQdWJsaWNJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gYX0scHJlcGFyZUZvckNvbW1pdDpmdW5jdGlvbigpe3hnPXRkO3ZhciBhPWRhKCk7aWYoS2QoYSkpe2lmKFwic2VsZWN0aW9uU3RhcnRcImluIGEpdmFyIGI9e3N0YXJ0OmEuc2VsZWN0aW9uU3RhcnQsZW5kOmEuc2VsZWN0aW9uRW5kfTtlbHNlIGE6e3ZhciBjPXdpbmRvdy5nZXRTZWxlY3Rpb24mJndpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbmlmKGMmJjAhPT1jLnJhbmdlQ291bnQpe2I9Yy5hbmNob3JOb2RlO3ZhciBkPWMuYW5jaG9yT2Zmc2V0LGU9Yy5mb2N1c05vZGU7Yz1jLmZvY3VzT2Zmc2V0O3RyeXtiLm5vZGVUeXBlLGUubm9kZVR5cGV9Y2F0Y2goeil7Yj1udWxsO2JyZWFrIGF9dmFyIGY9MCxnPS0xLGg9LTEsaz0wLHE9MCx2PWEseT1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHU7Oyl7diE9PWJ8fDAhPT1kJiYzIT09di5ub2RlVHlwZXx8KGc9ZitkKTt2IT09ZXx8MCE9PWMmJjMhPT12Lm5vZGVUeXBlfHwoaD1mK2MpOzM9PT12Lm5vZGVUeXBlJiYoZis9di5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHU9di5maXJzdENoaWxkKSlicmVhazt5PXY7dj11fWZvcig7Oyl7aWYodj09PWEpYnJlYWsgYjt5PT09YiYmKytrPT09ZCYmKGc9Zik7eT09PWUmJisrcT09PWMmJihoPWYpO2lmKG51bGwhPT0odT12Lm5leHRTaWJsaW5nKSlicmVhazt2PXk7eT12LnBhcmVudE5vZGV9dj11fWI9LTE9PT1nfHwtMT09PWg/bnVsbDpcbntzdGFydDpnLGVuZDpofX1lbHNlIGI9bnVsbH1iPWJ8fHtzdGFydDowLGVuZDowfX1lbHNlIGI9bnVsbDtNZz17Zm9jdXNlZEVsZW06YSxzZWxlY3Rpb25SYW5nZTpifTt1ZCghMSl9LHJlc2V0QWZ0ZXJDb21taXQ6ZnVuY3Rpb24oKXt2YXIgYT1NZyxiPWRhKCksYz1hLmZvY3VzZWRFbGVtLGQ9YS5zZWxlY3Rpb25SYW5nZTtpZihiIT09YyYmZmEoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGMpKXtpZihLZChjKSlpZihiPWQuc3RhcnQsYT1kLmVuZCx2b2lkIDA9PT1hJiYoYT1iKSxcInNlbGVjdGlvblN0YXJ0XCJpbiBjKWMuc2VsZWN0aW9uU3RhcnQ9YixjLnNlbGVjdGlvbkVuZD1NYXRoLm1pbihhLGMudmFsdWUubGVuZ3RoKTtlbHNlIGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pe2I9d2luZG93LmdldFNlbGVjdGlvbigpO3ZhciBlPWNbRWIoKV0ubGVuZ3RoO2E9TWF0aC5taW4oZC5zdGFydCxlKTtkPXZvaWQgMD09PWQuZW5kP2E6TWF0aC5taW4oZC5lbmQsZSk7IWIuZXh0ZW5kJiZhPlxuZCYmKGU9ZCxkPWEsYT1lKTtlPUpkKGMsYSk7dmFyIGY9SmQoYyxkKTtpZihlJiZmJiYoMSE9PWIucmFuZ2VDb3VudHx8Yi5hbmNob3JOb2RlIT09ZS5ub2RlfHxiLmFuY2hvck9mZnNldCE9PWUub2Zmc2V0fHxiLmZvY3VzTm9kZSE9PWYubm9kZXx8Yi5mb2N1c09mZnNldCE9PWYub2Zmc2V0KSl7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtnLnNldFN0YXJ0KGUubm9kZSxlLm9mZnNldCk7Yi5yZW1vdmVBbGxSYW5nZXMoKTthPmQ/KGIuYWRkUmFuZ2UoZyksYi5leHRlbmQoZi5ub2RlLGYub2Zmc2V0KSk6KGcuc2V0RW5kKGYubm9kZSxmLm9mZnNldCksYi5hZGRSYW5nZShnKSl9fWI9W107Zm9yKGE9YzthPWEucGFyZW50Tm9kZTspMT09PWEubm9kZVR5cGUmJmIucHVzaCh7ZWxlbWVudDphLGxlZnQ6YS5zY3JvbGxMZWZ0LHRvcDphLnNjcm9sbFRvcH0pO2lhKGMpO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspYT1iW2NdLGEuZWxlbWVudC5zY3JvbGxMZWZ0PWEubGVmdCxhLmVsZW1lbnQuc2Nyb2xsVG9wPVxuYS50b3B9TWc9bnVsbDt1ZCh4Zyk7eGc9bnVsbH0sY3JlYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCxlKXthPW5nKGEsYixjLGQpO2FbUV09ZTthW29iXT1iO3JldHVybiBhfSxhcHBlbmRJbml0aWFsQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjpmdW5jdGlvbihhLGIsYyxkKXtwZyhhLGIsYyxkKTthOntzd2l0Y2goYil7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjphPSEhYy5hdXRvRm9jdXM7YnJlYWsgYX1hPSExfXJldHVybiBhfSxwcmVwYXJlVXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHNnKGEsYixjLGQsZSl9LHNob3VsZFNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuXCJ0ZXh0YXJlYVwiPT09YXx8XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm51bWJlclwiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwib2JqZWN0XCI9PT1cbnR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJzdHJpbmdcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbH0sc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTpmdW5jdGlvbihhLGIpe3JldHVybiEhYi5oaWRkZW59LGNyZWF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkKXthPW9nKGEsYik7YVtRXT1kO3JldHVybiBhfSxub3c6cmYsbXV0YXRpb246e2NvbW1pdE1vdW50OmZ1bmN0aW9uKGEpe2EuZm9jdXMoKX0sY29tbWl0VXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7YVtvYl09ZTt0ZyhhLGIsYyxkLGUpfSxyZXNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEpe2EudGV4dENvbnRlbnQ9XCJcIn0sY29tbWl0VGV4dFVwZGF0ZTpmdW5jdGlvbihhLGIsYyl7YS5ub2RlVmFsdWU9Y30sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxhcHBlbmRDaGlsZFRvQ29udGFpbmVyOmZ1bmN0aW9uKGEsXG5iKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGIsYSk6YS5hcHBlbmRDaGlsZChiKX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGEsYixjKXthLmluc2VydEJlZm9yZShiLGMpfSxpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTpmdW5jdGlvbihhLGIsYyl7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGMpOmEuaW5zZXJ0QmVmb3JlKGIsYyl9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGEsYil7YS5yZW1vdmVDaGlsZChiKX0scmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpOmEucmVtb3ZlQ2hpbGQoYil9fSxoeWRyYXRpb246e2Nhbkh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIpe3JldHVybiAxIT09YS5ub2RlVHlwZXx8Yi50b0xvd2VyQ2FzZSgpIT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpP251bGw6YX0sY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLFxuYil7cmV0dXJuXCJcIj09PWJ8fDMhPT1hLm5vZGVUeXBlP251bGw6YX0sZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nOmZ1bmN0aW9uKGEpe2ZvcihhPWEubmV4dFNpYmxpbmc7YSYmMSE9PWEubm9kZVR5cGUmJjMhPT1hLm5vZGVUeXBlOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9LGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOmZ1bmN0aW9uKGEpe2ZvcihhPWEuZmlyc3RDaGlsZDthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX0saHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXthW1FdPWY7YVtvYl09YztyZXR1cm4gdWcoYSxiLGMsZSxkKX0saHlkcmF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyl7YVtRXT1jO3JldHVybiB2ZyhhLGIpfSxkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxcbmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90SHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9fSxzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s6c2YsY2FuY2VsRGVmZXJyZWRDYWxsYmFjazp0Zix1c2VTeW5jU2NoZWR1bGluZzohMH0pO3JjPVouYmF0Y2hlZFVwZGF0ZXM7XG5mdW5jdGlvbiBQZyhhLGIsYyxkLGUpe05nKGMpP3ZvaWQgMDpFKFwiMjAwXCIpO3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKVoudXBkYXRlQ29udGFpbmVyKGIsZixhLGUpO2Vsc2V7ZD1kfHxPZyhjKTtpZighZClmb3IoZj12b2lkIDA7Zj1jLmxhc3RDaGlsZDspYy5yZW1vdmVDaGlsZChmKTt2YXIgZz1aLmNyZWF0ZUNvbnRhaW5lcihjLGQpO2Y9Yy5fcmVhY3RSb290Q29udGFpbmVyPWc7Wi51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCl7Wi51cGRhdGVDb250YWluZXIoYixnLGEsZSl9KX1yZXR1cm4gWi5nZXRQdWJsaWNSb290SW5zdGFuY2UoZil9ZnVuY3Rpb24gUWcoYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtOZyhiKT92b2lkIDA6RShcIjIwMFwiKTtyZXR1cm4gcGYoYSxiLG51bGwsYyl9XG5mdW5jdGlvbiBSZyhhLGIpe3RoaXMuX3JlYWN0Um9vdENvbnRhaW5lcj1aLmNyZWF0ZUNvbnRhaW5lcihhLGIpfVJnLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSxiKXtaLnVwZGF0ZUNvbnRhaW5lcihhLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGIpfTtSZy5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbihhKXtaLnVwZGF0ZUNvbnRhaW5lcihudWxsLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGEpfTtcbnZhciBTZz17Y3JlYXRlUG9ydGFsOlFnLGZpbmRET01Ob2RlOmZ1bmN0aW9uKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoMT09PWEubm9kZVR5cGUpcmV0dXJuIGE7dmFyIGI9YS5fcmVhY3RJbnRlcm5hbEZpYmVyO2lmKGIpcmV0dXJuIFouZmluZEhvc3RJbnN0YW5jZShiKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5yZW5kZXI/RShcIjE4OFwiKTpFKFwiMjEzXCIsT2JqZWN0LmtleXMoYSkpfSxoeWRyYXRlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUGcobnVsbCxhLGIsITAsYyl9LHJlbmRlcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFBnKG51bGwsYSxiLCExLGMpfSx1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjpmdW5jdGlvbihhLGIsYyxkKXtudWxsPT1hfHx2b2lkIDA9PT1hLl9yZWFjdEludGVybmFsRmliZXI/RShcIjM4XCIpOnZvaWQgMDtyZXR1cm4gUGcoYSxiLGMsITEsZCl9LHVubW91bnRDb21wb25lbnRBdE5vZGU6ZnVuY3Rpb24oYSl7TmcoYSk/dm9pZCAwOlxuRShcIjQwXCIpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KFoudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe1BnKG51bGwsbnVsbCxhLCExLGZ1bmN0aW9uKCl7YS5fcmVhY3RSb290Q29udGFpbmVyPW51bGx9KX0pLCEwKTohMX0sdW5zdGFibGVfY3JlYXRlUG9ydGFsOlFnLHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOnRjLHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlczpaLmRlZmVycmVkVXBkYXRlcyxmbHVzaFN5bmM6Wi5mbHVzaFN5bmMsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e0V2ZW50UGx1Z2luSHViOm1iLEV2ZW50UGx1Z2luUmVnaXN0cnk6VmEsRXZlbnRQcm9wYWdhdG9yczpDYixSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6cWMsUmVhY3RET01Db21wb25lbnRUcmVlOnNiLFJlYWN0RE9NRXZlbnRMaXN0ZW5lcjp4ZH19O1xuWi5pbmplY3RJbnRvRGV2VG9vbHMoe2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOnBiLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOlwiMTYuMi4wXCIscmVuZGVyZXJQYWNrYWdlTmFtZTpcInJlYWN0LWRvbVwifSk7dmFyIFRnPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6U2d9KSxVZz1UZyYmU2d8fFRnO21vZHVsZS5leHBvcnRzPVVnW1wiZGVmYXVsdFwiXT9VZ1tcImRlZmF1bHRcIl06VWc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzVGV4dE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICB2YXIgZG9jID0gb2JqZWN0ID8gb2JqZWN0Lm93bmVyRG9jdW1lbnQgfHwgb2JqZWN0IDogZG9jdW1lbnQ7XG4gIHZhciBkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcbnZhciBoeXBoZW5hdGVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUnKTtcbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG4hUmVhY3QgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTSB3YXMgbG9hZGVkIGJlZm9yZSBSZWFjdC4gTWFrZSBzdXJlIHlvdSBsb2FkIHRoZSBSZWFjdCBwYWNrYWdlIGJlZm9yZSBsb2FkaW5nIFJlYWN0RE9NLicpIDogdm9pZCAwO1xuXG4vLyBUaGVzZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhbGwgbG93ZXJjYXNlIHRvIGFsbG93IGZvclxuLy8gY2FzZSBpbnNlbnNpdGl2ZSBjaGVja3NcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IHRydWUsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB0cnVlLFxuICBkZWZhdWx0VmFsdWU6IHRydWUsXG4gIGRlZmF1bHRDaGVja2VkOiB0cnVlLFxuICBpbm5lckhUTUw6IHRydWUsXG4gIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiB0cnVlLFxuICBzdHlsZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gY2hlY2tNYXNrKHZhbHVlLCBiaXRtYXNrKSB7XG4gIHJldHVybiAodmFsdWUgJiBiaXRtYXNrKSA9PT0gYml0bWFzaztcbn1cblxudmFyIERPTVByb3BlcnR5SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogTWFwcGluZyBmcm9tIG5vcm1hbGl6ZWQsIGNhbWVsY2FzZWQgcHJvcGVydHkgbmFtZXMgdG8gYSBjb25maWd1cmF0aW9uIHRoYXRcbiAgICogc3BlY2lmaWVzIGhvdyB0aGUgYXNzb2NpYXRlZCBET00gcHJvcGVydHkgc2hvdWxkIGJlIGFjY2Vzc2VkIG9yIHJlbmRlcmVkLlxuICAgKi9cbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MSxcbiAgSEFTX0JPT0xFQU5fVkFMVUU6IDB4NCxcbiAgSEFTX05VTUVSSUNfVkFMVUU6IDB4OCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MTAgfCAweDgsXG4gIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU6IDB4MjAsXG4gIEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTogMHg0MCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBQcm9wZXJ0aWVzOiBvYmplY3QgbWFwcGluZyBET00gcHJvcGVydHkgbmFtZSB0byBvbmUgb2YgdGhlXG4gICAqIERPTVByb3BlcnR5SW5qZWN0aW9uIGNvbnN0YW50cyBvciBudWxsLiBJZiB5b3VyIGF0dHJpYnV0ZSBpc24ndCBpbiBoZXJlLFxuICAgKiBpdCB3b24ndCBnZXQgd3JpdHRlbiB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZS4gQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSAqKmxvd2VyY2FzZSoqXG4gICAqIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXNwYWNlczogb2JqZWN0IG1hcHBpbmcgUmVhY3QgYXR0cmlidXRlIG5hbWUgdG8gdGhlIERPTVxuICAgKiBhdHRyaWJ1dGUgbmFtZXNwYWNlIFVSTC4gKEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSBubyBuYW1lc3BhY2UuKVxuICAgKlxuICAgKiBET01Qcm9wZXJ0eU5hbWVzOiBzaW1pbGFyIHRvIERPTUF0dHJpYnV0ZU5hbWVzIGJ1dCBmb3IgRE9NIHByb3BlcnRpZXMuXG4gICAqIFByb3BlcnR5IG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIHRoZSBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTU11dGF0aW9uTWV0aG9kczogUHJvcGVydGllcyB0aGF0IHJlcXVpcmUgc3BlY2lhbCBtdXRhdGlvbiBtZXRob2RzLiBJZlxuICAgKiBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgdGhlIG11dGF0aW9uIG1ldGhvZCBzaG91bGQgdW5zZXQgdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gZG9tUHJvcGVydHlDb25maWcgdGhlIGNvbmZpZyBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAqL1xuICBpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzogZnVuY3Rpb24gKGRvbVByb3BlcnR5Q29uZmlnKSB7XG4gICAgdmFyIEluamVjdGlvbiA9IERPTVByb3BlcnR5SW5qZWN0aW9uO1xuICAgIHZhciBQcm9wZXJ0aWVzID0gZG9tUHJvcGVydHlDb25maWcuUHJvcGVydGllcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXNwYWNlcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBpbnZhcmlhbnQoZmFsc2UsIFwiaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91J3JlIHRyeWluZyB0byBpbmplY3QgRE9NIHByb3BlcnR5ICclcycgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy5cIiwgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICB2YXIgbG93ZXJDYXNlZCA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcHJvcENvbmZpZyA9IFByb3BlcnRpZXNbcHJvcE5hbWVdO1xuXG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0ge1xuICAgICAgICBhdHRyaWJ1dGVOYW1lOiBsb3dlckNhc2VkLFxuICAgICAgICBhdHRyaWJ1dGVOYW1lc3BhY2U6IG51bGwsXG4gICAgICAgIHByb3BlcnR5TmFtZTogcHJvcE5hbWUsXG4gICAgICAgIG11dGF0aW9uTWV0aG9kOiBudWxsLFxuXG4gICAgICAgIG11c3RVc2VQcm9wZXJ0eTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWSksXG4gICAgICAgIGhhc0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc051bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzU3RyaW5nQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSlcbiAgICAgIH07XG4gICAgICAhKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICsgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgPD0gMSkgPyBpbnZhcmlhbnQoZmFsc2UsIFwiRE9NUHJvcGVydHk6IFZhbHVlIGNhbiBiZSBvbmUgb2YgYm9vbGVhbiwgb3ZlcmxvYWRlZCBib29sZWFuLCBvciBudW1lcmljIHZhbHVlLCBidXQgbm90IGEgY29tYmluYXRpb246ICVzXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcblxuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIC8vIERvd25jYXNlIHJlZmVyZW5jZXMgdG8gd2hpdGVsaXN0IHByb3BlcnRpZXMgdG8gY2hlY2sgZm9yIG1lbWJlcnNoaXBcbiAgICAgIC8vIHdpdGhvdXQgY2FzZS1zZW5zaXRpdml0eS4gVGhpcyBhbGxvd3MgdGhlIHdoaXRlbGlzdCB0byBwaWNrIHVwXG4gICAgICAvLyBgYWxsb3dmdWxsc2NyZWVuYCwgd2hpY2ggc2hvdWxkIGJlIHdyaXR0ZW4gdXNpbmcgdGhlIHByb3BlcnR5IGNvbmZpZ3VyYXRpb25cbiAgICAgIC8vIGZvciBgYWxsb3dGdWxsc2NyZWVuYFxuICAgICAgcHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfQ0hBUiA9IEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyBcIlxcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXCI7XG5cblxudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xuXG4vKipcbiAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICogdGhlIHByb3BlcnR5IGluIHRoZSBET00uIEVhY2ggb2JqZWN0IGNvbnRhaW5zOlxuICpcbiAqIGF0dHJpYnV0ZU5hbWU6XG4gKiAgIFVzZWQgd2hlbiByZW5kZXJpbmcgbWFya3VwIG9yIHdpdGggYCpBdHRyaWJ1dGUoKWAuXG4gKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAqIHByb3BlcnR5TmFtZTpcbiAqICAgVXNlZCBvbiBET00gbm9kZSBpbnN0YW5jZXMuIChUaGlzIGluY2x1ZGVzIHByb3BlcnRpZXMgdGhhdCBtdXRhdGUgZHVlIHRvXG4gKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICogbXV0YXRpb25NZXRob2Q6XG4gKiAgIElmIG5vbi1udWxsLCB1c2VkIGluc3RlYWQgb2YgdGhlIHByb3BlcnR5IG9yIGBzZXRBdHRyaWJ1dGUoKWAgYWZ0ZXJcbiAqICAgaW5pdGlhbCByZW5kZXIuXG4gKiBtdXN0VXNlUHJvcGVydHk6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgYWNjZXNzZWQgYW5kIG11dGF0ZWQgYXMgYW4gb2JqZWN0IHByb3BlcnR5LlxuICogaGFzQm9vbGVhblZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAqIGhhc051bWVyaWNWYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYyBhbmQgc2hvdWxkIGJlXG4gKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmVcbiAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBjYW4gYmUgdXNlZCBhcyBhIGZsYWcgYXMgd2VsbCBhcyB3aXRoIGEgdmFsdWUuXG4gKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICogICBzdHJpY3RseSBlcXVhbCB0byB0cnVlOyBwcmVzZW50IHdpdGggYSB2YWx1ZSBvdGhlcndpc2UuXG4gKi9cbnZhciBwcm9wZXJ0aWVzID0ge307XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBwcm9wZXJ0eSBuYW1lIGlzIGEgd3JpdGVhYmxlIGF0dHJpYnV0ZS5cbiAqIEBtZXRob2RcbiAqL1xuZnVuY3Rpb24gc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiBzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUobmFtZSk7XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmdW5jdGlvbiwgc3ltYm9sXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpIHtcbiAgaWYgKGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgIHJldHVybiBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNTdHJpbmdCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU7XG4gIH1cbiAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgcmV0dXJuIHByZWZpeCA9PT0gJ2RhdGEtJyB8fCBwcmVmaXggPT09ICdhcmlhLSc7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiBhIHByb3BlcnR5IG5hbWUgaXMgd2l0aGluIHRoZSBsaXN0IG9mIHByb3BlcnRpZXNcbiAqIHJlc2VydmVkIGZvciBpbnRlcm5hbCBSZWFjdCBvcGVyYXRpb25zLiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZFxuICogbm90IGJlIHNldCBvbiBhbiBIVE1MIGVsZW1lbnQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgbmFtZSBpcyB3aXRoaW4gcmVzZXJ2ZWQgcHJvcHNcbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZFByb3AobmFtZSkge1xuICByZXR1cm4gUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkobmFtZSk7XG59XG5cbnZhciBpbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG52YXIgSFRNTERPTVByb3BlcnR5Q29uZmlnID0ge1xuICAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gIC8vIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gIC8vIG5hbWUgd2FybmluZ3MuXG4gIFByb3BlcnRpZXM6IHtcbiAgICBhbGxvd0Z1bGxTY3JlZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIHNwZWNpZmllcyB0YXJnZXQgY29udGV4dCBmb3IgbGlua3Mgd2l0aCBgcHJlbG9hZGAgdHlwZVxuICAgIGFzeW5jOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4gICAgLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuICAgIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb2xzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBjb250ZW50RWRpdGFibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBjb250cm9sczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlzYWJsZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRvd25sb2FkOiBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLFxuICAgIGRyYWdnYWJsZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGxvb3A6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIENhdXRpb247IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4gICAgLy8gZGlzYWJsZWQgd2l0aCBgcmVtb3ZlQXR0cmlidXRlYC5cbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBub1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBvcGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBwbGF5c0lubGluZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2NvcGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIC8vIHN1cHBvcnQgZm9yIHByb2plY3RpbmcgcmVndWxhciBET00gRWxlbWVudHMgdmlhIFYxIG5hbWVkIHNsb3RzICggc2hhZG93IGRvbSApXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIFN0eWxlIG11c3QgYmUgZXhwbGljaXRseSBzZXQgaW4gdGhlIGF0dHJpYnV0ZSBsaXN0LiBSZWFjdCBjb21wb25lbnRzXG4gICAgLy8gZXhwZWN0IGEgc3R5bGUgb2JqZWN0XG4gICAgc3R5bGU6IDAsXG4gICAgLy8gS2VlcCBpdCBpbiB0aGUgd2hpdGVsaXN0IGJlY2F1c2UgaXQgaXMgY2FzZS1zZW5zaXRpdmUgZm9yIFNWRy5cbiAgICB0YWJJbmRleDogMCxcbiAgICAvLyBpdGVtU2NvcGUgaXMgZm9yIGZvciBNaWNyb2RhdGEgc3VwcG9ydC5cbiAgICAvLyBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBUaGVzZSBhdHRyaWJ1dGVzIG11c3Qgc3RheSBpbiB0aGUgd2hpdGUtbGlzdCBiZWNhdXNlIHRoZXkgaGF2ZVxuICAgIC8vIGRpZmZlcmVudCBhdHRyaWJ1dGUgbmFtZXMgKHNlZSBET01BdHRyaWJ1dGVOYW1lcyBiZWxvdylcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGNsYXNzTmFtZTogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICAvLyBBdHRyaWJ1dGVzIHdpdGggbXV0YXRpb24gbWV0aG9kcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgd2hpdGVsaXN0XG4gICAgLy8gU2V0IHRoZSBzdHJpbmcgYm9vbGVhbiBmbGFnIHRvIGFsbG93IHRoZSBiZWhhdmlvclxuICAgIHZhbHVlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01NdXRhdGlvbk1ldGhvZHM6IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE51bWJlciBpbnB1dHMgZ2V0IHNwZWNpYWwgdHJlYXRtZW50IGR1ZSB0byBzb21lIGVkZ2UgY2FzZXMgaW5cbiAgICAgIC8vIENocm9tZS4gTGV0IGV2ZXJ5dGhpbmcgZWxzZSBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSBhcyBub3JtYWwuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTMjaXNzdWVjb21tZW50LTIzNjA3NDMyNlxuICAgICAgaWYgKG5vZGUudHlwZSAhPT0gJ251bWJlcicgfHwgbm9kZS5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykgPT09IGZhbHNlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbGlkaXR5ICYmICFub2RlLnZhbGlkaXR5LmJhZElucHV0ICYmIG5vZGUub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBub2RlKSB7XG4gICAgICAgIC8vIERvbid0IGFzc2lnbiBhbiBhdHRyaWJ1dGUgaWYgdmFsaWRhdGlvbiByZXBvcnRzIGJhZFxuICAgICAgICAvLyBpbnB1dC4gQ2hyb21lIHdpbGwgY2xlYXIgdGhlIHZhbHVlLiBBZGRpdGlvbmFsbHksIGRvbid0XG4gICAgICAgIC8vIG9wZXJhdGUgb24gaW5wdXRzIHRoYXQgaGF2ZSBmb2N1cywgb3RoZXJ3aXNlIENocm9tZSBtaWdodFxuICAgICAgICAvLyBzdHJpcCBvZmYgdHJhaWxpbmcgZGVjaW1hbCBwbGFjZXMgYW5kIGNhdXNlIHRoZSB1c2VyJ3NcbiAgICAgICAgLy8gY3Vyc29yIHBvc2l0aW9uIHRvIGp1bXAgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgaW5wdXQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEluIFJlYWN0RE9NSW5wdXQsIHdlIGhhdmUgYW4gb25CbHVyIGV2ZW50IHRoYXQgd2lsbCB0cmlnZ2VyXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gYWdhaW4gd2hlbiBmb2N1cyBpcyBsb3N0LlxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSA9IGluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU7XG5cblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsXG4gKiBuYW1lc3BhY2luZywgb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LlxuICpcbiAqIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbiAqIHRoZSBgcG9zc2libGVTdGFuZGFyZE5hbWVzYCBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0XG4gKiBuYW1lIHdhcm5pbmdzLlxuICpcbiAqIFNWRyBBdHRyaWJ1dGVzIExpc3Q6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHL2F0dGluZGV4Lmh0bWxcbiAqIFNNSUwgU3BlYzpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9zbWlsXG4gKi9cbnZhciBBVFRSUyA9IFsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneC1oZWlnaHQnLCAneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnLCAneG1sOmJhc2UnLCAneG1sbnM6eGxpbmsnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJ107XG5cbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgUHJvcGVydGllczoge1xuICAgIGF1dG9SZXZlcnNlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSxcbiAgICBwcmVzZXJ2ZUFscGhhOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGF1dG9SZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICAgIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgICBwcmVzZXJ2ZUFscGhhOiAncHJlc2VydmVBbHBoYSdcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9XG59O1xuXG52YXIgQ0FNRUxJWkUgPSAvW1xcLVxcOl0oW2Etel0pL2c7XG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07XG5cbkFUVFJTLmZvckVhY2goZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciByZWFjdE5hbWUgPSBvcmlnaW5hbC5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcblxuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW3JlYWN0TmFtZV0gPSAwO1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc1tyZWFjdE5hbWVdID0gb3JpZ2luYWw7XG59KTtcblxuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKEhUTUxET01Qcm9wZXJ0eUNvbmZpZyk7XG5pbmplY3Rpb24uaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICAvLyBVc2VkIGJ5IEZpYmVyIHRvIHNpbXVsYXRlIGEgdHJ5LWNhdGNoLlxuICBfY2F1Z2h0RXJyb3I6IG51bGwsXG4gIF9oYXNDYXVnaHRFcnJvcjogZmFsc2UsXG5cbiAgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cbiAgX3JldGhyb3dFcnJvcjogbnVsbCxcbiAgX2hhc1JldGhyb3dFcnJvcjogZmFsc2UsXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0RXJyb3JVdGlsczogZnVuY3Rpb24gKGluamVjdGVkRXJyb3JVdGlscykge1xuICAgICAgISh0eXBlb2YgaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbmplY3RlZCBpbnZva2VHdWFyZGVkQ2FsbGJhY2soKSBtdXN0IGJlIGEgZnVuY3Rpb24uJykgOiB2b2lkIDA7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbmplY3RlZEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gICAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAgICpcbiAgICogSW4gcHJvZHVjdGlvbiwgdGhpcyBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHRyeS1jYXRjaC4gVGhlIHJlYXNvbiB3ZSBkb24ndFxuICAgKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAgICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAgICogaXQgaW4gYSBnbG9iYWwgc28gaXQgY2FuIGJlIHJldGhyb3duIGJ5IGByZXRocm93Q2F1Z2h0RXJyb3JgIGxhdGVyLlxuICAgKiBUT0RPOiBTZWUgaWYgX2NhdWdodEVycm9yIGFuZCBfcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmICghUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IpIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IgPSB0cnVlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gICAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAgICovXG4gIHJldGhyb3dDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXRocm93Q2F1Z2h0RXJyb3IuYXBwbHkoUmVhY3RFcnJvclV0aWxzLCBhcmd1bWVudHMpO1xuICB9LFxuXG4gIGhhc0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3I7XG4gIH0sXG5cbiAgY2xlYXJDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ2NsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSB0cnVlO1xuICB9XG59O1xuXG57XG4gIC8vIEluIERFViBtb2RlLCB3ZSBzd2FwIG91dCBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgZm9yIGEgc3BlY2lhbCB2ZXJzaW9uXG4gIC8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuICAvLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuICAvLyBmdW5jdGlvbnMgaW4gaW52b2tlR3VhcmRlZENhbGxiYWNrLCBhbmQgdGhlIHByb2R1Y3Rpb24gdmVyc2lvbiBvZlxuICAvLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuICAvLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG4gIC8vIHRha2VzIHRoZSBleHRyYSBzdGVwIG9mIGVuYWJsaW5nIHBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zLiBUaGlzIGlzXG4gIC8vIHVudGludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG5cbiAgLy8gQ2hlY2sgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJcyB3ZSBuZWVkIHRvIGltcGxlbWVudCBvdXIgc3BlY2lhbFxuICAvLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG5cbiAgICB2YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2ID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cbiAgICAgIHZhciBkaWRFcnJvciA9IHRydWU7XG5cbiAgICAgIC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG4gICAgICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gICAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4gICAgICAvLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuICAgICAgLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuICAgICAgLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4gICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4gICAgICAvLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgICAvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBvbkVycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTtcblxuICAgICAgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcm9zc29yaWdpbi1lcnJvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgIH07XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIHJldGhyb3dDYXVnaHRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBudWxsO1xuICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKHBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBwbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIWV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFyZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xudmFyIHBsdWdpbnMgPSBbXTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xudmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IHt9O1xuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuLyoqXG4gKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgISFldmVudFBsdWdpbk9yZGVyID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gKlxuICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZShpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH1cbn1cblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSBPYmplY3QuZnJlZXplKHtcblx0cGx1Z2luczogcGx1Z2lucyxcblx0ZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MsXG5cdHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblx0cmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczogcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcblx0cG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyxcblx0aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblx0aW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn0pO1xuXG52YXIgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IG51bGw7XG52YXIgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IG51bGw7XG5cbnZhciBpbmplY3Rpb24kMiA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSA9IEluamVjdGVkLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7XG4gICAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGU7XG4gICAgZ2V0Tm9kZUZyb21JbnN0YW5jZSA9IEluamVjdGVkLmdldE5vZGVGcm9tSW5zdGFuY2U7XG5cbiAgICB7XG4gICAgICB3YXJuaW5nKGdldE5vZGVGcm9tSW5zdGFuY2UgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJyk7XG4gICAgfVxuICB9XG59O1xuXG5cblxuXG5cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xue1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgIHdhcm5pbmcoaW5zdGFuY2VzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIGluc3RhbmNlc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gaW5zdCBJbnRlcm5hbCBjb21wb25lbnQgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbi8qKlxuICogU3RhbmRhcmQvc2ltcGxlIGl0ZXJhdGlvbiB0aHJvdWdoIGFuIGV2ZW50J3MgY29sbGVjdGVkIGRpc3BhdGNoZXMuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSW5zdGFuY2VzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuXG5cbi8qKlxuICogRXhlY3V0aW9uIG9mIGEgXCJkaXJlY3RcIiBkaXNwYXRjaCAtIHRoZXJlIG11c3QgYmUgYXQgbW9zdCBvbmUgZGlzcGF0Y2hcbiAqIGFjY3VtdWxhdGVkIG9uIHRoZSBldmVudCBvciBpdCBpcyBjb25zaWRlcmVkIGFuIGVycm9yLiBJdCBkb2Vzbid0IHJlYWxseSBtYWtlXG4gKiBzZW5zZSBmb3IgYW4gZXZlbnQgd2l0aCBtdWx0aXBsZSBkaXNwYXRjaGVzIChidWJibGVkKSB0byBrZWVwIHRyYWNrIG9mIHRoZVxuICogcmV0dXJuIHZhbHVlcyBhdCBlYWNoIGRpc3BhdGNoIGV4ZWN1dGlvbiwgYnV0IGl0IGRvZXMgdGVuZCB0byBtYWtlIHNlbnNlIHdoZW5cbiAqIGRlYWxpbmcgd2l0aCBcImRpcmVjdFwiIGRpc3BhdGNoZXMuXG4gKlxuICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiBleGVjdXRpbmcgdGhlIHNpbmdsZSBkaXNwYXRjaC5cbiAqL1xuXG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5cbi8qKlxuICogQWNjdW11bGF0ZXMgaXRlbXMgdGhhdCBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCBpbnRvIHRoZSBmaXJzdCBvbmUuIFRoaXNcbiAqIGlzIHVzZWQgdG8gY29uc2VydmUgbWVtb3J5IGJ5IGF2b2lkaW5nIGFycmF5IGFsbG9jYXRpb25zLCBhbmQgdGh1cyBzYWNyaWZpY2VzXG4gKiBBUEkgY2xlYW5uZXNzLiBTaW5jZSBgY3VycmVudGAgY2FuIGJlIG51bGwgYmVmb3JlIGJlaW5nIHBhc3NlZCBpbiBhbmQgbm90XG4gKiBudWxsIGFmdGVyIHRoaXMgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0byBhc3NpZ24gaXQgYmFjayB0byBgY3VycmVudGA6XG4gKlxuICogYGEgPSBhY2N1bXVsYXRlSW50byhhLCBiKTtgXG4gKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIHNwYXJpbmdseSB1c2VkLiBUcnkgYGFjY3VtdWxhdGVgIGZvciBzb21ldGhpbmcgY2xlYW5lci5cbiAqXG4gKiBAcmV0dXJuIHsqfGFycmF5PCo+fSBBbiBhY2N1bXVsYXRpb24gb2YgaXRlbXMuXG4gKi9cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUludG8oY3VycmVudCwgbmV4dCkge1xuICAhKG5leHQgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IHZvaWQgMDtcblxuICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvLyBCb3RoIGFyZSBub3QgZW1wdHkuIFdhcm5pbmc6IE5ldmVyIGNhbGwgeC5jb25jYXQoeSkgd2hlbiB5b3UgYXJlIG5vdFxuICAvLyBjZXJ0YWluIHRoYXQgeCBpcyBhbiBBcnJheSAoeCBjb3VsZCBiZSBhIHN0cmluZyB3aXRoIGNvbmNhdCBtZXRob2QpLlxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgICBjdXJyZW50LnB1c2guYXBwbHkoY3VycmVudCwgbmV4dCk7XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAvLyBBIGJpdCB0b28gZGFuZ2Vyb3VzIHRvIG11dGF0ZSBgbmV4dGAuXG4gICAgcmV0dXJuIFtjdXJyZW50XS5jb25jYXQobmV4dCk7XG4gIH1cblxuICByZXR1cm4gW2N1cnJlbnQsIG5leHRdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7YXJyYXl9IGFyciBhbiBcImFjY3VtdWxhdGlvblwiIG9mIGl0ZW1zIHdoaWNoIGlzIGVpdGhlciBhbiBBcnJheSBvclxuICogYSBzaW5nbGUgaXRlbS4gVXNlZnVsIHdoZW4gcGFpcmVkIHdpdGggdGhlIGBhY2N1bXVsYXRlYCBtb2R1bGUuIFRoaXMgaXMgYVxuICogc2ltcGxlIHV0aWxpdHkgdGhhdCBhbGxvd3MgdXMgdG8gcmVhc29uIGFib3V0IGEgY29sbGVjdGlvbiBvZiBpdGVtcywgYnV0XG4gKiBoYW5kbGluZyB0aGUgY2FzZSB3aGVuIHRoZXJlIGlzIGV4YWN0bHkgb25lIGl0ZW0gKGFuZCB3ZSBkbyBub3QgbmVlZCB0b1xuICogYWxsb2NhdGUgYW4gYXJyYXkpLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgaW52b2tlZCB3aXRoIGVhY2ggZWxlbWVudCBvciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0gez99IFtzY29wZV0gU2NvcGUgdXNlZCBhcyBgdGhpc2AgaW4gYSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEFjY3VtdWxhdGVkKGFyciwgY2IsIHNjb3BlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBhcnIuZm9yRWFjaChjYiwgc2NvcGUpO1xuICB9IGVsc2UgaWYgKGFycikge1xuICAgIGNiLmNhbGwoc2NvcGUsIGFycik7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBxdWV1ZSBvZiBldmVudHMgdGhhdCBoYXZlIGFjY3VtdWxhdGVkIHRoZWlyIGRpc3BhdGNoZXMgYW5kIGFyZVxuICogd2FpdGluZyB0byBoYXZlIHRoZWlyIGRpc3BhdGNoZXMgZXhlY3V0ZWQuXG4gKi9cbnZhciBldmVudFF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFuIGV2ZW50IGFuZCByZWxlYXNlcyBpdCBiYWNrIGludG8gdGhlIHBvb2wsIHVubGVzcyBwZXJzaXN0ZW50LlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gZXZlbnQgU3ludGhldGljIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQsIHNpbXVsYXRlZCkge1xuICBpZiAoZXZlbnQpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIGlzSW50ZXJhY3RpdmUodGFnKSB7XG4gIHJldHVybiB0YWcgPT09ICdidXR0b24nIHx8IHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICdzZWxlY3QnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJztcbn1cblxuZnVuY3Rpb24gc2hvdWxkUHJldmVudE1vdXNlRXZlbnQobmFtZSwgdHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnb25DbGljayc6XG4gICAgY2FzZSAnb25DbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2snOlxuICAgIGNhc2UgJ29uRG91YmxlQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bic6XG4gICAgY2FzZSAnb25Nb3VzZURvd25DYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmVDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlVXAnOlxuICAgIGNhc2UgJ29uTW91c2VVcENhcHR1cmUnOlxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAqL1xudmFyIGluamVjdGlvbiQxID0ge1xuICAvKipcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgbGlzdGVuZXI7XG5cbiAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgLy8gbGl2ZSBoZXJlOyBuZWVkcyB0byBiZSBtb3ZlZCB0byBhIGJldHRlciBwbGFjZSBzb29uXG4gIHZhciBzdGF0ZU5vZGUgPSBpbnN0LnN0YXRlTm9kZTtcbiAgaWYgKCFzdGF0ZU5vZGUpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKHN0YXRlTm9kZSk7XG4gIGlmICghcHJvcHMpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGlmIChzaG91bGRQcmV2ZW50TW91c2VFdmVudChyZWdpc3RyYXRpb25OYW1lLCBpbnN0LnR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gICEoIWxpc3RlbmVyIHx8IHR5cGVvZiBsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGEgdmFsdWUgb2YgYCVzYCB0eXBlLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBBbGxvd3MgcmVnaXN0ZXJlZCBwbHVnaW5zIGFuIG9wcG9ydHVuaXR5IHRvIGV4dHJhY3QgZXZlbnRzIGZyb20gdG9wLWxldmVsXG4gKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gKlxuICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG4vKipcbiAqIEVucXVldWVzIGEgc3ludGhldGljIGV2ZW50IHRoYXQgc2hvdWxkIGJlIGRpc3BhdGNoZWQgd2hlblxuICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICpcbiAqIEBwYXJhbSB7Kn0gZXZlbnRzIEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVFdmVudHMoZXZlbnRzKSB7XG4gIGlmIChldmVudHMpIHtcbiAgICBldmVudFF1ZXVlID0gYWNjdW11bGF0ZUludG8oZXZlbnRRdWV1ZSwgZXZlbnRzKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMgYWxsIHN5bnRoZXRpYyBldmVudHMgb24gdGhlIGV2ZW50IHF1ZXVlLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBwcm9jZXNzRXZlbnRRdWV1ZShzaW11bGF0ZWQpIHtcbiAgLy8gU2V0IGBldmVudFF1ZXVlYCB0byBudWxsIGJlZm9yZSBwcm9jZXNzaW5nIGl0IHNvIHRoYXQgd2UgY2FuIHRlbGwgaWYgbW9yZVxuICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gIHZhciBwcm9jZXNzaW5nRXZlbnRRdWV1ZSA9IGV2ZW50UXVldWU7XG4gIGV2ZW50UXVldWUgPSBudWxsO1xuXG4gIGlmICghcHJvY2Vzc2luZ0V2ZW50UXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQpO1xuICB9IGVsc2Uge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICB9XG4gICEhZXZlbnRRdWV1ZSA/IGludmFyaWFudChmYWxzZSwgJ3Byb2Nlc3NFdmVudFF1ZXVlKCk6IEFkZGl0aW9uYWwgZXZlbnRzIHdlcmUgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZyBhbiBldmVudCBxdWV1ZS4gU3VwcG9ydCBmb3IgdGhpcyBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMSxcblx0Z2V0TGlzdGVuZXI6IGdldExpc3RlbmVyLFxuXHRleHRyYWN0RXZlbnRzOiBleHRyYWN0RXZlbnRzLFxuXHRlbnF1ZXVlRXZlbnRzOiBlbnF1ZXVlRXZlbnRzLFxuXHRwcm9jZXNzRXZlbnRRdWV1ZTogcHJvY2Vzc0V2ZW50UXVldWVcbn0pO1xuXG52YXIgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IDA7IC8vIEJlZm9yZSB3ZSBrbm93IHdoZXRoZXIgaXQgaXMgZnVuY3Rpb25hbCBvciBjbGFzc1xudmFyIEZ1bmN0aW9uYWxDb21wb25lbnQgPSAxO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMjtcbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxudmFyIEhvc3RDb21wb25lbnQgPSA1O1xudmFyIEhvc3RUZXh0ID0gNjtcbnZhciBDYWxsQ29tcG9uZW50ID0gNztcbnZhciBDYWxsSGFuZGxlclBoYXNlID0gODtcbnZhciBSZXR1cm5Db21wb25lbnQgPSA5O1xudmFyIEZyYWdtZW50ID0gMTA7XG5cbnZhciByYW5kb21LZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gJ19fcmVhY3RFdmVudEhhbmRsZXJzJCcgKyByYW5kb21LZXk7XG5cbmZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlJDEoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgY2xvc2VzdCBSZWFjdERPTUNvbXBvbmVudCBvclxuICogUmVhY3RET01UZXh0Q29tcG9uZW50IGluc3RhbmNlIGFuY2VzdG9yLlxuICovXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIGlmIChub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcmV0dXJuIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgaW5zdGFuY2Ugd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUb3Agb2YgdGhlIHRyZWUuIFRoaXMgbm9kZSBtdXN0IG5vdCBiZSBwYXJ0IG9mIGEgUmVhY3QgdHJlZSAob3IgaXNcbiAgICAgIC8vIHVubW91bnRlZCwgcG90ZW50aWFsbHkpLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3Nlc3QgPSB2b2lkIDA7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyLCB0aGlzIHdpbGwgYWx3YXlzIGJlIHRoZSBkZWVwZXN0IHJvb3QuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgZm9yICg7IG5vZGUgJiYgKGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKTsgbm9kZSA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBjbG9zZXN0ID0gaW5zdDtcbiAgfVxuXG4gIHJldHVybiBjbG9zZXN0O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUkMShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlJDEoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9XG5cbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICBpbnZhcmlhbnQoZmFsc2UsICdnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LicpO1xufVxuXG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEobm9kZSkge1xuICByZXR1cm4gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMkMShub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBwcm9wcztcbn1cblxudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IE9iamVjdC5mcmVlemUoe1xuXHRwcmVjYWNoZUZpYmVyTm9kZTogcHJlY2FjaGVGaWJlck5vZGUkMSxcblx0Z2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuXHRnZXRJbnN0YW5jZUZyb21Ob2RlOiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEsXG5cdGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSxcblx0Z2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTogZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxLFxuXHR1cGRhdGVGaWJlclByb3BzOiB1cGRhdGVGaWJlclByb3BzJDFcbn0pO1xuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBkbyB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gZ2V0UGFyZW50KHRlbXBCKSkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIgfHwgaW5zdEEgPT09IGluc3RCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgcmV0dXJuIGdldFBhcmVudChpbnN0KTtcbn1cblxuLyoqXG4gKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlVHdvUGhhc2UoaW5zdCwgZm4sIGFyZykge1xuICB2YXIgcGF0aCA9IFtdO1xuICB3aGlsZSAoaW5zdCkge1xuICAgIHBhdGgucHVzaChpbnN0KTtcbiAgICBpbnN0ID0gZ2V0UGFyZW50KGluc3QpO1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCFmcm9tKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGZyb20gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBhbHRlcm5hdGUgPSBmcm9tLmFsdGVybmF0ZTtcbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aEZyb20ucHVzaChmcm9tKTtcbiAgICBmcm9tID0gZ2V0UGFyZW50KGZyb20pO1xuICB9XG4gIHZhciBwYXRoVG8gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRvID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgX2FsdGVybmF0ZSA9IHRvLmFsdGVybmF0ZTtcbiAgICBpZiAoX2FsdGVybmF0ZSAhPT0gbnVsbCAmJiBfYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoVG8ucHVzaCh0byk7XG4gICAgdG8gPSBnZXRQYXJlbnQodG8pO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKHZhciBfaSA9IHBhdGhUby5sZW5ndGg7IF9pLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tfaV0sICdjYXB0dXJlZCcsIGFyZ1RvKTtcbiAgfVxufVxuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbiBhXG4gKiBzaW5nbGUgb25lLlxuICovXG5cbi8qKlxuICogVGFncyBhIGBTeW50aGV0aWNFdmVudGAgd2l0aCBkaXNwYXRjaGVkIGxpc3RlbmVycy4gQ3JlYXRpbmcgdGhpcyBmdW5jdGlvblxuICogaGVyZSwgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGJpbmQgb3IgY3JlYXRlIGZ1bmN0aW9ucyBmb3IgZWFjaCBldmVudC5cbiAqIE11dGF0aW5nIHRoZSBldmVudCdzIG1lbWJlcnMgYWxsb3dzIHVzIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBhIHdyYXBwaW5nXG4gKiBcImRpc3BhdGNoXCIgb2JqZWN0IHRoYXQgcGFpcnMgdGhlIGV2ZW50IHdpdGggdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzKGluc3QsIHBoYXNlLCBldmVudCkge1xuICB7XG4gICAgd2FybmluZyhpbnN0LCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJyk7XG4gIH1cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdHJhdmVyc2VUd29QaGFzZShldmVudC5fdGFyZ2V0SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogU2FtZSBhcyBgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZWAsIGJ1dCBza2lwcyBvdmVyIHRoZSB0YXJnZXRJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgdmFyIHRhcmdldEluc3QgPSBldmVudC5fdGFyZ2V0SW5zdDtcbiAgICB2YXIgcGFyZW50SW5zdCA9IHRhcmdldEluc3QgPyBnZXRQYXJlbnRJbnN0YW5jZSh0YXJnZXRJbnN0KSA6IG51bGw7XG4gICAgdHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoaW5zdCAmJiBldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGRpc3BhdGNoZXMgb24gYW4gYFN5bnRoZXRpY0V2ZW50YCwgYnV0IG9ubHkgZm9yIHRoZVxuICogYGRpc3BhdGNoTWFya2VyYC5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgYWNjdW11bGF0ZURpc3BhdGNoZXMoZXZlbnQuX3RhcmdldEluc3QsIG51bGwsIGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSBPYmplY3QuZnJlZXplKHtcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuXHRhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyxcblx0YWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6IGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzXG59KTtcblxudmFyIGNvbnRlbnRLZXkgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIGtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQgb24gYSBET00gbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBLZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRDb250ZW50QWNjZXNzb3IoKSB7XG4gIGlmICghY29udGVudEtleSAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAvLyBQcmVmZXIgdGV4dENvbnRlbnQgdG8gaW5uZXJUZXh0IGJlY2F1c2UgbWFueSBicm93c2VycyBzdXBwb3J0IGJvdGggYnV0XG4gICAgLy8gU1ZHIDx0ZXh0PiBlbGVtZW50cyBkb24ndCBzdXBwb3J0IGlubmVyVGV4dCBldmVuIHdoZW4gPGRpdj4gZG9lcy5cbiAgICBjb250ZW50S2V5ID0gJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyAndGV4dENvbnRlbnQnIDogJ2lubmVyVGV4dCc7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnRLZXk7XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgb2JqZWN0IHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqXG4gKi9cbnZhciBjb21wb3NpdGlvblN0YXRlID0ge1xuICBfcm9vdDogbnVsbCxcbiAgX3N0YXJ0VGV4dDogbnVsbCxcbiAgX2ZhbGxiYWNrVGV4dDogbnVsbFxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkge1xuICBjb21wb3NpdGlvblN0YXRlLl9yb290ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gbnVsbDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQ7XG4gIHZhciBzdGFydFZhbHVlID0gY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuICBmb3IgKGVuZCA9IDE7IGVuZCA8PSBtaW5FbmQ7IGVuZCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc2xpY2VUYWlsID0gZW5kID4gMSA/IDEgLSBlbmQgOiB1bmRlZmluZWQ7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IGVuZFZhbHVlLnNsaWNlKHN0YXJ0LCBzbGljZVRhaWwpO1xuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiBjb21wb3NpdGlvblN0YXRlLl9yb290KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3RbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXTtcbn1cblxuLyogZXNsaW50IHZhbGlkLXR5cGVvZjogMCAqL1xuXG52YXIgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSBmYWxzZTtcbnZhciBpc1Byb3h5U3VwcG9ydGVkID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xudmFyIEVWRU5UX1BPT0xfU0laRSA9IDEwO1xuXG52YXIgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMgPSBbJ2Rpc3BhdGNoQ29uZmlnJywgJ190YXJnZXRJbnN0JywgJ25hdGl2ZUV2ZW50JywgJ2lzRGVmYXVsdFByZXZlbnRlZCcsICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsICdfZGlzcGF0Y2hMaXN0ZW5lcnMnLCAnX2Rpc3BhdGNoSW5zdGFuY2VzJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgdHlwZTogbnVsbCxcbiAgdGFyZ2V0OiBudWxsLFxuICAvLyBjdXJyZW50VGFyZ2V0IGlzIHNldCB3aGVuIGRpc3BhdGNoaW5nOyBubyB1c2UgaW4gY29weWluZyBpdCBoZXJlXG4gIGN1cnJlbnRUYXJnZXQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgfVxuICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAqIHdvbid0IGJlIGFkZGVkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICovXG4gIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzUGVyc2lzdGVudCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuICBhZGRFdmVudFBvb2xpbmdUbyhDbGFzcyk7XG59O1xuXG4vKiogUHJveHlpbmcgYWZ0ZXIgZXZlcnl0aGluZyBzZXQgb24gU3ludGhldGljRXZlbnRcbiAqIHRvIHJlc29sdmUgUHJveHkgaXNzdWUgb24gc29tZSBXZWJLaXQgYnJvd3NlcnNcbiAqIGluIHdoaWNoIHNvbWUgRXZlbnQgcHJvcGVydGllcyBhcmUgc2V0IHRvIHVuZGVmaW5lZCAoR0gjMTAwMTApXG4gKi9cbntcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBcIiArIFwic2VlaW5nIHRoaXMsIHlvdSdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuIFwiICsgJ1RoZSBwcm9wZXJ0eSBpcyBuZXZlciByZWxlYXNlZC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gIH1cbn1cblxuYWRkRXZlbnRQb29saW5nVG8oU3ludGhldGljRXZlbnQpO1xuXG4vKipcbiAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtIHs/b2JqZWN0fSBnZXRWYWxcbiAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgd2FybmluZyh3YXJuaW5nQ29uZGl0aW9uLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBcIiArIFwieW91J3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gXCIgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9vbGVkRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnBvcCgpO1xuICAgIEV2ZW50Q29uc3RydWN0b3IuY2FsbChpbnN0YW5jZSwgZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBFdmVudENvbnN0cnVjdG9yKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VQb29sZWRFdmVudChldmVudCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICEoZXZlbnQgaW5zdGFuY2VvZiBFdmVudENvbnN0cnVjdG9yKSA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGV2ZW50IGluc3RhbmNlICBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogdm9pZCAwO1xuICBldmVudC5kZXN0cnVjdG9yKCk7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGggPCBFVkVOVF9QT09MX1NJWkUpIHtcbiAgICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wdXNoKGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudFBvb2xpbmdUbyhFdmVudENvbnN0cnVjdG9yKSB7XG4gIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sID0gW107XG4gIEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkID0gZ2V0UG9vbGVkRXZlbnQ7XG4gIEV2ZW50Q29uc3RydWN0b3IucmVsZWFzZSA9IHJlbGVhc2VQb29sZWRFdmVudDtcbn1cblxudmFyIFN5bnRoZXRpY0V2ZW50JDEgPSBTeW50aGV0aWNFdmVudDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkJlZm9yZUlucHV0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBpc0NvbXBvc2luZyA9IGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGVzfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlICd0b3BUZXh0SW5wdXQnOlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDb21wb3NpdGlvbkVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBnZXREYXRhKCk7XG4gICAgICByZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmICghaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIC8vIElFIGZpcmVzIHRoZSBga2V5cHJlc3NgIGV2ZW50IHdoZW4gYSB1c2VyIHR5cGVzIGFuIGVtb2ppIHZpYVxuICAgICAgICAvLyBUb3VjaCBrZXlib2FyZCBvZiBXaW5kb3dzLiAgSW4gc3VjaCBhIGNhc2UsIHRoZSBgY2hhcmAgcHJvcGVydHlcbiAgICAgICAgLy8gaG9sZHMgYW4gZW1vamkgY2hhcmFjdGVyIGxpa2UgYFxcdUQ4M0RcXHVERTBBYC4gIEJlY2F1c2UgaXRzIGxlbmd0aFxuICAgICAgICAvLyBpcyAyLCB0aGUgcHJvcGVydHkgYHdoaWNoYCBkb2VzIG5vdCByZXByZXNlbnQgYW4gZW1vamkgY29ycmVjdGx5LlxuICAgICAgICAvLyBJbiBzdWNoIGEgY2FzZSwgd2UgZGlyZWN0bHkgcmV0dXJuIHRoZSBgY2hhcmAgcHJvcGVydHkgaW5zdGVhZCBvZlxuICAgICAgICAvLyB1c2luZyBgd2hpY2hgLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuY2hhciAmJiBuYXRpdmVFdmVudC5jaGFyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjtcbiAgICAgICAgfSBlbHNlIGlmIChuYXRpdmVFdmVudC53aGljaCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xuICB9XG59O1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxudmFyIGZpYmVySG9zdENvbXBvbmVudCA9IG51bGw7XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQ6IGZ1bmN0aW9uIChob3N0Q29tcG9uZW50SW1wbCkge1xuICAgIC8vIFRoZSBmaWJlciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHVzZSBkeW5hbWljIGRpc3BhdGNoIHNvIHdlIG5lZWQgdG9cbiAgICAvLyBpbmplY3QgdGhlIGltcGxlbWVudGF0aW9uLlxuICAgIGZpYmVySG9zdENvbXBvbmVudCA9IGhvc3RDb21wb25lbnRJbXBsO1xuICB9XG59O1xuXG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gICEoZmliZXJIb3N0Q29tcG9uZW50ICYmIHR5cGVvZiBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdGaWJlciBuZWVkcyB0byBiZSBpbmplY3RlZCB0byBoYW5kbGUgYSBmaWJlciB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKTtcbiAgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgcHJvcHMpO1xufVxuXG52YXIgaW5qZWN0aW9uJDMgPSBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb247XG5cbmZ1bmN0aW9uIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KSB7XG4gIGlmIChyZXN0b3JlVGFyZ2V0KSB7XG4gICAgaWYgKHJlc3RvcmVRdWV1ZSkge1xuICAgICAgcmVzdG9yZVF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdG9yZVF1ZXVlID0gW3RhcmdldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuXG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQzLFxuXHRlbnF1ZXVlU3RhdGVSZXN0b3JlOiBlbnF1ZXVlU3RhdGVSZXN0b3JlLFxuXHRyZXN0b3JlU3RhdGVJZk5lZWRlZDogcmVzdG9yZVN0YXRlSWZOZWVkZWRcbn0pO1xuXG4vLyBVc2VkIGFzIGEgd2F5IHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMgd2hlbiB3ZSBkb24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvXG4vLyB0aGUgcmVuZGVyZXIuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cblxuLy8gRGVmYXVsdHNcbnZhciBmaWJlckJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNOZXN0aW5nQmF0Y2hlZCkge1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIGFub3RoZXIgYmF0Y2gsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdFxuICAgIC8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLiBUaGVyZWZvcmUsIHdlIGFkZCB0aGUgdGFyZ2V0IHRvXG4gICAgLy8gYSBxdWV1ZSBvZiB3b3JrLlxuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH1cbiAgaXNOZXN0aW5nQmF0Y2hlZCA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZpYmVyQmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNOZXN0aW5nQmF0Y2hlZCA9IGZhbHNlO1xuICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gIH1cbn1cblxudmFyIFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoX2JhdGNoZWRVcGRhdGVzKSB7XG4gICAgZmliZXJCYXRjaGVkVXBkYXRlcyA9IF9iYXRjaGVkVXBkYXRlcztcbiAgfVxufTtcblxudmFyIGluamVjdGlvbiQ0ID0gUmVhY3RHZW5lcmljQmF0Y2hpbmdJbmplY3Rpb247XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAvLyBhbmQgZG9uJ3QgdHJhY2sgdmFsdWUgd2lsbCBjYXVzZSBvdmVyIHJlcG9ydGluZyBvZiBjaGFuZ2VzLFxuICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5zZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogT25jZSBpdCdzIGp1c3QgRmliZXIgd2UgY2FuIG1vdmUgdGhpcyB0byBub2RlLl93cmFwcGVyU3RhdGVcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7XG4gIC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAobmV4dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgZXZlbnRUeXBlcyQxID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQxLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCk7XG4gIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIGJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCk7XG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BTZWxlY3Rpb25DaGFuZ2UnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wSW5wdXQnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIoaW5zdCwgbm9kZSkge1xuICAvLyBUT0RPOiBJbiBJRSwgaW5zdCBpcyBvY2Nhc2lvbmFsbHkgbnVsbC4gV2h5P1xuICBpZiAoaW5zdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRmliZXIgYW5kIFJlYWN0RE9NIGtlZXAgd3JhcHBlciBzdGF0ZSBpbiBzZXBhcmF0ZSBwbGFjZXNcbiAgdmFyIHN0YXRlID0gaW5zdC5fd3JhcHBlclN0YXRlIHx8IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG4gIHZhciB2YWx1ZSA9ICcnICsgbm9kZS52YWx1ZTtcbiAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICE9PSB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKHRhcmdldEluc3QsIHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERPTUV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IG51bGwsXG4gIGRldGFpbDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBudWxsLFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgZXZlbnRUeXBlcyQyID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxudmFyIFJlYWN0SW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBEb24ndCBjaGFuZ2UgdGhlc2UgdHdvIHZhbHVlczpcbnZhciBOb0VmZmVjdCA9IDA7IC8vICAgICAgICAgICAwYjAwMDAwMDAwXG52YXIgUGVyZm9ybWVkV29yayA9IDE7IC8vICAgICAgMGIwMDAwMDAwMVxuXG4vLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cbnZhciBQbGFjZW1lbnQgPSAyOyAvLyAgICAgICAgICAwYjAwMDAwMDEwXG52YXIgVXBkYXRlID0gNDsgLy8gICAgICAgICAgICAgMGIwMDAwMDEwMFxudmFyIFBsYWNlbWVudEFuZFVwZGF0ZSA9IDY7IC8vIDBiMDAwMDAxMTBcbnZhciBEZWxldGlvbiA9IDg7IC8vICAgICAgICAgICAwYjAwMDAxMDAwXG52YXIgQ29udGVudFJlc2V0ID0gMTY7IC8vICAgICAgMGIwMDAxMDAwMFxudmFyIENhbGxiYWNrID0gMzI7IC8vICAgICAgICAgIDBiMDAxMDAwMDBcbnZhciBFcnIgPSA2NDsgLy8gICAgICAgICAgICAgICAwYjAxMDAwMDAwXG52YXIgUmVmID0gMTI4OyAvLyAgICAgICAgICAgICAgMGIxMDAwMDAwMFxuXG52YXIgTU9VTlRJTkcgPSAxO1xudmFyIE1PVU5URUQgPSAyO1xudmFyIFVOTU9VTlRFRCA9IDM7XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikge1xuICB2YXIgbm9kZSA9IGZpYmVyO1xuICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbiAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgIHJldHVybiBNT1VOVElORztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZVsncmV0dXJuJ10pIHtcbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIE1PVU5URUQ7XG4gIH1cbiAgLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuICByZXR1cm4gVU5NT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICEoaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBzdGF0ZSA9IGlzRmliZXJNb3VudGVkSW1wbChmaWJlcik7XG4gICAgIShzdGF0ZSAhPT0gVU5NT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYVsncmV0dXJuJ107XG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBID8gcGFyZW50QS5hbHRlcm5hdGUgOiBudWxsO1xuICAgIGlmICghcGFyZW50QSB8fCAhcGFyZW50Qikge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGFbJ3JldHVybiddICE9PSBiWydyZXR1cm4nXSkge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgICFkaWRGaW5kQ2hpbGQgPyBpbnZhcmlhbnQoZmFsc2UsICdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShhLmFsdGVybmF0ZSA9PT0gYikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnNcXCcgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgfVxuICAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG4gICEoYS50YWcgPT09IEhvc3RSb290KSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG52YXIgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUm9vdENvbnRhaW5lck5vZGUoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdFsncmV0dXJuJ10pIHtcbiAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gIH1cbiAgaWYgKGluc3QudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB3ZSdyZSBpbiBhIGRldGFjaGVkIHRyZWUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGluc3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnBvcCgpO1xuICAgIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGluc3RhbmNlLnRhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcExldmVsVHlwZTogdG9wTGV2ZWxUeXBlLFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0OiB0YXJnZXRJbnN0LFxuICAgIGFuY2VzdG9yczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyhpbnN0YW5jZSkge1xuICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSBudWxsO1xuICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG51bGw7XG4gIGluc3RhbmNlLnRhcmdldEluc3QgPSBudWxsO1xuICBpbnN0YW5jZS5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCA8IENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSkge1xuICAgIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBmaW5kUm9vdENvbnRhaW5lck5vZGUoYW5jZXN0b3IpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJvb3QpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIF9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZCA9IHRydWU7XG52YXIgX2hhbmRsZVRvcExldmVsID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBzZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCkge1xuICBfaGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbn1cblxuZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gIF9lbmFibGVkID0gISFlbmFibGVkO1xufVxuXG5mdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gIHJldHVybiBfZW5hYmxlZDtcbn1cblxuLyoqXG4gKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbi8qKlxuICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIGRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICghX2VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICBpZiAodGFyZ2V0SW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0SW5zdC50YWcgPT09ICdudW1iZXInICYmICFpc0ZpYmVyTW91bnRlZCh0YXJnZXRJbnN0KSkge1xuICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAvLyBjb21wb25lbnQncyBtb3VudCwgaWdub3JlIGl0IGZvciBub3cgKHRoYXQgaXMsIHRyZWF0IGl0IGFzIGlmIGl0IHdhcyBhblxuICAgIC8vIGV2ZW50IG9uIGEgbm9uLVJlYWN0IHRyZWUpLiBXZSBtaWdodCBhbHNvIGNvbnNpZGVyIHF1ZXVlaW5nIGV2ZW50cyBhbmRcbiAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBib29rS2VlcGluZyA9IGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KTtcblxuICB0cnkge1xuICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgIGJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoYm9va0tlZXBpbmcpO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUV2ZW50TGlzdGVuZXIgPSBPYmplY3QuZnJlZXplKHtcblx0Z2V0IF9lbmFibGVkICgpIHsgcmV0dXJuIF9lbmFibGVkOyB9LFxuXHRnZXQgX2hhbmRsZVRvcExldmVsICgpIHsgcmV0dXJuIF9oYW5kbGVUb3BMZXZlbDsgfSxcblx0c2V0SGFuZGxlVG9wTGV2ZWw6IHNldEhhbmRsZVRvcExldmVsLFxuXHRzZXRFbmFibGVkOiBzZXRFbmFibGVkLFxuXHRpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcblx0dHJhcEJ1YmJsZWRFdmVudDogdHJhcEJ1YmJsZWRFdmVudCxcblx0dHJhcENhcHR1cmVkRXZlbnQ6IHRyYXBDYXB0dXJlZEV2ZW50LFxuXHRkaXNwYXRjaEV2ZW50OiBkaXNwYXRjaEV2ZW50XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICpcbiAqIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZVxuICogdHJhcCBhdCBhIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkXG4gKiBjYXVzZSBkdXBsaWNhdGUgZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyQxID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpIHx8ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5jZWw6ICdjYW5jZWwnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ2xvc2U6ICdjbG9zZScsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZDogJ2xvYWQnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb2dnbGU6ICd0b2dnbGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbnZhciBCcm93c2VyRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMkMVxufTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgcHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG4vKipcbiAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG59XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gQnJvd3NlckV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFNjcm9sbCcpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcFNjcm9sbCcsICdzY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcEZvY3VzJyB8fCBkZXBlbmRlbmN5ID09PSAndG9wQmx1cicpIHtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcblxuICAgICAgICAvLyB0byBtYWtlIHN1cmUgYmx1ciBhbmQgZm9jdXMgZXZlbnQgbGlzdGVuZXJzIGFyZSBvbmx5IGF0dGFjaGVkIG9uY2VcbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQmx1ciA9IHRydWU7XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENhbmNlbCcpIHtcbiAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2NhbmNlbCcsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENhbmNlbCcsICdjYW5jZWwnLCBtb3VudEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xpc3RlbmluZy50b3BDYW5jZWwgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wQ2xvc2UnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjbG9zZScsIHRydWUpKSB7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcENsb3NlJywgJ2Nsb3NlJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2xvc2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGVzLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wTGV2ZWxUeXBlc1tkZXBlbmRlbmN5XSwgbW91bnRBdCk7XG4gICAgICB9XG5cbiAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyhyZWdpc3RyYXRpb25OYW1lLCBtb3VudEF0KSB7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2libGluZ05vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICByZXR1cm4gbm9kZS5uZXh0U2libGluZztcbiAgICB9XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBvYmplY3QgZGVzY3JpYmluZyB0aGUgbm9kZXMgd2hpY2ggY29udGFpbiBjaGFyYWN0ZXJzIGF0IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0cyhvdXRlck5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24gJiYgd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSQkMSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDtcblxuICAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlJCQxLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB7c3RhcnQsIGVuZH0gd2hlcmUgYHN0YXJ0YCBpcyB0aGUgY2hhcmFjdGVyL2NvZGVwb2ludCBpbmRleCBvZlxuICogKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgd2l0aGluIHRoZSB0ZXh0Q29udGVudCBvZiBgb3V0ZXJOb2RlYCwgYW5kXG4gKiBgZW5kYCBpcyB0aGUgaW5kZXggb2YgKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpLlxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB5b3UgcGFzcyBpbiBnYXJiYWdlIGlucHV0IGJ1dCB3ZSBzaG91bGQgcHJvYmFibHkganVzdCBjcmFzaC5cbiAqXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBhbmNob3JOb2RlICYmICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUkJDEgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3RcbiAgICAvLyBhY3R1YWxseSBpbnNpZGUgdGhlIHBhc3NlZC1pbiBub2RlLilcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEoaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbn1cblxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQsXG4gICAgICBlbmQgPSBvZmZzZXRzLmVuZDtcblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzJDMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuICAgIC8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICogICAndG9wQWJvcnQnOiB7IHNhbWVDb25maWcgfVxuICogfTtcbiAqL1xudmFyIGV2ZW50VHlwZXMkNCA9IHt9O1xudmFyIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHt9O1xuWydhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2JsdXInLCAnY2FuY2VsJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY2xvc2UnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvZ2dsZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaE1vdmUnLCAndG91Y2hTdGFydCcsICd0cmFuc2l0aW9uRW5kJywgJ3ZvbHVtZUNoYW5nZScsICd3YWl0aW5nJywgJ3doZWVsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gIHZhciBvbkV2ZW50ID0gJ29uJyArIGNhcGl0YWxpemVkRXZlbnQ7XG4gIHZhciB0b3BFdmVudCA9ICd0b3AnICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF1cbiAgfTtcbiAgZXZlbnRUeXBlcyQ0W2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG52YXIga25vd25IVE1MVG9wTGV2ZWxUeXBlcyA9IFsndG9wQWJvcnQnLCAndG9wQ2FuY2VsJywgJ3RvcENhblBsYXknLCAndG9wQ2FuUGxheVRocm91Z2gnLCAndG9wQ2xvc2UnLCAndG9wRHVyYXRpb25DaGFuZ2UnLCAndG9wRW1wdGllZCcsICd0b3BFbmNyeXB0ZWQnLCAndG9wRW5kZWQnLCAndG9wRXJyb3InLCAndG9wSW5wdXQnLCAndG9wSW52YWxpZCcsICd0b3BMb2FkJywgJ3RvcExvYWRlZERhdGEnLCAndG9wTG9hZGVkTWV0YWRhdGEnLCAndG9wTG9hZFN0YXJ0JywgJ3RvcFBhdXNlJywgJ3RvcFBsYXknLCAndG9wUGxheWluZycsICd0b3BQcm9ncmVzcycsICd0b3BSYXRlQ2hhbmdlJywgJ3RvcFJlc2V0JywgJ3RvcFNlZWtlZCcsICd0b3BTZWVraW5nJywgJ3RvcFN0YWxsZWQnLCAndG9wU3VibWl0JywgJ3RvcFN1c3BlbmQnLCAndG9wVGltZVVwZGF0ZScsICd0b3BUb2dnbGUnLCAndG9wVm9sdW1lQ2hhbmdlJywgJ3RvcFdhaXRpbmcnXTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENsaWNrJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BEb3VibGVDbGljayc6XG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgY2FzZSAndG9wTW91c2VNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgLy8gVE9ETzogRGlzYWJsZWQgZWxlbWVudHMgc2hvdWxkIG5vdCByZXNwb25kIHRvIG1vdXNlIGV2ZW50c1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wTW91c2VPdXQnOlxuICAgICAgY2FzZSAndG9wTW91c2VPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wRHJhZyc6XG4gICAgICBjYXNlICd0b3BEcmFnRW5kJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbnRlcic6XG4gICAgICBjYXNlICd0b3BEcmFnRXhpdCc6XG4gICAgICBjYXNlICd0b3BEcmFnTGVhdmUnOlxuICAgICAgY2FzZSAndG9wRHJhZ092ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ1N0YXJ0JzpcbiAgICAgIGNhc2UgJ3RvcERyb3AnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRvdWNoQ2FuY2VsJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoRW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoTW92ZSc6XG4gICAgICBjYXNlICd0b3BUb3VjaFN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uRW5kJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkl0ZXJhdGlvbic6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25TdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUcmFuc2l0aW9uRW5kJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BTY3JvbGwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BXaGVlbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvcHknOlxuICAgICAgY2FzZSAndG9wQ3V0JzpcbiAgICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLiBUaGlzIHdhcm5pbmcgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCB0b3BMZXZlbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50JDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbnNldEhhbmRsZVRvcExldmVsKGhhbmRsZVRvcExldmVsKTtcblxuLyoqXG4gKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihET01FdmVudFBsdWdpbk9yZGVyKTtcbmluamVjdGlvbiQyLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24kMS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxufSk7XG5cbnZhciBlbmFibGVBc3luY1N1YnRyZWVBUEkgPSB0cnVlO1xudmFyIGVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET00gPSBmYWxzZTtcbi8vIEV4cG9ydHMgUmVhY3RET00uY3JlYXRlUm9vdFxudmFyIGVuYWJsZUNyZWF0ZVJvb3QgPSBmYWxzZTtcbnZhciBlbmFibGVVc2VyVGltaW5nQVBJID0gdHJ1ZTtcblxuLy8gTXV0YXRpbmcgbW9kZSAoUmVhY3QgRE9NLCBSZWFjdCBBUlQsIFJlYWN0IE5hdGl2ZSk6XG52YXIgZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyID0gdHJ1ZTtcbi8vIEV4cGVyaW1lbnRhbCBub29wIG1vZGUgKGN1cnJlbnRseSB1bnVzZWQpOlxudmFyIGVuYWJsZU5vb3BSZWNvbmNpbGVyID0gZmFsc2U7XG4vLyBFeHBlcmltZW50YWwgcGVyc2lzdGVudCBtb2RlIChDUyk6XG52YXIgZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgPSBmYWxzZTtcblxuLy8gSGVscHMgaWRlbnRpZnkgc2lkZSBlZmZlY3RzIGluIGJlZ2luLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGUgcmVkdWNlcnM6XG52YXIgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzID0gZmFsc2U7XG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xuXG57XG4gIHZhciBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59XG5cblxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBjdXJzb3IuY3VycmVudDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBmaWJlcjtcbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0JDEoKSB7XG4gIHdoaWxlIChpbmRleCA+IC0xKSB7XG4gICAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIGluZGV4LS07XG4gIH1cbn1cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cbiAgICByZXR1cm4gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihmaWJlcik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lLFxuICBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtOiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtXG59O1xuXG4vLyBQcmVmaXggbWVhc3VyZW1lbnRzIHNvIHRoYXQgaXQncyBwb3NzaWJsZSB0byBmaWx0ZXIgdGhlbS5cbi8vIExvbmdlciBwcmVmaXhlcyBhcmUgaGFyZCB0byByZWFkIGluIERldlRvb2xzLlxudmFyIHJlYWN0RW1vamkgPSAnXFx1MjY5Qic7XG52YXIgd2FybmluZ0Vtb2ppID0gJ1xcdTI2RDQnO1xudmFyIHN1cHBvcnRzVXNlclRpbWluZyA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbi8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBmaWJlciBzbyB0aGF0IHdlIGtub3cgdGhlIHBhdGggdG8gdW53aW5kIG9uIHBhdXNlLlxuLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xudmFyIGN1cnJlbnRGaWJlciA9IG51bGw7XG4vLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHVzZXIgY29kZSwgd2hpY2ggZmliZXIgYW5kIG1ldGhvZCBpcyBpdD9cbi8vIFJldXNpbmcgYGN1cnJlbnRGaWJlcmAgd291bGQgYmUgY29uZnVzaW5nIGZvciB0aGlzIGJlY2F1c2UgdXNlciBjb2RlIGZpYmVyXG4vLyBjYW4gY2hhbmdlIGR1cmluZyBjb21taXQgcGhhc2UgdG9vLCBidXQgd2UgZG9uJ3QgbmVlZCB0byB1bndpbmQgaXQgKHNpbmNlXG4vLyBsaWZlY3ljbGVzIGluIHRoZSBjb21taXQgcGhhc2UgZG9uJ3QgcmVzZW1ibGUgYSB0cmVlKS5cbnZhciBjdXJyZW50UGhhc2UgPSBudWxsO1xudmFyIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbi8vIERpZCBsaWZlY3ljbGUgaG9vayBzY2hlZHVsZSBhbiB1cGRhdGU/IFRoaXMgaXMgb2Z0ZW4gYSBwZXJmb3JtYW5jZSBwcm9ibGVtLFxuLy8gc28gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIGl0LCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVwb3J0LlxuLy8gVHJhY2sgY29tbWl0cyBjYXVzZWQgYnkgY2FzY2FkaW5nIHVwZGF0ZXMuXG52YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbnZhciBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbnZhciBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG52YXIgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbi8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuLy8gdG8gYXZvaWQgc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIHdpdGggbWVhc3VyZW1lbnQgb3ZlcmhlYWQuXG52YXIgbGFiZWxzSW5DdXJyZW50Q29tbWl0ID0gbmV3IFNldCgpO1xuXG52YXIgZm9ybWF0TWFya05hbWUgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcmV0dXJuIHJlYWN0RW1vamkgKyAnICcgKyBtYXJrTmFtZTtcbn07XG5cbnZhciBmb3JtYXRMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCwgd2FybmluZyQkMSkge1xuICB2YXIgcHJlZml4ID0gd2FybmluZyQkMSA/IHdhcm5pbmdFbW9qaSArICcgJyA6IHJlYWN0RW1vamkgKyAnICc7XG4gIHZhciBzdWZmaXggPSB3YXJuaW5nJCQxID8gJyBXYXJuaW5nOiAnICsgd2FybmluZyQkMSA6ICcnO1xuICByZXR1cm4gJycgKyBwcmVmaXggKyBsYWJlbCArIHN1ZmZpeDtcbn07XG5cbnZhciBiZWdpbk1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UubWFyayhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGNsZWFyTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgZW5kTWFyayA9IGZ1bmN0aW9uIChsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGZvcm1hdHRlZE1hcmtOYW1lID0gZm9ybWF0TWFya05hbWUobWFya05hbWUpO1xuICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCwgd2FybmluZyQkMSk7XG4gIHRyeSB7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShmb3JtYXR0ZWRMYWJlbCwgZm9ybWF0dGVkTWFya05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHt9XG4gIC8vIElmIHByZXZpb3VzIG1hcmsgd2FzIG1pc3NpbmcgZm9yIHNvbWUgcmVhc29uLCB0aGlzIHdpbGwgdGhyb3cuXG4gIC8vIFRoaXMgY291bGQgb25seSBoYXBwZW4gaWYgUmVhY3QgY3Jhc2hlZCBpbiBhbiB1bmV4cGVjdGVkIHBsYWNlIGVhcmxpZXIuXG4gIC8vIERvbid0IHBpbGUgb24gd2l0aCBtb3JlIGVycm9ycy5cblxuICAvLyBDbGVhciBtYXJrcyBpbW1lZGlhdGVseSB0byBhdm9pZCBncm93aW5nIGJ1ZmZlci5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoZm9ybWF0dGVkTGFiZWwpO1xufTtcblxudmFyIGdldEZpYmVyTWFya05hbWUgPSBmdW5jdGlvbiAobGFiZWwsIGRlYnVnSUQpIHtcbiAgcmV0dXJuIGxhYmVsICsgJyAoIycgKyBkZWJ1Z0lEICsgJyknO1xufTtcblxudmFyIGdldEZpYmVyTGFiZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSkge1xuICBpZiAocGhhc2UgPT09IG51bGwpIHtcbiAgICAvLyBUaGVzZSBhcmUgY29tcG9zaXRlIGNvbXBvbmVudCB0b3RhbCB0aW1lIG1lYXN1cmVtZW50cy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcgWycgKyAoaXNNb3VudGVkID8gJ3VwZGF0ZScgOiAnbW91bnQnKSArICddJztcbiAgfSBlbHNlIHtcbiAgICAvLyBDb21wb3NpdGUgY29tcG9uZW50IG1ldGhvZHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnLicgKyBwaGFzZTtcbiAgfVxufTtcblxudmFyIGJlZ2luRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcblxuICBpZiAoaXNDb21taXR0aW5nICYmIGxhYmVsc0luQ3VycmVudENvbW1pdC5oYXMobGFiZWwpKSB7XG4gICAgLy8gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIHdlIGRvbid0IHNob3cgZHVwbGljYXRlIGxhYmVscyBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgYSBmaXhlZCBvdmVyaGVhZCBmb3IgZXZlcnkgbWVhc3VyZW1lbnQsIGFuZCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIGJleW9uZCBuZWNlc3NhcnkuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxhYmVsc0luQ3VycmVudENvbW1pdC5hZGQobGFiZWwpO1xuXG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBiZWdpbk1hcmsobWFya05hbWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBjbGVhckZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBjbGVhck1hcmsobWFya05hbWUpO1xufTtcblxudmFyIGVuZEZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBlbmRNYXJrKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyQkMSk7XG59O1xuXG52YXIgc2hvdWxkSWdub3JlRmliZXIgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgLy8gSG9zdCBjb21wb25lbnRzIHNob3VsZCBiZSBza2lwcGVkIGluIHRoZSB0aW1lbGluZS5cbiAgLy8gV2UgY291bGQgY2hlY2sgdHlwZW9mIGZpYmVyLnR5cGUsIGJ1dCBkb2VzIHRoaXMgd29yayB3aXRoIFJOP1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlclsncmV0dXJuJ10gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlclsncmV0dXJuJ10pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nICYmICFpc1dhaXRpbmdGb3JDYWxsYmFjaykge1xuICAgICAgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgYmVnaW5NYXJrKCcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBkaWRFeHBpcmUgPyAnUmVhY3Qgd2FzIGJsb2NrZWQgYnkgbWFpbiB0aHJlYWQnIDogbnVsbDtcbiAgICAgIGVuZE1hcmsoJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknLCAnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgdGhpcyBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1lbWJlciB3ZSBzaG91bGRuJ3QgY29tcGxldGUgbWVhc3VyZW1lbnQgZm9yIHRoaXMgZmliZXIuXG4gICAgLy8gT3RoZXJ3aXNlIGZsYW1lY2hhcnQgd2lsbCBiZSBkZWVwIGV2ZW4gZm9yIHNtYWxsIHVwZGF0ZXMuXG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBjbGVhckZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGYWlsZWRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgdmFyIHdhcm5pbmckJDEgPSAnQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgdGhpcyBlcnJvciBib3VuZGFyeSc7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFBoYXNlVGltZXIoZmliZXIsIHBoYXNlKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCgpO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIHBoYXNlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IGZpYmVyO1xuICAgIGN1cnJlbnRQaGFzZSA9IHBoYXNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BQaGFzZVRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB3YXJuaW5nJCQxID0gaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPyAnU2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZScgOiBudWxsO1xuICAgICAgZW5kRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UsIHdhcm5pbmckJDEpO1xuICAgIH1cbiAgICBjdXJyZW50UGhhc2UgPSBudWxsO1xuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtMb29wVGltZXIobmV4dFVuaXRPZldvcmspIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBjdXJyZW50RmliZXIgPSBuZXh0VW5pdE9mV29yaztcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBUaGlzIGlzIHRvcCBsZXZlbCBjYWxsLlxuICAgIC8vIEFueSBvdGhlciBtZWFzdXJlbWVudHMgYXJlIHBlcmZvcm1lZCB3aXRoaW4uXG4gICAgYmVnaW5NYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknKTtcbiAgICAvLyBSZXN1bWUgYW55IG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgaW4gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBsYXN0IGxvb3AuXG4gICAgcmVzdW1lVGltZXJzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB3YXJuaW5nJCQxID0gbnVsbDtcbiAgICBpZiAoaW50ZXJydXB0ZWRCeSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGludGVycnVwdGVkQnkudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0EgdG9wLWxldmVsIHVwZGF0ZSBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShpbnRlcnJ1cHRlZEJ5KSB8fCAnVW5rbm93bic7XG4gICAgICAgIHdhcm5pbmckJDEgPSAnQW4gdXBkYXRlIHRvICcgKyBjb21wb25lbnROYW1lICsgJyBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAxKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ1RoZXJlIHdlcmUgY2FzY2FkaW5nIHVwZGF0ZXMnO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICAvLyBQYXVzZSBhbnkgbWVhc3VyZW1lbnRzIHVudGlsIHRoZSBuZXh0IGxvb3AuXG4gICAgcGF1c2VUaW1lcnMoKTtcbiAgICBlbmRNYXJrKCcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknLCAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCkge1xuICAgICAgd2FybmluZyQkMSA9ICdMaWZlY3ljbGUgaG9vayBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJztcbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAwKSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ0NhdXNlZCBieSBhIGNhc2NhZGluZyB1cGRhdGUgaW4gZWFybGllciBjb21taXQnO1xuICAgIH1cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wKys7XG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG5cbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScsICcoQ29tbWl0dGluZyBDaGFuZ2VzKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0czogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknLCBudWxsKTtcbiAgfVxufVxuXG57XG4gIHZhciB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxuLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlPYmplY3QpO1xuLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTtcbi8vIEtlZXAgdHJhY2sgb2YgdGhlIHByZXZpb3VzIGNvbnRleHQgb2JqZWN0IHRoYXQgd2FzIG9uIHRoZSBzdGFjay5cbi8vIFdlIHVzZSB0aGlzIHRvIGdldCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBjb250ZXh0IGFmdGVyIHdlIGhhdmUgYWxyZWFkeVxuLy8gcHVzaGVkIHRoZSBuZXh0IGNvbnRleHQgcHJvdmlkZXIsIGFuZCBub3cgbmVlZCB0byBtZXJnZSB0aGVpciBjb250ZXh0cy5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcblxuZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBoYXNPd25Db250ZXh0ID0gaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICBpZiAoaGFzT3duQ29udGV4dCkge1xuICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAvLyB3ZSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgIC8vIHByb3ZpZGVyIHNob3VsZCBub3QgXCJzZWVcIiBpdHMgb3duIGNoaWxkIGNvbnRleHQuIFRoZXJlZm9yZSB3ZSByZWFkIHRoZVxuICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgbWFza2VkQ29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAvLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcbiAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSwgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0UHJvdmlkZXIoZmliZXIpIHtcbiAgaWYgKCFpc0NvbnRleHRQcm92aWRlcihmaWJlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcikge1xuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJzb3IgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgcGFyZW50Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgLy8gVE9ETyAoYnZhdWdobikgUmVwbGFjZSB0aGlzIGJlaGF2aW9yIHdpdGggYW4gaW52YXJpYW50KCkgaW4gdGhlIGZ1dHVyZS5cbiAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY2hpbGRDb250ZXh0VHlwZXMgaXMgc3BlY2lmaWVkIGJ1dCB0aGVyZSBpcyBubyBnZXRDaGlsZENvbnRleHQoKSBtZXRob2QgJyArICdvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJyArICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIHZhciBjaGlsZENvbnRleHQgPSB2b2lkIDA7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIH1cbiAgc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCAnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgY29udGV4dEtleSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAhKGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0VHlwZXMpID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lLFxuICAgIC8vIEluIHByYWN0aWNlLCB0aGVyZSBpcyBvbmUgY2FzZSBpbiB3aGljaCB3ZSB3b24ndCBnZXQgYSBzdGFjay4gSXQncyB3aGVuXG4gICAgLy8gc29tZWJvZHkgY2FsbHMgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIoKSBhbmQgd2UgcHJvY2Vzc1xuICAgIC8vIGNvbnRleHQgZnJvbSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIHN0YWNrIHdpbGwgYmUgbWlzc2luZ1xuICAgIC8vIGJlY2F1c2UgaXQncyBvdXRzaWRlIG9mIHRoZSByZWNvbmNpbGlhdGlvbiwgYW5kIHNvIHRoZSBwb2ludGVyIGhhcyBub3RcbiAgICAvLyBiZWVuIHNldC4gVGhpcyBpcyByYXJlIGFuZCBkb2Vzbid0IG1hdHRlci4gV2UnbGwgYWxzbyByZW1vdmUgdGhhdCBBUEkuXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKTtcbiAgfVxuXG4gIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyBXZSBwdXNoIHRoZSBjb250ZXh0IGFzIGVhcmx5IGFzIHBvc3NpYmxlIHRvIGVuc3VyZSBzdGFjayBpbnRlZ3JpdHkuXG4gIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG4gIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgLy8gSW5oZXJpdCB0aGUgcGFyZW50J3MgZGlkLXBlcmZvcm0td29yayB2YWx1ZSB0byBhdm9pZCBpbmFkdmVydGVudGx5IGJsb2NraW5nIHVwZGF0ZXMuXG4gIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZGlkQ2hhbmdlKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgIWluc3RhbmNlID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAvLyBNZXJnZSBwYXJlbnQgYW5kIG93biBjb250ZXh0LlxuICAgIC8vIFNraXAgdGhpcyBpZiB3ZSdyZSBub3QgdXBkYXRpbmcgZHVlIHRvIHNDVS5cbiAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICB2YXIgbWVyZ2VkQ29udGV4dCA9IHByb2Nlc3NDaGlsZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZpb3VzQ29udGV4dCk7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBtZXJnZWRDb250ZXh0O1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgIC8vIEl0IGlzIGltcG9ydGFudCB0byB1bndpbmQgdGhlIGNvbnRleHQgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgLy8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lcmdlZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldENvbnRleHQoKSB7XG4gIHByZXZpb3VzQ29udGV4dCA9IGVtcHR5T2JqZWN0O1xuICBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9IGVtcHR5T2JqZWN0O1xuICBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAhKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gbm9kZVsncmV0dXJuJ107XG4gICAgIXBhcmVudCA/IGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgbm9kZSA9IHBhcmVudDtcbiAgfVxuICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcbn1cblxudmFyIE5vV29yayA9IDA7IC8vIFRPRE86IFVzZSBhbiBvcGFxdWUgdHlwZSBvbmNlIEVTTGludCBldCBhbCBzdXBwb3J0IHRoZSBzeW50YXhcblxudmFyIFN5bmMgPSAxO1xudmFyIE5ldmVyID0gMjE0NzQ4MzY0NzsgLy8gTWF4IGludDMyOiBNYXRoLnBvdygyLCAzMSkgLSAxXG5cbnZhciBVTklUX1NJWkUgPSAxMDtcbnZhciBNQUdJQ19OVU1CRVJfT0ZGU0VUID0gMjtcblxuLy8gMSB1bml0IG9mIGV4cGlyYXRpb24gdGltZSByZXByZXNlbnRzIDEwbXMuXG5mdW5jdGlvbiBtc1RvRXhwaXJhdGlvblRpbWUobXMpIHtcbiAgLy8gQWx3YXlzIGFkZCBhbiBvZmZzZXQgc28gdGhhdCB3ZSBkb24ndCBjbGFzaCB3aXRoIHRoZSBtYWdpYyBudW1iZXIgZm9yIE5vV29yay5cbiAgcmV0dXJuIChtcyAvIFVOSVRfU0laRSB8IDApICsgTUFHSUNfTlVNQkVSX09GRlNFVDtcbn1cblxuZnVuY3Rpb24gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKSB7XG4gIHJldHVybiAoZXhwaXJhdGlvblRpbWUgLSBNQUdJQ19OVU1CRVJfT0ZGU0VUKSAqIFVOSVRfU0laRTtcbn1cblxuZnVuY3Rpb24gY2VpbGluZyhudW0sIHByZWNpc2lvbikge1xuICByZXR1cm4gKChudW0gLyBwcmVjaXNpb24gfCAwKSArIDEpICogcHJlY2lzaW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgZXhwaXJhdGlvbkluTXMsIGJ1Y2tldFNpemVNcykge1xuICByZXR1cm4gY2VpbGluZyhjdXJyZW50VGltZSArIGV4cGlyYXRpb25Jbk1zIC8gVU5JVF9TSVpFLCBidWNrZXRTaXplTXMgLyBVTklUX1NJWkUpO1xufVxuXG52YXIgTm9Db250ZXh0ID0gMDtcbnZhciBBc3luY1VwZGF0ZXMgPSAxO1xuXG57XG4gIHZhciBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cbiAgICBcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbi8vIEEgRmliZXIgaXMgd29yayBvbiBhIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgb3Igd2FzIGRvbmUuIFRoZXJlIGNhblxuLy8gYmUgbW9yZSB0aGFuIG9uZSBwZXIgY29tcG9uZW50LlxuXG5cbntcbiAgdmFyIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIC8vIEZpYmVyXG4gIHRoaXNbJ3JldHVybiddID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuXG4gIHRoaXMucmVmID0gbnVsbDtcblxuICB0aGlzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXG4gIHRoaXMuaW50ZXJuYWxDb250ZXh0VGFnID0gaW50ZXJuYWxDb250ZXh0VGFnO1xuXG4gIC8vIEVmZmVjdHNcbiAgdGhpcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgdGhpcy5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgY3VycmVudC5rZXksIGN1cnJlbnQuaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlLFxuICAgICAga2V5ID0gZWxlbWVudC5rZXk7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXIgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBjcmVhdGVGaWJlcihDbGFzc0NvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIDogY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgLy8gQ3VycmVudGx5IGFzc3VtZWQgdG8gYmUgYSBjb250aW51YXRpb24gYW5kIHRoZXJlZm9yZSBpcyBhIGZpYmVyIGFscmVhZHkuXG4gICAgLy8gVE9ETzogVGhlIHlpZWxkIHN5c3RlbSBpcyBjdXJyZW50bHkgYnJva2VuIGZvciB1cGRhdGVzIGluIHNvbWUgY2FzZXMuXG4gICAgLy8gVGhlIHJlaWZpZWQgeWllbGQgc3RvcmVzIGEgZmliZXIsIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZpYmVyIHRoYXQgaXM7XG4gICAgLy8gdGhlIGN1cnJlbnQgb3IgYSB3b3JrSW5Qcm9ncmVzcz8gV2hlbiB0aGUgY29udGludWF0aW9uIGdldHMgcmVuZGVyZWQgaGVyZVxuICAgIC8vIHdlIGRvbid0IGtub3cgaWYgd2UgY2FuIHJldXNlIHRoYXQgZmliZXIgb3IgaWYgd2UgbmVlZCB0byBjbG9uZSBpdC5cbiAgICAvLyBUaGVyZSBpcyBwcm9iYWJseSBhIGNsZXZlciB3YXkgdG8gcmVzdHJ1Y3R1cmUgdGhpcy5cbiAgICBmaWJlciA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG4gICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyKSA6IG51bGw7XG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50cztcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvbnRlbnQ7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKENhbGxDb21wb25lbnQsIGNhbGwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci50eXBlID0gY2FsbC5oYW5kbGVyO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjYWxsO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFJldHVybkNvbXBvbmVudCwgbnVsbCwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBvcnRhbC5rZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiB8fCBbXTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCwgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKCk7XG4gIHZhciByb290ID0ge1xuICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGlzUmVhZHlGb3JDb21taXQ6IGZhbHNlLFxuICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGxcbiAgfTtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xudmFyIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgIH1cbiAgICAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTtcbiAgICAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuICAgIG9uQ29tbWl0RmliZXJSb290ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0pO1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxue1xuICB2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xufVxuXG4vLyBDYWxsYmFja3MgYXJlIG5vdCB2YWxpZGF0ZWQgdW50aWwgaW52b2NhdGlvblxuXG5cbi8vIFNpbmdseSBsaW5rZWQtbGlzdCBvZiB1cGRhdGVzLiBXaGVuIGFuIHVwZGF0ZSBpcyBzY2hlZHVsZWQsIGl0IGlzIGFkZGVkIHRvXG4vLyB0aGUgcXVldWUgb2YgdGhlIGN1cnJlbnQgZmliZXIgYW5kIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBUaGUgdHdvIHF1ZXVlc1xuLy8gYXJlIHNlcGFyYXRlIGJ1dCB0aGV5IHNoYXJlIGEgcGVyc2lzdGVudCBzdHJ1Y3R1cmUuXG4vL1xuLy8gRHVyaW5nIHJlY29uY2lsaWF0aW9uLCB1cGRhdGVzIGFyZSByZW1vdmVkIGZyb20gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIsXG4vLyBidXQgdGhleSByZW1haW4gb24gdGhlIGN1cnJlbnQgZmliZXIuIFRoYXQgZW5zdXJlcyB0aGF0IGlmIGEgd29yay1pbi1wcm9ncmVzc1xuLy8gaXMgYWJvcnRlZCwgdGhlIGFib3J0ZWQgdXBkYXRlcyBhcmUgcmVjb3ZlcmVkIGJ5IGNsb25pbmcgZnJvbSBjdXJyZW50LlxuLy9cbi8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGFsd2F5cyBhIHN1YnNldCBvZiB0aGUgY3VycmVudCBxdWV1ZS5cbi8vXG4vLyBXaGVuIHRoZSB0cmVlIGlzIGNvbW1pdHRlZCwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgYmVjb21lcyB0aGUgY3VycmVudC5cblxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGVRdWV1ZShiYXNlU3RhdGUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGJhc2VTdGF0ZTogYmFzZVN0YXRlLFxuICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgZmlyc3Q6IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgaGFzRm9yY2VVcGRhdGU6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZhbHNlXG4gIH07XG4gIHtcbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbmZ1bmN0aW9uIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gIGlmIChxdWV1ZS5sYXN0ID09PSBudWxsKSB7XG4gICAgLy8gUXVldWUgaXMgZW1wdHlcbiAgICBxdWV1ZS5maXJzdCA9IHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgcXVldWUubGFzdC5uZXh0ID0gdXBkYXRlO1xuICAgIHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH1cbiAgaWYgKHF1ZXVlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcXVldWUuZXhwaXJhdGlvblRpbWUgPiB1cGRhdGUuZXhwaXJhdGlvblRpbWUpIHtcbiAgICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSkge1xuICAvLyBXZSdsbCBoYXZlIGF0IGxlYXN0IG9uZSBhbmQgYXQgbW9zdCB0d28gZGlzdGluY3QgdXBkYXRlIHF1ZXVlcy5cbiAgdmFyIGFsdGVybmF0ZUZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICB2YXIgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmIChxdWV1ZTEgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAgIC8vIEl0IGRlcGVuZHMgb24gd2hpY2ggZmliZXIgaXMgdGhlIG5leHQgY3VycmVudC4gSW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5XG4gICAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAgIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKG51bGwpO1xuICB9XG5cbiAgdmFyIHF1ZXVlMiA9IHZvaWQgMDtcbiAgaWYgKGFsdGVybmF0ZUZpYmVyICE9PSBudWxsKSB7XG4gICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWU7XG4gICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgfVxuICBxdWV1ZTIgPSBxdWV1ZTIgIT09IHF1ZXVlMSA/IHF1ZXVlMiA6IG51bGw7XG5cbiAgLy8gV2FybiBpZiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGFuIHVwZGF0ZXIgZnVuY3Rpb24uXG4gIHtcbiAgICBpZiAoKHF1ZXVlMS5pc1Byb2Nlc3NpbmcgfHwgcXVldWUyICE9PSBudWxsICYmIHF1ZXVlMi5pc1Byb2Nlc3NpbmcpICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSBxdWV1ZSwgYWRkIHRoZSB1cGRhdGUgdG8gdGhhdCBxdWV1ZSBhbmQgZXhpdC5cbiAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgZWl0aGVyIHF1ZXVlIGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGFkZCB0byBib3RoIHF1ZXVlcy5cbiAgaWYgKHF1ZXVlMS5sYXN0ID09PSBudWxsIHx8IHF1ZXVlMi5sYXN0ID09PSBudWxsKSB7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUyLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGJvdGggbGlzdHMgYXJlIG5vdCBlbXB0eSwgdGhlIGxhc3QgdXBkYXRlIGlzIHRoZSBzYW1lIGZvciBib3RoIGxpc3RzXG4gIC8vIGJlY2F1c2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLiBTbywgd2Ugc2hvdWxkIG9ubHkgYXBwZW5kIHRvIG9uZSBvZlxuICAvLyB0aGUgbGlzdHMuXG4gIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gIC8vIEJ1dCB3ZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSB0aGUgYGxhc3RgIHBvaW50ZXIgb2YgcXVldWUyLlxuICBxdWV1ZTIubGFzdCA9IHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVF1ZXVlLmV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcykge1xuICB2YXIgcGFydGlhbFN0YXRlID0gdXBkYXRlLnBhcnRpYWxTdGF0ZTtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdXBkYXRlRm4gPSBwYXJ0aWFsU3RhdGU7XG5cbiAgICAvLyBJbnZva2Ugc2V0U3RhdGUgY2FsbGJhY2sgYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgdXBkYXRlRm4uY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJ0aWFsU3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnVwZGF0ZVF1ZXVlID09PSBxdWV1ZSkge1xuICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGEgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgYnkgY2xvbmluZyB0aGUgY3VycmVudCBxdWV1ZS5cbiAgICB2YXIgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBjdXJyZW50UXVldWUuZXhwaXJhdGlvblRpbWUsXG4gICAgICBmaXJzdDogY3VycmVudFF1ZXVlLmZpcnN0LFxuICAgICAgbGFzdDogY3VycmVudFF1ZXVlLmxhc3QsXG4gICAgICBpc0luaXRpYWxpemVkOiBjdXJyZW50UXVldWUuaXNJbml0aWFsaXplZCxcbiAgICAgIC8vIFRoZXNlIGZpZWxkcyBhcmUgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2UgdGhleSB3ZXJlIGFscmVhZHkgY29tbWl0dGVkLlxuICAgICAgLy8gUmVzZXQgdGhlbS5cbiAgICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLy8gU2V0IHRoaXMgZmxhZyBzbyB3ZSBjYW4gd2FybiBpZiBzZXRTdGF0ZSBpcyBjYWxsZWQgaW5zaWRlIHRoZSB1cGRhdGVcbiAgICAvLyBmdW5jdGlvbiBvZiBhbm90aGVyIHNldFN0YXRlLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS4gSWYgd2Ugc2tpcCBvdmVyIGFueSB1cGRhdGVzLCB3ZSdsbFxuICAvLyBpbmNyZWFzZSB0aGlzIGFjY29yZGluZ2x5LlxuICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAvLyBiYXNlIHN0YXRlLCB0aGVuIHNldCB0byB0aGUgbWVtb2l6ZWRTdGF0ZSB3aGVuIHJlbmRlcmluZy4gTm90IHN1cGVyXG4gIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgdmFyIHN0YXRlID0gdm9pZCAwO1xuICBpZiAocXVldWUuaXNJbml0aWFsaXplZCkge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBxdWV1ZS5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuICB2YXIgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdDtcbiAgdmFyIGRpZFNraXAgPSBmYWxzZTtcbiAgd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAodXBkYXRlRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBub3QgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBTa2lwIGl0LlxuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcXVldWUuZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA+IHVwZGF0ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS5cbiAgICAgICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICAgICAgcXVldWUuYmFzZVN0YXRlID0gc3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBDb250aW51ZSB0byB0aGUgbmV4dCB1cGRhdGUuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgbm8gcHJldmlvdXMgdXBkYXRlcyB3ZXJlIHNraXBwZWQsIGRyb3AgdGhpcyB1cGRhdGUgZnJvbSB0aGUgcXVldWUgYnlcbiAgICAvLyBhZHZhbmNpbmcgdGhlIGhlYWQgb2YgdGhlIGxpc3QuXG4gICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICBxdWV1ZS5maXJzdCA9IHVwZGF0ZS5uZXh0O1xuICAgICAgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmxhc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgdGhlIHVwZGF0ZVxuICAgIHZhciBfcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgIGlmICh1cGRhdGUuaXNSZXBsYWNlKSB7XG4gICAgICBzdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wYXJ0aWFsU3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGlmIChfcGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChkb250TXV0YXRlUHJldlN0YXRlKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZTogSWRrIGhvdyB0byB0eXBlIHRoaXMgcHJvcGVybHkuXG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHt9LCBzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBkb250TXV0YXRlUHJldlN0YXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGUuaXNGb3JjZWQpIHtcbiAgICAgIHF1ZXVlLmhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gQXBwZW5kIHRvIGxpc3Qgb2YgY2FsbGJhY2tzLlxuICAgICAgdmFyIF9jYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gICAgICBpZiAoX2NhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgICAgICBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0ID0gW107XG4gICAgICB9XG4gICAgICBfY2FsbGJhY2tMaXN0LnB1c2godXBkYXRlKTtcbiAgICB9XG4gICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gIH1cblxuICBpZiAocXVldWUuY2FsbGJhY2tMaXN0ICE9PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrO1xuICB9IGVsc2UgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsICYmICFxdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBlbXB0eS4gV2UgY2FuIHJlc2V0IGl0LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghZGlkU2tpcCkge1xuICAgIGRpZFNraXAgPSB0cnVlO1xuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAge1xuICAgIC8vIE5vIGxvbmdlciBwcm9jZXNzaW5nLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3MocXVldWUsIGNvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdDtcbiAgaWYgKGNhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTZXQgdGhlIGxpc3QgdG8gbnVsbCB0byBtYWtlIHN1cmUgdGhleSBkb24ndCBnZXQgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlxuICBxdWV1ZS5jYWxsYmFja0xpc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cGRhdGUgPSBjYWxsYmFja0xpc3RbaV07XG4gICAgdmFyIF9jYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAvLyBUaGlzIHVwZGF0ZSBtaWdodCBiZSBwcm9jZXNzZWQgYWdhaW4uIENsZWFyIHRoZSBjYWxsYmFjayBzbyBpdCdzIG9ubHlcbiAgICAvLyBjYWxsZWQgb25jZS5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBudWxsO1xuICAgICEodHlwZW9mIF9jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBfY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG57XG4gIHZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2FybmluZyhjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0IGEgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc25cXCd0IHN1cHBvcnRlZC4gVHJ5IHRvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoIHRvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbnZhciBSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSkge1xuICAvLyBDbGFzcyBjb21wb25lbnQgc3RhdGUgdXBkYXRlclxuICB2YXIgdXBkYXRlciA9IHtcbiAgICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHBhcnRpYWxTdGF0ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogc3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiB0cnVlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogdHJ1ZSxcbiAgICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCkge1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgICAgLy8gSWYgdGhlIHdvcmtJblByb2dyZXNzIGFscmVhZHkgaGFzIGFuIFVwZGF0ZSBlZmZlY3QsIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPSAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIHdhcm5pbmcobm9HZXRJbml0aWFsU3RhdGVPbkVTNiwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICAgIHZhciBub0dldERlZmF1bHRQcm9wc09uRVM2ID0gIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcyB8fCBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQ7XG4gICAgICB3YXJuaW5nKG5vR2V0RGVmYXVsdFByb3BzT25FUzYsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlUHJvcFR5cGVzID0gIWluc3RhbmNlLnByb3BUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZVByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlQ29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgICAgfVxuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkVW5tb3VudCA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudERpZFVubW91bnQsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZURlZmF1bHRQcm9wcyA9ICFpbnN0YW5jZS5kZWZhdWx0UHJvcHM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMsICdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShzdGF0ZSkpKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybmluZyh0eXBlb2Ygd29ya0luUHJvZ3Jlc3MudHlwZS5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAvLyBUaGUgaW5zdGFuY2UgbmVlZHMgYWNjZXNzIHRvIHRoZSBmaWJlciBzbyB0aGF0IGl0IGNhbiBzY2hlZHVsZSB1cGRhdGVzXG4gICAgc2V0KGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByb3BzKSB7XG4gICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZWVkc0NvbnRleHQgPSBpc0NvbnRleHRDb25zdW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBuZWVkc0NvbnRleHQgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlPYmplY3Q7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG4gICAgaWYgKG5lZWRzQ29udGV4dCkge1xuICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICB9XG5cbiAgICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgLy8gU2ltdWxhdGUgYW4gYXN5bmMgYmFpbG91dC9pbnRlcnJ1cHRpb24gYnkgaW52b2tpbmcgbGlmZWN5Y2xlIHR3aWNlLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJyArIFwidGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG4gIGZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIHtcbiAgICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlIHx8IG51bGw7XG5cbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgIXByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgbXVzdCBiZSBwZW5kaW5nIHByb3BzIGZvciBhbiBpbml0aWFsIG1vdW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlO1xuICAgIGluc3RhbmNlLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgd29ya0luUHJvZ3Jlc3MudHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlICE9IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5pbnRlcm5hbENvbnRleHRUYWcgfD0gQXN5bmNVcGRhdGVzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgICAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgcHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb24gYSBwcmVleGlzdGluZyBjbGFzcyBpbnN0YW5jZS4gUmV0dXJucyBmYWxzZSBpZiBhIHJlc3VtZWQgcmVuZGVyXG4gIC8vIGNvdWxkIGJlIHJldXNlZC5cbiAgLy8gZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKFxuICAvLyAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgLy8gICBwcmlvcml0eUxldmVsOiBQcmlvcml0eUxldmVsLFxuICAvLyApOiBib29sZWFuIHtcbiAgLy8gICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAvLyAgIGxldCBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIC8vICAgbGV0IG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAvLyAgIGlmICghbmV3UHJvcHMpIHtcbiAgLy8gICAgIC8vIElmIHRoZXJlIGlzbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAvLyAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gIC8vICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIC8vICAgICBpbnZhcmlhbnQoXG4gIC8vICAgICAgIG5ld1Byb3BzICE9IG51bGwsXG4gIC8vICAgICAgICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgJyArXG4gIC8vICAgICAgICAgJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gIC8vICAgICApO1xuICAvLyAgIH1cbiAgLy8gICBjb25zdCBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAvLyAgIGNvbnN0IG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gIC8vICAgY29uc3Qgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIC8vICAgY29uc3Qgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiZcbiAgLy8gICAgIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dClcbiAgLy8gICApIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUgYmVmb3JlIGNhbGxpbmcgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gIC8vICAgY29uc3QgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgLy8gICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgdXBkYXRlUXVldWUsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICApO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIFRPRE86IFNob3VsZCB3ZSBkZWFsIHdpdGggYSBzZXRTdGF0ZSB0aGF0IGhhcHBlbmVkIGFmdGVyIHRoZSBsYXN0XG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGFuZCBiZWZvcmUgdGhpcyBjb21wb25lbnRXaWxsTW91bnQ/IFByb2JhYmx5XG4gIC8vICAgLy8gdW5zdXBwb3J0ZWQgYW55d2F5LlxuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgIWNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gIC8vICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKVxuICAvLyAgICkge1xuICAvLyAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyAgICAgLy8gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LlxuICAvLyAgICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIC8vICAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcbiAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBVcGRhdGUgdGhlIGlucHV0IHBvaW50ZXJzIG5vdyBzbyB0aGF0IHRoZXkgYXJlIGNvcnJlY3Qgd2hlbiB3ZSBjYWxsXG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50XG4gIC8vICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgLy8gICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBtYXkgaGF2ZSBjYWxsZWQgc2V0U3RhdGUuIFByb2Nlc3MgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgLy8gICAgIGNvbnN0IG5ld1VwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgICBpZiAobmV3VXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoXG4gIC8vICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgICAgbmV3VXBkYXRlUXVldWUsXG4gIC8vICAgICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgLy8gICAgICAgKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG5cbiAgLy8gICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAvLyAgIH1cblxuICAvLyAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG5cbiAgLy8gICByZXR1cm4gdHJ1ZTtcbiAgLy8gfVxuXG4gIC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHJlc2V0SW5wdXRQb2ludGVycyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gICAgICBuZXdQcm9wcyA9IG9sZFByb3BzO1xuICAgICAgIShuZXdQcm9wcyAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIHNob3VsZCBhbHdheXMgYmUgcGVuZGluZyBvciBtZW1vaXplZCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAgIHZhciBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAgIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAgIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXdDb250ZXh0KSkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV4dCBzdGF0ZSB1c2luZyB0aGUgbWVtb2l6ZWQgc3RhdGUgYW5kIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAvLyBUT0RPOiBQcmV2aW91cyBzdGF0ZSBjYW4gYmUgbnVsbC5cbiAgICB2YXIgbmV3U3RhdGUgPSB2b2lkIDA7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsIGluc3RhbmNlLCBuZXdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZSA9IG9sZFN0YXRlO1xuICAgIH1cblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICEod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpKSB7XG4gICAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgICAgIC8vIFNpbXVsYXRlIGFuIGFzeW5jIGJhaWxvdXQvaW50ZXJydXB0aW9uIGJ5IGludm9raW5nIGxpZmVjeWNsZSB0d2ljZS5cbiAgICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMpO1xuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAgIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZTogYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6IGNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gICAgbW91bnRDbGFzc0luc3RhbmNlOiBtb3VudENsYXNzSW5zdGFuY2UsXG4gICAgLy8gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlLFxuICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2U6IHVwZGF0ZUNsYXNzSW5zdGFuY2VcbiAgfTtcbn07XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX0NBTExfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNhbGwnKSA6IDB4ZWFjODtcbnZhciBSRUFDVF9SRVRVUk5fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnJldHVybicpIDogMHhlYWM5O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxue1xuICB2YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG4gIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgdmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yICcgKyAnbW9yZSBpbmZvcm1hdGlvbi4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gIH07XG59XG5cbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCkge1xuICB2YXIgbWl4ZWRSZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKG1peGVkUmVmICE9PSBudWxsICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdCA9IHZvaWQgMDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgICAhKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogdm9pZCAwO1xuICAgICAgICBpbnN0ID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgICAhaW5zdCA/IGludmFyaWFudChmYWxzZSwgJ01pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgJXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7XG4gICAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIGN1cnJlbnQucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuJykgOiB2b2lkIDA7XG4gICAgICAhZWxlbWVudC5fb3duZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFlvdSBtYXkgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkLiAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICB7XG4gICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuXG4gIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICB3YXJuaW5nKGZhbHNlLCAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG59XG5cbi8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG4gICAgY2hpbGRUb0RlbGV0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHRvIGEgdGVtcG9yYXJ5IG1hcCBzbyB0aGF0IHdlIGNhbiBmaW5kIHRoZW0gYnlcbiAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnQsIGNhbGwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYWxzbyBjb21wYXJlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV1c2U/XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IENhbGxDb21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnQsIHJldHVybk5vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IFJldHVybkNvbXBvbmVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkMi5yZWYgPSBjb2VyY2VSZWYobnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDJbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21DYWxsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkM1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDQudHlwZSA9IG5ld0NoaWxkLnZhbHVlO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQ1ID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkNVsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDU7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQ2ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgICBfY3JlYXRlZDZbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDY7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBmaWJlciBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYVxuICAgICAgICAgICAgLy8geWllbGQuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgICAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSByZXR1cm5zLCB0aGV5IG1hdGNoLlxuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVJldHVybihyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI0ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjUgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjUsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCk7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4lcycsIGtleSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGhzIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmICghX25ld0ZpYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXIyKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwb3NzaWJsZU1hcCA9IG5ld0NoaWxkcmVuSXRlcmFibGU7XG4gICAgICAgIGlmIChwb3NzaWJsZU1hcC5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgICAgd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgICB2YXIgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgIShuZXdDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci4nKSA6IHZvaWQgMDtcblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIHZhciBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKCFvbGRGaWJlcikge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICB2YXIgX25ld0ZpYmVyMyA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuWydkZWxldGUnXShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihjaGlsZCwgZWxlbWVudCk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDcgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ3LnJlZiA9IGNvZXJjZVJlZihjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gX2NyZWF0ZWQ3O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBjYWxsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB5aWVsZHMgc2luY2UgdGhleSdyZSBzdGF0ZWxlc3MuXG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZC50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbDtcblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlQ2FsbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVJldHVybihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCB0byB0aGUgbmV4dCBjYXNlLCB3aGljaCBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5cbmZ1bmN0aW9uIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSA/IGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcblxuICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld0NoaWxkWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufVxuXG57XG4gIHZhciB3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnMgPSB7fTtcbn1cblxudmFyIFJlYWN0RmliZXJCZWdpbldvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKSB7XG4gIHZhciBzaG91bGRTZXRUZXh0Q29udGVudCA9IGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudCxcbiAgICAgIHVzZVN5bmNTY2hlZHVsaW5nID0gY29uZmlnLnVzZVN5bmNTY2hlZHVsaW5nLFxuICAgICAgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSA9IGNvbmZpZy5zaG91bGREZXByaW9yaXRpemVTdWJ0cmVlO1xuICB2YXIgcHVzaEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250ZXh0LFxuICAgICAgcHVzaEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wdXNoSG9zdENvbnRhaW5lcjtcbiAgdmFyIGVudGVySHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LmVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5yZXNldEh5ZHJhdGlvblN0YXRlLFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIHZhciBfUmVhY3RGaWJlckNsYXNzQ29tcG8gPSBSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQoc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSksXG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgICAgbW91bnRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLm1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8udXBkYXRlQ2xhc3NJbnN0YW5jZTtcblxuICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBhbmQgdXNlIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZSBkaXJlY3RseS5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmcmVzaCBuZXcgY29tcG9uZW50IHRoYXQgaGFzbid0IGJlZW4gcmVuZGVyZWQgeWV0LCB3ZVxuICAgICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAgIC8vIHdlIGNhbiBvcHRpbWl6ZSB0aGlzIHJlY29uY2lsaWF0aW9uIHBhc3MgYnkgbm90IHRyYWNraW5nIHNpZGUtZWZmZWN0cy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCAmJiAoIWN1cnJlbnQgfHwgY3VycmVudC5yZWYgIT09IHJlZikpIHtcbiAgICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgdmFyIG1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwgfHwgbWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIC8vIFRPRE86IGNvbnNpZGVyIGJyaW5naW5nIGZuLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpIGJhY2suXG4gICAgICAvLyBJdCB1c2VkIHRvIGJlIGhlcmUuXG4gICAgfVxuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIG5leHRDaGlsZHJlbjtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGZuKG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB2b2lkIDA7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIGlmICghd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKSB7XG4gICAgICAgIC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpO1xuICAgICAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG4gICAgICAgIC8vIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQpIHtcbiAgICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKCFzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgLy8gUmVyZW5kZXJcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICB9XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIC8vIE1lbW9pemUgcHJvcHMgYW5kIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnByb3BzKTtcblxuICAgIC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LmNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKHByZXZTdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN0YXRlIGlzIHRoZSBzYW1lIGFzIGJlZm9yZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHdlIGhhZFxuICAgICAgICAvLyBubyB3b3JrIHRoYXQgZXhwaXJlcyBhdCB0aGlzIHRpbWUuXG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50O1xuICAgICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBpZiAoKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkgJiYgcm9vdC5oeWRyYXRlICYmIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGN1cnJlbnQgY2hpbGRyZW4gdGhpcyBtaWdodCBiZSB0aGUgZmlyc3QgcGFzcy5cbiAgICAgICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAgICAgLy8gYmUgYW55IGNoaWxkcmVuIHRvIGh5ZHJhdGUgd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcgYXNcbiAgICAgICAgLy8gbm90IGh5ZHJhdGluZy5cblxuICAgICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgICAgICAvLyBrbm93IHRoYXQgd2UncmUgY3VycmVudGx5IGluIGEgbW91bnRpbmcgc3RhdGUuIFRoYXQgd2F5IGlzTW91bnRlZFxuICAgICAgICAvLyB3b3JrcyBhcyBleHBlY3RlZC4gV2UgbXVzdCByZXNldCB0aGlzIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGNoaWxkcmVuIG1vdW50IGludG8gdGhpcyByb290IHdpdGhvdXQgdHJhY2tpbmdcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgICAgICAvLyBub2RlcyB0aGF0IHdpbGwgYmUgaHlkcmF0ZWQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgZWxlbWVudCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgICAgICAvLyByb290LlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgc3RhdGUpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdXBkYXRlIHF1ZXVlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2UgdGhlIHJvb3QgaGFzIG5vIHByb3BzLlxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwpIHtcbiAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICAhKG5leHRQcm9wcyAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICAgIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgICAgLy8gV2Ugc3BlY2lhbCBjYXNlIGEgZGlyZWN0IHRleHQgY2hpbGQgb2YgYSBob3N0IG5vZGUuIFRoaXMgaXMgYSBjb21tb25cbiAgICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhdmUgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChwcmV2UHJvcHMgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ29udGVudFJlc2V0O1xuICAgIH1cblxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGhvc3QgY29uZmlnIHRvIHNlZSBpZiB0aGUgY2hpbGRyZW4gYXJlIG9mZnNjcmVlbi9oaWRkZW4uXG4gICAgaWYgKHJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOZXZlciAmJiAhdXNlU3luY1NjaGVkdWxpbmcgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpKSB7XG4gICAgICAvLyBEb3duLXByaW9yaXRpemUgdGhlIGNoaWxkcmVuLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICAgIC8vIEJhaWxvdXQgYW5kIGNvbWUgYmFjayB0byB0aGlzIGZpYmVyIGxhdGVyLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH1cbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgIShjdXJyZW50ID09PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBuZXZlciBoYXZlIG1vdW50ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIHZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGZuLnByb3RvdHlwZSAmJiB0eXBlb2YgZm4ucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhbHVlID0gZm4ocHJvcHMsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0cnVlLCBoYXNDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgICB2YXIgb3duZXJOYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWUoKTtcbiAgICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgfHwgJyc7XG4gICAgICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuICAgICAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICAgIHdhcm5lZEFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4lcyVzJywgaW5mbywgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgcHJvcHMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENhbGwgPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENhbGwgPSBjdXJyZW50ICYmIGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgIShuZXh0Q2FsbCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENhbGwgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENhbGwpIHtcbiAgICAgIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIC8vIFRPRE86IFdoZW4gYmFpbGluZyBvdXQsIHdlIG1pZ2h0IG5lZWQgdG8gcmV0dXJuIHRoZSBzdGF0ZU5vZGUgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIGNoaWxkLiBUbyBjaGVjayBpdCBmb3Igd29yay5cbiAgICAgIC8vIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENhbGwuY2hpbGRyZW47XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgYnV0IHVzaW5nXG4gICAgLy8gc3RhdGVOb2RlIHRvIHN0b3JlIHRoZSBjaGlsZC5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2FsbCk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHRha2UgYXJiaXRyYXJ5IHRpbWUgc28gd2UgY291bGQgc3luY2hyb25vdXNseSBqdXN0IGJlZ2luXG4gICAgLy8gZWFnZXJseSBkbyB0aGUgd29yayBvZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBhcyBhbiBvcHRpbWl6YXRpb24uXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICEobmV4dENoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIHBlbmRpbmcgb3IgY3VycmVudCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICAvKlxuICBmdW5jdGlvbiByZXVzZUNoaWxkcmVuRWZmZWN0cyhyZXR1cm5GaWJlciA6IEZpYmVyLCBmaXJzdENoaWxkIDogRmliZXIpIHtcbiAgICBsZXQgY2hpbGQgPSBmaXJzdENoaWxkO1xuICAgIGRvIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBmaXJzdCBhbmQgbGFzdCBlZmZlY3Qgb2YgdGhlIHBhcmVudCBjb3JyZXNwb25kc1xuICAgICAgLy8gdG8gdGhlIGNoaWxkcmVuJ3MgZmlyc3QgYW5kIGxhc3QgZWZmZWN0LlxuICAgICAgaWYgKCFyZXR1cm5GaWJlci5maXJzdEVmZmVjdCkge1xuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGQubGFzdEVmZmVjdDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICB9XG4gICovXG5cbiAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgaWRlYWxseSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVhcmx5IGlmIHRoZSBjaGlsZHJlbiBoYXZlIG5vXG4gICAgLy8gbW9yZSB3b3JrIHRvIGRvLiBIb3dldmVyLCBzaW5jZSB3ZSBkb24ndCBoYXZlIGEgc2VwYXJhdGlvbiBvZiB0aGlzXG4gICAgLy8gRmliZXIncyBwcmlvcml0eSBhbmQgaXRzIGNoaWxkcmVuIHlldCAtIHdlIGRvbid0IGtub3cgd2l0aG91dCBkb2luZyBsb3RzXG4gICAgLy8gb2YgdGhlIHNhbWUgd29yayB3ZSBkbyBhbnl3YXkuIE9uY2Ugd2UgaGF2ZSB0aGF0IHNlcGFyYXRpb24gd2UgY2FuIGp1c3RcbiAgICAvLyBiYWlsIG91dCBoZXJlIGlmIHRoZSBjaGlsZHJlbiBoYXMgbm8gbW9yZSB3b3JrIGF0IHRoaXMgcHJpb3JpdHkgbGV2ZWwuXG4gICAgLy8gaWYgKHdvcmtJblByb2dyZXNzLnByaW9yaXR5T2ZDaGlsZHJlbiA8PSBwcmlvcml0eUxldmVsKSB7XG4gICAgLy8gICAvLyBJZiB0aGVyZSBhcmUgc2lkZS1lZmZlY3RzIGluIHRoZXNlIGNoaWxkcmVuIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAvLyAgIC8vIGNvbW1pdHRlZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZXkgZ2V0IHByb3Blcmx5IHRyYW5zZmVycmVkIHVwLlxuICAgIC8vICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICAvLyAgICAgcmV1c2VDaGlsZHJlbkVmZmVjdHMod29ya0luUHJvZ3Jlc3MsIGNoaWxkKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cblxuICAgIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IEhhbmRsZSBIb3N0Q29tcG9uZW50IHRhZ3MgaGVyZSBhcyB3ZWxsIGFuZCBjYWxsIHB1c2hIb3N0Q29udGV4dCgpP1xuICAgIC8vIFNlZSBQUiA4NTkwIGRpc2N1c3Npb24gZm9yIGNvbnRleHRcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gVE9ETzogV2hhdCBpZiB0aGlzIGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcz9cbiAgICAvLyBIb3cgY2FuIHRoYXQgaGFwcGVuPyBIb3cgaXMgdGhpcyBub3QgYmVpbmcgY2xvbmVkP1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVE9ETzogRGVsZXRlIG1lbW9pemVQcm9wcy9TdGF0ZSBhbmQgbW92ZSB0byByZWNvbmNpbGUvYmFpbG91dCBpbnN0ZWFkXG4gIGZ1bmN0aW9uIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAvLyBEb24ndCByZXNldCB0aGUgdXBkYXRlUXVldWUsIGluIGNhc2UgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gUmVzZXR0aW5nXG4gICAgLy8gaXMgaGFuZGxlZCBieSBwcm9jZXNzVXBkYXRlUXVldWUuXG4gIH1cblxuICBmdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBUaGlzIGlzIGEgcmVzdGFydC4gUmVzZXQgdGhlIHRhZyB0byB0aGUgaW5pdGlhbCBwaGFzZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHNpbmNlIHRoaXMgaXMgbm93IHRoZSBzYW1lLlxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIEEgcmV0dXJuIGNvbXBvbmVudCBpcyBqdXN0IGEgcGxhY2Vob2xkZXIsIHdlIGNhbiBqdXN0IHJ1biB0aHJvdWdoIHRoZVxuICAgICAgICAvLyBuZXh0IG9uZSBpbW1lZGlhdGVseS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5GYWlsZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgaGVyZSB0byBhdm9pZCBhIHB1c2gvcG9wIGNvbnRleHQgbWlzbWF0Y2guXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbiBlcnJvciBlZmZlY3Qgc28gd2UgY2FuIGhhbmRsZSB0aGUgZXJyb3IgZHVyaW5nIHRoZSBjb21taXQgcGhhc2VcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gRXJyO1xuXG4gICAgLy8gVGhpcyBpcyBhIHdlaXJkIGNhc2Ugd2hlcmUgd2UgZG8gXCJyZXN1bWVcIiB3b3JrIOKAlCB3b3JrIHRoYXQgZmFpbGVkIG9uXG4gICAgLy8gb3VyIGZpcnN0IGF0dGVtcHQuIEJlY2F1c2Ugd2Ugbm8gbG9uZ2VyIGhhdmUgYSBub3Rpb24gb2YgXCJwcm9ncmVzc2VkXG4gICAgLy8gZGVsZXRpb25zLFwiIHJlc2V0IHRoZSBjaGlsZCB0byB0aGUgY3VycmVudCBjaGlsZCB0byBtYWtlIHN1cmUgd2UgZGVsZXRlXG4gICAgLy8gaXQgYWdhaW4uIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLCBwZXJoYXBzIGR1cmluZyBhIG1vcmVcbiAgICAvLyBnZW5lcmFsIG92ZXJoYXVsIG9mIGVycm9yIGhhbmRsaW5nLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgYmFpbCBvdXQsIHdlJ3JlIGdvaW5nIGJlIHJlY29tcHV0aW5nIG91ciBjaGlsZHJlbiBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZHJvcCBvdXIgZWZmZWN0IGxpc3QuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAgLy8gVW5tb3VudCB0aGUgY3VycmVudCBjaGlsZHJlbiBhcyBpZiB0aGUgY29tcG9uZW50IHJlbmRlcmVkIG51bGxcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luV29yazogYmVnaW5Xb3JrLFxuICAgIGJlZ2luRmFpbGVkV29yazogYmVnaW5GYWlsZWRXb3JrXG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlckNvbXBsZXRlV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSB7XG4gIHZhciBjcmVhdGVJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQgPSBjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSBjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBwcmVwYXJlVXBkYXRlID0gY29uZmlnLnByZXBhcmVVcGRhdGUsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuICB2YXIgZ2V0Um9vdEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5nZXRSb290SG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICBnZXRIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LmdldEhvc3RDb250ZXh0LFxuICAgICAgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXI7XG4gIHZhciBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgICAgcG9wSHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnBvcEh5ZHJhdGlvblN0YXRlO1xuXG5cbiAgZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbiAgICAvLyBhbiBVcGRhdGVBbmRQbGFjZW1lbnQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBIGNhbGwgY2Fubm90IGhhdmUgaG9zdCBjb21wb25lbnQgY2hpbGRyZW4uJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJucy5wdXNoKG5vZGUudHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBjYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAhY2FsbCA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBiZSByZXNvbHZlZCBieSBub3cuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBGaXJzdCBzdGVwIG9mIHRoZSBjYWxsIGhhcyBjb21wbGV0ZWQuIE5vdyB3ZSBuZWVkIHRvIGRvIHRoZSBzZWNvbmQuXG4gICAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSB0byBoYXZlIGEgbXVsdGkgc3RhZ2UgY2FsbCByZXByZXNlbnRlZCBieSBhXG4gICAgLy8gc2luZ2xlIGNvbXBvbmVudCwgb3IgYXQgbGVhc3QgdGFpbCBjYWxsIG9wdGltaXplIG5lc3RlZCBvbmVzLiBDdXJyZW50bHlcbiAgICAvLyB0aGF0IHJlcXVpcmVzIGFkZGl0aW9uYWwgZmllbGRzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgdG8gdGhlIGZpYmVyLlxuICAgIC8vIFNvIHRoaXMgcmVxdWlyZXMgbmVzdGVkIGhhbmRsZXJzLlxuICAgIC8vIE5vdGU6IFRoaXMgZG9lc24ndCBtdXRhdGUgdGhlIGFsdGVybmF0ZSBub2RlLiBJIGRvbid0IHRoaW5rIGl0IG5lZWRzIHRvXG4gICAgLy8gc2luY2UgdGhpcyBzdGFnZSBpcyByZXNldCBmb3IgZXZlcnkgcGFzcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsSGFuZGxlclBoYXNlO1xuXG4gICAgLy8gQnVpbGQgdXAgdGhlIHJldHVybnMuXG4gICAgLy8gVE9ETzogQ29tcGFyZSB0aGlzIHRvIGEgZ2VuZXJhdG9yIG9yIG9wYXF1ZSBoZWxwZXJzIGxpa2UgQ2hpbGRyZW4uXG4gICAgdmFyIHJldHVybnMgPSBbXTtcbiAgICBhcHBlbmRBbGxSZXR1cm5zKHJldHVybnMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgZm4gPSBjYWxsLmhhbmRsZXI7XG4gICAgdmFyIHByb3BzID0gY2FsbC5wcm9wcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gZm4ocHJvcHMsIHJldHVybnMpO1xuXG4gICAgdmFyIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuY2hpbGQgOiBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVIb3N0Q29udGFpbmVyID0gdm9pZCAwO1xuICB2YXIgdXBkYXRlSG9zdENvbXBvbmVudCA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RUZXh0ID0gdm9pZCAwO1xuICBpZiAobXV0YXRpb24pIHtcbiAgICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBNdXRhdGlvbiBtb2RlXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAgICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIFBlcnNpc3RlbnQgaG9zdCB0cmVlIG1vZGVcbiAgICAgIHZhciBjbG9uZUluc3RhbmNlID0gcGVyc2lzdGVuY2UuY2xvbmVJbnN0YW5jZSxcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UuZmluYWxpemVDb250YWluZXJDaGlsZHJlbjtcblxuICAgICAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG5cbiAgICAgIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgICAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY29udGFpbmVyIHRvIHN3YXAgb3V0IHRoZSBjb250YWluZXIuXG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIHJldXNlIGFsbCBvZiB0aGVtLlxuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlY3ljbGFibGVJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3SW5zdGFuY2UgPSBjbG9uZUluc3RhbmNlKGN1cnJlbnRJbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGRyZW5VbmNoYW5nZWQsIHJlY3ljbGFibGVJbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBjb250ZW50IGRpZmZlcnMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyB0ZXh0IGluc3RhbmNlIGZvciBpdC5cbiAgICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBXZSdsbCBoYXZlIHRvIG1hcmsgaXQgYXMgaGF2aW5nIGFuIGVmZmVjdCwgZXZlbiB0aG91Z2ggd2Ugd29uJ3QgdXNlIHRoZSBlZmZlY3QgZm9yIGFueXRoaW5nLlxuICAgICAgICAgIC8vIFRoaXMgbGV0cyB0aGUgcGFyZW50cyBrbm93IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIGNoaWxkcmVuIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdQZXJzaXN0ZW50IHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgLy8gTm8gaG9zdCBvcGVyYXRpb25zXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBHZXQgdGhlIGxhdGVzdCBwcm9wcy5cbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5ld1Byb3BzID09PSBudWxsKSB7XG4gICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgfHwgcmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBSZXNldCB0aGUgcGVuZGluZyBwcm9wcywgdW5sZXNzIHRoaXMgd2FzIGEgZG93bi1wcmlvcml0aXphdGlvbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGdldCB1cGRhdGVkIGJlY2F1c2Ugb25lIG9mIG91ciBjaGlsZHJlbiB1cGRhdGVkLCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gaGF2ZSBuZXdQcm9wcyBzbyB3ZSdsbCBoYXZlIHRvIHJldXNlIHRoZW0uXG4gICAgICAgICAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAgICAgICAgIC8vIEV2ZW4gYmV0dGVyIHdvdWxkIGJlIGlmIGNoaWxkcmVuIHdlcmVuJ3Qgc3BlY2lhbCBjYXNlZCBhdCBhbGwgdGhvLlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAgIC8vIG9yIGNvbXBsZXRlV29yayBkZXBlbmRpbmcgb24gd2Ugd2FudCB0byBhZGQgdGhlbiB0b3AtPmRvd24gb3JcbiAgICAgICAgICAgIC8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cbiAgICAgICAgICAgIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmICh3YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWRzIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihfaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuICAgICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgICAgdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQyID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQyLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIENhbGxIYW5kbGVyUGhhc2U6XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0YWcgdG8gbm93IGJlIGEgZmlyc3QgcGhhc2UgY2FsbC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgLy8gRXJyb3IgY2FzZXNcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIGhhdmUgYmVjb21lIGRldGVybWluYXRlIGJlZm9yZSBjb21wbGV0aW5nLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0ZVdvcms6IGNvbXBsZXRlV29ya1xuICB9O1xufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQyID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbnZhciBSZWFjdEZpYmVyQ29tbWl0V29yayA9IGZ1bmN0aW9uIChjb25maWcsIGNhcHR1cmVFcnJvcikge1xuICB2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSBjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuXG5cbiAgdmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50LCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gIH07XG5cbiAgLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbiAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yJDEoKTtcbiAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMihudWxsLCByZWYsIG51bGwsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChfdXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwgPyBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlIDogbnVsbDtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyhfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gICAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcmVmKGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICAgIHZhciBjdXJyZW50UmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4gIC8vIGRlbGV0aW9uLCBzbyBkb24ndCBsZXQgdGhlbSB0aHJvdy4gSG9zdC1vcmlnaW5hdGluZyBlcnJvcnMgc2hvdWxkXG4gIC8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG4gIGZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCkge1xuICAgIGlmICh0eXBlb2Ygb25Db21taXRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNvbW1pdFVubW91bnQoY3VycmVudCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhlIHBvcnRhbCB3aWxsIGdldCBwdXNoZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciAmJiBtdXRhdGlvbikge1xuICAgICAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgJiYgcGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhyb290KSB7XG4gICAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gICAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgICAvLyBjYWxsIGFueXdheS4gV2UgYWxzbyB3YW50IHRvIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQgb24gYWxsXG4gICAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbW1pdFVubW91bnQobm9kZSk7XG4gICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoXG4gICAgICAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgICAhbXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hGaWJlcihjdXJyZW50KSB7XG4gICAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXJzIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS4gSWRlYWxseSwgd2VcbiAgICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gICAgLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuIFRoaXMgY2hpbGRcbiAgICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAgIGN1cnJlbnRbJ3JldHVybiddID0gbnVsbDtcbiAgICBjdXJyZW50LmNoaWxkID0gbnVsbDtcbiAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUpIHtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlLmNoaWxkID0gbnVsbDtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlWydyZXR1cm4nXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXRhdGlvbikge1xuICAgIHZhciBjb21taXRDb250YWluZXIgPSB2b2lkIDA7XG4gICAgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgICB2YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gcGVyc2lzdGVuY2UuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQ7XG5cbiAgICAgIHZhciBlbXB0eVBvcnRhbENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgIHZhciBwb3J0YWwgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcblxuICAgICAgICB2YXIgZW1wdHlDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckluZm8pO1xuICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgZW1wdHlDaGlsZFNldCk7XG4gICAgICB9O1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgICAgICAgIF9wZW5kaW5nQ2hpbGRyZW4gPSBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBfcGVuZGluZ0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRDb250YWluZXIgPSBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciB8fCBlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdFBsYWNlbWVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdERlbGV0aW9uOiBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMoY3VycmVudCk7XG4gICAgICAgICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1pdFdvcms6IGZ1bmN0aW9uIChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmOiBjb21taXREZXRhY2hSZWZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdOb29wIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9XG4gIHZhciBjb21taXRNb3VudCA9IG11dGF0aW9uLmNvbW1pdE1vdW50LFxuICAgICAgY29tbWl0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VXBkYXRlLFxuICAgICAgcmVzZXRUZXh0Q29udGVudCA9IG11dGF0aW9uLnJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRUZXh0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgIGFwcGVuZENoaWxkID0gbXV0YXRpb24uYXBwZW5kQ2hpbGQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gbXV0YXRpb24uYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixcbiAgICAgIGluc2VydEJlZm9yZSA9IG11dGF0aW9uLmluc2VydEJlZm9yZSxcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlID0gbXV0YXRpb24uaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG4gICAgICByZW1vdmVDaGlsZCA9IG11dGF0aW9uLnJlbW92ZUNoaWxkLFxuICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gbXV0YXRpb24ucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xuXG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICAgIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAgIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAgIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZVsncmV0dXJuJ10pKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICAvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4gICAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgICAgaWYgKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuICAgICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG4gICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgaXNDb250YWluZXIgPSB2b2lkIDA7XG4gICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBpc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRGaWJlci5lZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHBhcmVudCBiZWZvcmUgZG9pbmcgYW55IGluc2VydGlvbnNcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTtcbiAgICAgIC8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG4gICAgICBwYXJlbnRGaWJlci5lZmZlY3RUYWcgJj0gfkNvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIHZhciBub2RlID0gY3VycmVudDtcblxuICAgIC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudElzVmFsaWQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBmaW5kUGFyZW50OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICEocGFyZW50ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50WydyZXR1cm4nXTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMobm9kZSk7XG4gICAgICAgIC8vIEFmdGVyIGFsbCB0aGUgY2hpbGRyZW4gaGF2ZSB1bm1vdW50ZWQsIGl0IGlzIG5vdyBzYWZlIHRvIHJlbW92ZSB0aGVcbiAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVDaGlsZChjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIG1heSBmaW5kIG1vcmUgaG9zdCBjb21wb25lbnRzIGJlbG93LlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIGdvIG91dCBvZiB0aGUgcG9ydGFsLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHBhcmVudC5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oY3VycmVudCkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cbiAgICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAhKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcbiAgICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQpIHtcbiAgICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgfVxuXG4gIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudDogY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb246IGNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yazogY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdNdXRhdGluZyByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICB9XG59O1xuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xuXG52YXIgUmVhY3RGaWJlckhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dDtcblxuXG4gIHZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbiAgdmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG4gIGZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICAgIShjICE9PSBOT19DT05URVhUKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICAgIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gICAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG5cbiAgICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUsIHJvb3RJbnN0YW5jZSk7XG5cbiAgICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAgIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBpZiAoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEhvc3RDb250YWluZXIoKSB7XG4gICAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRIb3N0Q29udGV4dDogZ2V0SG9zdENvbnRleHQsXG4gICAgZ2V0Um9vdEhvc3RDb250YWluZXI6IGdldFJvb3RIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250YWluZXI6IHBvcEhvc3RDb250YWluZXIsXG4gICAgcG9wSG9zdENvbnRleHQ6IHBvcEhvc3RDb250ZXh0LFxuICAgIHB1c2hIb3N0Q29udGFpbmVyOiBwdXNoSG9zdENvbnRhaW5lcixcbiAgICBwdXNoSG9zdENvbnRleHQ6IHB1c2hIb3N0Q29udGV4dCxcbiAgICByZXNldEhvc3RDb250YWluZXI6IHJlc2V0SG9zdENvbnRhaW5lclxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBoeWRyYXRpb24gPSBjb25maWcuaHlkcmF0aW9uO1xuXG4gIC8vIElmIHRoaXMgZG9lc24ndCBoYXZlIGh5ZHJhdGlvbiBtb2RlLlxuXG4gIGlmICghaHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9IGh5ZHJhdGlvbi5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9IGh5ZHJhdGlvbi5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG5cbiAgLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4gIC8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbiAgdmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgdmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICB2YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUsIHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMsIHJldHVybkZpYmVyLnN0YXRlTm9kZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgIGNoaWxkVG9EZWxldGVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcblxuICAgIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWNvbmNpbGlhdGlvbiBsaXN0IG9mIGNoaWxkcmVuLlxuICAgIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gICAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gICAgLy8gcmVjcmVhdGVkLlxuICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgICBmaWJlci5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICAgIHtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSk7XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7XG4gICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICAgIHtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgICAvLyB0cmVlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAgIC8vIHNpYmxpbmdzLlxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAgIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAgIC8vIHNpZGUgb2YgdGhlbS5cbiAgICAvLyBUT0RPOiBCZXR0ZXIgaGV1cmlzdGljLlxuICAgIGlmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgdHlwZSAhPT0gJ2hlYWQnICYmIHR5cGUgIT09ICdib2R5JyAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpIHtcbiAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZTogcmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTogdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gICAgcG9wSHlkcmF0aW9uU3RhdGU6IHBvcEh5ZHJhdGlvblN0YXRlXG4gIH07XG59O1xuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxudmFyIGRlZmF1bHRTaG93RGlhbG9nID0gZnVuY3Rpb24gKGNhcHR1cmVkRXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2hvd0RpYWxvZyA9IGRlZmF1bHRTaG93RGlhbG9nO1xuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3IpIHtcbiAgdmFyIGxvZ0Vycm9yID0gc2hvd0RpYWxvZyhjYXB0dXJlZEVycm9yKTtcblxuICAvLyBBbGxvdyBpbmplY3RlZCBzaG93RGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGVycm9yICYmIGVycm9yLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmc7XG4gIGlmIChzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudE5hbWUsXG4gICAgICAgIGNvbXBvbmVudFN0YWNrID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSBjYXB0dXJlZEVycm9yLmVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgd2lsbFJldHJ5ID0gY2FwdHVyZWRFcnJvci53aWxsUmV0cnk7XG5cblxuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBjb21wb25lbnQ6JyA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuXG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gdm9pZCAwO1xuICAgIC8vIGVycm9yQm91bmRhcnlGb3VuZCBjaGVjayBpcyBzdWZmaWNpZW50OyBlcnJvckJvdW5kYXJ5TmFtZSBjaGVjayBpcyB0byBzYXRpc2Z5IEZsb3cuXG4gICAgaWYgKGVycm9yQm91bmRhcnlGb3VuZCAmJiBlcnJvckJvdW5kYXJ5TmFtZSkge1xuICAgICAgaWYgKHdpbGxSZXRyeSkge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCAnICsgKCd1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnVGhpcyBlcnJvciB3YXMgaW5pdGlhbGx5IGhhbmRsZWQgYnkgdGhlIGVycm9yIGJvdW5kYXJ5ICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuXFxuJyArICdSZWNyZWF0aW5nIHRoZSB0cmVlIGZyb20gc2NyYXRjaCBmYWlsZWQgc28gUmVhY3Qgd2lsbCB1bm1vdW50IHRoZSB0cmVlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgIH1cbiAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gJycgKyBjb21wb25lbnROYW1lTWVzc2FnZSArIGNvbXBvbmVudFN0YWNrICsgJ1xcblxcbicgKyAoJycgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7XG5cbiAgICAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2l0aCBqdXN0IHRoZSBjb21wb25lbnQgc3RhY2suXG4gICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAvLyBkaXNwbGF5ZWQgYnkgdGhlIGJyb3dzZXIgdGhhbmtzIHRvIHRoZSBERVYtb25seSBmYWtlIGV2ZW50IHRyaWNrIGluIFJlYWN0RXJyb3JVdGlscy5cbiAgICBjb25zb2xlLmVycm9yKGNvbWJpbmVkTWVzc2FnZSk7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQxID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3I7XG5cblxue1xuICB2YXIgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSBmYWxzZTtcbiAgdmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG4gIHZhciB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJ0NhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgJyArICdjb21wb25lbnQuIFRoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkIHNldFN0YXRlLCByZXBsYWNlU3RhdGUsICcgKyAnb3IgZm9yY2VVcGRhdGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSAnICsgJ2NoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgdmFyIHdhcm5BYm91dEludmFsaWRVcGRhdGVzID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlKSB7XG4gICAgICBjYXNlICdnZXRDaGlsZENvbnRleHQnOlxuICAgICAgICBpZiAoZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpO1xuICAgICAgICBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlbmRlcic6XG4gICAgICAgIGlmIChkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgd2l0aGluICcgKyBcImByZW5kZXJgIG9yIGFub3RoZXIgY29tcG9uZW50J3MgY29uc3RydWN0b3IpLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgXCIgKyAnYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgY29uc3RydWN0b3Igc2lkZS1lZmZlY3RzIGFyZSAnICsgJ2FuIGFudGktcGF0dGVybiwgYnV0IGNhbiBiZSBtb3ZlZCB0byBgY29tcG9uZW50V2lsbE1vdW50YC4nKTtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xufVxuXG52YXIgUmVhY3RGaWJlclNjaGVkdWxlciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGhvc3RDb250ZXh0ID0gUmVhY3RGaWJlckhvc3RDb250ZXh0KGNvbmZpZyk7XG4gIHZhciBoeWRyYXRpb25Db250ZXh0ID0gUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQoY29uZmlnKTtcbiAgdmFyIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyLFxuICAgICAgcG9wSG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGV4dCxcbiAgICAgIHJlc2V0SG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnJlc2V0SG9zdENvbnRhaW5lcjtcblxuICB2YXIgX1JlYWN0RmliZXJCZWdpbldvcmsgPSBSZWFjdEZpYmVyQmVnaW5Xb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciksXG4gICAgICBiZWdpbldvcmsgPSBfUmVhY3RGaWJlckJlZ2luV29yay5iZWdpbldvcmssXG4gICAgICBiZWdpbkZhaWxlZFdvcmsgPSBfUmVhY3RGaWJlckJlZ2luV29yay5iZWdpbkZhaWxlZFdvcms7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ29tcGxldGVXbyA9IFJlYWN0RmliZXJDb21wbGV0ZVdvcmsoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCksXG4gICAgICBjb21wbGV0ZVdvcmsgPSBfUmVhY3RGaWJlckNvbXBsZXRlV28uY29tcGxldGVXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBSZWFjdEZpYmVyQ29tbWl0V29yayhjb25maWcsIGNhcHR1cmVFcnJvciksXG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb24gPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RGVsZXRpb24sXG4gICAgICBjb21taXRXb3JrID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRBdHRhY2hSZWYgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0QXR0YWNoUmVmLFxuICAgICAgY29tbWl0RGV0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERldGFjaFJlZjtcblxuICB2YXIgbm93ID0gY29uZmlnLm5vdyxcbiAgICAgIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayA9IGNvbmZpZy5zY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssXG4gICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrID0gY29uZmlnLmNhbmNlbERlZmVycmVkQ2FsbGJhY2ssXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHByZXBhcmVGb3JDb21taXQgPSBjb25maWcucHJlcGFyZUZvckNvbW1pdCxcbiAgICAgIHJlc2V0QWZ0ZXJDb21taXQgPSBjb25maWcucmVzZXRBZnRlckNvbW1pdDtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBjdXJyZW50IHRpbWUgaW4gbXMuXG5cbiAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuICB2YXIgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKDApO1xuXG4gIC8vIFJlcHJlc2VudHMgdGhlIGV4cGlyYXRpb24gdGltZSB0aGF0IGluY29taW5nIHVwZGF0ZXMgc2hvdWxkIHVzZS4gKElmIHRoaXNcbiAgLy8gaXMgTm9Xb3JrLCB1c2UgdGhlIGRlZmF1bHQgc3RyYXRlZ3k6IGFzeW5jIHVwZGF0ZXMgaW4gYXN5bmMgbW9kZSwgc3luY1xuICAvLyB1cGRhdGVzIGluIHN5bmMgbW9kZS4pXG4gIHZhciBleHBpcmF0aW9uQ29udGV4dCA9IE5vV29yaztcblxuICB2YXIgaXNXb3JraW5nID0gZmFsc2U7XG5cbiAgLy8gVGhlIG5leHQgd29yayBpbiBwcm9ncmVzcyBmaWJlciB0aGF0IHdlJ3JlIGN1cnJlbnRseSB3b3JraW5nIG9uLlxuICB2YXIgbmV4dFVuaXRPZldvcmsgPSBudWxsO1xuICB2YXIgbmV4dFJvb3QgPSBudWxsO1xuICAvLyBUaGUgdGltZSBhdCB3aGljaCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHdvcmsuXG4gIHZhciBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVGhlIG5leHQgZmliZXIgd2l0aCBhbiBlZmZlY3QgdGhhdCB3ZSdyZSBjdXJyZW50bHkgY29tbWl0dGluZy5cbiAgdmFyIG5leHRFZmZlY3QgPSBudWxsO1xuXG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZmliZXJzIGhhdmUgY2FwdHVyZWQgYW4gZXJyb3IgdGhhdCBuZWVkIHRvIGJlIGhhbmRsZWQuXG4gIC8vIFdvcmsgaXMgcmVtb3ZlZCBmcm9tIHRoaXMgY29sbGVjdGlvbiBhZnRlciBjb21wb25lbnREaWRDYXRjaCBpcyBjYWxsZWQuXG4gIHZhciBjYXB0dXJlZEVycm9ycyA9IG51bGw7XG4gIC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZmliZXJzIGhhdmUgZmFpbGVkIGR1cmluZyB0aGUgY3VycmVudCBiYXRjaCBvZiB3b3JrLlxuICAvLyBUaGlzIGlzIGEgZGlmZmVyZW50IHNldCB0aGFuIGNhcHR1cmVkRXJyb3JzLCBiZWNhdXNlIGl0IGlzIG5vdCByZXNldCB1bnRpbFxuICAvLyB0aGUgZW5kIG9mIHRoZSBiYXRjaC4gVGhpcyBpcyBuZWVkZWQgdG8gcHJvcGFnYXRlIGVycm9ycyBjb3JyZWN0bHkgaWYgYVxuICAvLyBzdWJ0cmVlIGZhaWxzIG1vcmUgdGhhbiBvbmNlLlxuICB2YXIgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gIC8vIEVycm9yIGJvdW5kYXJpZXMgdGhhdCBjYXB0dXJlZCBhbiBlcnJvciBkdXJpbmcgdGhlIGN1cnJlbnQgY29tbWl0LlxuICB2YXIgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbnVsbDtcbiAgdmFyIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gIHZhciBkaWRGYXRhbCA9IGZhbHNlO1xuXG4gIHZhciBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgdmFyIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuXG4gIC8vIFVzZWQgZm9yIHBlcmZvcm1hbmNlIHRyYWNraW5nLlxuICB2YXIgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVzZXRDb250ZXh0U3RhY2soKSB7XG4gICAgLy8gUmVzZXQgdGhlIHN0YWNrXG4gICAgcmVzZXQkMSgpO1xuICAgIC8vIFJlc2V0IHRoZSBjdXJzb3JzXG4gICAgcmVzZXRDb250ZXh0KCk7XG4gICAgcmVzZXRIb3N0Q29udGFpbmVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxIb3N0RWZmZWN0cygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICAgIHJlY29yZEVmZmVjdCgpO1xuXG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG4gICAgICBpZiAoZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnlcbiAgICAgIC8vIHBvc3NpYmxlIGJpdG1hcCB2YWx1ZSwgd2UgcmVtb3ZlIHRoZSBzZWNvbmRhcnkgZWZmZWN0cyBmcm9tIHRoZVxuICAgICAgLy8gZWZmZWN0IHRhZyBhbmQgc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG4gICAgICB2YXIgcHJpbWFyeUVmZmVjdFRhZyA9IGVmZmVjdFRhZyAmIH4oQ2FsbGJhY2sgfCBFcnIgfCBDb250ZW50UmVzZXQgfCBSZWYgfCBQZXJmb3JtZWRXb3JrKTtcbiAgICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgICBjYXNlIFBsYWNlbWVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAgIC8vIGRvZXMgYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZVxuICAgICAgICAgICAgLy8gdG8ga2lsbCB0aGlzLlxuICAgICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpcyBpbnNlcnRlZCwgYmVmb3JlXG4gICAgICAgICAgICAvLyBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZVxuICAgICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb21taXREZWxldGlvbihuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGlzVW5tb3VudGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsTGlmZUN5Y2xlcygpIHtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlcyhjdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgRXJyKSB7XG4gICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICBjb21taXRFcnJvckhhbmRsaW5nKG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIGNsZWFuIHRoZXNlIHVwIHNvIHRoYXQgd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IGtlZXAgdGhlbS5cbiAgICAgIC8vIEknbSBub3QgYWN0dWFsbHkgc3VyZSB0aGlzIG1hdHRlcnMgYmVjYXVzZSB3ZSBjYW4ndCByZXNldCBmaXJzdEVmZmVjdFxuICAgICAgLy8gYW5kIGxhc3RFZmZlY3Qgc2luY2UgdGhleSdyZSBvbiBldmVyeSBub2RlLCBub3QganVzdCB0aGUgZWZmZWN0ZnVsXG4gICAgICAvLyBvbmVzLiBTbyB3ZSBoYXZlIHRvIGNsZWFuIGV2ZXJ5dGhpbmcgYXMgd2UgcmV1c2Ugbm9kZXMgYW55d2F5LlxuICAgICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc2V0IHRoZSBlZmZlY3RUYWcgaGVyZSBzbyB0aGF0IHdlIGNhbiByZWx5IG9uIGVmZmVjdFxuICAgICAgLy8gdGFncyB0byByZWFzb24gYWJvdXQgdGhlIGN1cnJlbnQgbGlmZS1jeWNsZS5cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKSB7XG4gICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGlzIHNvIHRoYXQgY2FwdHVyZUVycm9yIGNhbiBjb2xsZWN0IGFueSBib3VuZGFyaWVzXG4gICAgLy8gdGhhdCBjYXB0dXJlIGFuIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGUgcmVhc29uIHRoZXNlIGFyZW4ndFxuICAgIC8vIGxvY2FsIHRvIHRoaXMgZnVuY3Rpb24gaXMgYmVjYXVzZSBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgY1dVIGFyZVxuICAgIC8vIGNhcHR1cmVkIGVsc2V3aGVyZSwgdG8gcHJldmVudCB0aGUgdW5tb3VudCBmcm9tIGJlaW5nIGludGVycnVwdGVkLlxuICAgIGlzV29ya2luZyA9IHRydWU7XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBzdGFydENvbW1pdFRpbWVyKCk7XG5cbiAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICB2YXIgZmlyc3RFZmZlY3QgPSB2b2lkIDA7XG4gICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAvLyBBIGZpYmVyJ3MgZWZmZWN0IGxpc3QgY29uc2lzdHMgb25seSBvZiBpdHMgY2hpbGRyZW4sIG5vdCBpdHNlbGYuIFNvIGlmXG4gICAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAgIC8vIHJlc3VsdGluZyBsaXN0IGlzIHRoZSBzZXQgdGhhdCB3b3VsZCBiZWxvbmcgdG8gdGhlIHJvb3QncyBwYXJlbnQsIGlmXG4gICAgICAvLyBpdCBoYWQgb25lOyB0aGF0IGlzLCBhbGwgdGhlIGVmZmVjdHMgaW4gdGhlIHRyZWUgaW5jbHVkaW5nIHRoZSByb290LlxuICAgICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmlzaGVkV29yay5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGVmZmVjdCBvbiB0aGUgcm9vdC5cbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgIH1cblxuICAgIHByZXBhcmVGb3JDb21taXQoKTtcblxuICAgIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gICAgLy8gVGhlIGZpcnN0IHBhc3MgcGVyZm9ybXMgYWxsIHRoZSBob3N0IGluc2VydGlvbnMsIHVwZGF0ZXMsIGRlbGV0aW9ucyBhbmRcbiAgICAvLyByZWYgdW5tb3VudHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIGNvbW1pdEFsbEhvc3RFZmZlY3RzLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBjYXB0dXJlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yKTtcbiAgICAgICAgLy8gQ2xlYW4tdXBcbiAgICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG5cbiAgICByZXNldEFmdGVyQ29tbWl0KCk7XG5cbiAgICAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBmaXJzdCBwYXNzIG9mIHRoZSBjb21taXQgcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGxcbiAgICAvLyBjdXJyZW50IGR1cmluZyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgc2Vjb25kIHBhc3MsIHNvIHRoYXRcbiAgICAvLyB0aGUgZmluaXNoZWQgd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuXG4gICAgLy8gSW4gdGhlIHNlY29uZCBwYXNzIHdlJ2xsIHBlcmZvcm0gYWxsIGxpZmUtY3ljbGVzIGFuZCByZWYgY2FsbGJhY2tzLlxuICAgIC8vIExpZmUtY3ljbGVzIGhhcHBlbiBhcyBhIHNlcGFyYXRlIHBhc3Mgc28gdGhhdCBhbGwgcGxhY2VtZW50cywgdXBkYXRlcyxcbiAgICAvLyBhbmQgZGVsZXRpb25zIGluIHRoZSBlbnRpcmUgdHJlZSBoYXZlIGFscmVhZHkgYmVlbiBpbnZva2VkLlxuICAgIC8vIFRoaXMgcGFzcyBhbHNvIHRyaWdnZXJzIGFueSByZW5kZXJlci1zcGVjaWZpYyBpbml0aWFsIGVmZmVjdHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBfZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfZXJyb3IyID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxMaWZlQ3ljbGVzLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBfZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvcjIgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfZGlkRXJyb3IpIHtcbiAgICAgICAgIShuZXh0RWZmZWN0ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIG5leHQgZWZmZWN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICBjYXB0dXJlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIHN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgICBzdG9wQ29tbWl0VGltZXIoKTtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tbWl0V29yayhmaW5pc2hlZFdvcmspO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGNhdWdodCBhbnkgZXJyb3JzIGR1cmluZyB0aGlzIGNvbW1pdCwgc2NoZWR1bGUgdGhlaXIgYm91bmRhcmllc1xuICAgIC8vIHRvIHVwZGF0ZS5cbiAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzKSB7XG4gICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMuZm9yRWFjaChzY2hlZHVsZUVycm9yUmVjb3ZlcnkpO1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RVbmNhdWdodEVycm9yICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2Vycm9yMyA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcbiAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICBvblVuY2F1Z2h0RXJyb3IoX2Vycm9yMyk7XG4gICAgfVxuXG4gICAgdmFyIHJlbWFpbmluZ1RpbWUgPSByb290LmN1cnJlbnQuZXhwaXJhdGlvblRpbWU7XG5cbiAgICBpZiAocmVtYWluaW5nVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICBjYXB0dXJlZEVycm9ycyA9IG51bGw7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtYWluaW5nVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIHJlbmRlclRpbWUpIHtcbiAgICBpZiAocmVuZGVyVGltZSAhPT0gTmV2ZXIgJiYgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBwZW5kaW5nIHVwZGF0ZXMuXG4gICAgdmFyIG5ld0V4cGlyYXRpb25UaW1lID0gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogQ2FsbHMgbmVlZCB0byB2aXNpdCBzdGF0ZU5vZGVcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLmV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgKG5ld0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV3RXhwaXJhdGlvblRpbWUgPiBjaGlsZC5leHBpcmF0aW9uVGltZSkpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSBjaGlsZC5leHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBuZXdFeHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgICAvLyBwcm9ncmVzcy5cbiAgICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzc1sncmV0dXJuJ107XG4gICAgICB2YXIgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgICAgcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFwcGVuZCBhbGwgdGhlIGVmZmVjdHMgb2YgdGhlIHN1YnRyZWUgYW5kIHRoaXMgZmliZXIgb250byB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0IG9yZGVyLlxuICAgICAgICBpZiAocmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAvLyBuZWVkZWQsIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyB0byBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgLy8gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlIGNvbW1pdHRlZC5cbiAgICAgICAgaWYgKGVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbW9yZSB3b3JrIHRvIGRvIGluIHRoaXMgcmV0dXJuRmliZXIsIGRvIHRoYXQgbmV4dC5cbiAgICAgICAgcmV0dXJuIHNpYmxpbmdGaWJlcjtcbiAgICAgIH0gZWxzZSBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBtb3JlIHdvcmsgaW4gdGhpcyByZXR1cm5GaWJlci4gQ29tcGxldGUgdGhlIHJldHVybkZpYmVyLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3QuXG4gICAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXaXRob3V0IHRoaXMgZXhwbGljaXQgbnVsbCByZXR1cm4gRmxvdyBjb21wbGFpbnMgb2YgaW52YWxpZCByZXR1cm4gdHlwZVxuICAgIC8vIFRPRE8gUmVtb3ZlIHRoZSBhYm92ZSB3aGlsZSh0cnVlKSBsb29wXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSB1bmhhbmRsZWQgZXJyb3JzLCBzd2l0Y2ggdG8gdGhlIHNsb3cgd29yayBsb29wLlxuICAgICAgLy8gVE9ETzogSG93IHRvIGF2b2lkIHRoaXMgY2hlY2sgaW4gdGhlIGZhc3QgcGF0aD8gTWF5YmUgdGhlIHJlbmRlcmVyXG4gICAgICAvLyBjb3VsZCBrZWVwIHRyYWNrIG9mIHdoaWNoIHJvb3RzIGhhdmUgdW5oYW5kbGVkIGVycm9ycyBhbmQgY2FsbCBhXG4gICAgICAvLyBmb3JrZWQgdmVyc2lvbiBvZiByZW5kZXJSb290LlxuICAgICAgc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZEVycm9yKG5leHRVbml0T2ZXb3JrKSkge1xuICAgICAgICAgIC8vIFVzZSBhIGZvcmtlZCB2ZXJzaW9uIG9mIHBlcmZvcm1Vbml0T2ZXb3JrXG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSb290Q2F0Y2hCbG9jayhyb290LCBmYWlsZWRXb3JrLCBib3VuZGFyeSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byByZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB0aGF0IGNhcHR1cmVkIHRoZSBlcnJvci5cbiAgICAvLyBDb25jZXB0dWFsbHksIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2suIFdlIG5lZWQgdG8gdW53aW5kIHRoZVxuICAgIC8vIGNvbnRleHQgc3RhY2ssIHRvby5cbiAgICB1bndpbmRDb250ZXh0cyhmYWlsZWRXb3JrLCBib3VuZGFyeSk7XG5cbiAgICAvLyBSZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB1c2luZyBhIGZvcmtlZCB2ZXJzaW9uIG9mXG4gICAgLy8gcGVyZm9ybVVuaXRPZldvcmsgdGhhdCBkZWxldGVzIHRoZSBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGUgZW50aXJlXG4gICAgLy8gZmFpbGVkIHN1YnJlZSB3aWxsIGJlIHVubW91bnRlZC4gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIGEgc3BlY2lhbFxuICAgIC8vIGxpZmVjeWNsZSBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBlcnJvciBib3VuZGFyeSwgd2hpY2ggdHJpZ2dlcnNcbiAgICAvLyBhIHJlLXJlbmRlci5cbiAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKGJvdW5kYXJ5KTtcblxuICAgIC8vIENvbnRpbnVlIHdvcmtpbmcuXG4gICAgd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgICEhaXNXb3JraW5nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGlzV29ya2luZyA9IHRydWU7XG5cbiAgICAvLyBXZSdyZSBhYm91dCB0byBtdXRhdGUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZS4gSWYgdGhlIHJvb3Qgd2FzIHBlbmRpbmdcbiAgICAvLyBjb21taXQsIGl0IG5vIGxvbmdlciBpczogd2UnbGwgbmVlZCB0byBjb21wbGV0ZSBpdCBhZ2Fpbi5cbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIHN0YXJ0aW5nIGZyb20gYSBmcmVzaCBzdGFjaywgb3IgaWYgd2UncmUgcmVzdW1pbmcgZnJvbVxuICAgIC8vIHByZXZpb3VzbHkgeWllbGRlZCB3b3JrLlxuICAgIGlmIChyb290ICE9PSBuZXh0Um9vdCB8fCBleHBpcmF0aW9uVGltZSAhPT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIHx8IG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICAvLyBSZXNldCB0aGUgc3RhY2sgYW5kIHN0YXJ0IHdvcmtpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHJlc2V0Q29udGV4dFN0YWNrKCk7XG4gICAgICBuZXh0Um9vdCA9IHJvb3Q7XG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MobmV4dFJvb3QuY3VycmVudCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIHdvcmtMb29wLCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgd2hpbGUgKGRpZEVycm9yKSB7XG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBmYXRhbCBlcnJvci4gRG9uJ3QgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gaXQuXG4gICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGZhaWxlZFdvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgIGlmIChmYWlsZWRXb3JrID09PSBudWxsKSB7XG4gICAgICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gYnV0IHRoZXJlJ3Mgbm8gY3VycmVudCB1bml0IG9mIHdvcmsuIFRoaXMgY2FuXG4gICAgICAgIC8vIGhhcHBlbiBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gXCJDYXB0dXJlXCIgdGhlIGVycm9yIGJ5IGZpbmRpbmcgdGhlIG5lYXJlc3QgYm91bmRhcnkuIElmIHRoZXJlIGlzIG5vXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgd2UgdXNlIHRoZSByb290LlxuICAgICAgdmFyIGJvdW5kYXJ5ID0gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKTtcbiAgICAgICEoYm91bmRhcnkgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgZm91bmQgYW4gZXJyb3IgYm91bmRhcnkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgICAvLyBUaGUgZXJyb3Igd2UganVzdCBjYXB0dXJlZCB3YXMgYSBmYXRhbCBlcnJvci4gVGhpcyBoYXBwZW5zXG4gICAgICAgIC8vIHdoZW4gdGhlIGVycm9yIHByb3BhZ2F0ZXMgdG8gdGhlIHJvb3QgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCByZW5kZXJSb290Q2F0Y2hCbG9jaywgbnVsbCwgcm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlJ3JlIGZpbmlzaGVkIHdvcmtpbmcuIEV4aXQgdGhlIGVycm9yIGxvb3AuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdW5jYXVnaHRFcnJvciA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcblxuICAgIC8vIFdlJ3JlIGRvbmUgcGVyZm9ybWluZyB3b3JrLiBUaW1lIHRvIGNsZWFuIHVwLlxuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpO1xuICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIGRpZEZhdGFsID0gZmFsc2U7XG4gICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcblxuICAgIGlmICh1bmNhdWdodEVycm9yICE9PSBudWxsKSB7XG4gICAgICBvblVuY2F1Z2h0RXJyb3IodW5jYXVnaHRFcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA/IHJvb3QuY3VycmVudC5hbHRlcm5hdGUgOiBudWxsO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IsIG9yIG51bGwgaWYgdGhlIGVycm9yIGlzIGlnbm9yZWRcbiAgZnVuY3Rpb24gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKSB7XG4gICAgLy8gSXQgaXMgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2Ugd2UgZXhpdGVkIHRoZSB1c2VyIGNvZGUuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkuXG4gICAgdmFyIGJvdW5kYXJ5ID0gbnVsbDtcblxuICAgIC8vIFBhc3NlZCB0byBsb2dDYXB0dXJlZEVycm9yKClcbiAgICB2YXIgZXJyb3JCb3VuZGFyeUZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgIHZhciBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG5cbiAgICAvLyBIb3N0IGNvbnRhaW5lcnMgYXJlIGEgc3BlY2lhbCBjYXNlLiBJZiB0aGUgZmFpbGVkIHdvcmsgaXRzZWxmIGlzIGEgaG9zdFxuICAgIC8vIGNvbnRhaW5lciwgdGhlbiBpdCBhY3RzIGFzIGl0cyBvd24gYm91bmRhcnkuIEluIGFsbCBvdGhlciBjYXNlcywgd2VcbiAgICAvLyBpZ25vcmUgdGhlIHdvcmsgaXRzZWxmIGFuZCBvbmx5IHNlYXJjaCB0aHJvdWdoIHRoZSBwYXJlbnRzLlxuICAgIGlmIChmYWlsZWRXb3JrLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGJvdW5kYXJ5ID0gZmFpbGVkV29yaztcblxuICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkoZmFpbGVkV29yaykpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByb290IGFscmVhZHkgZmFpbGVkLCB0aGVyZSBtdXN0IGhhdmUgYmVlbiBhbiBlcnJvciB3aGVuXG4gICAgICAgIC8vIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBpdC4gVGhpcyBpcyBhIHdvcnN0LWNhc2Ugc2NlbmFyaW8gYW5kXG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIHBvc3NpYmxlIGlmIHRoZXJlJ3MgYSBidWcgaW4gdGhlIHJlbmRlcmVyLlxuICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub2RlID0gZmFpbGVkV29ya1sncmV0dXJuJ107XG4gICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShub2RlKTtcblxuICAgICAgICAgICAgLy8gRm91bmQgYW4gZXJyb3IgYm91bmRhcnkhXG4gICAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgICAgICB3aWxsUmV0cnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICAvLyBUcmVhdCB0aGUgcm9vdCBsaWtlIGEgbm8tb3AgZXJyb3IgYm91bmRhcnlcbiAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGYWlsZWRCb3VuZGFyeShub2RlKSkge1xuICAgICAgICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgYWxyZWFkeSBpbiBhIGZhaWxlZCBzdGF0ZS5cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSB1bm1vdW50aW5nLCB0aGF0IG1lYW5zIHRoaXMgZXJyb3Igd2FzXG4gICAgICAgICAgLy8gdGhyb3duIHdoaWxlIHVubW91bnRpbmcgYSBmYWlsZWQgc3VidHJlZS4gV2Ugc2hvdWxkIGlnbm9yZVxuICAgICAgICAgIC8vIHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoaXNVbm1vdW50aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSBzaG91bGQgY2hlY2sgdG8gc2VlIGlmXG4gICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGFuIGVycm9yIGR1cmluZyB0aGlzIGNvbW1pdC5cbiAgICAgICAgICAvLyBUaGlzIGNhc2UgZXhpc3RzIGJlY2F1c2UgbXVsdGlwbGUgZXJyb3JzIGNhbiBiZSB0aHJvd24gZHVyaW5nXG4gICAgICAgICAgLy8gYSBzaW5nbGUgY29tbWl0IHdpdGhvdXQgaW50ZXJydXB0aW9uLlxuICAgICAgICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZSkgfHwgbm9kZS5hbHRlcm5hdGUgIT09IG51bGwgJiYgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmhhcyhub2RlLmFsdGVybmF0ZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiBzbywgd2Ugc2hvdWxkIGlnbm9yZSB0aGlzIGVycm9yLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGVycm9yIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkgLeKAlCB3ZSBrZWVwIGxvb2tpbmcuXG4gICAgICAgICAgYm91bmRhcnkgPSBudWxsO1xuICAgICAgICAgIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChib3VuZGFyeSAhPT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGZhaWxlZCBib3VuZGFyaWVzLiBUaGlzIGxldHMgdXMga25vdyB0aGF0XG4gICAgICAvLyBzdWJzZXF1ZW50IGVycm9ycyBpbiB0aGlzIHN1YnRyZWUgc2hvdWxkIHByb3BhZ2F0ZSB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChib3VuZGFyeSk7XG5cbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHVuc2FmZSBvdXRzaWRlIG9mIHRoZSBiZWdpbiBhbmQgY29tcGxldGUgcGhhc2VzLlxuICAgICAgLy8gV2UgbWlnaHQgYmUgaW4gdGhlIGNvbW1pdCBwaGFzZSB3aGVuIGFuIGVycm9yIGlzIGNhcHR1cmVkLlxuICAgICAgLy8gVGhlIHJpc2sgaXMgdGhhdCB0aGUgcmV0dXJuIHBhdGggZnJvbSB0aGlzIEZpYmVyIG1heSBub3QgYmUgYWNjdXJhdGUuXG4gICAgICAvLyBUaGF0IHJpc2sgaXMgYWNjZXB0YWJsZSBnaXZlbiB0aGUgYmVuZWZpdCBvZiBwcm92aWRpbmcgdXNlcnMgbW9yZSBjb250ZXh0LlxuICAgICAgdmFyIF9jb21wb25lbnRTdGFjayA9IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmFpbGVkV29yayk7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZhaWxlZFdvcmspO1xuXG4gICAgICAvLyBBZGQgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY2FwdHVyZWQgZXJyb3JzLiBUaGlzIGlzIHN0b3JlZCBhcyBhIGdsb2JhbFxuICAgICAgLy8gbWFwIG9mIGVycm9ycyBhbmQgdGhlaXIgY29tcG9uZW50IHN0YWNrIGxvY2F0aW9uIGtleWVkIGJ5IHRoZSBib3VuZGFyaWVzXG4gICAgICAvLyB0aGF0IGNhcHR1cmUgdGhlbS4gV2UgbW9zdGx5IHVzZSB0aGlzIE1hcCBhcyBhIFNldDsgaXQncyBhIE1hcCBvbmx5IHRvXG4gICAgICAvLyBhdm9pZCBhZGRpbmcgYSBmaWVsZCB0byBGaWJlciB0byBzdG9yZSB0aGUgZXJyb3IuXG4gICAgICBpZiAoY2FwdHVyZWRFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgY2FwdHVyZWRFcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXB0dXJlZEVycm9yID0ge1xuICAgICAgICBjb21wb25lbnROYW1lOiBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IF9jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5OiBlcnJvckJvdW5kYXJ5Rm91bmQgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWU6IGVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICB3aWxsUmV0cnk6IHdpbGxSZXRyeVxuICAgICAgfTtcblxuICAgICAgY2FwdHVyZWRFcnJvcnMuc2V0KGJvdW5kYXJ5LCBjYXB0dXJlZEVycm9yKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUHJldmVudCBjeWNsZSBpZiBsb2dDYXB0dXJlZEVycm9yKCkgdGhyb3dzLlxuICAgICAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgICAgIHZhciBzdXBwcmVzc0xvZ2dpbmcgPSBlICYmIGUuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZztcbiAgICAgICAgaWYgKCFzdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBjb21taXQgcGhhc2UsIGRlZmVyIHNjaGVkdWxpbmcgYW4gdXBkYXRlIG9uIHRoZVxuICAgICAgLy8gYm91bmRhcnkgdW50aWwgYWZ0ZXIgdGhlIGNvbW1pdCBpcyBjb21wbGV0ZVxuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzY2hlZHVsZSBhbiB1cGRhdGUgbm93LlxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGFjdHVhbGx5IG5lY2Vzc2FyeSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZT8gSXMgaXRcbiAgICAgICAgLy8gcG9zc2libGUgdG8gdW53aW5kIGFuZCBjb250aW51ZSByZW5kZXJpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHksXG4gICAgICAgIC8vIHdpdGhvdXQgY29ycnVwdGluZyBpbnRlcm5hbCBzdGF0ZT9cbiAgICAgICAgc2NoZWR1bGVFcnJvclJlY292ZXJ5KGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3VuZGFyeTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgbm8gYm91bmRhcnkgaXMgZm91bmQsIHdlJ2xsIG5lZWQgdG8gdGhyb3cgdGhlIGVycm9yXG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDYXB0dXJlZEVycm9yKGZpYmVyKSB7XG4gICAgLy8gVE9ETzogY2FwdHVyZWRFcnJvcnMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWQgbmVlZGluZ1xuICAgIC8vIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGNhcHR1cmVkRXJyb3JzICE9PSBudWxsICYmIChjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZhaWxlZEJvdW5kYXJ5KGZpYmVyKSB7XG4gICAgLy8gVE9ETzogZmFpbGVkQm91bmRhcmllcyBzaG91bGQgc3RvcmUgdGhlIGJvdW5kYXJ5IGluc3RhbmNlLCB0byBhdm9pZFxuICAgIC8vIG5lZWRpbmcgdG8gY2hlY2sgdGhlIGFsdGVybmF0ZS5cbiAgICByZXR1cm4gZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCAmJiAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlci5hbHRlcm5hdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEVycm9ySGFuZGxpbmcoZWZmZWN0ZnVsRmliZXIpIHtcbiAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHZvaWQgMDtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgY2FwdHVyZWRFcnJvcnNbJ2RlbGV0ZSddKGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGlmIChjYXB0dXJlZEVycm9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVmZmVjdGZ1bEZpYmVyID0gZWZmZWN0ZnVsRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNhcHR1cmVkRXJyb3IgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdObyBlcnJvciBmb3IgZ2l2ZW4gdW5pdCBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgc3dpdGNoIChlZmZlY3RmdWxGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGVmZmVjdGZ1bEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICBjb21wb25lbnRTdGFjazogY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFja1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFsbG93IHRoZSBib3VuZGFyeSB0byBoYW5kbGUgdGhlIGVycm9yLCB1c3VhbGx5IGJ5IHNjaGVkdWxpbmdcbiAgICAgICAgLy8gYW4gdXBkYXRlIHRvIGl0c2VsZlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaChjYXB0dXJlZEVycm9yLmVycm9yLCBpbmZvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0eXBlIG9mIHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW53aW5kQ29udGV4dHMoZnJvbSwgdG8pIHtcbiAgICB2YXIgbm9kZSA9IGZyb207XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICBwb3BDb250ZXh0UHJvdmlkZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dChub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0byB8fCBub2RlLmFsdGVybmF0ZSA9PT0gdG8pIHtcbiAgICAgICAgc3RvcEZhaWxlZFdvcmtUaW1lcihub2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9wV29ya1RpbWVyKG5vZGUpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKSB7XG4gICAgLy8gR2l2ZW4gdGhlIGN1cnJlbnQgY2xvY2sgdGltZSwgcmV0dXJucyBhbiBleHBpcmF0aW9uIHRpbWUuIFdlIHVzZSByb3VuZGluZ1xuICAgIC8vIHRvIGJhdGNoIGxpa2UgdXBkYXRlcyB0b2dldGhlci5cbiAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH4xMDAwbXMuIDEyMDBtcyBtYXguXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSAxMDAwO1xuICAgIHZhciBidWNrZXRTaXplTXMgPSAyMDA7XG4gICAgcmV0dXJuIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uTXMsIGJ1Y2tldFNpemVNcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gdm9pZCAwO1xuICAgIGlmIChleHBpcmF0aW9uQ29udGV4dCAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBbiBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldDtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfSBlbHNlIGlmIChpc1dvcmtpbmcpIHtcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgLy8gVXBkYXRlcyB0aGF0IG9jY3VyIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHNob3VsZCBoYXZlIHN5bmMgcHJpb3JpdHlcbiAgICAgICAgLy8gYnkgZGVmYXVsdC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlcyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSBzaG91bGQgZXhwaXJlIGF0IHRoZSBzYW1lIHRpbWUgYXNcbiAgICAgICAgLy8gdGhlIHdvcmsgdGhhdCBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0LCBhbmQgd2UncmUgbm90IGN1cnJlbnRseVxuICAgICAgLy8gcGVyZm9ybWluZyB3b3JrLiBDYWxjdWxhdGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKHVzZVN5bmNTY2hlZHVsaW5nICYmICEoZmliZXIuaW50ZXJuYWxDb250ZXh0VGFnICYgQXN5bmNVcGRhdGVzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKCFpc1dvcmtpbmcgJiYgcm9vdCA9PT0gbmV4dFJvb3QgJiYgZXhwaXJhdGlvblRpbWUgPCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFJlc3RhcnQgdGhlIHJvb3QgZnJvbSB0aGUgdG9wLlxuICAgICAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJydXB0aW9uLiAoVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuKVxuICAgICAgICBpbnRlcnJ1cHRlZEJ5ID0gZmliZXI7XG4gICAgICB9XG4gICAgICBuZXh0Um9vdCA9IG51bGw7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGlzRXJyb3JSZWNvdmVyeSkge1xuICAgIHJlY29yZFNjaGVkdWxlVXBkYXRlKCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWlzRXJyb3JSZWNvdmVyeSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgZWFjaCBub2RlJ3NcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChub2RlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5vZGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZChmaWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlRXJyb3JSZWNvdmVyeShmaWJlcikge1xuICAgIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIFN5bmMsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpIHtcbiAgICAvLyBTdWJ0cmFjdCBpbml0aWFsIHRpbWUgc28gaXQgZml0cyBpbnNpZGUgMzJiaXRzXG4gICAgdmFyIG1zID0gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgbW9zdFJlY2VudEN1cnJlbnRUaW1lID0gbXNUb0V4cGlyYXRpb25UaW1lKG1zKTtcbiAgICByZXR1cm4gbW9zdFJlY2VudEN1cnJlbnRUaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzeW5jVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBTeW5jO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwaXJhdGlvbkNvbnRleHQgPSBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEV2ZXJ5dGhpbmcgYmVsb3cgdGhpcyBpcyB3cml0dGVuIGFzIGlmIGl0IGhhcyBiZWVuIGxpZnRlZCB0byB0aGVcbiAgLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbiAgLy8gTGlua2VkLWxpc3Qgb2Ygcm9vdHNcbiAgdmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gIHZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbiAgdmFyIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBjYWxsYmFja0lEID0gLTE7XG4gIHZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB2YXIgbmV4dEZsdXNoZWRSb290ID0gbnVsbDtcbiAgdmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICB2YXIgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgdmFyIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgdmFyIGRlYWRsaW5lID0gbnVsbDtcblxuICB2YXIgaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgdmFyIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG4gIHZhciBORVNURURfVVBEQVRFX0xJTUlUID0gMTAwMDtcbiAgdmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICB2YXIgdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsgPSAxO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjYWxsYmFja0V4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEEgY2FsbGJhY2sgaXMgYWxyZWFkeSBzY2hlZHVsZWQuIENoZWNrIGl0cyBleHBpcmF0aW9uIHRpbWUgKHRpbWVvdXQpLlxuICAgICAgaWYgKGV4cGlyYXRpb25UaW1lID4gY2FsbGJhY2tFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgc3VmZmljaWVudCB0aW1lb3V0LiBFeGl0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFeGlzdGluZyBjYWxsYmFjayBoYXMgaW5zdWZmaWNpZW50IHRpbWVvdXQuIENhbmNlbCBhbmQgc2NoZWR1bGUgYVxuICAgICAgICAvLyBuZXcgb25lLlxuICAgICAgICBjYW5jZWxEZWZlcnJlZENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHJlcXVlc3QgY2FsbGJhY2sgdGltZXIgaXMgYWxyZWFkeSBydW5uaW5nLiBEb24ndCBzdGFydCBhIG5ldyBvbmUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGEgdGltZW91dCBmb3IgdGhlIGdpdmVuIGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY3VycmVudE1zID0gbm93KCkgLSBzdGFydFRpbWU7XG4gICAgdmFyIGV4cGlyYXRpb25NcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSk7XG4gICAgdmFyIHRpbWVvdXQgPSBleHBpcmF0aW9uTXMgLSBjdXJyZW50TXM7XG5cbiAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgY2FsbGJhY2tJRCA9IHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayhwZXJmb3JtQXN5bmNXb3JrLCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSk7XG4gIH1cblxuICAvLyByZXF1ZXN0V29yayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB3aGVuZXZlciBhIHJvb3QgcmVjZWl2ZXMgYW4gdXBkYXRlLlxuICAvLyBJdCdzIHVwIHRvIHRoZSByZW5kZXJlciB0byBjYWxsIHJlbmRlclJvb3QgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuICBmdW5jdGlvbiByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAgIC8vIENoZWNrIGlmIHRoaXMgcm9vdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNjaGVkdWxlLlxuICAgIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHkuXG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmVlbnRyYW5jeS4gUmVtYWluaW5nIHdvcmsgd2lsbCBiZSBzY2hlZHVsZWQgYXQgdGhlIGVuZCBvZlxuICAgICAgLy8gdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYmF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgICAgaWYgKGlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgICAgLy8gLi4udW5sZXNzIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZFxuICAgICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICAgIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPT09IFN5bmMpIHtcbiAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24oZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCkge1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlXb3JrID0gTm9Xb3JrO1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlSb290ID0gbnVsbDtcblxuICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290O1xuICAgICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yaykge1xuICAgICAgICAgIC8vIFRoaXMgcm9vdCBubyBsb25nZXIgaGFzIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZXIuXG5cbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIGNoZWNrIGlzIHJlZHVkYW50LCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgYnJhbmNoXG4gICAgICAgICAgLy8gYmVsb3cgd2hlcmUgd2Ugc2V0IGxhc3RTY2hlZHVsZWRSb290IHRvIG51bGwsIGV2ZW4gdGhvdWdoIHdlIGJyZWFrXG4gICAgICAgICAgLy8gZnJvbSB0aGUgbG9vcCByaWdodCBhZnRlci5cbiAgICAgICAgICAhKHByZXZpb3VzU2NoZWR1bGVkUm9vdCAhPT0gbnVsbCAmJiBsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBhIHByZXZpb3VzIGFuZCBsYXN0IHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJvb3QgPT09IHJvb3QubmV4dFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBmaXJzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaGlnaGVzdFByaW9yaXR5V29yayA9PT0gTm9Xb3JrIHx8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lIDwgaGlnaGVzdFByaW9yaXR5V29yaykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eSwgaWYgaXQncyBoaWdoZXJcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVJvb3QgPSByb290O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG5leHQgcm9vdCBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgcm9vdCwgdGhpcyBpcyBhIG5lc3RlZFxuICAgIC8vIHVwZGF0ZS4gVG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBpbmNyZW1lbnQgdGhlIG5lc3RlZCB1cGRhdGUgY291bnQuXG4gICAgdmFyIHByZXZpb3VzRmx1c2hlZFJvb3QgPSBuZXh0Rmx1c2hlZFJvb3Q7XG4gICAgaWYgKHByZXZpb3VzRmx1c2hlZFJvb3QgIT09IG51bGwgJiYgcHJldmlvdXNGbHVzaGVkUm9vdCA9PT0gaGlnaGVzdFByaW9yaXR5Um9vdCkge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgd2hlbmV2ZXIgd2Ugc3dpdGNoIHJvb3RzLlxuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgIH1cbiAgICBuZXh0Rmx1c2hlZFJvb3QgPSBoaWdoZXN0UHJpb3JpdHlSb290O1xuICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBoaWdoZXN0UHJpb3JpdHlXb3JrO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUFzeW5jV29yayhkbCkge1xuICAgIHBlcmZvcm1Xb3JrKE5vV29yaywgZGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmsobWluRXhwaXJhdGlvblRpbWUsIGRsKSB7XG4gICAgZGVhZGxpbmUgPSBkbDtcblxuICAgIC8vIEtlZXAgd29ya2luZyBvbiByb290cyB1bnRpbCB0aGVyZSdzIG5vIG1vcmUgd29yaywgb3IgdW50aWwgdGhlIHdlIHJlYWNoXG4gICAgLy8gdGhlIGRlYWRsaW5lLlxuICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG5cbiAgICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSAmJiBkZWFkbGluZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEV4cGlyZSA9IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPCByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgICBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlKTtcbiAgICB9XG5cbiAgICB3aGlsZSAobmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobWluRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDw9IG1pbkV4cGlyYXRpb25UaW1lKSAmJiAhZGVhZGxpbmVEaWRFeHBpcmUpIHtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICAvLyBGaW5kIHRoZSBuZXh0IGhpZ2hlc3QgcHJpb3JpdHkgd29yay5cbiAgICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gICAgfVxuXG4gICAgLy8gV2UncmUgZG9uZSBmbHVzaGluZyB3b3JrLiBFaXRoZXIgd2UgcmFuIG91dCBvZiB0aW1lIGluIHRoaXMgY2FsbGJhY2ssXG4gICAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBjYWxsYmFjaywgc2V0IHRoaXMgdG8gZmFsc2Ugc2luY2Ugd2UganVzdCBjb21wbGV0ZWQgaXQuXG4gICAgaWYgKGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgY2FsbGJhY2tJRCA9IC0xO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIHdvcmsgbGVmdCBvdmVyLCBzY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cbiAgICBpZiAobmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24obmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4tdXAuXG4gICAgZGVhZGxpbmUgPSBudWxsO1xuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgaWYgKGhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICB2YXIgX2Vycm9yNCA9IHVuaGFuZGxlZEVycm9yO1xuICAgICAgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHRocm93IF9lcnJvcjQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAncGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYXN5bmMgd29yayBvciBzeW5jL2V4cGlyZWQgd29yay5cbiAgICAvLyBUT0RPOiBQYXNzIGN1cnJlbnQgdGltZSBhcyBhcmd1bWVudCB0byByZW5kZXJSb290LCBjb21taXRSb290XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lIDw9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSkge1xuICAgICAgLy8gRmx1c2ggc3luYyB3b3JrLlxuICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICBmaW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ29tbWl0IGl0LlxuICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmMgd29yay5cbiAgICAgIHZhciBfZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChfZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgX2ZpbmlzaGVkV29yayA9IHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ2hlY2sgdGhlIGRlYWRsaW5lIG9uZSBtb3JlIHRpbWVcbiAgICAgICAgICAvLyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgICBpZiAoIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIHRpbWUgbGVmdC4gQ29tbWl0IHRoZSByb290LlxuICAgICAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgICAgLy8gYmFjayBhbmQgY29tbWl0IGl0IGxhdGVyLlxuICAgICAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICAvLyBXaGVuIHdvcmtpbmcgb24gYXN5bmMgd29yaywgdGhlIHJlY29uY2lsZXIgYXNrcyB0aGUgcmVuZGVyZXIgaWYgaXQgc2hvdWxkXG4gIC8vIHlpZWxkIGV4ZWN1dGlvbi4gRm9yIERPTSwgd2UgaW1wbGVtZW50IHRoaXMgd2l0aCByZXF1ZXN0SWRsZUNhbGxiYWNrLlxuICBmdW5jdGlvbiBzaG91bGRZaWVsZCgpIHtcbiAgICBpZiAoZGVhZGxpbmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBEaXNyZWdhcmQgZGVhZGxpbmUuZGlkVGltZW91dC4gT25seSBleHBpcmVkIHdvcmsgc2hvdWxkIGJlIGZsdXNoZWRcbiAgICAgIC8vIGR1cmluZyBhIHRpbWVvdXQuIFRoaXMgcGF0aCBpcyBvbmx5IGhpdCBmb3Igbm9uLWV4cGlyZWQgd29yay5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGVhZGxpbmVEaWRFeHBpcmUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVE9ETzogTm90IGhhcHB5IGFib3V0IHRoaXMgaG9vay4gQ29uY2VwdHVhbGx5LCByZW5kZXJSb290IHNob3VsZCByZXR1cm4gYVxuICAvLyB0dXBsZSBvZiAoaXNSZWFkeUZvckNvbW1pdCwgZGlkRXJyb3IsIGVycm9yKVxuICBmdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgICAhKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgd29ya2luZyBvbiBhIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgLy8gVW5zY2hlZHVsZSB0aGlzIHJvb3Qgc28gd2UgZG9uJ3Qgd29yayBvbiBpdCBhZ2FpbiB1bnRpbCB0aGVyZSdzXG4gICAgLy8gYW5vdGhlciB1cGRhdGUuXG4gICAgbmV4dEZsdXNoZWRSb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgIGlmICghaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGEpIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3QgaW5zaWRlXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiB1bmJhdGNoZWRVcGRhdGVzKGZuKSB7XG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm4oKTtcbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCB3aXRoaW5cbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGZsdXNoU3luYyhmbikge1xuICAgIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3luY1VwZGF0ZXMoZm4pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAnZmx1c2hTeW5jIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSBsaWZlY3ljbGUgbWV0aG9kLiBJdCBjYW5ub3QgYmUgY2FsbGVkIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuJykgOiB2b2lkIDA7XG4gICAgICBwZXJmb3JtV29yayhTeW5jLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXB1dGVBc3luY0V4cGlyYXRpb246IGNvbXB1dGVBc3luY0V4cGlyYXRpb24sXG4gICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcjogY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixcbiAgICBzY2hlZHVsZVdvcms6IHNjaGVkdWxlV29yayxcbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlc1xuICB9O1xufTtcblxue1xuICB2YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xufVxuXG4vLyAwIGlzIFBST0QsIDEgaXMgREVWLlxuLy8gTWlnaHQgYWRkIFBST0ZJTEUgbGF0ZXIuXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuICByZXR1cm4gaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpID8gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgcGFyZW50Q29udGV4dCkgOiBwYXJlbnRDb250ZXh0O1xufVxuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMSA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlO1xuXG4gIHZhciBfUmVhY3RGaWJlclNjaGVkdWxlciA9IFJlYWN0RmliZXJTY2hlZHVsZXIoY29uZmlnKSxcbiAgICAgIGNvbXB1dGVBc3luY0V4cGlyYXRpb24gPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgICAgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgICBzY2hlZHVsZVdvcmsgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5zY2hlZHVsZVdvcmssXG4gICAgICBiYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmJhdGNoZWRVcGRhdGVzLFxuICAgICAgdW5iYXRjaGVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLnVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICBmbHVzaFN5bmMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5mbHVzaFN5bmMsXG4gICAgICBkZWZlcnJlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5kZWZlcnJlZFVwZGF0ZXM7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjaykge1xuICAgIHtcbiAgICAgIGlmIChSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID09PSAncmVuZGVyJyAmJiBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgICAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgJyArICd0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gJyArICdJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbicgKyAnQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgZ2V0Q29tcG9uZW50TmFtZShSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgIHtcbiAgICAgIHdhcm5pbmcoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gdm9pZCAwO1xuICAgIC8vIENoZWNrIGlmIHRoZSB0b3AtbGV2ZWwgZWxlbWVudCBpcyBhbiBhc3luYyB3cmFwcGVyIGNvbXBvbmVudC4gSWYgc28sXG4gICAgLy8gdHJlYXQgdXBkYXRlcyB0byB0aGUgcm9vdCBhcyBhc3luYy4gVGhpcyBpcyBhIGJpdCB3ZWlyZCBidXQgbGV0cyB1c1xuICAgIC8vIGF2b2lkIGEgc2VwYXJhdGUgYHJlbmRlckFzeW5jYCBBUEkuXG4gICAgaWYgKGVuYWJsZUFzeW5jU3VidHJlZUFQSSAmJiBlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudC50eXBlICE9IG51bGwgJiYgZWxlbWVudC50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlKSB7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICBwYXJ0aWFsU3RhdGU6IHsgZWxlbWVudDogZWxlbWVudCB9LFxuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgaXNSZXBsYWNlOiBmYWxzZSxcbiAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihjdXJyZW50LCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlV29yayhjdXJyZW50LCBleHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNyZWF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaHlkcmF0ZSk7XG4gICAgfSxcbiAgICB1cGRhdGVDb250YWluZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICAgICAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcblxuICAgICAge1xuICAgICAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIGlmIChjdXJyZW50LmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbk1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVW5tb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgICAgIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZVRvcExldmVsVXBkYXRlKGN1cnJlbnQsIGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICB9LFxuXG5cbiAgICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgICB1bmJhdGNoZWRVcGRhdGVzOiB1bmJhdGNoZWRVcGRhdGVzLFxuXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXMsXG5cbiAgICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICAgIGdldFB1YmxpY1Jvb3RJbnN0YW5jZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgdmFyIGNvbnRhaW5lckZpYmVyID0gY29udGFpbmVyLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfSxcblxuXG4gICAgZmluZEhvc3RJbnN0YW5jZTogZmluZEhvc3RJbnN0YW5jZSxcblxuICAgIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO1xuICAgICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgIH0sXG4gICAgaW5qZWN0SW50b0RldlRvb2xzOiBmdW5jdGlvbiAoZGV2VG9vbHNDb25maWcpIHtcbiAgICAgIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuXG4gICAgICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKF9hc3NpZ24oe30sIGRldlRvb2xzQ29uZmlnLCB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShmaWJlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoIWZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBNaWdodCBub3QgYmUgaW1wbGVtZW50ZWQgYnkgdGhlIHJlbmRlcmVyLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdEZpYmVyUmVjb25jaWxlciQxXG59KTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDMgPSAoIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgJiYgUmVhY3RGaWJlclJlY29uY2lsZXIkMSApIHx8IFJlYWN0RmliZXJSZWNvbmNpbGVyJDI7XG5cbi8vIFRPRE86IGJ1bmRsZSBGbG93IHR5cGVzIHdpdGggdGhlIHBhY2thZ2UuXG5cblxuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdFJlY29uY2lsZXIgPSBSZWFjdEZpYmVyUmVjb25jaWxlciQzWydkZWZhdWx0J10gPyBSZWFjdEZpYmVyUmVjb25jaWxlciQzWydkZWZhdWx0J10gOiBSZWFjdEZpYmVyUmVjb25jaWxlciQzO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbyxcbi8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi4yLjAnO1xuXG4vLyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSwgc3RvcmluZyB0aGUgdGltZSBmb3IgdGhlIHN0YXJ0IG9mIHRoZSBmcmFtZSwgdGhlblxuLy8gc2NoZWR1bGluZyBhIHBvc3RNZXNzYWdlIHdoaWNoIGdldHMgc2NoZWR1bGVkIGFmdGVyIHBhaW50LiBXaXRoaW4gdGhlXG4vLyBwb3N0TWVzc2FnZSBoYW5kbGVyIGRvIGFzIG11Y2ggd29yayBhcyBwb3NzaWJsZSB1bnRpbCB0aW1lICsgZnJhbWUgcmF0ZS5cbi8vIEJ5IHNlcGFyYXRpbmcgdGhlIGlkbGUgY2FsbCBpbnRvIGEgc2VwYXJhdGUgZXZlbnQgdGljayB3ZSBlbnN1cmUgdGhhdFxuLy8gbGF5b3V0LCBwYWludCBhbmQgb3RoZXIgYnJvd3NlciB3b3JrIGlzIGNvdW50ZWQgYWdhaW5zdCB0aGUgYXZhaWxhYmxlIHRpbWUuXG4vLyBUaGUgZnJhbWUgcmF0ZSBpcyBkeW5hbWljYWxseSBhZGp1c3RlZC5cblxue1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIG5vdyA9IHZvaWQgMDtcbmlmIChoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdykge1xuICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG4vLyBUT0RPOiBUaGVyZSdzIG5vIHdheSB0byBjYW5jZWwsIGJlY2F1c2UgRmliZXIgZG9lc24ndCBhdG0uXG52YXIgcklDID0gdm9pZCAwO1xudmFyIGNJQyA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcklDID0gZnVuY3Rpb24gKGZyYW1lQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmcmFtZUNhbGxiYWNrKHtcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIGNJQyA9IGZ1bmN0aW9uICh0aW1lb3V0SUQpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNhbmNlbElkbGVDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAvLyBQb2x5ZmlsbCByZXF1ZXN0SWRsZUNhbGxiYWNrIGFuZCBjYW5jZWxJZGxlQ2FsbGJhY2tcblxuICB2YXIgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICB2YXIgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciB0aW1lb3V0VGltZSA9IC0xO1xuXG4gIHZhciBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmUgPSAwO1xuICAvLyBXZSBzdGFydCBvdXQgYXNzdW1pbmcgdGhhdCB3ZSBydW4gYXQgMzBmcHMgYnV0IHRoZW4gdGhlIGhldXJpc3RpYyB0cmFja2luZ1xuICAvLyB3aWxsIGFkanVzdCB0aGlzIHZhbHVlIHRvIGEgZmFzdGVyIGZwcyBpZiB3ZSBnZXQgbW9yZSBmcmVxdWVudCBhbmltYXRpb25cbiAgLy8gZnJhbWVzLlxuICB2YXIgcHJldmlvdXNGcmFtZVRpbWUgPSAzMztcbiAgdmFyIGFjdGl2ZUZyYW1lVGltZSA9IDMzO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lT2JqZWN0O1xuICBpZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgICBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGlmIHdlIGhhdmUgYSBwZXJmb3JtYW5jZSB0aW1lciB0aGF0IHRoZSByQUYgY2FsbGJhY2tcbiAgICAgICAgLy8gZ2V0cyBhIHBlcmZvcm1hbmNlIHRpbWVyIHZhbHVlLiBOb3Qgc3VyZSBpZiB0aGlzIGlzIGFsd2F5cyB0cnVlLlxuICAgICAgICB2YXIgcmVtYWluaW5nID0gZnJhbWVEZWFkbGluZSAtIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgICAgZGlkVGltZW91dDogZmFsc2UsXG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIERhdGUubm93KClcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IGZyYW1lRGVhZGxpbmUgLSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nID4gMCA/IHJlbWFpbmluZyA6IDA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFdlIHVzZSB0aGUgcG9zdE1lc3NhZ2UgdHJpY2sgdG8gZGVmZXIgaWRsZSB3b3JrIHVudGlsIGFmdGVyIHRoZSByZXBhaW50LlxuICB2YXIgbWVzc2FnZUtleSA9ICdfX3JlYWN0SWRsZUNhbGxiYWNrJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgdmFyIGlkbGVUaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSAhPT0gd2luZG93IHx8IGV2ZW50LmRhdGEgIT09IG1lc3NhZ2VLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIHZhciBjdXJyZW50VGltZSA9IG5vdygpO1xuICAgIGlmIChmcmFtZURlYWRsaW5lIC0gY3VycmVudFRpbWUgPD0gMCkge1xuICAgICAgLy8gVGhlcmUncyBubyB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC4gQ2hlY2sgaWYgdGhlIGNhbGxiYWNrIGhhc1xuICAgICAgLy8gYSB0aW1lb3V0IGFuZCB3aGV0aGVyIGl0J3MgYmVlbiBleGNlZWRlZC5cbiAgICAgIGlmICh0aW1lb3V0VGltZSAhPT0gLTEgJiYgdGltZW91dFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgLy8gRXhjZWVkZWQgdGhlIHRpbWVvdXQuIEludm9rZSB0aGUgY2FsbGJhY2sgZXZlbiB0aG91Z2ggdGhlcmUncyBub1xuICAgICAgICAvLyB0aW1lIGxlZnQuXG4gICAgICAgIGZyYW1lRGVhZGxpbmVPYmplY3QuZGlkVGltZW91dCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyB0aW1lb3V0LlxuICAgICAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbm90aGVyIGFuaW1hdGlvbiBjYWxsYmFjayBzbyB3ZSByZXRyeSBsYXRlci5cbiAgICAgICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXhpdCB3aXRob3V0IGludm9raW5nIHRoZSBjYWxsYmFjay5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSdzIHN0aWxsIHRpbWUgbGVmdCBpbiB0aGlzIGlkbGUgcGVyaW9kLlxuICAgICAgZnJhbWVEZWFkbGluZU9iamVjdC5kaWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGltZW91dFRpbWUgPSAtMTtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY2hlZHVsZWRSSUNDYWxsYmFjaztcbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IG51bGw7XG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhmcmFtZURlYWRsaW5lT2JqZWN0KTtcbiAgICB9XG4gIH07XG4gIC8vIEFzc3VtZXMgdGhhdCB3ZSBoYXZlIGFkZEV2ZW50TGlzdGVuZXIgaW4gdGhpcyBlbnZpcm9ubWVudC4gTWlnaHQgbmVlZFxuICAvLyBzb21ldGhpbmcgYmV0dGVyIGZvciBvbGQgSUUuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaWRsZVRpY2ssIGZhbHNlKTtcblxuICB2YXIgYW5pbWF0aW9uVGljayA9IGZ1bmN0aW9uIChyYWZUaW1lKSB7XG4gICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBuZXh0RnJhbWVUaW1lID0gcmFmVGltZSAtIGZyYW1lRGVhZGxpbmUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKG5leHRGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUgJiYgcHJldmlvdXNGcmFtZVRpbWUgPCBhY3RpdmVGcmFtZVRpbWUpIHtcbiAgICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgOCkge1xuICAgICAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBXZSBkb24ndCBzdXBwb3J0IGhpZ2hlciBmcmFtZSByYXRlcyB0aGFuIDEyMGh6LlxuICAgICAgICAvLyBJZiB3ZSBnZXQgbG93ZXIgdGhhbiB0aGF0LCBpdCBpcyBwcm9iYWJseSBhIGJ1Zy5cbiAgICAgICAgbmV4dEZyYW1lVGltZSA9IDg7XG4gICAgICB9XG4gICAgICAvLyBJZiBvbmUgZnJhbWUgZ29lcyBsb25nLCB0aGVuIHRoZSBuZXh0IG9uZSBjYW4gYmUgc2hvcnQgdG8gY2F0Y2ggdXAuXG4gICAgICAvLyBJZiB0d28gZnJhbWVzIGFyZSBzaG9ydCBpbiBhIHJvdywgdGhlbiB0aGF0J3MgYW4gaW5kaWNhdGlvbiB0aGF0IHdlXG4gICAgICAvLyBhY3R1YWxseSBoYXZlIGEgaGlnaGVyIGZyYW1lIHJhdGUgdGhhbiB3aGF0IHdlJ3JlIGN1cnJlbnRseSBvcHRpbWl6aW5nLlxuICAgICAgLy8gV2UgYWRqdXN0IG91ciBoZXVyaXN0aWMgZHluYW1pY2FsbHkgYWNjb3JkaW5nbHkuIEZvciBleGFtcGxlLCBpZiB3ZSdyZVxuICAgICAgLy8gcnVubmluZyBvbiAxMjBoeiBkaXNwbGF5IG9yIDkwaHogVlIgZGlzcGxheS5cbiAgICAgIC8vIFRha2UgdGhlIG1heCBvZiB0aGUgdHdvIGluIGNhc2Ugb25lIG9mIHRoZW0gd2FzIGFuIGFub21hbHkgZHVlIHRvXG4gICAgICAvLyBtaXNzZWQgZnJhbWUgZGVhZGxpbmVzLlxuICAgICAgYWN0aXZlRnJhbWVUaW1lID0gbmV4dEZyYW1lVGltZSA8IHByZXZpb3VzRnJhbWVUaW1lID8gcHJldmlvdXNGcmFtZVRpbWUgOiBuZXh0RnJhbWVUaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2aW91c0ZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWU7XG4gICAgfVxuICAgIGZyYW1lRGVhZGxpbmUgPSByYWZUaW1lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmICghaXNJZGxlU2NoZWR1bGVkKSB7XG4gICAgICBpc0lkbGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgd2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2VLZXksICcqJyk7XG4gICAgfVxuICB9O1xuXG4gIHJJQyA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0aW9ucykge1xuICAgIC8vIFRoaXMgYXNzdW1lcyB0aGF0IHdlIG9ubHkgc2NoZWR1bGUgb25lIGNhbGxiYWNrIGF0IGEgdGltZSBiZWNhdXNlIHRoYXQnc1xuICAgIC8vIGhvdyBGaWJlciB1c2VzIGl0LlxuICAgIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgdGltZW91dFRpbWUgPSBub3coKSArIG9wdGlvbnMudGltZW91dDtcbiAgICB9XG4gICAgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAvLyBJZiByQUYgZGlkbid0IGFscmVhZHkgc2NoZWR1bGUgb25lLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgZnJhbWUuXG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIHJBRiBkb2Vzbid0IG1hdGVyaWFsaXplIGJlY2F1c2UgdGhlIGJyb3dzZXIgdGhyb3R0bGVzLCB3ZVxuICAgICAgLy8gbWlnaHQgd2FudCB0byBzdGlsbCBoYXZlIHNldFRpbWVvdXQgdHJpZ2dlciBySUMgYXMgYSBiYWNrdXAgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGtlZXAgcGVyZm9ybWluZyB3b3JrLlxuICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uVGljayk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIGNJQyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IG51bGw7XG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdGltZW91dFRpbWUgPSAtMTtcbiAgfTtcbn0gZWxzZSB7XG4gIHJJQyA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrO1xuICBjSUMgPSB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG4vLyBpc0F0dHJpYnV0ZU5hbWVTYWZlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc2hvdWxkSWdub3JlVmFsdWUoKSBpcyBjdXJyZW50bHkgZHVwbGljYXRlZCBpbiBET01NYXJrdXBPcGVyYXRpb25zLlxuLy8gVE9ETzogRmluZCBhIGJldHRlciBwbGFjZSBmb3IgdGhpcy5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG5cblxuXG5cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgXCJleHBlY3RlZFwiIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLlxuICogU29tZSBwcm9wZXJ0aWVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kIHx8IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuXG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGEgYm9vbGVhbiwgaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgICAgLy8gVG8gdXNlIGdldEF0dHJpYnV0ZU5TIHdlIG5lZWQgdGhlIGxvY2FsIG5hbWUgd2hpY2ggd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuICAgICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG51bGw7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAmJiBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpID8gdmFsdWUgOiBudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGVzIGFuIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lKSB7XG4gIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xufVxuXG4vKipcbiAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsXG59O1xuXG57XG4gIHZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICBjaGVja2JveDogdHJ1ZSxcbiAgICBpbWFnZTogdHJ1ZSxcbiAgICBoaWRkZW46IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgcmVzZXQ6IHRydWUsXG4gICAgc3VibWl0OiB0cnVlXG4gIH07XG5cbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfSxcbiAgICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIHRhZ05hbWUsIGdldFN0YWNrKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAvLyBiZWZvcmUgLnR5cGUgbWVhbnMgLnZhbHVlIGlzIGxvc3QgaW4gSUUxMSBhbmQgYmVsb3cpXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgLy8gbWVhbnMgLnZhbHVlIGlzIHJvdW5kZWQgb24gbW91bnQsIGJhc2VkIHVwb24gc3RlcCBwcmVjaXNpb24pXG4gICAgc3RlcDogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgIC8vIGluIGNvcm5lciBjYXNlcyBzdWNoIGFzIG1pbiBvciBtYXggZGVyaXZpbmcgZnJvbSB2YWx1ZSwgZS5nLiBJc3N1ZSAjNzE3MClcbiAgICBtaW46IHVuZGVmaW5lZCxcbiAgICBtYXg6IHVuZGVmaW5lZFxuICB9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUsXG4gICAgY29udHJvbGxlZDogaXNDb250cm9sbGVkKHByb3BzKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCAnY2hlY2tlZCcsIGNoZWNrZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMlcycsIHByb3BzLnR5cGUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMygpKTtcbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodmFsdWUgPT09IDAgJiYgbm9kZS52YWx1ZSA9PT0gJycpIHtcbiAgICAgIG5vZGUudmFsdWUgPSAnMCc7XG4gICAgICAvLyBOb3RlOiBJRTkgcmVwb3J0cyBhIG51bWJlciBpbnB1dHMgYXMgJ3RleHQnLCBzbyBjaGVjayBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFNpbXVsYXRlIGBpbnB1dC52YWx1ZUFzTnVtYmVyYC4gSUU5IGRvZXMgbm90IHN1cHBvcnQgaXRcbiAgICAgIHZhciB2YWx1ZUFzTnVtYmVyID0gcGFyc2VGbG9hdChub2RlLnZhbHVlKSB8fCAwO1xuXG4gICAgICBpZiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlICE9IHZhbHVlQXNOdW1iZXIgfHxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdmFsdWUgPT0gdmFsdWVBc051bWJlciAmJiBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuICAgICAgLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuICAgICAgLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbiAgICAgIC8vXG4gICAgICAvLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuICAgICAgLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuICAgICAgLy9cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWUuIFdlIHdvbid0IGRvIGFueXRoaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb25cbiAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gIC8vIHJlbW92ZXMgYnJvd3Nlci1kZWZhdWx0IHZhbHVlcyAoZWcgXCJTdWJtaXQgUXVlcnlcIikgd2hlbiBubyB2YWx1ZSBpc1xuICAvLyBwcm92aWRlZC5cblxuICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICBjYXNlICdzdWJtaXQnOlxuICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbG9yJzpcbiAgICBjYXNlICdkYXRlJzpcbiAgICBjYXNlICdkYXRldGltZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICBjYXNlICd0aW1lJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgIG5vZGUudmFsdWUgPSAnJztcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShvdGhlck5vZGUpO1xuICAgICAgIW90aGVyUHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcblxuICAgICAgLy8gV2UgbmVlZCB1cGRhdGUgdGhlIHRyYWNrZWQgdmFsdWUgb24gdGhlIG5hbWVkIGNvdXNpbiBzaW5jZSB0aGUgdmFsdWVcbiAgICAgIC8vIHdhcyBjaGFuZ2VkIGJ1dCB0aGUgaW5wdXQgc2F3IG5vIGV2ZW50IG9yIHZhbHVlIHNldFxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcblxuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB1cGRhdGVXcmFwcGVyKG90aGVyTm9kZSwgb3RoZXJQcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4gYW5kIHdhcm4gaWYgdGhleSBhcmVuJ3Qgc3RyaW5ncyBvciBudW1iZXJzO1xuICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAvLyBXZSBjYW4gc2lsZW50bHkgc2tpcCB0aGVtIGJlY2F1c2UgaW52YWxpZCBET00gbmVzdGluZyB3YXJuaW5nXG4gIC8vIGNhdGNoZXMgdGhlc2UgY2FzZXMgaW4gRmliZXIuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29udGVudDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zZWxlY3RlZCA9PSBudWxsLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIG9uIDxzZWxlY3Q+IGluc3RlYWQgb2YgJyArICdzZXR0aW5nIGBzZWxlY3RlZGAgb24gPG9wdGlvbj4uJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzKCk7XG4gIGlmIChvd25lck5hbWUpIHtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKSB7XG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHByb3BWYWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9wdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KCckJyArIG9wdGlvbnNbX2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW19pXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIHZhciBkZWZhdWx0U2VsZWN0ZWQgPSBudWxsO1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICAgIG9wdGlvbnNbX2kyXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRTZWxlY3RlZC5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcyk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgLy8gdGhpcyB2YWx1ZSBkb3duXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgdmFyIHdhc011bHRpcGxlID0gbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuXG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gISFwcm9wcy5tdWx0aXBsZSkge1xuICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuXG4gIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rU29waGllIHNlZW1lZCB0byBsaWtlIHRoaXNcbiAgLy8gc29sdXRpb24uIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkXG4gIC8vIHRvIGJlIGEgc3RyaW5nLlxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIGNoaWxkcmVuOiAnJyArIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWVcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUpO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5pdGlhbFZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcbiAgaWYgKGluaXRpYWxWYWx1ZSA9PSBudWxsKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICAgIH1cbiAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogdm9pZCAwO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiAnJyArIGluaXRpYWxWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50O1xuXG4gIC8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4gIC8vIGluaXRpYWwgdmFsdWUuIEluIElFMTAvSUUxMSB0aGVyZSBpcyBhIGJ1ZyB3aGVyZSB0aGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlXG4gIC8vIHdpbGwgcG9wdWxhdGUgdGV4dENvbnRlbnQgYXMgd2VsbC5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuICBpZiAodGV4dENvbnRlbnQgPT09IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcbiAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcyk7XG59XG5cbnZhciBIVE1MX05BTUVTUEFDRSQxID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG52YXIgTmFtZXNwYWNlcyA9IHtcbiAgaHRtbDogSFRNTF9OQU1FU1BBQ0UkMSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59O1xuXG4vLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5mdW5jdGlvbiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdmcnOlxuICAgICAgcmV0dXJuIFNWR19OQU1FU1BBQ0U7XG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSkge1xuICBpZiAocGFyZW50TmFtZXNwYWNlID09IG51bGwgfHwgcGFyZW50TmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IFNWR19OQU1FU1BBQ0UgJiYgdHlwZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gV2UncmUgbGVhdmluZyBTVkcuXG4gICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFJDE7XG4gIH1cbiAgLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHZvaWQgMDtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGVcbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG5cbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBOYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICB9XG59KTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgXCJTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb24uIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJXMnLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkRm9yTmFOVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JOYU5WYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkobmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzLCBnZXRTdGFjaykge1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgZ2V0U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG4gICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgc3R5bGVOYW1lID0gJ2Nzc0Zsb2F0JztcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MJDEgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjaykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCB0YWcsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MJDEgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICB3YXJuaW5nKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJXMnLCBnZXRTdGFjaygpKTtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gdXNpbmcgSlNYLiVzJywgZ2V0U3RhY2soKSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIHdoaXRlbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFByb3BlcnRpZXMsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQUNhbWVsLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoY29ycmVjdE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBjb3JyZWN0TmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkodHlwZSwga2V5KTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH0gZWxzZSBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDEoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKSB7XG4gIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIGRpZFdhcm5WYWx1ZU51bGwgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLiVzJywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyB3aGl0ZWxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgJ2RlZmF1bHQnOiAnZGVmYXVsdCcsXG4gIGRlZmF1bHRjaGVja2VkOiAnZGVmYXVsdENoZWNrZWQnLFxuICBkZWZhdWx0dmFsdWU6ICdkZWZhdWx0VmFsdWUnLFxuICBkZWZlcjogJ2RlZmVyJyxcbiAgZGlyOiAnZGlyJyxcbiAgZGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gICdmb3InOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbmNlOiAnbm9uY2UnLFxuICBub3ZhbGlkYXRlOiAnbm9WYWxpZGF0ZScsXG4gIG9wZW46ICdvcGVuJyxcbiAgb3B0aW11bTogJ29wdGltdW0nLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBsYWNlaG9sZGVyOiAncGxhY2Vob2xkZXInLFxuICBwbGF5c2lubGluZTogJ3BsYXlzSW5saW5lJyxcbiAgcG9zdGVyOiAncG9zdGVyJyxcbiAgcHJlbG9hZDogJ3ByZWxvYWQnLFxuICBwcm9maWxlOiAncHJvZmlsZScsXG4gIHJhZGlvZ3JvdXA6ICdyYWRpb0dyb3VwJyxcbiAgcmVhZG9ubHk6ICdyZWFkT25seScsXG4gIHJlZmVycmVycG9saWN5OiAncmVmZXJyZXJQb2xpY3knLFxuICByZWw6ICdyZWwnLFxuICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgcmV2ZXJzZWQ6ICdyZXZlcnNlZCcsXG4gIHJvbGU6ICdyb2xlJyxcbiAgcm93czogJ3Jvd3MnLFxuICByb3dzcGFuOiAncm93U3BhbicsXG4gIHNhbmRib3g6ICdzYW5kYm94JyxcbiAgc2NvcGU6ICdzY29wZScsXG4gIHNjb3BlZDogJ3Njb3BlZCcsXG4gIHNjcm9sbGluZzogJ3Njcm9sbGluZycsXG4gIHNlYW1sZXNzOiAnc2VhbWxlc3MnLFxuICBzZWxlY3RlZDogJ3NlbGVjdGVkJyxcbiAgc2hhcGU6ICdzaGFwZScsXG4gIHNpemU6ICdzaXplJyxcbiAgc2l6ZXM6ICdzaXplcycsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3BlbGxjaGVjazogJ3NwZWxsQ2hlY2snLFxuICBzcmM6ICdzcmMnLFxuICBzcmNkb2M6ICdzcmNEb2MnLFxuICBzcmNsYW5nOiAnc3JjTGFuZycsXG4gIHNyY3NldDogJ3NyY1NldCcsXG4gIHN0YXJ0OiAnc3RhcnQnLFxuICBzdGVwOiAnc3RlcCcsXG4gIHN0eWxlOiAnc3R5bGUnLFxuICBzdW1tYXJ5OiAnc3VtbWFyeScsXG4gIHRhYmluZGV4OiAndGFiSW5kZXgnLFxuICB0YXJnZXQ6ICd0YXJnZXQnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHlwZTogJ3R5cGUnLFxuICB1c2VtYXA6ICd1c2VNYXAnLFxuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgd2lkdGg6ICd3aWR0aCcsXG4gIHdtb2RlOiAnd21vZGUnLFxuICB3cmFwOiAnd3JhcCcsXG5cbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgJ2luJzogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgJ3R5cGVvZic6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQyKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG57XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzJDEgPSB7fTtcbiAgdmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIHR5cGVvZiB2YWx1ZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gaXNSZXNlcnZlZFByb3AobmFtZSk7XG5cbiAgICAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJXMnLCBuYW1lLCBsb3dlckNhc2VkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiAhc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoIXNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5LCBwcm9wc1trZXldLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCB2YWx1ZSBmb3IgcHJvcCAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSBpdCBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgaXQgaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FyblNoYWR5RE9NID0gZmFsc2U7XG5cbnZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCA9ICdkYW5nZXJvdXNseVNldElubmVySFRNTCc7XG52YXIgU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HID0gJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7XG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xudmFyIEFVVE9GT0NVUyA9ICdhdXRvRm9jdXMnO1xudmFyIENISUxEUkVOID0gJ2NoaWxkcmVuJztcbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSBOYW1lc3BhY2VzLmh0bWw7XG5cblxudmFyIGdldFN0YWNrID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucygnJyk7XG5cbntcbiAgZ2V0U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDI7XG5cbiAgdmFyIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIENocm9tZSBpcyB0aGUgb25seSBtYWpvciBicm93c2VyIG5vdCBzaGlwcGluZyA8dGltZT4uIEJ1dCBhcyBvZiBKdWx5XG4gICAgLy8gMjAxNyBpdCBpbnRlbmRzIHRvIHNoaXAgaXQgZHVlIHRvIHdpZGVzcHJlYWQgdXNhZ2UuIFdlIGludGVudGlvbmFsbHlcbiAgICAvLyAqZG9uJ3QqIHdhcm4gZm9yIDx0aW1lPiBldmVuIGlmIGl0J3MgdW5yZWNvZ25pemVkIGJ5IENocm9tZSBiZWNhdXNlXG4gICAgLy8gaXQgc29vbiB3aWxsIGJlLCBhbmQgbWFueSBhcHBzIGhhdmUgYmVlbiB1c2luZyBpdCBhbnl3YXkuXG4gICAgdGltZTogdHJ1ZSxcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWVcbiAgfTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCAvKiBjYW5Vc2VFdmVudFN5c3RlbSAqL3RydWUpO1xuICB9O1xuXG4gIC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICB2YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBtYXJrdXBTdHJpbmcgPSB0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJyA/IG1hcmt1cCA6ICcnICsgbWFya3VwO1xuICAgIHJldHVybiBtYXJrdXBTdHJpbmcucmVwbGFjZShOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgsICdcXG4nKS5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwgJycpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVGV4dCA9PT0gbm9ybWFsaXplZENsaWVudFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yUHJvcERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHNlcnZlclZhbHVlLCBjbGllbnRWYWx1ZSkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclZhbHVlKTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclZhbHVlID09PSBub3JtYWxpemVkQ2xpZW50VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdQcm9wIGAlc2AgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiAlcyBDbGllbnQ6ICVzJywgcHJvcE5hbWUsIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmcoZmFsc2UsICdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gIHZhciBub3JtYWxpemVIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAgIC8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbiAgICAvLyByZS1pbml0aWFsaXppbmcgY3VzdG9tIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QuIEJ1dCB0aGlzIGJyZWFrc1xuICAgIC8vIGhvdyA8bm9zY3JpcHQ+IGlzIGJlaW5nIGhhbmRsZWQuIFNvIHdlIHVzZSB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAvLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG4gICAgdmFyIHRlc3RFbGVtZW50ID0gcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLCBwYXJlbnQudGFnTmFtZSk7XG4gICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgaXNEb2N1bWVudE9yRnJhZ21lbnQgPSByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbiAgdmFyIGRvYyA9IGlzRG9jdW1lbnRPckZyYWdtZW50ID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAvLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcbiAgLy8gcmVtb3ZlZC5cbiAgLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbiAgbm9kZS5vbmNsaWNrID0gZW1wdHlGdW5jdGlvbjtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgbmV4dFByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBmb3IgKHZhciBwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgbmV4dFByb3AsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIGluaXRpYWwgdGV4dENvbnRlbnQgd2hlbiB0aGUgdGV4dCBpcyBlbXB0eS4gSW4gSUUxMSBzZXR0aW5nXG4gICAgICAgIC8vIHRleHRDb250ZW50IG9uIGEgPHRleHRhcmVhPiB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIDx0ZXh0YXJlYT4gdW50aWwgaXQgaGFzIGJlZW4gZm9jdXNlZCBhbmQgYmx1cnJlZCBhZ2Fpbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82NzMxI2lzc3VlY29tbWVudC0yNTQ4NzQ1NTNcbiAgICAgICAgdmFyIGNhblNldFRleHRDb250ZW50ID0gdGFnICE9PSAndGV4dGFyZWEnIHx8IG5leHRQcm9wICE9PSAnJztcbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBXZSBwb2x5ZmlsbCBpdCBzZXBhcmF0ZWx5IG9uIHRoZSBjbGllbnQgZHVyaW5nIGNvbW1pdC5cbiAgICAgIC8vIFdlIGJsYWNrbGlzdCBpdCBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBwcm9wZXJ0eSBsaXN0IGJlY2F1c2Ugd2UgZW1pdCBpdCBpbiBTU1IuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBwcm9wVmFsdWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICBkZWxldGVWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50LCBwYXJlbnROYW1lc3BhY2UpIHtcbiAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICB2YXIgb3duZXJEb2N1bWVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIHZhciBkb21FbGVtZW50O1xuICB2YXIgbmFtZXNwYWNlVVJJID0gcGFyZW50TmFtZXNwYWNlO1xuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIHtcbiAgICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTtcbiAgICAgIC8vIFNob3VsZCB0aGlzIGNoZWNrIGJlIGdhdGVkIGJ5IHBhcmVudCBuYW1lc3BhY2U/IE5vdCBzdXJlIHdlIHdhbnQgdG9cbiAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgIHdhcm5pbmcoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgdHlwZSA9PT0gdHlwZS50b0xvd2VyQ2FzZSgpLCAnPCVzIC8+IGlzIHVzaW5nIHVwcGVyY2FzZSBIVE1MLiBBbHdheXMgdXNlIGxvd2VyY2FzZSBIVE1MIHRhZ3MgJyArICdpbiBSZWFjdC4nLCB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgIC8vIENyZWF0ZSB0aGUgc2NyaXB0IHZpYSAuaW5uZXJIVE1MIHNvIGl0cyBcInBhcnNlci1pbnNlcnRlZFwiIGZsYWcgaXNcbiAgICAgIC8vIHNldCB0byB0cnVlIGFuZCBpdCBkb2VzIG5vdCBleGVjdXRlXG4gICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwgeyBpczogcHJvcHMuaXMgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJyArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgKyAnYW4gdXBwZXJjYXNlIGxldHRlci4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUkMSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgdmFyIHByb3BzO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMsIGdldFN0YWNrKTtcblxuICBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5mdW5jdGlvbiBkaWZmUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICB2YXIgbGFzdFByb3BzO1xuICB2YXIgbmV4dFByb3BzO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsYXN0UHJvcHMgPSBsYXN0UmF3UHJvcHM7XG4gICAgICBuZXh0UHJvcHMgPSBuZXh0UmF3UHJvcHM7XG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHZhciBwcm9wS2V5O1xuICB2YXIgc3R5bGVOYW1lO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcbiAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBsYXN0UHJvcHNbcHJvcEtleV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgc3R5bGVzIHRoYXQgY2hhbmdlZCBzaW5jZSBgbGFzdFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSBuZXh0UHJvcFtzdHlsZU5hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcCA/IGxhc3RQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogSXQgbWlnaHQgYmUgdG9vIGxhdGUgdG8gY2xlYXIgdGhpcyBpZiB3ZSBoYXZlIGNoaWxkcmVuXG4gICAgICAgIC8vIGluc2VydGVkIGFscmVhZHkuXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKGxhc3RQcm9wICE9PSBuZXh0UHJvcCAmJiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSkge1xuICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIHdoaXRlbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2goU1RZTEUsIHN0eWxlVXBkYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbi8vIEFwcGx5IHRoZSBkaWZmLlxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdID09PSB0cnVlO1xuICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzLCBnZXRTdGFjayk7XG5cbiAge1xuICAgIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW2ldLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIHdoaXRlbGlzdGVkXG4gICAgICAgIGNhc2UgJ2RhdGEtcmVhY3Ryb290JzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBGb3IgdGV4dCBjb250ZW50IGNoaWxkcmVuIHdlIGNvbXBhcmUgYWdhaW5zdCB0ZXh0Q29udGVudC4gVGhpc1xuICAgICAgLy8gbWlnaHQgbWF0Y2ggYWRkaXRpb25hbCBIVE1MIHRoYXQgaXMgaGlkZGVuIHdoZW4gd2UgcmVhZCBpdCB1c2luZ1xuICAgICAgLy8gdGV4dENvbnRlbnQuIEUuZy4gXCJmb29cIiB3aWxsIG1hdGNoIFwiZjxzcGFuPm9vPC9zcGFuPlwiIGJ1dCB0aGF0IHN0aWxsXG4gICAgICAvLyBzYXRpc2ZpZXMgb3VyIHJlcXVpcmVtZW50LiBPdXIgcmVxdWlyZW1lbnQgaXMgbm90IHRvIHByb2R1Y2UgcGVyZmVjdFxuICAgICAgLy8gSFRNTCBhbmQgYXR0cmlidXRlcy4gSWRlYWxseSB3ZSBzaG91bGQgcHJlc2VydmUgc3RydWN0dXJlIGJ1dCBpdCdzXG4gICAgICAvLyBvayBub3QgdG8gaWYgdGhlIHZpc2libGUgY29udGVudCBpcyBzdGlsbCBlbm91Z2ggdG8gaW5kaWNhdGUgd2hhdFxuICAgICAgLy8gZXZlbiBsaXN0ZW5lcnMgdGhlc2Ugbm9kZXMgbWlnaHQgYmUgd2lyZWQgdXAgdG8uXG4gICAgICAvLyBUT0RPOiBXYXJuIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBhIHNpbmdsZSB0ZXh0Tm9kZSBhcyBhIGNoaWxkLlxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHVzZSBkb21FbGVtZW50LmZpcnN0Q2hpbGQubm9kZVZhbHVlIHRvIGNvbXBhcmU/XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICB2YXIgc2VydmVyVmFsdWU7XG4gICAgICB2YXIgcHJvcGVydHlJbmZvO1xuICAgICAgaWYgKHN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nLiBXZSdyZSBpZ25vcmluZyBhbGwgdGhlc2Ugd2FybmluZ3MuXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxIHx8XG4gICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICAgIHZhciByYXdIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSB8fCAnJyA6ICcnO1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCByYXdIdG1sKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkSFRNTCAhPT0gc2VydmVySFRNTCkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJIVE1MLCBleHBlY3RlZEhUTUwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgc2VydmVyVmFsdWUgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBleHBlY3RlZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRTZXRBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3ApKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSkpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgb3duTmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UodGV4dE5vZGUubm9kZVZhbHVlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLCBjaGlsZC5ub2RlVmFsdWUsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLCB0YWcsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUkMSxcblx0c2V0SW5pdGlhbFByb3BlcnRpZXM6IHNldEluaXRpYWxQcm9wZXJ0aWVzJDEsXG5cdGRpZmZQcm9wZXJ0aWVzOiBkaWZmUHJvcGVydGllcyQxLFxuXHR1cGRhdGVQcm9wZXJ0aWVzOiB1cGRhdGVQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkVGV4dDogZGlmZkh5ZHJhdGVkVGV4dCQxLFxuXHR3YXJuRm9yVW5tYXRjaGVkVGV4dDogd2FybkZvclVubWF0Y2hlZFRleHQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEsXG5cdHJlc3RvcmVDb250cm9sbGVkU3RhdGU6IHJlc3RvcmVDb250cm9sbGVkU3RhdGVcbn0pO1xuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxue1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8kMSA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIGNhc2UgJ2hyJzpcbiAgICAgIGNhc2UgJ3htcCc6XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvclRhZyA9IGludmFsaWRQYXJlbnRPckFuY2VzdG9yLnRhZztcbiAgICB2YXIgYWRkZW5kdW0gPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYoKTtcblxuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIGFkZGVuZHVtO1xuICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgfVxuICAgICAgd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBpbmZvLCBhZGRlbmR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBhZGRlbmR1bSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IHR1cm4gdGhpcyBpbnRvIGEgbmFtZWQgZXhwb3J0XG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyQxO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmckMSA9IHZhbGlkYXRlRE9NTmVzdGluZztcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG52YXIgY3JlYXRlVGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxO1xudmFyIHNldEluaXRpYWxQcm9wZXJ0aWVzID0gc2V0SW5pdGlhbFByb3BlcnRpZXMkMTtcbnZhciBkaWZmUHJvcGVydGllcyA9IGRpZmZQcm9wZXJ0aWVzJDE7XG52YXIgdXBkYXRlUHJvcGVydGllcyA9IHVwZGF0ZVByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzID0gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFRleHQgPSBkaWZmSHlkcmF0ZWRUZXh0JDE7XG52YXIgd2FybkZvclVubWF0Y2hlZFRleHQgPSB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMTtcbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nJDEudXBkYXRlZEFuY2VzdG9ySW5mbztcbnZhciBwcmVjYWNoZUZpYmVyTm9kZSA9IHByZWNhY2hlRmliZXJOb2RlJDE7XG52YXIgdXBkYXRlRmliZXJQcm9wcyA9IHVwZGF0ZUZpYmVyUHJvcHMkMTtcblxuXG57XG4gIHZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbmluamVjdGlvbiQzLmluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQoUmVhY3RET01GaWJlckNvbXBvbmVudCk7XG5cbnZhciBldmVudHNFbmFibGVkID0gbnVsbDtcbnZhciBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBET01SZW5kZXJlciA9IHJlYWN0UmVjb25jaWxlcih7XG4gIGdldFJvb3RIb3N0Q29udGV4dDogZnVuY3Rpb24gKHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHZhciB0eXBlID0gdm9pZCAwO1xuICAgIHZhciBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgdmFyIG5vZGVUeXBlID0gcm9vdENvbnRhaW5lckluc3RhbmNlLm5vZGVUeXBlO1xuICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgICAge1xuICAgICAgICAgIHR5cGUgPSBub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/ICcjZG9jdW1lbnQnIDogJyNmcmFnbWVudCc7XG4gICAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckluc3RhbmNlLnBhcmVudE5vZGUgOiByb290Q29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICAgICAgbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2Uob3duTmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZywgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiBuYW1lc3BhY2U7XG4gIH0sXG4gIGdldENoaWxkSG9zdENvbnRleHQ6IGZ1bmN0aW9uIChwYXJlbnRIb3N0Q29udGV4dCwgdHlwZSkge1xuICAgIHtcbiAgICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgICAgdmFyIF9uYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8yID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRIb3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBfbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8yIH07XG4gICAgfVxuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICByZXR1cm4gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKTtcbiAgfSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSxcbiAgcHJlcGFyZUZvckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50c0VuYWJsZWQgPSBpc0VuYWJsZWQoKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gICAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIH0sXG4gIHJlc2V0QWZ0ZXJDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG4gICAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgICBldmVudHNFbmFibGVkID0gbnVsbDtcbiAgfSxcbiAgY3JlYXRlSW5zdGFuY2U6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAge1xuICAgICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICB9XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgZG9tRWxlbWVudCk7XG4gICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgcmV0dXJuIGRvbUVsZW1lbnQ7XG4gIH0sXG4gIGFwcGVuZEluaXRpYWxDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfSxcbiAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xuICB9LFxuICBwcmVwYXJlVXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICBpZiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuICE9PSB0eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4gJiYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgfSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiB0eXBlID09PSAndGV4dGFyZWEnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgPT09ICdzdHJpbmcnO1xuICB9LFxuICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gISFwcm9wcy5oaWRkZW47XG4gIH0sXG4gIGNyZWF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB7XG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHRleHQsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgfVxuICAgIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgfSxcblxuXG4gIG5vdzogbm93LFxuXG4gIG11dGF0aW9uOiB7XG4gICAgY29tbWl0TW91bnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgZG9tRWxlbWVudC5mb2N1cygpO1xuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgICAgIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgbmV3UHJvcHMpO1xuICAgICAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxuICAgICAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIH0sXG4gICAgcmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQpIHtcbiAgICAgIGRvbUVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICB9LFxuICAgIGNvbW1pdFRleHRVcGRhdGU6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSBuZXdUZXh0O1xuICAgIH0sXG4gICAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkVG9Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmU6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoeWRyYXRpb246IHtcbiAgICBjYW5IeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8IHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sXG4gICAgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodGV4dCA9PT0gJycgfHwgaW5zdGFuY2Uubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9LFxuICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZzogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICB2YXIgbm9kZSA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgICAgIHdoaWxlIChub2RlICYmIG5vZGUubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBub2RlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UpIHtcbiAgICAgIHZhciBuZXh0ID0gcGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZDtcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobmV4dCAmJiBuZXh0Lm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbmV4dC5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcbiAgICBoeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTtcbiAgICAgIC8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuICAgICAgLy8gZ2V0IGF0dGFjaGVkLlxuICAgICAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIH0sXG4gICAgaHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOiBySUMsXG4gIGNhbmNlbERlZmVycmVkQ2FsbGJhY2s6IGNJQyxcblxuICB1c2VTeW5jU2NoZWR1bGluZzogIWVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET01cbn0pO1xuXG5pbmplY3Rpb24kNC5pbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzKERPTVJlbmRlcmVyLmJhdGNoZWRVcGRhdGVzKTtcblxudmFyIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IGZhbHNlO1xuXG5mdW5jdGlvbiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjb250YWluZXIsIGZvcmNlSHlkcmF0ZSwgY2FsbGJhY2spIHtcbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLmN1cnJlbnQpO1xuICAgICAgaWYgKGhvc3RJbnN0YW5jZSkge1xuICAgICAgICB3YXJuaW5nKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlID09PSBjb250YWluZXIsICdyZW5kZXIoLi4uKTogSXQgbG9va3MgbGlrZSB0aGUgUmVhY3QtcmVuZGVyZWQgY29udGVudCBvZiB0aGlzICcgKyAnY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgJ1JlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUgdG8gZW1wdHkgYSBjb250YWluZXIuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCkpO1xuXG4gICAgd2FybmluZyghaGFzTm9uUm9vdFJlYWN0Q2hpbGQgfHwgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgaWYgKCFyb290KSB7XG4gICAgdmFyIHNob3VsZEh5ZHJhdGUgPSBmb3JjZUh5ZHJhdGUgfHwgc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcik7XG4gICAgLy8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgICB2YXIgcm9vdFNpYmxpbmcgPSB2b2lkIDA7XG4gICAgICB3aGlsZSAocm9vdFNpYmxpbmcgPSBjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXdhcm5lZCAmJiByb290U2libGluZy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RTaWJsaW5nLmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdyZW5kZXIoKTogVGFyZ2V0IG5vZGUgaGFzIG1hcmt1cCByZW5kZXJlZCBieSBSZWFjdCwgYnV0IHRoZXJlICcgKyAnYXJlIHVucmVsYXRlZCBub2RlcyBhcyB3ZWxsLiBUaGlzIGlzIG1vc3QgY29tbW9ubHkgY2F1c2VkIGJ5ICcgKyAnd2hpdGUtc3BhY2UgaW5zZXJ0ZWQgYXJvdW5kIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChzaG91bGRIeWRyYXRlICYmICFmb3JjZUh5ZHJhdGUgJiYgIXdhcm5lZEFib3V0SHlkcmF0ZUFQSSkge1xuICAgICAgICB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSB0cnVlO1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxNy4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBuZXdSb290ID0gRE9NUmVuZGVyZXIuY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgc2hvdWxkSHlkcmF0ZSk7XG4gICAgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbmV3Um9vdDtcbiAgICAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgbmV3Um9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gRE9NUmVuZGVyZXIuZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuICAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn1cblxuZnVuY3Rpb24gUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSkge1xuICB2YXIgcm9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIGh5ZHJhdGUpO1xuICB0aGlzLl9yZWFjdFJvb3RDb250YWluZXIgPSByb290O1xufVxuUmVhY3RSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihudWxsLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuXG52YXIgUmVhY3RET00gPSB7XG4gIGNyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIGZpbmRET01Ob2RlOiBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gICAge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyO1xuICAgICAgICB3YXJuaW5nKHdhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgICAgb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgaW5zdCA9IGdldChjb21wb25lbnRPckVsZW1lbnQpO1xuICAgIGlmIChpbnN0KSB7XG4gICAgICByZXR1cm4gRE9NUmVuZGVyZXIuZmluZEhvc3RJbnN0YW5jZShpbnN0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUuIEtleXM6ICVzJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSk7XG4gICAgfVxuICB9LFxuICBoeWRyYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKTtcbiAgICAgICAgd2FybmluZyghcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0LCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICAvLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICAgIERPTVJlbmRlcmVyLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAgIC8vIGdldCBgdHJ1ZWAgdHdpY2UuIFRoYXQncyBwcm9iYWJseSBmaW5lP1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIF9yb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEoX3Jvb3RFbCAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEoX3Jvb3RFbCkpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IDEgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gVGVtcG9yYXJ5IGFsaWFzIHNpbmNlIHdlIGFscmVhZHkgc2hpcHBlZCBSZWFjdCAxNiBSQyB3aXRoIGl0LlxuICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuXG4gIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsLFxuXG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcblxuICB1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6IERPTVJlbmRlcmVyLmRlZmVycmVkVXBkYXRlcyxcblxuICBmbHVzaFN5bmM6IERPTVJlbmRlcmVyLmZsdXNoU3luYyxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEZvciBUYXBFdmVudFBsdWdpbiB3aGljaCBpcyBwb3B1bGFyIGluIG9wZW4gc291cmNlXG4gICAgRXZlbnRQbHVnaW5IdWI6IEV2ZW50UGx1Z2luSHViLFxuICAgIC8vIFVzZWQgYnkgdGVzdC11dGlsc1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50UGx1Z2luUmVnaXN0cnksXG4gICAgRXZlbnRQcm9wYWdhdG9yczogRXZlbnRQcm9wYWdhdG9ycyxcbiAgICBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCxcbiAgICBSZWFjdERPTUNvbXBvbmVudFRyZWU6IFJlYWN0RE9NQ29tcG9uZW50VHJlZSxcbiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXI6IFJlYWN0RE9NRXZlbnRMaXN0ZW5lclxuICB9XG59O1xuXG5pZiAoZW5hYmxlQ3JlYXRlUm9vdCkge1xuICBSZWFjdERPTS5jcmVhdGVSb290ID0gZnVuY3Rpb24gY3JlYXRlUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICB2YXIgaHlkcmF0ZSA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGUgPT09IHRydWU7XG4gICAgcmV0dXJuIG5ldyBSZWFjdFJvb3QoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgfTtcbn1cblxudmFyIGZvdW5kRGV2VG9vbHMgPSBET01SZW5kZXJlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgUmVhY3RET00kMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVxufSk7XG5cbnZhciBSZWFjdERPTSQzID0gKCBSZWFjdERPTSQyICYmIFJlYWN0RE9NICkgfHwgUmVhY3RET00kMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3REb20gPSBSZWFjdERPTSQzWydkZWZhdWx0J10gPyBSZWFjdERPTSQzWydkZWZhdWx0J10gOiBSZWFjdERPTSQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0RG9tO1xuICB9KSgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tICdoaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmltcG9ydCBSb3V0ZXIgZnJvbSAnLi9Sb3V0ZXInO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBhIDxSb3V0ZXI+IHRoYXQgdXNlcyBIVE1MNSBoaXN0b3J5LlxuICovXG5cbnZhciBCcm93c2VyUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEJyb3dzZXJSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCcm93c2VyUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgQnJvd3NlclJvdXRlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHdhcm5pbmcoIXRoaXMucHJvcHMuaGlzdG9yeSwgJzxCcm93c2VyUm91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIEJyb3dzZXJSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHsgaGlzdG9yeTogdGhpcy5oaXN0b3J5LCBjaGlsZHJlbjogdGhpcy5wcm9wcy5jaGlsZHJlbiB9KTtcbiAgfTtcblxuICByZXR1cm4gQnJvd3NlclJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuQnJvd3NlclJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBmb3JjZVJlZnJlc2g6IFByb3BUeXBlcy5ib29sLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgQnJvd3NlclJvdXRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Ccm93c2VyUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJyxcbiAgICAgICAgICAgICAgcHJvcEZ1bGxOYW1lLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBnZXRIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGluY2x1ZGluZ1xuICogcHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQuXG4gKi9cbnZhciBjcmVhdGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShfRE9NVXRpbHMuY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSAoMCwgX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gISgwLCBfRE9NVXRpbHMuc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSkoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBfRE9NVXRpbHMuZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoIWJhc2VuYW1lIHx8ICgwLCBfUGF0aFV0aWxzLmhhc0Jhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gKDAsIF9QYXRoVXRpbHMuc3RyaXBCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmICgoMCwgX0RPTVV0aWxzLmlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQpKGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeS5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNyZWF0ZUhpc3RvcnkgZnJvbSAnaGlzdG9yeS9jcmVhdGVIYXNoSGlzdG9yeSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHVzZXMgd2luZG93LmxvY2F0aW9uLmhhc2guXG4gKi9cblxudmFyIEhhc2hSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoSGFzaFJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gSGFzaFJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhhc2hSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBIYXNoUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPEhhc2hSb3V0ZXI+IGlnbm9yZXMgdGhlIGhpc3RvcnkgcHJvcC4gVG8gdXNlIGEgY3VzdG9tIGhpc3RvcnksICcgKyAndXNlIGBpbXBvcnQgeyBSb3V0ZXIgfWAgaW5zdGVhZCBvZiBgaW1wb3J0IHsgSGFzaFJvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBIYXNoUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5IYXNoUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBoYXNoVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnaGFzaGJhbmcnLCAnbm9zbGFzaCcsICdzbGFzaCddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEhhc2hSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyAoMCwgX1BhdGhVdGlscy5zdHJpcExlYWRpbmdTbGFzaCkocGF0aCk7XG4gICAgfSxcbiAgICBkZWNvZGVQYXRoOiBmdW5jdGlvbiBkZWNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xuICAgIH1cbiAgfSxcbiAgbm9zbGFzaDoge1xuICAgIGVuY29kZVBhdGg6IF9QYXRoVXRpbHMuc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBfUGF0aFV0aWxzLmFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKF9ET01VdGlscy5jYW5Vc2VET00sICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuR29XaXRob3V0UmVsb2FkID0gKDAsIF9ET01VdGlscy5zdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCkoKTtcblxuICB2YXIgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IF9ET01VdGlscy5nZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBwcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB1bmRlZmluZWQgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgX0hhc2hQYXRoQ29kZXJzJGhhc2hUID0gSGFzaFBhdGhDb2RlcnNbaGFzaFR5cGVdLFxuICAgICAgZW5jb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5lbmNvZGVQYXRoLFxuICAgICAgZGVjb2RlUGF0aCA9IF9IYXNoUGF0aENvZGVycyRoYXNoVC5kZWNvZGVQYXRoO1xuXG5cbiAgdmFyIGdldERPTUxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RE9NTG9jYXRpb24oKSB7XG4gICAgdmFyIHBhdGggPSBkZWNvZGVQYXRoKGdldEhhc2hQYXRoKCkpO1xuXG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghYmFzZW5hbWUgfHwgKDAsIF9QYXRoVXRpbHMuaGFzQmFzZW5hbWUpKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSAoMCwgX1BhdGhVdGlscy5zdHJpcEJhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgKDAsIF9Mb2NhdGlvblV0aWxzLmxvY2F0aW9uc0FyZUVxdWFsKShwcmV2TG9jYXRpb24sIGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBBIGhhc2hjaGFuZ2UgZG9lc24ndCBhbHdheXMgPT0gbG9jYXRpb24gY2hhbmdlLlxuXG4gICAgICBpZiAoaWdub3JlUGF0aCA9PT0gKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoZnJvbUxvY2F0aW9uKSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgaGFzaCBpcyBlbmNvZGVkIHByb3Blcmx5IGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLlxuICB2YXIgcGF0aCA9IGdldEhhc2hQYXRoKCk7XG4gIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICB2YXIgYWxsUGF0aHMgPSBbKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoaW5pdGlhbExvY2F0aW9uKV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG4gICAgICAgIHZhciBuZXh0UGF0aHMgPSBhbGxQYXRocy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgIG5leHRQYXRocy5wdXNoKHBhdGgpO1xuICAgICAgICBhbGxQYXRocyA9IG5leHRQYXRocztcblxuICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBQVVNIIHRoZSBzYW1lIHBhdGg7IGEgbmV3IGVudHJ5IHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrJyk7XG5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBSRVBMQUNFLCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMuaW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShoaXN0b3J5LmxvY2F0aW9uKSk7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpO1xuXG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSGFzaEhpc3Rvcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlSGFzaEhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgTWVtb3J5Um91dGVyIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9NZW1vcnlSb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBNZW1vcnlSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTWVtb3J5Um91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tICdoaXN0b3J5L2NyZWF0ZU1lbW9yeUhpc3RvcnknO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCBzdG9yZXMgbG9jYXRpb24gaW4gbWVtb3J5LlxuICovXG5cbnZhciBNZW1vcnlSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoTWVtb3J5Um91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBNZW1vcnlSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZW1vcnlSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBNZW1vcnlSb3V0ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICB3YXJuaW5nKCF0aGlzLnByb3BzLmhpc3RvcnksICc8TWVtb3J5Um91dGVyPiBpZ25vcmVzIHRoZSBoaXN0b3J5IHByb3AuIFRvIHVzZSBhIGN1c3RvbSBoaXN0b3J5LCAnICsgJ3VzZSBgaW1wb3J0IHsgUm91dGVyIH1gIGluc3RlYWQgb2YgYGltcG9ydCB7IE1lbW9yeVJvdXRlciBhcyBSb3V0ZXIgfWAuJyk7XG4gIH07XG5cbiAgTWVtb3J5Um91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1lbW9yeVJvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuTWVtb3J5Um91dGVyLnByb3BUeXBlcyA9IHtcbiAgaW5pdGlhbEVudHJpZXM6IFByb3BUeXBlcy5hcnJheSxcbiAgaW5pdGlhbEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICBnZXRVc2VyQ29uZmlybWF0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAga2V5TGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgTWVtb3J5Um91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvTWVtb3J5Um91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IHByb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHVuZGVmaW5lZCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IHByb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikoZW50cnksIHVuZGVmaW5lZCwgY3JlYXRlS2V5KCkpIDogKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBfUGF0aFV0aWxzLmNyZWF0ZVBhdGg7XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldkluZGV4ID0gaGlzdG9yeS5pbmRleDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBwcmV2SW5kZXggKyAxO1xuXG4gICAgICB2YXIgbmV4dEVudHJpZXMgPSBoaXN0b3J5LmVudHJpZXMuc2xpY2UoMCk7XG4gICAgICBpZiAobmV4dEVudHJpZXMubGVuZ3RoID4gbmV4dEluZGV4KSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnNwbGljZShuZXh0SW5kZXgsIG5leHRFbnRyaWVzLmxlbmd0aCAtIG5leHRJbmRleCwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEVudHJpZXMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgZW50cmllczogbmV4dEVudHJpZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSb3V0ZSBmcm9tICcuL1JvdXRlJztcbmltcG9ydCBMaW5rIGZyb20gJy4vTGluayc7XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbnZhciBOYXZMaW5rID0gZnVuY3Rpb24gTmF2TGluayhfcmVmKSB7XG4gIHZhciB0byA9IF9yZWYudG8sXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBnZXRJc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICBhcmlhQ3VycmVudCA9IF9yZWYuYXJpYUN1cnJlbnQsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG8nLCAnZXhhY3QnLCAnc3RyaWN0JywgJ2xvY2F0aW9uJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdjbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnc3R5bGUnLCAnaXNBY3RpdmUnLCAnYXJpYUN1cnJlbnQnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtcbiAgICBwYXRoOiAodHlwZW9mIHRvID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0bykpID09PSAnb2JqZWN0JyA/IHRvLnBhdGhuYW1lIDogdG8sXG4gICAgZXhhY3Q6IGV4YWN0LFxuICAgIHN0cmljdDogc3RyaWN0LFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oX3JlZjIpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF9yZWYyLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoID0gX3JlZjIubWF0Y2g7XG5cbiAgICAgIHZhciBpc0FjdGl2ZSA9ICEhKGdldElzQWN0aXZlID8gZ2V0SXNBY3RpdmUobWF0Y2gsIGxvY2F0aW9uKSA6IG1hdGNoKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe1xuICAgICAgICB0bzogdG8sXG4gICAgICAgIGNsYXNzTmFtZTogaXNBY3RpdmUgPyBbY2xhc3NOYW1lLCBhY3RpdmVDbGFzc05hbWVdLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KS5qb2luKCcgJykgOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBpc0FjdGl2ZSA/IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpIDogc3R5bGUsXG4gICAgICAgICdhcmlhLWN1cnJlbnQnOiBpc0FjdGl2ZSAmJiBhcmlhQ3VycmVudFxuICAgICAgfSwgcmVzdCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5OYXZMaW5rLnByb3BUeXBlcyA9IHtcbiAgdG86IExpbmsucHJvcFR5cGVzLnRvLFxuICBleGFjdDogUHJvcFR5cGVzLmJvb2wsXG4gIHN0cmljdDogUHJvcFR5cGVzLmJvb2wsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICBhY3RpdmVDbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgYWN0aXZlU3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBpc0FjdGl2ZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGFyaWFDdXJyZW50OiBQcm9wVHlwZXMub25lT2YoWydwYWdlJywgJ3N0ZXAnLCAnbG9jYXRpb24nLCAndHJ1ZSddKVxufTtcblxuTmF2TGluay5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZScsXG4gIGFyaWFDdXJyZW50OiAndHJ1ZSdcbn07XG5cbmV4cG9ydCBkZWZhdWx0IE5hdkxpbms7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvTmF2TGluay5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGlzYXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG5tb2R1bGUuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZVxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW11cbiAgdmFyIGtleSA9IDBcbiAgdmFyIGluZGV4ID0gMFxuICB2YXIgcGF0aCA9ICcnXG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLydcbiAgdmFyIHJlc1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF1cbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXVxuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXhcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGhcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdXG4gICAgdmFyIHByZWZpeCA9IHJlc1syXVxuICAgIHZhciBuYW1lID0gcmVzWzNdXG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF1cbiAgICB2YXIgZ3JvdXAgPSByZXNbNV1cbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl1cbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN11cblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gICAgICBwYXRoID0gJydcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXhcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyXG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwXG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pXG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpXG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aClcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJ1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW5cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdXG4gICAgICB2YXIgc2VnbWVudFxuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXhcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzYXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pXG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpXG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5c1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZylcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKVxuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2VcbiAgdmFyIHJvdXRlID0gJydcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpXG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJ1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pXG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonXG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPydcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSdcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKVxuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlclxuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nXG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnXG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJ1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9wYXRoLXRvLXJlZ2V4cC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgUHJvbXB0IGZyb20gJ3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQnO1xuXG5leHBvcnQgZGVmYXVsdCBQcm9tcHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUHJvbXB0LmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwcm9tcHRpbmcgdGhlIHVzZXIgYmVmb3JlIG5hdmlnYXRpbmcgYXdheVxuICogZnJvbSBhIHNjcmVlbiB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbnZhciBQcm9tcHQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUHJvbXB0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQcm9tcHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb21wdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFByb21wdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB0aGlzLnVuYmxvY2soKTtcblxuICAgIHRoaXMudW5ibG9jayA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeS5ibG9jayhtZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLnVuYmxvY2spIHtcbiAgICAgIHRoaXMudW5ibG9jaygpO1xuICAgICAgdGhpcy51bmJsb2NrID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFByb21wdD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG5cbiAgICBpZiAodGhpcy5wcm9wcy53aGVuKSB0aGlzLmVuYWJsZSh0aGlzLnByb3BzLm1lc3NhZ2UpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy53aGVuKSB7XG4gICAgICBpZiAoIXRoaXMucHJvcHMud2hlbiB8fCB0aGlzLnByb3BzLm1lc3NhZ2UgIT09IG5leHRQcm9wcy5tZXNzYWdlKSB0aGlzLmVuYWJsZShuZXh0UHJvcHMubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgIH1cbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5kaXNhYmxlKCk7XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFByb21wdDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUHJvbXB0LnByb3BUeXBlcyA9IHtcbiAgd2hlbjogUHJvcFR5cGVzLmJvb2wsXG4gIG1lc3NhZ2U6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSkuaXNSZXF1aXJlZFxufTtcblByb21wdC5kZWZhdWx0UHJvcHMgPSB7XG4gIHdoZW46IHRydWVcbn07XG5Qcm9tcHQuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGJsb2NrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFByb21wdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1Byb21wdC5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gV3JpdHRlbiBpbiB0aGlzIHJvdW5kIGFib3V0IHdheSBmb3IgYmFiZWwtdHJhbnNmb3JtLWltcG9ydHNcbmltcG9ydCBSZWRpcmVjdCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QnO1xuXG5leHBvcnQgZGVmYXVsdCBSZWRpcmVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9SZWRpcmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsIH0gZnJvbSAnaGlzdG9yeSc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHVwZGF0aW5nIHRoZSBsb2NhdGlvbiBwcm9ncmFtbWF0aWNhbGx5XG4gKiB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbnZhciBSZWRpcmVjdCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSZWRpcmVjdCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUmVkaXJlY3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZGlyZWN0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmlzU3RhdGljID0gZnVuY3Rpb24gaXNTdGF0aWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5yb3V0ZXIgJiYgdGhpcy5jb250ZXh0LnJvdXRlci5zdGF0aWNDb250ZXh0O1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJlZGlyZWN0PiBvdXRzaWRlIGEgPFJvdXRlcj4nKTtcblxuICAgIGlmICh0aGlzLmlzU3RhdGljKCkpIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICghdGhpcy5pc1N0YXRpYygpKSB0aGlzLnBlcmZvcm0oKTtcbiAgfTtcblxuICBSZWRpcmVjdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgIHZhciBwcmV2VG8gPSBjcmVhdGVMb2NhdGlvbihwcmV2UHJvcHMudG8pO1xuICAgIHZhciBuZXh0VG8gPSBjcmVhdGVMb2NhdGlvbih0aGlzLnByb3BzLnRvKTtcblxuICAgIGlmIChsb2NhdGlvbnNBcmVFcXVhbChwcmV2VG8sIG5leHRUbykpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdZb3UgdHJpZWQgdG8gcmVkaXJlY3QgdG8gdGhlIHNhbWUgcm91dGUgeW91XFwncmUgY3VycmVudGx5IG9uOiAnICsgKCdcIicgKyBuZXh0VG8ucGF0aG5hbWUgKyBuZXh0VG8uc2VhcmNoICsgJ1wiJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gcGVyZm9ybSgpIHtcbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcHVzaCA9IF9wcm9wcy5wdXNoLFxuICAgICAgICB0byA9IF9wcm9wcy50bztcblxuXG4gICAgaWYgKHB1c2gpIHtcbiAgICAgIGhpc3RvcnkucHVzaCh0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZSh0byk7XG4gICAgfVxuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJlZGlyZWN0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZWRpcmVjdC5wcm9wVHlwZXMgPSB7XG4gIHB1c2g6IFByb3BUeXBlcy5ib29sLFxuICBmcm9tOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0bzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pLmlzUmVxdWlyZWRcbn07XG5SZWRpcmVjdC5kZWZhdWx0UHJvcHMgPSB7XG4gIHB1c2g6IGZhbHNlXG59O1xuUmVkaXJlY3QuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHB1c2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByZXBsYWNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gICAgfSkuaXNSZXF1aXJlZCxcbiAgICBzdGF0aWNDb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0XG4gIH0pLmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUmVkaXJlY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9SZWRpcmVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IF9jcmVhdGVCcm93c2VySGlzdG9yeSBmcm9tICcuL2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVCcm93c2VySGlzdG9yeSBhcyBjcmVhdGVCcm93c2VySGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVIYXNoSGlzdG9yeSBmcm9tICcuL2NyZWF0ZUhhc2hIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVIYXNoSGlzdG9yeSBhcyBjcmVhdGVIYXNoSGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGZyb20gJy4vY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVNZW1vcnlIaXN0b3J5IH07XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5leHBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIHN0cmlwVHJhaWxpbmdTbGFzaCwgaGFzQmFzZW5hbWUsIHN0cmlwQmFzZW5hbWUsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5pbXBvcnQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBjYW5Vc2VET00sIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGdldENvbmZpcm1hdGlvbiwgc3VwcG9ydHNIaXN0b3J5LCBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlLCBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50IH0gZnJvbSAnLi9ET01VdGlscyc7XG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBnZXRIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGluY2x1ZGluZ1xuICogcHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQuXG4gKi9cbnZhciBjcmVhdGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGludmFyaWFudChjYW5Vc2VET00sICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuVXNlSGlzdG9yeSA9IHN1cHBvcnRzSGlzdG9yeSgpO1xuICB2YXIgbmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIgPSAhc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpO1xuXG4gIHZhciBfcHJvcHMkZm9yY2VSZWZyZXNoID0gcHJvcHMuZm9yY2VSZWZyZXNoLFxuICAgICAgZm9yY2VSZWZyZXNoID0gX3Byb3BzJGZvcmNlUmVmcmVzaCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcHJvcHMkZm9yY2VSZWZyZXNoLFxuICAgICAgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IGdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHZhciBfcmVmID0gaGlzdG9yeVN0YXRlIHx8IHt9LFxuICAgICAgICBrZXkgPSBfcmVmLmtleSxcbiAgICAgICAgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gICAgdmFyIF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgIHBhdGhuYW1lID0gX3dpbmRvdyRsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoID0gX3dpbmRvdyRsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc2ggPSBfd2luZG93JGxvY2F0aW9uLmhhc2g7XG5cblxuICAgIHZhciBwYXRoID0gcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuXG4gICAgd2FybmluZyghYmFzZW5hbWUgfHwgaGFzQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9IHN0cmlwQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXkpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb3BTdGF0ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvcFN0YXRlKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cbiAgICBpZiAoaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkpIHJldHVybjtcblxuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIGtleXMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsS2V5cy5pbmRleE9mKHRvTG9jYXRpb24ua2V5KTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGZyb21Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpO1xuICB2YXIgYWxsS2V5cyA9IFtpbml0aWFsTG9jYXRpb24ua2V5XTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcbiAgICAgICAgICB2YXIgbmV4dEtleXMgPSBhbGxLZXlzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgICBuZXh0S2V5cy5wdXNoKGxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgYWxsS2V5cyA9IG5leHRLZXlzO1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcblxuICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxLZXlzW3ByZXZJbmRleF0gPSBsb2NhdGlvbi5rZXk7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJyb3dzZXJIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIHN0cmlwTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoIH0gZnJvbSAnLi9ET01VdGlscyc7XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyBzdHJpcExlYWRpbmdTbGFzaChwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuXG4gIHZhciBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdW5kZWZpbmVkID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmIGxvY2F0aW9uc0FyZUVxdWFsKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcblxuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChmcm9tTG9jYXRpb24pKTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFtjcmVhdGVQYXRoKGluaXRpYWxMb2NhdGlvbildO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuXG4gICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKTtcblxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuXG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgd2FybmluZyhjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKTtcblxuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUhhc2hIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUhhc2hIaXN0b3J5LmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IHsgY3JlYXRlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciBmcm9tICcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJztcblxudmFyIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAobiwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCBzdG9yZXMgbG9jYXRpb25zIGluIG1lbW9yeS5cbiAqL1xudmFyIGNyZWF0ZU1lbW9yeUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPSBwcm9wcy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxFbnRyaWVzID0gX3Byb3BzJGluaXRpYWxFbnRyaWVzID09PSB1bmRlZmluZWQgPyBbJy8nXSA6IF9wcm9wcyRpbml0aWFsRW50cmllcyxcbiAgICAgIF9wcm9wcyRpbml0aWFsSW5kZXggPSBwcm9wcy5pbml0aWFsSW5kZXgsXG4gICAgICBpbml0aWFsSW5kZXggPSBfcHJvcHMkaW5pdGlhbEluZGV4ID09PSB1bmRlZmluZWQgPyAwIDogX3Byb3BzJGluaXRpYWxJbmRleCxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGluZGV4ID0gY2xhbXAoaW5pdGlhbEluZGV4LCAwLCBpbml0aWFsRW50cmllcy5sZW5ndGggLSAxKTtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiBjcmVhdGVMb2NhdGlvbihlbnRyeSwgdW5kZWZpbmVkLCBlbnRyeS5rZXkgfHwgY3JlYXRlS2V5KCkpO1xuICB9KTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBjcmVhdGVQYXRoO1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgaGlzdG9yeS5lbnRyaWVzW2hpc3RvcnkuaW5kZXhdID0gbG9jYXRpb247XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGNsYW1wKGhpc3RvcnkuaW5kZXggKyBuLCAwLCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoIC0gMSk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG4gICAgdmFyIGxvY2F0aW9uID0gaGlzdG9yeS5lbnRyaWVzW25leHRJbmRleF07XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgaW5kZXg6IG5leHRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1pbWljIHRoZSBiZWhhdmlvciBvZiBET00gaGlzdG9yaWVzIGJ5XG4gICAgICAgIC8vIGNhdXNpbmcgYSByZW5kZXIgYWZ0ZXIgYSBjYW5jZWxsZWQgUE9QLlxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnb0JhY2sgPSBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgcmV0dXJuIGdvKC0xKTtcbiAgfTtcblxuICB2YXIgZ29Gb3J3YXJkID0gZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIHJldHVybiBnbygxKTtcbiAgfTtcblxuICB2YXIgY2FuR28gPSBmdW5jdGlvbiBjYW5HbyhuKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGhpc3RvcnkuaW5kZXggKyBuO1xuICAgIHJldHVybiBuZXh0SW5kZXggPj0gMCAmJiBuZXh0SW5kZXggPCBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGVudHJpZXMubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGVudHJpZXNbaW5kZXhdLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBlbnRyaWVzOiBlbnRyaWVzLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBjYW5HbzogY2FuR28sXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgU3RhdGljUm91dGVyIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9TdGF0aWNSb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCBTdGF0aWNSb3V0ZXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvU3RhdGljUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgY3JlYXRlUGF0aCwgcGFyc2VQYXRoIH0gZnJvbSAnaGlzdG9yeS9QYXRoVXRpbHMnO1xuaW1wb3J0IFJvdXRlciBmcm9tICcuL1JvdXRlcic7XG5cbnZhciBub3JtYWxpemVMb2NhdGlvbiA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uKG9iamVjdCkge1xuICB2YXIgX29iamVjdCRwYXRobmFtZSA9IG9iamVjdC5wYXRobmFtZSxcbiAgICAgIHBhdGhuYW1lID0gX29iamVjdCRwYXRobmFtZSA9PT0gdW5kZWZpbmVkID8gJy8nIDogX29iamVjdCRwYXRobmFtZSxcbiAgICAgIF9vYmplY3Qkc2VhcmNoID0gb2JqZWN0LnNlYXJjaCxcbiAgICAgIHNlYXJjaCA9IF9vYmplY3Qkc2VhcmNoID09PSB1bmRlZmluZWQgPyAnJyA6IF9vYmplY3Qkc2VhcmNoLFxuICAgICAgX29iamVjdCRoYXNoID0gb2JqZWN0Lmhhc2gsXG4gICAgICBoYXNoID0gX29iamVjdCRoYXNoID09PSB1bmRlZmluZWQgPyAnJyA6IF9vYmplY3QkaGFzaDtcblxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbnZhciBhZGRCYXNlbmFtZSA9IGZ1bmN0aW9uIGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBsb2NhdGlvbikge1xuICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgIHBhdGhuYW1lOiBhZGRMZWFkaW5nU2xhc2goYmFzZW5hbWUpICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgfSk7XG59O1xuXG52YXIgc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICB2YXIgYmFzZSA9IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSk7XG5cbiAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmluZGV4T2YoYmFzZSkgIT09IDApIHJldHVybiBsb2NhdGlvbjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLnN1YnN0cihiYXNlLmxlbmd0aClcbiAgfSk7XG59O1xuXG52YXIgY3JlYXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGxvY2F0aW9uID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aChsb2NhdGlvbikgOiBub3JtYWxpemVMb2NhdGlvbihsb2NhdGlvbik7XG59O1xuXG52YXIgY3JlYXRlVVJMID0gZnVuY3Rpb24gY3JlYXRlVVJMKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gbG9jYXRpb24gOiBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbn07XG5cbnZhciBzdGF0aWNIYW5kbGVyID0gZnVuY3Rpb24gc3RhdGljSGFuZGxlcihtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnWW91IGNhbm5vdCAlcyB3aXRoIDxTdGF0aWNSb3V0ZXI+JywgbWV0aG9kTmFtZSk7XG4gIH07XG59O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuLyoqXG4gKiBUaGUgcHVibGljIHRvcC1sZXZlbCBBUEkgZm9yIGEgXCJzdGF0aWNcIiA8Um91dGVyPiwgc28tY2FsbGVkIGJlY2F1c2UgaXRcbiAqIGNhbid0IGFjdHVhbGx5IGNoYW5nZSB0aGUgY3VycmVudCBsb2NhdGlvbi4gSW5zdGVhZCwgaXQganVzdCByZWNvcmRzXG4gKiBsb2NhdGlvbiBjaGFuZ2VzIGluIGEgY29udGV4dCBvYmplY3QuIFVzZWZ1bCBtYWlubHkgaW4gdGVzdGluZyBhbmRcbiAqIHNlcnZlci1yZW5kZXJpbmcgc2NlbmFyaW9zLlxuICovXG5cbnZhciBTdGF0aWNSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3RhdGljUm91dGVyLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdGF0aWNSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGF0aWNSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmNyZWF0ZUhyZWYgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgcmV0dXJuIGFkZExlYWRpbmdTbGFzaChfdGhpcy5wcm9wcy5iYXNlbmFtZSArIGNyZWF0ZVVSTChwYXRoKSk7XG4gICAgfSwgX3RoaXMuaGFuZGxlUHVzaCA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wcy5iYXNlbmFtZSxcbiAgICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMuY29udGV4dDtcblxuICAgICAgY29udGV4dC5hY3Rpb24gPSAnUFVTSCc7XG4gICAgICBjb250ZXh0LmxvY2F0aW9uID0gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSk7XG4gICAgICBjb250ZXh0LnVybCA9IGNyZWF0ZVVSTChjb250ZXh0LmxvY2F0aW9uKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVSZXBsYWNlID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gX3RoaXMucHJvcHMsXG4gICAgICAgICAgYmFzZW5hbWUgPSBfdGhpcyRwcm9wczIuYmFzZW5hbWUsXG4gICAgICAgICAgY29udGV4dCA9IF90aGlzJHByb3BzMi5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgIGNvbnRleHQudXJsID0gY3JlYXRlVVJMKGNvbnRleHQubG9jYXRpb24pO1xuICAgIH0sIF90aGlzLmhhbmRsZUxpc3RlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBub29wO1xuICAgIH0sIF90aGlzLmhhbmRsZUJsb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiB7XG4gICAgICAgIHN0YXRpY0NvbnRleHQ6IHRoaXMucHJvcHMuY29udGV4dFxuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgU3RhdGljUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgd2FybmluZyghdGhpcy5wcm9wcy5oaXN0b3J5LCAnPFN0YXRpY1JvdXRlcj4gaWdub3JlcyB0aGUgaGlzdG9yeSBwcm9wLiBUbyB1c2UgYSBjdXN0b20gaGlzdG9yeSwgJyArICd1c2UgYGltcG9ydCB7IFJvdXRlciB9YCBpbnN0ZWFkIG9mIGBpbXBvcnQgeyBTdGF0aWNSb3V0ZXIgYXMgUm91dGVyIH1gLicpO1xuICB9O1xuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBiYXNlbmFtZSA9IF9wcm9wcy5iYXNlbmFtZSxcbiAgICAgICAgY29udGV4dCA9IF9wcm9wcy5jb250ZXh0LFxuICAgICAgICBsb2NhdGlvbiA9IF9wcm9wcy5sb2NhdGlvbixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ2Jhc2VuYW1lJywgJ2NvbnRleHQnLCAnbG9jYXRpb24nXSk7XG5cbiAgICB2YXIgaGlzdG9yeSA9IHtcbiAgICAgIGNyZWF0ZUhyZWY6IHRoaXMuY3JlYXRlSHJlZixcbiAgICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgICBsb2NhdGlvbjogc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKSxcbiAgICAgIHB1c2g6IHRoaXMuaGFuZGxlUHVzaCxcbiAgICAgIHJlcGxhY2U6IHRoaXMuaGFuZGxlUmVwbGFjZSxcbiAgICAgIGdvOiBzdGF0aWNIYW5kbGVyKCdnbycpLFxuICAgICAgZ29CYWNrOiBzdGF0aWNIYW5kbGVyKCdnb0JhY2snKSxcbiAgICAgIGdvRm9yd2FyZDogc3RhdGljSGFuZGxlcignZ29Gb3J3YXJkJyksXG4gICAgICBsaXN0ZW46IHRoaXMuaGFuZGxlTGlzdGVuLFxuICAgICAgYmxvY2s6IHRoaXMuaGFuZGxlQmxvY2tcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgaGlzdG9yeTogaGlzdG9yeSB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIFN0YXRpY1JvdXRlcjtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuU3RhdGljUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGNvbnRleHQ6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgbG9jYXRpb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKVxufTtcblN0YXRpY1JvdXRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGJhc2VuYW1lOiAnJyxcbiAgbG9jYXRpb246ICcvJ1xufTtcblN0YXRpY1JvdXRlci5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IFN3aXRjaCBmcm9tICdyZWFjdC1yb3V0ZXIvZXMvU3dpdGNoJztcblxuZXhwb3J0IGRlZmF1bHQgU3dpdGNoO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IG1hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyB0aGUgZmlyc3QgPFJvdXRlPiB0aGF0IG1hdGNoZXMuXG4gKi9cblxudmFyIFN3aXRjaCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTd2l0Y2gsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN3aXRjaCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3dpdGNoKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaW52YXJpYW50KHRoaXMuY29udGV4dC5yb3V0ZXIsICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFN3aXRjaD4gb3V0c2lkZSBhIDxSb3V0ZXI+Jyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKCEobmV4dFByb3BzLmxvY2F0aW9uICYmICF0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgaW5pdGlhbGx5IHVzZWQgbm8gXCJsb2NhdGlvblwiIHByb3AgYW5kIHRoZW4gcHJvdmlkZWQgb25lIG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB3YXJuaW5nKCEoIW5leHRQcm9wcy5sb2NhdGlvbiAmJiB0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxTd2l0Y2g+IGVsZW1lbnRzIHNob3VsZCBub3QgY2hhbmdlIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiBZb3UgcHJvdmlkZWQgYSBcImxvY2F0aW9uXCIgcHJvcCBpbml0aWFsbHkgYnV0IG9taXR0ZWQgaXQgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcbiAgfTtcblxuICBTd2l0Y2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcm91dGUgPSB0aGlzLmNvbnRleHQucm91dGVyLnJvdXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XG5cbiAgICB2YXIgbG9jYXRpb24gPSB0aGlzLnByb3BzLmxvY2F0aW9uIHx8IHJvdXRlLmxvY2F0aW9uO1xuXG4gICAgdmFyIG1hdGNoID0gdm9pZCAwLFxuICAgICAgICBjaGlsZCA9IHZvaWQgMDtcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgcmV0dXJuO1xuXG4gICAgICB2YXIgX2VsZW1lbnQkcHJvcHMgPSBlbGVtZW50LnByb3BzLFxuICAgICAgICAgIHBhdGhQcm9wID0gX2VsZW1lbnQkcHJvcHMucGF0aCxcbiAgICAgICAgICBleGFjdCA9IF9lbGVtZW50JHByb3BzLmV4YWN0LFxuICAgICAgICAgIHN0cmljdCA9IF9lbGVtZW50JHByb3BzLnN0cmljdCxcbiAgICAgICAgICBzZW5zaXRpdmUgPSBfZWxlbWVudCRwcm9wcy5zZW5zaXRpdmUsXG4gICAgICAgICAgZnJvbSA9IF9lbGVtZW50JHByb3BzLmZyb207XG5cbiAgICAgIHZhciBwYXRoID0gcGF0aFByb3AgfHwgZnJvbTtcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgY2hpbGQgPSBlbGVtZW50O1xuICAgICAgICBtYXRjaCA9IHBhdGggPyBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIHsgcGF0aDogcGF0aCwgZXhhY3Q6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCwgc2Vuc2l0aXZlOiBzZW5zaXRpdmUgfSkgOiByb3V0ZS5tYXRjaDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBtYXRjaCA/IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgeyBsb2NhdGlvbjogbG9jYXRpb24sIGNvbXB1dGVkTWF0Y2g6IG1hdGNoIH0pIDogbnVsbDtcbiAgfTtcblxuICByZXR1cm4gU3dpdGNoO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Td2l0Y2guY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgcm91dGU6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxuICB9KS5pc1JlcXVpcmVkXG59O1xuU3dpdGNoLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBTd2l0Y2g7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Td2l0Y2guanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIFdyaXR0ZW4gaW4gdGhpcyByb3VuZCBhYm91dCB3YXkgZm9yIGJhYmVsLXRyYW5zZm9ybS1pbXBvcnRzXG5pbXBvcnQgbWF0Y2hQYXRoIGZyb20gJ3JlYWN0LXJvdXRlci9lcy9tYXRjaFBhdGgnO1xuXG5leHBvcnQgZGVmYXVsdCBtYXRjaFBhdGg7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvbWF0Y2hQYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBXcml0dGVuIGluIHRoaXMgcm91bmQgYWJvdXQgd2F5IGZvciBiYWJlbC10cmFuc2Zvcm0taW1wb3J0c1xuaW1wb3J0IHdpdGhSb3V0ZXIgZnJvbSAncmVhY3Qtcm91dGVyL2VzL3dpdGhSb3V0ZXInO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL3dpdGhSb3V0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcbmltcG9ydCBSb3V0ZSBmcm9tICcuL1JvdXRlJztcblxuLyoqXG4gKiBBIHB1YmxpYyBoaWdoZXItb3JkZXIgY29tcG9uZW50IHRvIGFjY2VzcyB0aGUgaW1wZXJhdGl2ZSBBUElcbiAqL1xudmFyIHdpdGhSb3V0ZXIgPSBmdW5jdGlvbiB3aXRoUm91dGVyKENvbXBvbmVudCkge1xuICB2YXIgQyA9IGZ1bmN0aW9uIEMocHJvcHMpIHtcbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudFJlZiA9IHByb3BzLndyYXBwZWRDb21wb25lbnRSZWYsXG4gICAgICAgIHJlbWFpbmluZ1Byb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbJ3dyYXBwZWRDb21wb25lbnRSZWYnXSk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwgeyByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyb3V0ZUNvbXBvbmVudFByb3BzKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHJlbWFpbmluZ1Byb3BzLCByb3V0ZUNvbXBvbmVudFByb3BzLCB7IHJlZjogd3JhcHBlZENvbXBvbmVudFJlZiB9KSk7XG4gICAgICB9IH0pO1xuICB9O1xuXG4gIEMuZGlzcGxheU5hbWUgPSAnd2l0aFJvdXRlcignICsgKENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSkgKyAnKSc7XG4gIEMuV3JhcHBlZENvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgQy5wcm9wVHlwZXMgPSB7XG4gICAgd3JhcHBlZENvbXBvbmVudFJlZjogUHJvcFR5cGVzLmZ1bmNcbiAgfTtcblxuICByZXR1cm4gaG9pc3RTdGF0aWNzKEMsIENvbXBvbmVudCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlci5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mICYmIGdldFByb3RvdHlwZU9mKE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHsgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0xLTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanM/P3JlZi0tMS0yIS4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi9tYWluLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wibWluaW1pemVcIjp0cnVlLFwiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcblx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XG5cdFx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTEtMSEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz8/cmVmLS0xLTIhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuL21haW4uc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMS0xIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzPz9yZWYtLTEtMiEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4vbWFpbi5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Nzcy9tYWluLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBlc2NhcGUgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanNcIik7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIip7Ym94LXNpemluZzpib3JkZXItYm94fWJvZHl7Zm9udC1mYW1pbHk6TGF0byxzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6MThweDtsaW5lLWhlaWdodDoxLjU7bWFyZ2luOjA7cGFkZGluZzowfWgxLGgyLGgze21hcmdpbjowO3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZX1oMXtmb250LXNpemU6NTBweH1oMSxoMntmb250LXdlaWdodDo5MDB9aDJ7Zm9udC1zaXplOjMwcHh9aDN7Zm9udC1zaXplOjI0cHg7Zm9udC13ZWlnaHQ6MzAwO3RleHQtdHJhbnNmb3JtOm5vbmV9YXtjb2xvcjppbmhlcml0O3RleHQtZGVjb3JhdGlvbjpub25lfWJ1dHRvbntiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOjA7b3V0bGluZTowO2N1cnNvcjpwb2ludGVyfXN2ZyBwYXRoe3RyYW5zaXRpb246ZmlsbCAuM3N9LnBhZGRpbmd7cGFkZGluZy10b3A6MTAwcHg7cGFkZGluZy1ib3R0b206MTAwcHh9LndyYXBwZXJ7bWF4LXdpZHRoOjg0MHB4O21hcmdpbjowIGF1dG87cGFkZGluZzowIDIwcHh9LndyYXBwZXItc21hbGx7bWF4LXdpZHRoOjYyMHB4O21hcmdpbjowIGF1dG87cGFkZGluZy1yaWdodDoyMHB4O3BhZGRpbmctbGVmdDoyMHB4fW1haW57bWFyZ2luLXRvcDo4MHB4fWhlYWRlcntiYWNrZ3JvdW5kOiMwMDA7aGVpZ2h0OjgwcHg7dGV4dC1hbGlnbjpsZWZ0O3Bvc2l0aW9uOnJlbGF0aXZlO3Bvc2l0aW9uOmZpeGVkO3dpZHRoOjEwMCU7ei1pbmRleDozO3RvcDowfWhlYWRlciAudGFtdGFtLWljb24saGVhZGVyIG5hdntwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO2Rpc3BsYXk6YmxvY2s7ZmxvYXQ6bGVmdH1oZWFkZXIgLnRhbXRhbS1pY29ue21hcmdpbjowIDIwcHggMCAzMHB4O21heC13aWR0aDozMnB4fWhlYWRlciAudGFtdGFtLWljb24gc3Zne2Rpc3BsYXk6YmxvY2s7dHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuM3M7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjNzO3RyYW5zaXRpb246dHJhbnNmb3JtIC4zcywtd2Via2l0LXRyYW5zZm9ybSAuM3N9aGVhZGVyIC50YW10YW0taWNvbjpob3ZlciBzdmd7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDE4MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfWhlYWRlciBuYXYgdWx7cGFkZGluZzowO21hcmdpbjowfWhlYWRlciBuYXYgdWwgbGl7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGlzdC1zdHlsZS10eXBlOm5vbmV9aGVhZGVyIG5hdiB1bCBsaSBhe2NvbG9yOiNmZmY7b3BhY2l0eTouNztmb250LXNpemU6MTZweDtwYWRkaW5nOjMwcHggMjBweDt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzLGNvbG9yIC4zc31oZWFkZXIgbmF2IHVsIGxpIGE6aG92ZXJ7b3BhY2l0eToxO2NvbG9yOiNmZDU0NTR9aGVhZGVyIG5hdiB1bCBsaSBhLmFjdGl2ZXtvcGFjaXR5OjF9LmhhbWJ1cmdlcnt6LWluZGV4OjM7bWFyZ2luLWxlZnQ6MjBweDtmbG9hdDpsZWZ0O3dpZHRoOjMwcHg7aGVpZ2h0OjIycHg7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDBkZWcpIHRyYW5zbGF0ZVkoLTUwJSk7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKSB0cmFuc2xhdGVZKC01MCUpO3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDo1MCU7dHJhbnNpdGlvbjouNXMgZWFzZS1pbi1vdXQ7Y3Vyc29yOnBvaW50ZXI7ZGlzcGxheTpub25lfS5oYW1idXJnZXIgc3BhbntkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDozcHg7d2lkdGg6MTAwJTtiYWNrZ3JvdW5kOiNmZmY7b3BhY2l0eToxO2xlZnQ6MDstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgwZGVnKTt0cmFuc2l0aW9uOi4yNXMgZWFzZS1pbi1vdXR9LmhhbWJ1cmdlciBzcGFuOmZpcnN0LWNoaWxke3RvcDowfS5oYW1idXJnZXIgc3BhbjpudGgtY2hpbGQoMiksLmhhbWJ1cmdlciBzcGFuOm50aC1jaGlsZCgzKXt0b3A6MTFweH0uaGFtYnVyZ2VyIHNwYW46bnRoLWNoaWxkKDQpe3RvcDoyMnB4fWhlYWRlci5hY3RpdmUgLmhhbWJ1cmdlciBzcGFuOmZpcnN0LWNoaWxke3RvcDoxMnB4O3dpZHRoOjA7bGVmdDo1MCV9aGVhZGVyLmFjdGl2ZSAuaGFtYnVyZ2VyIHNwYW46bnRoLWNoaWxkKDIpey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyl9aGVhZGVyLmFjdGl2ZSAuaGFtYnVyZ2VyIHNwYW46bnRoLWNoaWxkKDMpey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX1oZWFkZXIuYWN0aXZlIC5oYW1idXJnZXIgc3BhbjpudGgtY2hpbGQoNCl7dG9wOjExcHg7d2lkdGg6MDtsZWZ0OjUwJX0uc2xpZGVye3Bvc2l0aW9uOnJlbGF0aXZlfS5zbGlkZXIgLm92ZXJsYXl7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQoMTgwZGVnLHRyYW5zcGFyZW50IDAsdHJhbnNwYXJlbnQgNTAlLHJnYmEoMCwwLDAsLjMpKTtmaWx0ZXI6cHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9XFxcIiRjb2xvci1ibGFjazAwMDAwXFxcIixlbmRDb2xvcnN0cj1cXFwiIzRkMDAwMDAwXFxcIixHcmFkaWVudFR5cGU9MCk7aGVpZ2h0OjEwMCV9LnNsaWRlciAuc2Nyb2xsLWRvd257Ym90dG9tOjM5cHg7YmFja2dyb3VuZDojZmZmO3dpZHRoOjU0cHg7aGVpZ2h0OjU0cHg7Ym9yZGVyLXJhZGl1czo1MCV9LnNsaWRlciAuc2Nyb2xsLWRvd24sLnNsaWRlciAuc2Nyb2xsLWRvd24gc3Zne3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDtyaWdodDowO21hcmdpbjowIGF1dG99LnNsaWRlciAuc2Nyb2xsLWRvd24gc3Zne3RvcDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSk7ZGlzcGxheTpibG9ja30uc2xpZGVyIC5zY3JvbGwtZG93biBzdmcuYXJyb3dzLWRvd257ZGlzcGxheTpub25lfS5zbGlkZXIgLnNjcm9sbC1kb3duIHN2Zy5tb3VzZXtkaXNwbGF5OmJsb2NrfS5zbGlkZXIgLnNjcm9sbC1kb3duOmhvdmVyIHN2ZyBwYXRoe2ZpbGw6I2ZkNTQ1NH0uc2xpZGVyIC5jaGV2cm9uLWRvd257cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjI1cHg7bWFyZ2luOjAgYXV0bzttYXgtd2lkdGg6MTBweH0uc2xpZGVyIC5zbGlkZXtiYWNrZ3JvdW5kLXNpemU6Y292ZXI7YmFja2dyb3VuZC1wb3NpdGlvbjo1MCU7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2hlaWdodDo3MDBweDt3aWR0aDoxMDAlfS5zbGlkZXIgLnNsaWRlIC5zbGlkZS1jb250YWluZXJ7dGV4dC1hbGlnbjpjZW50ZXI7cG9zaXRpb246cmVsYXRpdmU7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX0uc2xpZGVyIC5zbGlkZSAuc2xpZGUtY29udGFpbmVyIG5hdnttYXJnaW4tdG9wOjQwcHh9LnNsaWRlciAuc2xpZGUgLnNsaWRlLWNvbnRhaW5lciBhLC5zbGlkZXIgLnNsaWRlIC5zbGlkZS1jb250YWluZXIgYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowIDEwcHg7dmVydGljYWwtYWxpZ246bWlkZGxlfS5jb250cm9sLWFycm93e3Zpc2liaWxpdHk6aGlkZGVufS5zbGlkZXIgLnNsaWRlIC5zbGlkZS1jb250YWluZXIgLmFycm93e3dpZHRoOjQwcHg7aGVpZ2h0OjQwcHg7YmFja2dyb3VuZDojMDAwO2JvcmRlci1yYWRpdXM6NTAlO3RleHQtYWxpZ246Y2VudGVyO3Bvc2l0aW9uOnJlbGF0aXZlO3RyYW5zaXRpb246YmFja2dyb3VuZCAuM3N9LnNsaWRlciAuc2xpZGUgLnNsaWRlLWNvbnRhaW5lciAuYXJyb3c6aG92ZXJ7YmFja2dyb3VuZDojZmQ1NDU0fS5zbGlkZXIgLnNsaWRlIC5zbGlkZS1jb250YWluZXIgLmFycm93IHN2Z3twb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO21hcmdpbjphdXRvO2xlZnQ6MDtyaWdodDowO3RvcDowO2JvdHRvbTowfS5zbGlkZXIgLnNsaWRlIC5zbGlkZS1jb250YWluZXIgLnJhZGl1cy1idXR0b257aGVpZ2h0OjQwcHg7bGluZS1oZWlnaHQ6NDBweDt3aWR0aDoxNTBweDtiYWNrZ3JvdW5kOiMwMDA7Y29sb3I6I2ZmZjtib3JkZXItcmFkaXVzOjQwcHg7Zm9udC1zaXplOjE2cHg7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC4zc30uc2xpZGVyIC5zbGlkZSAuc2xpZGUtY29udGFpbmVyIC5yYWRpdXMtYnV0dG9uOmhvdmVye2JhY2tncm91bmQ6I2ZkNTQ1NH0uaW50cm97Zm9udC1zaXplOjIwcHg7Y29sb3I6IzI5MjkyOX0uZmVlZCwuaW50cm97dGV4dC1hbGlnbjpjZW50ZXJ9LmZlZWR7YmFja2dyb3VuZC1zaXplOmNvdmVyO2JhY2tncm91bmQtcG9zaXRpb246NTAlO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLWltYWdlOnVybChcIiArIGVzY2FwZShyZXF1aXJlKFwiLi4vaW1nL2ZlZWRfYmcuanBnXCIpKSArIFwiKX0uZmVlZCAucGFkZGluZ3twYWRkaW5nLWJvdHRvbToyMDBweH0uZmVlZCBoMntjb2xvcjojNzg5MTk5O21hcmdpbi1ib3R0b206MTBweH0uZmVlZCBoM3tjb2xvcjojZmZmfS5mZWVkIC5mZWVkLWNvbnRlbnR7LXdlYmtpdC1jb2x1bW4tY291bnQ6Mztjb2x1bW4tY291bnQ6Mzstd2Via2l0LWNvbHVtbi1nYXA6MjBweDtjb2x1bW4tZ2FwOjIwcHg7bWFyZ2luLXRvcDo1MHB4fS5mZWVkIC5mZWVkLWNvbnRlbnQgLnBvc3R7YmFja2dyb3VuZC1jb2xvcjojZWVlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowIDAgMjBweDt3aWR0aDoxMDAlO2N1cnNvcjpwb2ludGVyfS5mZWVkIC5mZWVkLWNvbnRlbnQgLnBvc3QgaW1ne3dpZHRoOjEwMCU7ZGlzcGxheTpibG9ja30uZmVlZCAuZmVlZC1jb250ZW50IC5wb3N0IC5jb250ZW50e3BhZGRpbmc6MTBweDtiYWNrZ3JvdW5kOiNmZmY7Zm9udC1zaXplOjE2cHg7dGV4dC1hbGlnbjpsZWZ0fS5mZWVkIC5mZWVkLWNvbnRlbnQgLnBvc3QgLmNvbnRlbnQgcHttYXJnaW46MH0uZmVlZCAuZmVlZC1wb3B1cCwuZmVlZCAuZmVlZC1wb3B1cCAub3ZlcmxheXtwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uZmVlZCAuZmVlZC1wb3B1cCAub3ZlcmxheXtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjUpO2N1cnNvcjpwb2ludGVyfS5mZWVkIC5mZWVkLXBvcHVwIC5jb250YWluZXJ7aGVpZ2h0OmNhbGMoMTAwJSAtIDE2MHB4KTt3aWR0aDoxMDAlO21heC13aWR0aDo4MDBweDttYXJnaW46MCBhdXRvO3otaW5kZXg6Mztwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tdG9wOjEyMHB4fS5mZWVkIC5mZWVkLXBvcHVwIC5jb250YWluZXIgLmNvbnRlbnR7YmFja2dyb3VuZDojZmZmO21heC13aWR0aDo4MDBweDttYXJnaW46MCBhdXRvO292ZXJmbG93LXk6c2Nyb2xsO2hlaWdodDoxMDAlfS5mZWVkIC5mZWVkLXBvcHVwIC5jb250YWluZXIgLmNvbnRlbnQgLmltYWdle3dpZHRoOmNhbGMoMTAwJSAtIDMwMHB4KTtmbG9hdDpsZWZ0O2JhY2tncm91bmQtc2l6ZTpjb3ZlcjtiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJTtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7aGVpZ2h0OjEwMCV9LmZlZWQgLmZlZWQtcG9wdXAgLmNvbnRhaW5lciAuY29udGVudCAuaW5mb2JveHt3aWR0aDoxMDAlO21heC13aWR0aDozMDBweDtmbG9hdDpsZWZ0O3BhZGRpbmc6MjBweDt0ZXh0LWFsaWduOmxlZnR9LmZlZWQgLmZlZWQtcG9wdXAgLmNvbnRhaW5lciAuY29udGVudCAuaW5mb2JveCAuY3Jvc3N7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MjBweDt0b3A6MjBweH0uZmVlZCAuZmVlZC1wb3B1cCAuY29udGFpbmVyIC5jb250ZW50IC5pbmZvYm94IC5jcm9zcyBzdmd7ZmlsbDojOGU4ZThlO3dpZHRoOjE1cHg7aGVpZ2h0OjE1cHh9LmZlZWQgLmZlZWQtcG9wdXAgLmNvbnRhaW5lciAuY29udGVudCAuaW5mb2JveCAudXNlcntwYWRkaW5nLWJvdHRvbToyMHB4O2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlOWU5ZTl9LmZlZWQgLmZlZWQtcG9wdXAgLmNvbnRhaW5lciAuY29udGVudCAuaW5mb2JveCAudXNlciBpbWd7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO2JvcmRlci1yYWRpdXM6NTAlO21heC13aWR0aDo1MHB4O21hcmdpbi1yaWdodDoxMHB4fS5mZWVkIC5mZWVkLXBvcHVwIC5jb250YWluZXIgLmNvbnRlbnQgLmluZm9ib3ggLnVzZXIgLnVzZXJuYW1le2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtmb250LXdlaWdodDo5MDA7Zm9udC1zaXplOjE2cHh9LmZlZWQgLmZlZWQtcG9wdXAgLmNvbnRhaW5lciAuY29udGVudCAuaW5mb2JveCAudGV4dHtmb250LXNpemU6MTZweDtwYWRkaW5nOjIwcHggMH0uZmVlZCAuZmVlZC1wb3B1cCAuY29udGFpbmVyIC5jb250ZW50IC5pbmZvYm94IC5saWtlc3tmb250LXNpemU6MTZweH0uZmVlZCAuZmVlZC1wb3B1cCAuY29udGFpbmVyIC5jb250ZW50IC5pbmZvYm94IC5saWtlcyBzcGFuOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcMjY2NVxcXCI7Zm9udC1zaXplOjMwcHg7bWFyZ2luLXJpZ2h0OjEwcHg7Y29sb3I6I2ZkNTQ1NDtkaXNwbGF5OmlubGluZS1ibG9jaztsaW5lLWhlaWdodDouN30uZmVlZC1idXR0b257YmFja2dyb3VuZDojZmQ1NDU0O2JvcmRlcjowO291dGxpbmU6MDt3aWR0aDoxNTBweDtoZWlnaHQ6NDBweDtjb2xvcjojZmZmO2JvcmRlci1yYWRpdXM6NDBweDtjdXJzb3I6cG9pbnRlcjttYXJnaW4tdG9wOjQwcHg7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC4zc30uZmVlZC1idXR0b24ubG9hZGluZ3tjb2xvcjp0cmFuc3BhcmVudH0uZmVlZC1idXR0b24ubG9hZGluZzphZnRlcntjb250ZW50OlxcXCJcXFwiO2JhY2tncm91bmQtaW1hZ2U6dXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuLi9pbWcvaWNvbnMvbG9hZGVyLmdpZlwiKSkgKyBcIik7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0O2JhY2tncm91bmQtc2l6ZTpjb250YWluO2JhY2tncm91bmQtcG9zaXRpb246NTAlO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjA7bWFyZ2luOmF1dG87dG9wOjEwcHh9LmZlZWQtYnV0dG9uOmhvdmVye2JhY2tncm91bmQ6I2ZmNzY3Nn0uY29udGFjdC1mb3Jte3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtc2l6ZTpjb3ZlcjtiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJTtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4uL2ltZy9mZWVkX2JnLmpwZ1wiKSkgKyBcIil9LmNvbnRhY3QtZm9ybSAucGFkZGluZ3twYWRkaW5nLWJvdHRvbToyMTVweH0uY29udGFjdC1mb3JtIGgxe2NvbG9yOiNmZmY7Zm9udC1zaXplOjQwcHg7bWF4LXdpZHRoOjUwMHB4O21hcmdpbjowIGF1dG8gNDBweH0uY29udGFjdC1mb3JtIGZvcm17dHJhbnNpdGlvbjpvcGFjaXR5IC4zcztwb2ludGVyLWV2ZW50czphdXRvfS5jb250YWN0LWZvcm0gZm9ybS5oaWRle29wYWNpdHk6MDtwb2ludGVyLWV2ZW50czpub25lfS5jb250YWN0LWZvcm0gZm9ybSAuZm9ybS1jb250YWluZXJ7YmFja2dyb3VuZDpoc2xhKDAsMCUsMTAwJSwuMik7cGFkZGluZzoxMHB4IDAgMjBweCAxMHB4O292ZXJmbG93OmhpZGRlbn0uY29udGFjdC1mb3JtIGZvcm0gLmZvcm0tY29udGFpbmVyIC5maWVsZHtwYWRkaW5nOjEwcHggMTBweCAwIDA7cG9zaXRpb246cmVsYXRpdmV9LmNvbnRhY3QtZm9ybSBmb3JtIC5mb3JtLWNvbnRhaW5lciAuZmllbGQuZnVsbHtjbGVhcjpib3RoO3BhZGRpbmctdG9wOjIwcHh9LmNvbnRhY3QtZm9ybSBmb3JtIC5mb3JtLWNvbnRhaW5lciAuZmllbGQuaGFsZnt3aWR0aDo1MCU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246dG9wfS5jb250YWN0LWZvcm0gZm9ybSAuZm9ybS1jb250YWluZXIgLmZpZWxkIGlucHV0LC5jb250YWN0LWZvcm0gZm9ybSAuZm9ybS1jb250YWluZXIgLmZpZWxkIHRleHRhcmVhe3dpZHRoOjEwMCU7Ym9yZGVyOjA7YmFja2dyb3VuZDojZmZmO291dGxpbmU6MDtmb250LXNpemU6MTZweDtwYWRkaW5nLWxlZnQ6MjBweDt0cmFuc2l0aW9uOmNvbG9yIC4zc30uY29udGFjdC1mb3JtIGZvcm0gLmZvcm0tY29udGFpbmVyIC5maWVsZCBpbnB1dDo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciwuY29udGFjdC1mb3JtIGZvcm0gLmZvcm0tY29udGFpbmVyIC5maWVsZCB0ZXh0YXJlYTo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcnt0cmFuc2l0aW9uOmNvbG9yIC4zc30uY29udGFjdC1mb3JtIGZvcm0gLmZvcm0tY29udGFpbmVyIC5maWVsZCBpbnB1dDotbXMtaW5wdXQtcGxhY2Vob2xkZXIsLmNvbnRhY3QtZm9ybSBmb3JtIC5mb3JtLWNvbnRhaW5lciAuZmllbGQgdGV4dGFyZWE6LW1zLWlucHV0LXBsYWNlaG9sZGVye3RyYW5zaXRpb246Y29sb3IgLjNzfS5jb250YWN0LWZvcm0gZm9ybSAuZm9ybS1jb250YWluZXIgLmZpZWxkIGlucHV0OjpwbGFjZWhvbGRlciwuY29udGFjdC1mb3JtIGZvcm0gLmZvcm0tY29udGFpbmVyIC5maWVsZCB0ZXh0YXJlYTo6cGxhY2Vob2xkZXJ7dHJhbnNpdGlvbjpjb2xvciAuM3N9LmNvbnRhY3QtZm9ybSBmb3JtIC5mb3JtLWNvbnRhaW5lciAuZmllbGQgaW5wdXQ6aG92ZXI6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIsLmNvbnRhY3QtZm9ybSBmb3JtIC5mb3JtLWNvbnRhaW5lciAuZmllbGQgdGV4dGFyZWE6aG92ZXI6Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXJ7Y29sb3I6IzAwMH0uY29udGFjdC1mb3JtIGZvcm0gLmZvcm0tY29udGFpbmVyIC5maWVsZCBpbnB1dDpob3ZlcjotbXMtaW5wdXQtcGxhY2Vob2xkZXIsLmNvbnRhY3QtZm9ybSBmb3JtIC5mb3JtLWNvbnRhaW5lciAuZmllbGQgdGV4dGFyZWE6aG92ZXI6LW1zLWlucHV0LXBsYWNlaG9sZGVye2NvbG9yOiMwMDB9LmNvbnRhY3QtZm9ybSBmb3JtIC5mb3JtLWNvbnRhaW5lciAuZmllbGQgaW5wdXQ6aG92ZXI6OnBsYWNlaG9sZGVyLC5jb250YWN0LWZvcm0gZm9ybSAuZm9ybS1jb250YWluZXIgLmZpZWxkIHRleHRhcmVhOmhvdmVyOjpwbGFjZWhvbGRlcntjb2xvcjojMDAwfS5jb250YWN0LWZvcm0gZm9ybSAuZm9ybS1jb250YWluZXIgLmZpZWxkIGlucHV0e2hlaWdodDo1MHB4fS5jb250YWN0LWZvcm0gZm9ybSAuZm9ybS1jb250YWluZXIgLmZpZWxkLnZhbGlkOmFmdGVye2NvbnRlbnQ6XFxcIlxcXCI7YmFja2dyb3VuZC1pbWFnZTp1cmwoXCIgKyBlc2NhcGUocmVxdWlyZShcIi4uL2ltZy9pY29ucy9jaGVjay1ncmVlbi5zdmdcIikpICsgXCIpO2JhY2tncm91bmQtcmVwZWF0Om5vLXJlcGVhdDtiYWNrZ3JvdW5kLXNpemU6Y29udGFpbjtiYWNrZ3JvdW5kLXBvc2l0aW9uOjUwJTt3aWR0aDoyNHB4O2hlaWdodDoyNHB4O2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7dG9wOjIzcHg7cmlnaHQ6MjNweH0uY29udGFjdC1mb3JtIGZvcm0gLmZvcm0tY29udGFpbmVyIC5maWVsZC5mdWxsLnZhbGlkOmFmdGVye3RvcDozM3B4fS5jb250YWN0LWZvcm0gZm9ybSAuZm9ybS1jb250YWluZXIgLmZpZWxkIHRleHRhcmVhe2hlaWdodDoxMjBweDtwYWRkaW5nLXRvcDoyMHB4O2ZvbnQtZmFtaWx5OkxhdG8sc2Fucy1zZXJpZjtkaXNwbGF5OmJsb2NrfS5jb250YWN0LWZvcm0gZm9ybSAuc3VibWl0LWJ1dHRvbntiYWNrZ3JvdW5kOiNmZDU0NTQ7Ym9yZGVyOjA7b3V0bGluZTowO3dpZHRoOjE1MHB4O2hlaWdodDo0MHB4O2NvbG9yOiNmZmY7Ym9yZGVyLXJhZGl1czo0MHB4O2N1cnNvcjpwb2ludGVyO21hcmdpbi10b3A6NDBweDt0cmFuc2l0aW9uOmJhY2tncm91bmQgLjNzfS5jb250YWN0LWZvcm0gZm9ybSAuc3VibWl0LWJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOiNmZjc2NzZ9Lm1lc3NhZ2V7d2lkdGg6MTAwJTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsLjIpO3BhZGRpbmc6MTVweCAyMHB4O3RleHQtYWxpZ246bGVmdH0ubWVzc2FnZS1pY29ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuMik7Ym9yZGVyLXJhZGl1czo1MCU7d2lkdGg6MzBweDtoZWlnaHQ6MzBweDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7bWFyZ2luLXJpZ2h0OjIwcHh9Lm1lc3NhZ2UtaWNvbiAuaWNvbntiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7YmFja2dyb3VuZC1zaXplOmNvbnRhaW47YmFja2dyb3VuZC1wb3NpdGlvbjo1MCU7d2lkdGg6MTRweDtoZWlnaHQ6MTRweDttYXJnaW46MCBhdXRvO3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9Lm1lc3NhZ2UtaWNvbiAuaWNvbi5zdWNjZXNze2JhY2tncm91bmQtaW1hZ2U6dXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuLi9pbWcvaWNvbnMvY2hlY2std2hpdGUuc3ZnXCIpKSArIFwiKX0ubWVzc2FnZS1pY29uIC5pY29uLmVycm9ye2JhY2tncm91bmQtaW1hZ2U6dXJsKFwiICsgZXNjYXBlKHJlcXVpcmUoXCIuLi9pbWcvaWNvbnMvZXhjbGFtYXRpb24uc3ZnXCIpKSArIFwiKX0ubWVzc2FnZS10ZXh0e2NvbG9yOiNmZmY7dmVydGljYWwtYWxpZ246bWlkZGxlO3dpZHRoOmNhbGMoMTAwJSAtIDcwcHgpO2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5lcnJvci1wb3B1cHtiYWNrZ3JvdW5kOiM1NTVkNjA7Y29sb3I6I2ZmZjt0ZXh0LWFsaWduOmxlZnQ7cGFkZGluZzoxMHB4IDIwcHg7Zm9udC1zaXplOjE2cHg7cG9zaXRpb246cmVsYXRpdmV9LmVycm9yLXBvcHVwIC50cmlhbmdsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6LTEwcHg7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjEwcHggc29saWQgIzU1NWQ2MH0ucGVvcGxlIGltZy5jYXR7d2lkdGg6MTAwJTtkaXNwbGF5OmJsb2NrfWZvb3RlcntoZWlnaHQ6MTAwcHg7YmFja2dyb3VuZDojMDAwO3RleHQtYWxpZ246Y2VudGVyfWZvb3RlciAuZm9vdGVyLWNvbnRlbnR7cG9zaXRpb246cmVsYXRpdmU7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX1mb290ZXIgLmZvb3Rlci1jb250ZW50IGEuc29jaWFse2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbjowIDIwcHh9Zm9vdGVyIC5mb290ZXItY29udGVudCBhLnNvY2lhbDpob3ZlciBzdmcgcGF0aHtmaWxsOiNmZDU0NTR9Zm9vdGVyIC5mb290ZXItY29udGVudCBhLnNvY2lhbCBzdmd7d2lkdGg6MTAwJTttYXgtd2lkdGg6MjBweH1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjgwMHB4KXsuY29udGFjdC1mb3JtIGgxe2ZvbnQtc2l6ZTozMHB4O21heC13aWR0aDozMDBweH0uc2xpZGVyIGgxe2ZvbnQtc2l6ZTo0MHB4fS5mZWVkIC5mZWVkLWNvbnRlbnR7LXdlYmtpdC1jb2x1bW4tY291bnQ6Mjtjb2x1bW4tY291bnQ6Mn0ucGFkZGluZ3twYWRkaW5nLXRvcDo4MHB4O3BhZGRpbmctYm90dG9tOjgwcHh9LnNsaWRlciAuc2Nyb2xsLWRvd257d2lkdGg6NDBweDtoZWlnaHQ6NDBweDtib3R0b206MjBweH0uc2xpZGVyIC5zY3JvbGwtZG93biBzdmcuYXJyb3dzLWRvd257ZGlzcGxheTpibG9ja30uc2xpZGVyIC5jaGV2cm9uLWRvd24sLnNsaWRlciAuc2Nyb2xsLWRvd24gc3ZnLm1vdXNle2Rpc3BsYXk6bm9uZX19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2NDBweCl7LmNvbnRhY3QtZm9ybSBmb3JtIC5mb3JtLWNvbnRhaW5lciAuZmllbGQuaGFsZnt3aWR0aDoxMDAlO2Zsb2F0Om5vbmV9LmZlZWQgLmZlZWQtY29udGVudHstd2Via2l0LWNvbHVtbi1jb3VudDoxO2NvbHVtbi1jb3VudDoxfS5mZWVkIGgyLC5pbnRybyBoMntmb250LXNpemU6MjRweH0uZmVlZCBoM3tmb250LXNpemU6MjBweH0uZmVlZCAuZmVlZC1wb3B1cCAuY29udGFpbmVye21hcmdpbi10b3A6ODBweDtoZWlnaHQ6Y2FsYygxMDAlIC0gMTAwcHgpfS5mZWVkIC5mZWVkLXBvcHVwIC5jb250YWluZXIgLmNvbnRlbnQgLmltYWdle3dpZHRoOjEwMCU7ZmxvYXQ6bm9uZTttYXgtaGVpZ2h0OjMwMHB4fS5mZWVkIC5mZWVkLXBvcHVwIC5jb250YWluZXIgLmNvbnRlbnQgLmluZm9ib3h7d2lkdGg6MTAwJTtmbG9hdDpub25lO21heC13aWR0aDpub25lfS5zbGlkZXIgLnNsaWRle2hlaWdodDo1MDhweH0uc2xpZGVyIGgxe2ZvbnQtc2l6ZTozMHB4fS5zbGlkZXIgLnNsaWRlIC5zbGlkZS1jb250YWluZXIgbmF2e21hcmdpbi10b3A6MzBweH0uZmVlZCAucGFkZGluZ3twYWRkaW5nLWJvdHRvbToxMDBweDtwYWRkaW5nLXRvcDo2MHB4fS5wYWRkaW5ne3BhZGRpbmctdG9wOjYwcHg7cGFkZGluZy1ib3R0b206NjBweH0uZmVlZCAuZmVlZC1jb250ZW50e21hcmdpbi10b3A6MzBweH0uaW50cm8gcHttYXJnaW4tdG9wOjEwcHh9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6NDgwcHgpe2hlYWRlcntoZWlnaHQ6NjBweH1tYWlue21hcmdpbi10b3A6NjBweH0uY29udGFjdC1mb3JtIC5wYWRkaW5ne3BhZGRpbmc6NDBweCAwIDEwMHB4fS5jb250YWN0LWZvcm0gaDF7Zm9udC1zaXplOjI0cHg7bWFyZ2luLWJvdHRvbToyMHB4fS5jb250YWN0LWZvcm0gZm9ybSAuc3VibWl0LWJ1dHRvbnttYXJnaW4tdG9wOjIwcHh9aGVhZGVyIC50YW10YW0taWNvbntwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7cmlnaHQ6MDttYXJnaW46YXV0b31oZWFkZXIgLnRhbXRhbS1pY29uIHN2Z3ttYXgtd2lkdGg6MjJweDttYXJnaW46MCBhdXRvfS5oYW1idXJnZXJ7ZGlzcGxheTpibG9ja31oZWFkZXIgbmF2e3Bvc2l0aW9uOmZpeGVkO2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7dG9wOjYwcHg7bGVmdDowO2JhY2tncm91bmQ6IzAwMDtvcGFjaXR5OjA7cG9pbnRlci1ldmVudHM6bm9uZTt6LWluZGV4OjI7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKTt0cmFuc2l0aW9uOm9wYWNpdHkgLjNzfWhlYWRlci5hY3RpdmUgbmF2e29wYWNpdHk6MTtwb2ludGVyLWV2ZW50czphdXRvfWhlYWRlciBuYXYgdWx7dGV4dC1hbGlnbjpjZW50ZXI7Ym9yZGVyLXRvcDoxcHggc29saWQgI2ZmZjtwYWRkaW5nLXRvcDoyMHB4fWhlYWRlciBuYXYgdWwgbGl7ZGlzcGxheTpibG9ja31oZWFkZXIgbmF2IHVsIGxpIGF7Zm9udC1zaXplOjMwcHg7Zm9udC13ZWlnaHQ6OTAwO3dpZHRoOjEwMCU7cGFkZGluZzoyMHB4IDA7ZGlzcGxheTpibG9jaztvcGFjaXR5OjE7dHJhbnNpdGlvbjpjb2xvciAuM3N9aGVhZGVyIG5hdiB1bCBsaSBhLmFjdGl2ZSxoZWFkZXIgbmF2IHVsIGxpIGE6aG92ZXJ7Y29sb3I6I2ZkNTQ1NH19XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/e1wibWluaW1pemVcIjp0cnVlfSEuLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvbGliL2xvYWRlci5qcz97XCJtaW5pbWl6ZVwiOnRydWV9IS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIhLi9jc3MvbWFpbi5zY3NzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZSh1cmwpIHtcbiAgICAvLyBJZiB1cmwgaXMgYWxyZWFkeSB3cmFwcGVkIGluIHF1b3RlcywgcmVtb3ZlIHRoZW1cbiAgICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICAgICAgdXJsID0gdXJsLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgLy8gU2hvdWxkIHVybCBiZSB3cmFwcGVkP1xuICAgIC8vIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgaWYgKC9bXCInKCkgXFx0XFxuXS8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiAnXCInICsgdXJsLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgJ1xcXFxuJykgKyAnXCInXG4gICAgfVxuXG4gICAgcmV0dXJuIHVybFxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL3VybC9lc2NhcGUuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaHlBRElBT1ovQVAvLy8vUDA5T3ZzN05IVDFJQ0NoWStSbE1IQ3hObmIzSyt4dEoraHBNbkx6T0xqNVB6OC9QajQrUHI2K3YzOS9mSHg4dXZyN1A3Ky90ZlkyZm41K2ZYMTllenQ3ZVBqNUt1dHIrL3c4UFgyOXZEeDhmYjM5OC9RMGUvdjhQdjcrL2YzOThmSXlkWFcxK2JuNThYR3lOdmQzdVRsNXN6T3o2V25xdFRXMS9UMTliUzJ1WmFZbTRpS2pkemQzczNPMFAzKy92UHo5UG41K3ZYMTl2ajQrZnY3L1BmMytQcjYrL3o5L2VycjYrZm42T0hpNHRIUjA5M2UzK1BrNWJlNXU4UEZ4NkNocE9ucTYrZm82Y25LeTlEUzB2SHk4cDJmb2VYbTU3bTd2ZDdnNE5mWjJlN3U3cENTbEwvQXd1RGc0ZWpwNmVUbDVmVDA5ZmY0K052YzNmcjcrKzd1NytqbzZlSGk0OXJiM05qWjJ1TGs1TkxUMWZUMDlQUHo4OFBFeHVmcDZlM3U3dDNmMzdtNnZMQ3hzL2o1K2NEQnc4bkt6TGk1dTkvZzRPRGk0N0d6dGRQVjFzM056NzdBd3BpYW5LU21xT1RrNWU3djhQTHo4KzN0N3V6czdOemMzZmIyOS92OC9QRHc4ZTd2NzZpcHE5L2g0YjIrd2JLMHR2Ly8veUgvQzA1RlZGTkRRVkJGTWk0d0F3RUFBQUFoK1FRSkJ3Qi9BQ3dBQUFBQXlBRElBQUFILzRCL2dvT0VoWWFIaUltS2k0eU5qbytRa1pLVGxKV1dsNWlabXB1Y25aNmZvS0dpbzZTbHBxZW9xYXFycksydXI3Q3hzck8wdGJhM3VMbXVBTHk5dXIvQWo3M0R2c0hHeDRMRXlnREl6YnJMeTg3U3RkREswOWV3MWRIWTNLcmExdDNocHQvRTR1YWo1TVBuNjUvcHhlendtZTY4OGRJVWYvZWg4OHlnVG4vKzlUWlZDRUN3WUlWMjh6NDFJY0N3WVpPQWxzb1VuRml3VEtkOW5kQTAzTmdRRGNSSkZFTUd1SmlRRThlVEJENUdFaW1TRThaTktGR3FkTlNBWlVnUW0xNW0yaFB6SkptWmpBYmFwSml6WkthZUp4OENWVFEwNUVGNVJpOHRSTXB4S2RPbVJLRzYwMFQxcE5WRVdDbXEwSm91VTR1dVZiOGVVaEYyb3NWTE92OHJhVVRic0lYYVF6WGJGc1FVbHhMZGpUL3ZHdEpia0FQY3FKT0MvRzBvK0pCRXdpTXQ5WlcwbUdGalJHd0pQNlUwR2RMVXYzWXZINEljSU4ra3pvOHFFK2dnK3BBR3lHTTVJNFowZHZHYjFvaElONUM5ZFJJWjFiZ1JnU0ROdSt3azFYdUM1NFpzV0JMcVJZb3JLd2NMK2ZUc1JzQ25JeEtxZDdPdzY0cyswMVdxM1ZBVjRwR2VJM0tTdmZ3aERyRFRnMDlVKzI4UTk5UUo0L3plMnhGUDZmZ2hraGRoa0tobmlHcUJCYmdXWkJyd1oxd2piMVFXbW9MTEVlaUlnWVMwUitFaDNMVVZHeU1ZQ2xMZmVCdGVSWmhwaW9USUhvQWxJZ0pmZFNET2wyRmw5N1dZbjE3TnBTaWpJTkV0QnBFWFRBZ2dwQVZlZ1BLWWhUcjJsNGovYWg1OU1nWUxCVVI1eEJpckNHbmxsVjE4a2xsM2l4Z29IbG9UY21KR2xHU1dpVW9YVjZZNTVDZm9KV0tnaHB0QVdlYWNCWmhoaXBwNENwQkJKeDJHOWVFaDZvMklGbm1hd0VIbm9RV1VFbVNlZUJyQkNXbHZBVHJmWEQ1dTRnZWlpQjVCQ3FPY2VtZkppMGdhOHB4cU5XSVNBcWFvamxJQnA1d3lvUWxwT1JhQ1dvOS9hWElFcXFpR01BcXJyRzZBQ1FWdHlncWVhZ0JaZ2dHdXVLcktLNjlGV3JKbFc1NG1jOTJYWFlVNXlSaklJcXVyS012eWFrRzBrSkNHb3JSS0NySmlwWlhJbVcycXUzYkxxNnVVdkViWW4rUStPSWlnWGQxR3lhM3JJa3ZLb3U3MlNrbXc5Wkp6SUl1UkhOc3ZzcHB1R3ZDeVdVWXluR2FpMmlzSS83VlVKUmZKbUF0bmF3cWFEM3NyeWJOaFZXeHdJUkpLb203SHFOcDVTc2pMd3ZzSWpNSnFjd2pDamZETGNyS3FHQUV6cjc0NjBtZFRpTmg4ODErRUxxTHd6cWo2NFFyQVArY0o3bWdlSnZuT0lmajI1TWlwVEtQYU1Dd1dSTTJvQlkyQTJ0UnVtZnlHVnFtS3JOejFuQ3pVQXJMWWVPNjVTRnNtb2NXSW9XOGo2ckl0RzlDZHA2T0pIR2xUcEpsUTJsT1RpRnphOTZFWUFBTzE0R3NtTW1CTG55Q1ZvQ0VodVAxNEFWOEhFemJsVjhxOG9GZ09nQklDdnRZV292UG5VY2J0akJla3B4bTBnQndZVmtVcFpBUnhIMnVJTEExN2xGUmVFM2p0VmtZTURNZkRSeGw1T0pOVDNxd3UyRFlQT2p1ajF3Nk05U3hzeTQ3UHRaT2RpLy9uYnpzTlVRYmE1ekk4SEV0bEwvYjB0VlRmdCt4V3JVcjM3YlVJejdUM2FoMy9NLzYwMEYvSG5pZWE2SFZMRjB3TEhXN2MxNjBwcUs5ajlOUE8zSllsUGx5UUQxTi93NC8vV1BVTHJpR0xnQnN5NEpYZ2h3djVaY3BHaEdDZ2xaQ0JxQWlpVUJCZEFCaVJuUEVrTWgwaGd5L01vUTUzeU1NZSt2Q0hRQ3lFRUJaQXhDSWE4WWhJVEtJU2wxaEVJYkRqQndtSW9oU25TTVVxV3ZHS1dKVGlEeWd4QkNaNjhZdGdST0lReExHR0xKcnhqR2lzNGhvaVlZSXd1dkdOU3pSQk4xQ1F4anJhRVlzb2VFUVg0Y2pIUGk1Z2pOY280eDBIU2NnRXJMRVJma3drSExGUnlFYmVzUkZEVktRa3YraEVhVURSa1pnODR4WVhNY2xPZW5IL0dwa01wUmtaNGNsU0poR1Vva3hsRlVscHlsWVNFWldxakdVQ1dPbEtVOEpTbHFsa1JDUnIyY2xLT3VPU3VBemxKam5KeTA0eU1waWhkTVFlaTVsSVFFNURrTWhzNUNFYjBVWm05bEdPM0tCak5BbVpSMGdzMDVwaGRDWTNvTG5OTkU0ekVyc0U1eEo5YVE1Z2xoT0x3d3lpUE9kSnozcmE4NTc0eEVVT2xIQ0FmcFlBRE01NHdRb1FRTkFrY0tHSEplaW5RaFdhQTJOd2dhQVFoZWdLZE1qUGhWcjBBTUY0UVVRM1dsQWIrZUNpSUQxQUJYSEIwWklpQUFnVXlrRklRMW9DWFF6VXBDVTlxSHNTdXRLUTZnS21NSjNvZENwYTA1QUM5QllheFNsTWs0Q2JqL2EwcGo3QUJSQ0VLbFNVQ3NZQ1J6MXFVbSt4VktZS2RRSnEvNkZwVkd0NlU2c0tWYWN6VWNOV285cFZyd3JWRFI5QndsaWoydEpjdk5Tc1FqMURQQ3lnMWJYV1ZBNjZjQUZjclFwV2MvRFVybHdGUmxEM0tsU2loc09vZ08xcFE0MUJXS3M2ZFJwZ1NLeFVFMkdGUC9TZ0Ixc294Ulgrd0FNZWFFRVJWVzBzVGw4Z2picEs5cUpLVUVRS0JzRGExcVpBRkNRd2dHeG5Td0pGSkVHME9PMHJNUDU2V291V1lLU0YyRUpyaDl2YXpIWkNDN05ON213L200aTM0cGFqaHRVRlludDdVU1FvQWduRXplNEFPdUVDNVhyWEFJczR3M05oK3RoYXFKUzZJRlVESTdTclhVNTg5N3VNY01ONFRTclRXWmdXdlFkbzZ5SjZ3TjdzR2hjVHlIMnZjbm5RQ09mT2w2QzZiUVZ2OFN0U1IvUTN1NjlOeFA4RUZFQmhCV0ExRWJFVnNISWRNWUVEUTljVmFtWHdRcWZhaUNVOE9MdUlZRU9GVjZ3QU5pQkN3OTRsd2lOQzYyR0N5bFVWSWw1b2FoOEJoUk9qMkJBbllER0xUM0FJR0h2M0NaQzRiWTBoaW9yejVsaS9qMWl0ajRkckNCVUxtY1V1TG9TUmxWdmJTQmo0d1BVZFJZNzd1VmhJOEdIS3cxMkNJYTU4WlVNUVljdkp6VElrSHJwa0JKUml3YjBsY1NUUVBGenJFbUxDYkdieGhRa0I1K1JTZ3NiempXNG9STHpqU1dTQno2eU5NQ0VDM2VaQ1pMalFiYWlFa2c4OENxaWlGOHFUZ0RSckQwRnBJUnZpQ1lXZTdTVyszTmhCZ3dLOVA2MkVsUG1zNWpXWGVzV0hlSE9xdTF5SndlSzIwM25HUkk5RmpZaGI0N3JJcVRZQWtpLy9nZWk5dXZvVGttMzBKVVE5Z0I0VTI5Z1VSZ1FQa2czZVRHeDZyNlJJTEhBcndWOWlYeHZiaWVBMmdUUFJZY0tTQXM4cjliTW1xQzF2VzZNYkVkMU5OaWZFYTFaRkx6cXE2dVdFaVNFdGFWSmpXd0dLdURTY1pjd0orVnJWRkU1bTZTZW92WWlESTF3UjNQNEVxeU1hNW5DSHRNeWNtRFdhYTUwSWl5OUMxNFhtTlNmb1hOSlZnSUduL3dRRmRzMnRDSk12Z3RzdUFJVkFJWm9FMGdhRTJ0YXUrTUVac1cxOSs3RGNrRzZFelcrZTdIWHprTnBRVVByUUdZRnFvKzl3NEh3dWVNMm56Z2lGYjVuaE9SeDIwaDJ4ZEVad2U5a3ZGUG1Vcy9DSXNpK2lEY2xXZVl1RVMzT3AzOXNSR1g4aHRma0FDYmN2Z2cxNWJ4SFMwYXgxLzBiNGZSRmVON0xUTjBUeFNCeWU2YWx1RWRaSExvbkhLd0xsQzkrUTJQazhDY3RqUE5sb3h3L1FPODkxU0JROThnRTZjOTM3WG5wSWNGdk81YUgyZngzZitrY0VHUFhsZVRUQksrRjV4Q2M3MDdGZlBlM3ZQb25BSzBmdFBpWTU2WWt2Q2N4dldlNmltZm5ZZVYvN1NPQmNPYU8zUk8rSmJ2ekwwSDM2MUdkKzhaUE5YTkVnLzhUMXBzVDJHWkh2bE9ORzFJVmZ2ckV6a1hnWXZ4LzgycS8rK0F0OWY4cG5ZdjJONEh6MjF4cVRkMktiQUlDTlVHaGc1MzFveG5lYWdJQ01BSGhiVm42aWdXYWNBSUZtdDJYVDRXT2RnSUVacUdIYUlYM2FsWDZZNElHTDBIN2ZsWFBsVVlBRG9Id0hxSCtYSUlBTGlCOVJGM1dnWUlLUGdFeGtvWmRQaGdlRFBMZ0tPUGlEbnhDRVF0aUJQbGlFcDBDRVNLZ0pnSFpyejdhRVFEaC9VUGdLVmtacHNEZUZyQkJrZ1Vaa1dBZ0xWWWhsWFRnTFRXaGhZVmlHWm5pR2FKaUduQkFJQUNINUJBa0hBSDhBTEFBQUFBRElBTWdBQUFmL2dIK0NnNFNGaG9lSWlZcUxqSTJPajVDUmtwT1VsWmFYbUptYW01eWRucCtnb2FLanBLV21wNmlwcXF1c3JhNnZzTEd5czdTMXRyZTR1YTRjQWIwQkhMckJ3bzhhdnNZQkdzUEt5NE1xeDhjcXpOSzZ4Yy9IeWRQWnROYlcydDZ3dk56SHdOL2xxdUxkNXVxbTZNL3I3NlB0eC9EMG4vTEc5Zm1iOTc3NjJSVi9BSWJpMTRzQktBQi9FUHJieEVTQXc0ZE03Qkg4QktDaXhZb0xMWFY1eVBGaGwwNEVBM1M2U05KaXhra2RVd29BT1pGVHlaSW5JNmxVeVNta3k1Y3dZemJ5TWpPbGtYMEVEV2JDaVZNbm80WTlPd0xsdDRub1M2T0xrcWFNbU1ubVVLYzVvU0tTbWxLVFZVeFlzMm8xeExXamhhb3RMNFVWTzVhUWhiSWMvejllQ2ltMDBscTJiUVh4aFBzUTAxZTdkeS9tUGNUMzRZYTVhU2tGRmp5WWNPR1ZsdjVPV295eDhhRzNoYWxTa2h5SmNtWExaQjhMbkVRWE1HWFFoekk4UHJzNWNXZlBxTGMrOXRLYTZXVFlzUThaZVF4WkVtZEhuaFhtRGwzNHNHL1h3SEVQTjFTQk4rbWdrcFF2TjRTVXIrWkh2eGNGbjU3SWVhVHNpYlp6UjdSaDlYZmsycVdQTDhUN0ozYjA0ZFd2SjdTM01LVFN5VS9QUjRTWmI0YjN0alVpM242eTJlY0llSWJJUnlBaDFjSEZHaU1JRWpMZ2dvNFZOcG9pRVFveUlZV0dsUGRZSS9ncHNpR0g3RDFtSElid1NhZ2dQR0dNc01DTEpvUUJ5a1lmTHBMaGlKcVEwUUlCUERaQnhpb3ZCaW1rQjUvMEI5ZDFoMFNJSS84bWFQRG81Sk9vZUNEa2xEQis0bDBpU3VyWHlZNVBka2tBR3FaUUtlWUNRM1RTWUZrUEpna2RJa3RXOG9hWGNCSlFpb3RqaXRsYkpyekpwV2FBQ2E1SXlSNXh4dGtFS1hVV2V1SWxIaHE0NXozeGFYbUpFNEZHT3NvR2hSWTZnaWE4SFVwSWRtMUcwa1Nra1RveFNxV1ZDb0ZKY3pVYXdxbWZqd1FCS3FpVGtrcXFqSllZV1JhU2dvUTRTS2VOa1BIcXE2S0tJaXVwSm1ncWsyaXFJc2NySTF6K0t1bW93NUo2S1NXcUZaWm1yc3F5dXNpbnpyNUtDcDNSbGtySmxZT0VJdzg1S2k1R2lhdmR2am9vb2VIS1NtUWt1MldXckR4OU91cElrKzMrYW9xVThSSXJpYTFjR1ZJTk90aWtHNWdremZZYktaaW5CQ3pydEkra1Nvai9NK0pFays5ZG5qcnNyeW9DU0V5cXFZNmNLUlVpQjEvRHBycU9zT3R4cEh1NEFxN0lZeHBiSUZmWEZtTHVMeUl1M0Fpa0wwZjZMaXdtMEZ5bkNZMGtLaFZ0VjNITWJOQ0J0bEFMd0VhTFdXWlVaZDBVRmlOdlFoMG54TFlJVWZXWWR4cENZMUo2Tm8yVklvQjZEV2NRd3N3OGRwV0oxRWNUUlU0bDRrVERidmZJVE5GekMwbnhaU2xaZ081SVJTWENiZDlPU2oxTkdJRlBTVElpWG14dzJCU2xtQ1NjSVM0enp1T1Azb2dkZVpEekNzT3Y1enpDclk3Y2M5T3FpNitvRXpEME80QkhMa3pzTFFSYlQ4aVJJNTBMMzE3SG5ORVF0dWZpK1J0UTFXNjA2N1hBN3JYaldsRmE5ZVMxZFA2eTdtMkpMakwxdEZqZnIrcWdzVDZzL3k0dnp4NmI4c05LWVh5LzBFOUh0YXkrNHdMOHd3UnFYMmt3UUw4Sy9vTGlDOGs4THM0VEZJa0lnYjRnTVNOTzdSdWdJRHdBcmhoTlEwZE9hZ0xZRkVqQkNscndnaGpNb0FZM2FBZ2ZIT0NESUF5aENFZEl3aEthRUlRK3FBY0dDc0RDRnJyd2hUQ01vUXhuMkVJTVVFSU5KOHloRG5jNFFqV3NBdzQwREtJUWh3aERPRVNpQkR4TW9oSk5XQUp6c0lDSVVJemlERm53Q0J3dThZcFlQSUFQdlFGRUtYcnhpd1V3WWlPeVNNWWxmZ09NYUpSaUl6eFl4amJxTUlYWldHRWE1eWhFR3k3Q2pYak1vVGJveU1jZ01pS1BnQ1RoSHZ0SVNCaitNWkNJL09BZ0M4bklBaHd5a1lGY1pDTUp5UWcyUWhLUGNKeUdIQ2ZKUnp2ZThmK1NlRHdqSi9ub0NDdUNrb3hiMUVZWFI0bEdNVFlDaWFmRVloUEw4VVJXZnBHS2tEQmxMSG1ZeW5LczBwWkVkR1VrTExsTEUyYnlIWnNFNWd3OXljRm1Pdk9aMEl5bU5LZUpDeVFzWVFEWVRNRVdwdkVGRkNUZ214ZzRBd1pUZ00xeWxoTUp5ampETjllNVRoUlU4SnJtak9jQWh2RUZkdG9UbkNUcWdUejNPUUFvQk9PZUFFM0FEd2lFQkg3eU13VzY4R1pBQVNyTzhaRFRvUHpVeFVJWDZzN2x3Qk9pL056bUxlbzUwWVV5c3pINnhDaEVlNENMSDNTMG93TWREQlJFS2xLUzNzS2tKKzFvQjlyeVVKWkNWS0l4N1NnS3FHQ1VMTmlVcFRqTmFVZlhjQkkrL0pTbENNMkZRb1hhMFQ3b0F3bzFQU3BFeTFZTEVUQTFwaWovbUNrOExpclZtd3FEbzFmdEtBWjRhbzZRZGhXajZGUkdXR09hVW0xczRhd3RUVVFFL2pDQkNZaWhGRmo0QXhDQThBSkZ3SFN0RS8xQ05xSUtWM2t1UVJFblVJQmlGM3NDVWF3QUFaQ043QW9VZ1FIQVRqU3J5K0JxWWVPWkFuOGlRZ3lMRGUxaTc5cUpGMFQydEpIdGF5S1dhdGw3ZnZRV1p0MnNQUG1naUIySTlyWUs2QVFYVU10YkJDeWlENjFkYUZ0clVWRFo3ak1Mak1BdGJqblIyOTR5WWczQkRXaERaMEZZNHc0Z3FZdVlnSEp2UzFwTW1MYTVxQVZDSTFnYjNXOVdGQmFhdFc0L0hiSGQyelkyRVR3d2dId053QU5GUEJhOHFIVkVCOHJyV2xjWVZiM21kR2tqaXREZTJ5S2lEZk5Oc0FIYWdBajg4allKai9nci8zKy82VlJWQU5pY2gzMUVGQXBzWUVPUVFNRUtKc0VoSE16YkNVQ2lzaE5lcHdoT1Vkd0xZL2NSaWVWd2FBMkJZQkFybU1HRklERnFKeHNKOHBiM0ZCZkdabG9oa1FVWmg3WUlockN4alEyUkJCMmZkcnFQVUdlS0UxQ0s5RzVXd0pFd2NtaDNVSWo0S2xuQjljMnhreU5MQ1FsSDk3V2VBSENHSjhFR0xTdjJ2WVQ0OHBJTGNkOHh1NkVTS1A2eEtGWnEzQmRQd3MyS1BZU2NRV3lJQ1l5WnpKYnc4VnExR2dyamFyUVNNZFl5a3BNODZBUWZvc21INW5FbHdHclpVZkFacmxpbXhJWUJqWWhLVzNyRWgwYUFpUzloNXFzeUdoUndYZk1sQUsyQVZWUGExQVpBQkJCUzdkdE01UG1xcERpclp6R2hYVktYR3RlNWJuQ3F4ZitiaWYyR2xSUldOaWh0TjBGckxoOGIxNG5ZYmFvNUFWeWhvam5OTEVVdUp3anNaamdMR3RuMlRUV0VPUUhkbUpxaXhRZjlCSzBYZ2V4a0o0TFhuMUEwTzZFY2JINE9tUk9STnZLa0UxSHZSV0I2ekpybWhKUUJ1b290WEZTYm9MQ3RzUlZSOEVYd21ndWc2T1k2TVNEWWhkRGExZ1JIOXlKMnZlME1GdHZOamFpNHhaZWRRVnBISWVVaXp5NitMMGh1TFp1YjRqRmZSSjJkdkc0S2pocmxqbEE1STNnTmNoSUZYTVpzZUlUUUYrR0dWQ2VjUTZDZE9NeXgvWWlaRDVEVzRnNTZ6aGx4QnF0VDZPUkd2amtqbHM2SW5ldVkyUlNhZHlUSVB2U1NMNmptQXBjRTJ3MnU3Z1g5WE11VG1QdktEMTEwN253ODcxdDNCTWtQdlovL0lrc2RFbnJmKzVqNXZSeGFkM2Z0Z1hmRWR3ay9uamFYdXhLSjEzbXE3K3ozdzBPZTZwVHdlbTZPenVHQkF4NzBremk0azU4T0dva0RIZk9SaDhURmgvTjNTMlNlRVlNZmMyNmkvbnJZb3o3MHFWWXRhRWhmWUd2YlB2YVEwRGJDWXdOb3NaL2UxSmt3TzRtWjMvdmovNzRTYnJlTW0wMXZmZWhuUXZYVFJ3M2NDN3lKMjFlZDU3SGhmWUd6amduek82THJPaFkrYUl6TUNmYzd3c21OSjMvOWtROTgvRTdIOWJobGZKcGdmNDZnZkwyRmNkd3hmZ3JBZlFQSWY1VUFmZ2pRYy9QeGNpOEhDZ1FvQ1NiV2Q5U0VjOWUzZ2E1d2dSNG9DaUFZZ2hib2dDUm9DaU40Z3AzZ1paVVdaaXI0Z2Q3M2dxNVFZM0tHWXpMb0NoLzJHMlVpZG9Pd1FJTTN4b096d0lMMEJZUkVXSVJHZUlSSXlBbUJBQUFoK1FRSkJ3Qi9BQ3dBQUFBQXlBRElBQUFILzRCL2dvT0VoWWFIaUltS2k0eU5qbytRa1pLVGxKV1dsNWlabXB1Y25aNmZvS0dpbzZTbHBxZW9xYXFycksydXI3Q3hzck8wdGJhM3VMbXVHd0s5QWh1NndjS1BHYjdHQWhuRHlzdURGc2ZIRnN6U3VzWFB4OG5UMmJUVzF0cmVzTHpjeDhEZjVhcmkzZWJxcHVqUDYrK2o3Y2Z3OUoveXh2WDVtL2UrK3RuQTVFRHg2eFdLd2grRC9qYU5XTUN3NFFoN0F6OVZDRUN4WW9XRWxqdzAzTmpRUTZlQkFqcVZxVWl5WWhtTWt6aXFYUEF4SXFlU01BT2dqTFJ5SlNlUUwyUENuT2tvVEUyVklUWGgxQVJDSjh3R1BCa3QvTWx4bjh0TVJtRmVUS3FJcWNxSG1ZWmltaGkxSk5XcVZwdG1mWHFwNjg2dmlNSnlOREdXWHlZVlp2KzlvajFrUXUxR2o1ZTBWaG9adDZLS3VZZDgybTJJU1MrbHZpU1JBalkwdUtHUXZHUW5jVUJjY2ZFaGpZMVpXaklzaVRKRnk0anFOc1pLaVRNa3Jvai9najZVZVVGQVNhWWZlUTVRWmZXaElablpsbzRNQ1M1bERiYlRaZzZ6Misya0JyT0RJeExRdXZpOXc1NUJLQmZlK0RGczNvMG1lNTZlcVBsMTQ1R1NjMGUwZEREcFI3RVZvZTQ3ZGJ3aEtkNGhwVWRFUWJ6N1EwSnlSNXAveURkaUR2ZDFsMWxRanZCWFNGSGJCWWlJWUkzSmgxMGlzeW1tSUYyWkRZSGVnNGRvNEpscUUxSTMySVhnTVdKZmg0ZVVaNWR1akJnb2lIL3NrUWhXWTY4bG9tSjlDYnFJU0g2Wk5hTGliQURhS0dCMUtXSTRpSGFVWVFTR0VnY2tXUUwvR0tCZzF1QWlCczUyMGljQVZHa2xBS3NrcWVXV09Yd2ltbmxRQ3ZuSGVuRnh5TW1WYUdKNVNnNWJ0cW5rSi9FdEorYUltNlJwcHlsdTVubUFHcDJZcUJhS2g4ekhZbHp0YVdMbm9hVWdxV2VlU0hEU0dsNkJZc2hYa1hVZWFpa3BpMllhVFNZNFBobHBpSVh3YUtpbHBJNWlRYWFaS3FGSmE5WVpFaHVSaUkxS2FxbWlvSXFxRDVoc0VDY2hzYzJHa0NXekJtdXFyYll5YWNtWGRwMDNpR2xrbW1YbUpNRkdxMllveE5wYXdxYVV0QmJqSDV6UlNHa2wwZ283U3JYRXFrb0pibzBCS2dobmc1b0ZIQ1hoUmt1S291VGVtbTJPaFlRano3WjBQaEt2dEtYVVcyMlgrMldtTExmUEZkSnNWOUpGOGkvQXBiQXBzTFdTSUt1Vy95SFZvSU1OSVJ0SzhqREVlRTVzcTdtUDRGdUlNK0pneS9HM2pud3NyeXBJaUd3cnJvNzRhUlVpR1YrRENHV0ZMdUx5eTZ6UUs3T2VLcjhZbHJyNUdyTXRJZTBhMWZMUHM4cFN3dENMbHRCSXAxWVJsd2x5Y2ZYb005U1gwaUl4MVhueXVZaGRPWm5GQ05pMDJ1SUQyWG8ybW9pVFAwR2F5YVJHVFlrSTIySHJJalRjYnliQ29FMmZSQ1doSVh3anVzelVnRzlKTW9WcnpRR0tBKzArVzBqaWFXWURSdU50MHJ5Z0VJOUpVVW9ESEFCWTI5NllvL25OMjV4clNiQXdxYXV1enQrQUc2dEw3RmJXd3pqbnNPT3VUOHljVzUyTDd4aXB3ZnZ3bUZPMU85VzIxNUk4V3FlUzdibnpmRnZHdXN6VDA4SjJjTFJYZTd2TDR5MWZMZjhFeVA4YjROakVDby9Md3gxZWoyb3c4ZnJZL1piTnJ5K3VqNEtJcnlVemZlTS9TQTcwV3RJMDd1Uy9BaHJ3Z0FoTW9BSVh5RUJFOUdBQUVJeWdCQ2RJd1FwYThJSVI3RUU5Z2tDQURucndneUFNb1FoSFNFSVBCb0VTV2NDZ0NsZklRZ3BtWVIxdktLRU1aMGpERUw0aEVpbG9vUTUzZU1FVW1LTUZOUXlpRUVuWWdrZWtrSWRJVE9JQVh1aU5HQTd4aVZBa3dBMGJvY1FxOHZBYlVjemlFQnZ4UUN0NmNZVWF6QVlIdFVqR0daNXdFVjlNb3dxMVVjWTJ5cEFSYW94akJkbm94anFHRUk1eXpDTUU2V2pIUGhJQWozcVVJeC85V0VkR2RER1FhUXpqTk1aSXlEYWVFWTJJVENNV0c5bEdSeHd4a2xWa29qYWNTTWtzVHJIL0VUbkVaQko5V0E0Z2RoS0tSWVRFSlVYWlFrMldnNU9uck9FbkkzRklWbDVRa2U5Z1pDeEorTWdHK3ZLWHdBeW1NSWRKVEZ6c29BZ0tTT1lKeERDTk1iQ2dBTkE4Z2hrU2VJSmtXdE9hTzFDR0dhREpUVzZ5d0lESXZLWTRGVENNTVhUem5OSDAwUVRHeVU0RlJDRVk2SXhuQVREUW9SMjBzNTBuME1VejVSblBhZDZubXZkc3B5NzR5Yzl2Y2llY0FXMG5NMjloVG9MeTh3akJXV2RDQXpvQlhHREFvUTZsNTJLaU1OR0pWdlFXRjhXb1EwTXdGNEIyTktBREZhbEREY29UTnB5MG95bFZxVVBoZ0pJc3ZMU2orY3pGUG1YcVVEL29Jd29tdldsQUxaU0xGL0JVcEN4OUIwS0ZpbEpoTlBTb0RvV29PaVRLMUlSbVV4bFEveFdwUnJVaGhxcDZOQkZYK0FNUGVLQ0ZVbERoRHovNHdSY1VFZEtzRW5RTTJRaXFWOGRaQkVXUXdBQjR6U3NKUklHQ0JQajFyeWhReEJIY1N0Q2tDbU9wY3hYbkNkNkpDQzNrOWJGNUxXc252dkRYeXY1MXJZbllLV0hSS1ZWZFVEV3g0M1NsSVZ3QTJkSWFvQk5uc0t4cUU3QUlQMnlXbjF1dGhUMUJ5MDQyTU1LMHB1WEVhbGZMQ0RpOFZwNytuSVZjYWF1QW5DNkNCN2d0cldReFFkbmRXdllIamREc2I2RnAyRllnbHJqdWRFUnlTN3ZYUkFBQkFlQkZBQkFVMFZmbld0WVJJWmd1WjExaFUreGU4Nk9OSU1KMlM0c0lONFQzdmdod0F5TE1xOXJZTHFLdDZvV21UMVhoM212VzlSRlBtQzk5RGJFQy9PSjNCWWZnci85cU93Q0p3UWFZbTZpWWJZR04rNGk3S3ZpeGhyQ3ZnL0dyMzBKSTJMS0JqWVIwcHh2Y1VSUTRtVmVGQkJzKy9GZ2lHR0xFSXpZRUJrNWMyVDVJWXBzWExrQXBycHRZK0VhQ3hvOTFRU0craTJQOGp0ZkVQUDRySlFEODI4Nkd3cjBIbmtRYmtJelg3aEtpeVRrdVJIbWp2SVpLV0hpNm8rQW9iVGs4Q1M3ajlSQmdkckFoT2hCbEtWdGl4VmtscVNob3U5QktlQmpKTnI1eG5POTdpQjNYT2NXVmVDcGgwMXhrVENUWXpZZ1lOS0VqWE9jRVVQZ1NWRDZxbnE5YzFTeGZ3czBHNEVHa0pRMWVSUHlnMHF6TnhKbVBTb3FxTWhZVHlJWDBJU0pBNmxMdnQ5TFF6VVI2b1VvS0l0OVR0SjkyczVKSFRlcEVwTGJTbkhDdFRLMy96T21KMnBZVDh1V3lsK0ZjYS9KVzJyK1k4SzFJVGFGaGZINEMxSXVvTlFJV2dlcFA0TG1iTFc1MU8yUE1pVC9UT05DSW9IVzEyVnBwUkhNQ3lQRmNoUmdRdWt4UWtGYldpaEEzSTFCOUJsQTRrNXRIZ0d0Q1FDM3FjTTliRWFkR3RnSmp6ZVZHQ0h6Z3VGWWdxSjlnOFljcmdzNFNQMkMwa1R6dFJNaTcySTBZTTQreGJhTkhWOXdSRjI4RXFpL3RQM2QvdUEyUGlEa2oxbER2QWpvVzRCMUh1U1BLN1Q5UVB4dm1IbWRFSDRodUk0clR1T1NMT0xta0k2SHlFK2ZhUmVDT2hNNkhIdklPamZ6ZGt0aDZJd3dkWlphUHgrVklub1RZWlY1cG1nZUk0V3BQdWlNaVh1Y0p6UmpvajVENm9DbUJhaCsvM2MzTDFicmNIZEhjLzdyZlo4dlNyc1RhSFZGMUNaZlpQVm1ueE9LNWJuanUyRnpCOEk2NzBDZEJkaDdiMnpiL2Zqa2w5QjduU3hCOE9uQzN4T1RuenZUVi9GejBpaDk4SkZDTjJkVmNmcjdEVnIzc0lYSHNLSDkrTVc2R3V1YW5qb25HOHpjNGVCLzk2aUhSZGN0d09mTzYzN3dsT2kvaDRIeDl2cHRZUHZOWEhwelh6L2ZvbU5EK0k1Wis0dHF2aHNhY0VQOGplTXdkQlhPQzlHRHVSUFc1RTNyVDVsNFQ2bjlFNzFkYmNQZGMzd0RRaDMrN04zMzlSU0ljeDNHZ2tIK1RRR0Z1VjB5TW9JQU9PQXJ3MTJRUk9Bc1FXSUdoY0lFWStBa2F1SUdkd0dTRDltUWU2QXJTTjRLcklHSmdWbUltNkFvTjFtUVF0b0t3Z0lJa0JvT3pBSUxpUllNNG1BbURPcmlEUE1nSmdRQUFJZmtFQ1FjQWZ3QXNBQUFBQU1nQXlBQUFCLytBZjRLRGhJV0doNGlKaW91TWpZNlBrSkdTazVTVmxwZVltWnFibkoyZW42Q2hvcU9rcGFhbnFLbXFxNnl0cnErd3NiS3p0TFcydDdpNXJrSUx2UXRDdXNIQ2owTyt4Z3REdzhyTGd5Ykh4eWJNMHJyRno4ZkowOW0wMXRiYTNyQzgzTWZBMytXcTR0M202cWJveit2dm8rM0g4UFNmOHNiMStadjN2dnJaRm44QWh1TFhLMVNGUHdmOWJWSnlvS0ZESmZZSWZtSWlvS0pGSmdvdDVYREkwV0dPVGdRWGRPcGlzYVRGTGhrbmRWeDVBS1JFVGlaakNrZ1ppU1ZMVGlGaHlveEoweEVZbXl1UjdIdVp5Y2pPbUY1Nk1tSUl0T05RZnB1T3hzU29WRkhUbFJBejVjeEVVYXJKcWxhdk90Vks5SkpYbm1BUmllMVlnaXhVVEJiL3puNU5lNmpFV280ZkwyMjFSRkt1UllGMEMvMjg2eERUM2twK1N5WU5iSWl3UXg5NnkwN2FrTmdpNDBNYkhiZTBkSGhTNVlxWEVkbDFuSlZTNTBoZEV3TU9YVWp6Z2RXUlRrUDZMR0FLNjBOcU5MYzFMUmxTM01vWmJxdlZESWIzVzBsZWFBdEhoTVMxOFh1VWFCdFpQdHd4WkVteUdWSCtURDJSYyt5OUd5bnZqb2dwNGRLUHNpdEs3WmNxZVVNUXZrTlNqNmpDK1BlSGZPaU9IVjdSNzhRYjRPZWRaa0tsMXg4aVJuRW5JQ0tET1RiZmdZZlF0dGlDZFdtbWhvSEhNWkxCWjdCUjJKcG1HRUxueUgwZUhtTGVYYnN4UWg4aC83VlhZbGlPZFhqSWlvTFlwK0NMaU9nSG9vb1FEa0piZ0RnT2FCMlBHU0t5WFdVWmJiSEUvd0JNcHJBRktKazV1QWlOdEtIMFNRTXFCS0JsQlEyc3d1U1hZQmJZeVdqblRka2plM0xKaUVrWldyYnBKaXBJZ0Nsbms1L0loOGlLSkc2U3BadDhCbENHS1hNR09rQVduWnk0Vm9velF0aWlYTzVwb2tHZmtBWlF5cEtDQnNvSEo2N2xsV2lSaFBTRjVDWWdSQnBwUXFKVWFpb1VtdWdvNWFZaVJ2Z1prSmhRSU9xc28wQmhxcWxMYU9MYWRZWmtkMlJpbWxRdzY2d1VqSExyclQzQVpTY2gyZEZHYWlVY0REdHNyY2NlKzZRbFpONkYzaUN5b1htV21vODBJSzIweFpaYTdhMHBvRnFKYXgyZVp1T25sZXc1THEzR25udHNycFRrNWhpaWdweTI2Rm5CVVNMc3ZOS1NRcW05eUZLeTdCL2h5RU1PSVhrK0VpM0IwajRiQ3YvQzU0cjVTSE9rOWRycUlONTZOVjBrYkZJOHJpbHhZbnhzQ3BKa3U1WWgxYUNERGNTVmdadUl2Q2JQK3VjcEtsZUw3eU03RnVLTU9ORVljcU1qQStjOHJTcDg5SHhzc280WWVoVWlNVitEU0dXTkxqS3gwck9DNE1yQlRndXFMaU9FOFZ0SXc3LzRCMndqc25JOXE4V3RwQkIycFN3em91cFZ4V1dTbkZ5d0tvS3oyM3lxVUV2S2N3ZEs2Q0ozNlhRV0k0OENIdW5PdHZSUXVLQ1hKaElsVUpwbTR1bFJWaUlTcXVPUWNpQU0ySlBUbVVpRE4zMGkxWVNHVVBBMzZBSEFyWXZjcFlQNWM0VnN5UUVLQi8vYW5EVHNXZ28relJhMXl3azFnejVBQmtFcFhtd1FvRzJJYkEyOGxsMTZJM254WDJxc1M4blRheW02T3FTWGZxMy9MdUoySDNzOXRCY3ZqUGtxbEZ0UDA4WFhqY3ZyZ0h1ZFVSYnE1eks5QmxXbFAvZjR0U2lmNDRRSEZsc1Y3bmkxa0I3WDNFZVg2emtOZ2JSUW9NbSt4NXJ3blVzWFhKTmRhUHgzTGl2b3oyUUVKQS9ocWlXL1c5QlBWSkFUa0FOdkZZeTJTWXVDSmJJZ21BQ0lDd0dPS2tpRTRPQ1htQkdwRU9KUUVFZzRtSk9tZ2FVMlZTQ0ZQMHlpRXBmSXhDWTY4WWxRTE1RRUZFREZLbHJ4aWxqTW9oYTNXTVVKMUFNQVlBeWpHTWRJeGpLYThZeGpwQVFidU1qR05yb1JpMnhZQnhyblNNYzZtakVTSjNpakh2ZTR4Uk9ZdzQ2QURPUWNIN0ZHUGhyeWtBcUlvemNFeWNoR2l0RVJpSXdrSDcvaHlFb0tzaEZUbEtRbTIrakZiRmp5LzVPQVpNUW1SOGxHYllEeWxJTmNCQ2xYbVVWVG92S1ZaQlFsSzJkSlJWZkM4cFlBa0NVdFdXbExYTDZTRVpuYzVTZzdPUTFmM3JJUndpUWxKWTE1U2tjVU1wbVJWR1F2bVZuSlIrUVJtb2YwWXptb2FjbElQQk9iYjVUbU5ybkpTRW9FRTV4YkpPWTd5R25IS0xyem5mQ01wenpuU2M5Z3VJQUlCc2duQ2JRd0RUSzBnQUFBYlFJYW1raUNmQnJVb0M1UUJob0F5bENHdGtDSitEeW9SQTB3RERJMDlLSUJEUklQSnNwUkF6d2hHQmdOS1FHQzRDRVhkTFNqSk5ERlAwVWEwb0hpcDZBbjdhZ3VXTXJTaDNZbm9qSHRLRDl2WVZHYXNyUUp3dGxvVG1QS0Exd0V3YWMrSlNsam5qRFVvUmIxRmtkRnFrK2RRQmVZTmpXbU0vK1Zxazl0MnBNMlhMV3BXZFdxVDkrUUVqWjh0YWtwemNWS3hlclRQZWpqQ1ZZOWEwempvSXNRc0ZXcVhIMEhUdVdLVldIMDlLNCtCYW82aE1yWG5DWlVHWUNWcWxLMW9ZWENPalVSV1BnREVJRHdnbEtJNEE4WXdNQVlGQkhWeE5LVURObUlxMk1uU2dSRnJBQUJxRTN0Q2tUQmdnSzQ5clVzVUVRVFBFdlR2QXBqcjZPVktBaytpb2dYcFBhM3FhMXNKOGJ3MnVLK2RyT0pXQ3R0TVNwWVhSQTJ0eE1WcHlHNEFOenFJcUFUWmpDdWRndXdpRDBzbDZXTHJZVkpvY3ZSTmpEQ3V0Ymx4SGEzeTRnM2ZGZWtMcDJGYU1scmdMUXVBZ2pvcmE1d01VSGM5Um9YQTQxUTduc0JhdHRXNEphK0huVkVmcXU3MmtUOElBRVFUc0QvRHhUUld2OGExeEZPR0RCelhXRldCQi8wcVkxSXdvS3JpNGcxUlBqRUNWZ0RJaXlzM1NNOG9yTWFCcWhiVmVIaGc1YjJFUk1ZTVlrTmdRSVVveGdGaDJDeGRrTUFpZG5HbUtHb0dHK043ZnVJMCtyNHQ0WXdzWTlSck9KQ0NObTRzWTJFZ0FjYzMxSFVPSitIaGNRWm52emJKQmhpeWxNMnhCR3VYRncvU0dLaFJ5WkFLUTZjV3hCSGdzeS81VUloSG94bUZFL1l5bXgrTFNWZy9ON21oc0xETjU2RUcvQ00yZ1lUb3M5cExrU0ZBdzJIU2hoNXdLTmdLbm1aUEFsR28vWVFrUGF4SVVJUWFFRmJZc3VKcGFvb3lMdlRTamdaejJZK2M2aFBmSWcxbHpyTGxmZ3JiVE5kWjB6azJOT0ltRFd0ZzF6cUFoRDVFb1MrcTZvUC8xM1lSRi9DMHdnQVFyQ0ZEV0ZFWUtEWTNNM0VwZTlLaXNMeUZoUDRCZmEwcVowSWJBTTRFeGtHTENub2ZGTHBQdHZUZWg2M3NCT1IzV0p6d3J0aU5UU3poMnBlVG9pWTBZNEdOYlVUUU9GaXU1Z1Q3cFdxS1pTTTBrOUFleEVESjdnaXNQMEpWRGUweTkzdWFKZzU4V295eHpvUkVWK0VyUU9OYTA3QU9hU3IwQUpPOXdrSzZvcGJFU0ZmQkxiTkFBcC9NclFKb0ZVSXRLVU44WUV6NHRyMmRtSzRHZDJJbU11ODJPZG1JclRWQ1hLZk00TFVRVi9pdi9FY2NKZzduUkdUWnZQQmsvaHJvanZDNkl6QTlyRi8yUEVudStFUllGOEVISXBkY2h6NTl1VkZ2M29qS1A1RGFKOEJFbWxmaEIvb2pxT2hrN25xak1qN0lySis1ZitrbCtqaGtSRDgwVXVObzZsN1hCS0tWOFRJdFY2aXJ1TjVFcEdmZUxISExxQ2RZMTd1andBNjR4YzBacmpqSGZTUHdMYWJPKy9wL1NZZTlZN283K2pmczJpQVZ5THpneTkycGQrRGVFcmdmdkdCZmsvWmRmenh6NU83RXBPL2N0dFo0M0t2M3g3MmtKZzVkVHh2aWQ4dlF2VEJGODdibmYvODQxc0MyOGhsemZCSEhPL3FReDhTOVNhNWNEd05lT1BQR3hPRUYvTDZ1VzkrNzE4aTZxRmhkUEhyLzM1TUpKL0Z3dUY0STdZSjF1Y0lnYloxb2JGOUkzWjNtbENBamJCM1Z4WityRUZtbk9DQWMzZGwzYUZqbldDQkYyaGg1TkY4MWxWK0RYaCtsSkIrMjBWejd5R0FDTEIvSTJoL20vQi9DQ2dnWHNSMEZVaUNtRUJrbkZkSlQ0Rm5nenFZQ2h6WWc2THdnMEFJQ2tJNGhKNVFoRWJJQ1h3MmEzK1doSzdnZ2s2NENsSUdhVlVXaGE3UVkzMEdaRllJQzFOSVpWczRDMHNvWVY4NGhtUllobVo0aHB3UUNBQWgrUVFKQndCL0FDd0FBQUFBeUFESUFBQUgvNEIvZ29PRWhZYUhpSW1LaTR5TmpvK1FrWktUbEpXV2w1aVptcHVjblo2Zm9LR2lvNlNscHFlb3FhcXJySzJ1cjdDeHNyTzB0YmEzdUxtdVBnZTlCejY2d2NLUGFyN0dCMnJEeXN1REpjZkhKY3pTdXNYUHg4blQyYlRXMXRyZXNMemN4OERmNWFyaTNlYnFwdWpQNisrajdjZnc5Si95eHZYNW0vZSsrdGxRZndDRzR0ZExBNmdOZnhENjI3UmtnTU9IUyt3Ui9EUmlnY1dMSXhaYVF2S3c0ME1rblFnZTZPVGhvc21MSGpSTzhzaHlRTWlKbkU3S1hLQXlVc3VXbkVUR25DbXpwcU10TjFueTJVZlFZQ1lCUEdXRzhjbW9ZVkNQUlBsdFNpb3pJMU5GVDFsR3pLUXpVMFdxSjY5aXpRcVZLMHhNWUh1S1JVVFdZd3F6VXY4eG1VZ2JkdTJoRkcwN2dyd2swbWlsa25Rdm1yQjdDR2plaDVpNldncHNjaWxoUTRjZjl1QjdscElReGhjZkgrSVkyYVVseFpRd1c5U01DRy9rclpSQVMvcktlRERwUTUwSENKelV0NUxvQlZKZUg4clMrVzNxeXBIbVloNmltMjNuTGIvalNncHp1emdpUHJHVDN3c3RXb0J6NDVFblMxTHQ2TExvNjRtaWJ5OHFxVGw0UkU0UG8zN0VuUkhyd0ZiUEc3SWlIbEo3UlJ2TXl6L1VvM2VrKzRrSXg1Z1ErNFhYMlZEc0FiY0lVdDhWaUloaGtkbEhuaU8zT2ViZ1haMWxrYUJ5akF3aG1tc1hZbmZZaHROUjJHQ0k2UG5YQ0lDRkNBZ2ZpbU5GTnBzaUxBNlMzNGt3OGxjZmpSTXFjaHVCT1JxWUhTTTEvdUVkWmhxSlVZVC9Ba3llSUFZb25FVzRTSkczcGZTSkZ4WUlvQ1VUWHF6QzVKZGc3dkNKYWVwTnFXQWg3OUVGSWlkZGFPbm1tNmpzQU9hY1RYNnk0eUUxNnNkSmxtLzJLVUFYcHRBcHFBSnNkSkplWHI0aFVoc2lMdElWbnlZWitDbXBkYVFzT2FpZ0dtNFMyMTU0bmlrSVlFaHVZc1Nra3pKQnlxV29ScUZKZjUwbEF1Q1BtbFJBNnF5alJJRXFxa1ZvRXB0Mmh0eDNKR09hTURIcnJCV01jdXV0RTJBQ3haMkQzSGViUXBac01PeXd0UjU3N0pPV2tKblhlczMyT0VpYWFhMDVpUmZUVGx1c0tOWWVlNEtxbGNRMm95RGMzUmhxSlh5V1M2dXg2UjZiS3lXOFJaWm90eHdLMG1oYXhGRWlyTDNUVnBxdnRjbXUxR29oNGNoRERpRjZRaUl0LzhMVG1ucnF3dGFLR1FsMHAvVmFJaUhnZ2tVcEpHMWlYSzRwY25Lc3JpVGF0bVZJTmVoZ1F6Rm00alpTcjhxekFucUt5OWJ1KzhqRGhUZ2pUalNHNE5qSXdUeFRxMG9XUUIvYmNDT0hrb1VJemRjZ2d0bWppMXpjOUt4R3VHSnAxSmV5eThoaC94b1M4UytLREp5VUk3SitQYXZHc0p4QTlxVW5OTUlxV2NobHdoeGRRQzZ5czl4OVdsQkx5M2NMV3VnaWVlMlVGaU9SRWo2cHo3Wk1rUGlnbVNJU1pWQ2NaZ0pxVWxZaU1xcmtra0tieTlpWGY1bDNJaERpOUFsVkZocFN3ZUNrQzBEM01IYW5EcWJRR0xwMWNpZHpESnd6SVV6WHJxWGgwNGloKzV4VEY5YkRaRmFVRW9ZUUJPYUdpTmZHYTltbE41WXYvNlhId3FTY3ZmK1dwbitEdXU3WTZrTHUrTGJYay92eXdyQnZ3Ym4xUUwzODZyalFUbmpZR3JFQmZ5N1p5OEJWM25lMzlOVmlmWkpEbmxoc2xiam0wUUo3WDZPZlhib1hOUWZPQW9JcUs5OWp6cGN2WFh6dGRzVWhZTG9pQUVDVktmQThpTE1XL202aFAxSlJya0FVdkZVdzRqWXREVHFJZzNNeUlDNFFXS29nRVVLRVgyTEdwRTdvUTBIc1lHeE9tZ2FXM01TRUZ4YnhpVkNNb2hTblNNVXFXckVRUERDQUZyZkl4UzU2OFl0Z0RPTVdlVkFQRGdUZ2pHaE1veHJYeU1ZMnVoR05IS0JFRzhSSXh6cmEwWXR0V0ljRzNzakhQdnB4alg1eEJBbnVTTWhDaHBFRTVsREJIeGZKU0RlcTRCRnpOS1FrSjJtQVBIcGpqNDNNcENZREVFaEZVUEwvazRiOHhpWkgyY2hHWkJHVXFLd2pHYk5oUmxLNnNvOXhYRVFxWjBsSGJienlsbnhrQkMxMytVVmI0dktYYTlRbEw0ZXBSVjhDODVnQkVDWXhlV2xNWlA2U0VhZGM1aXhYT1kxV092T1dzWlNsTkdjcHltdmUwaEdSM09Zbkxha05USHB6bEoxVXhDREZPVWxFbGtPUjU5VGtJeUVSVG5iZWtaemxNR2M4LzVoT1IwVFRubUdrNWp1c3VVODNadk9LQ0Uyb1FoZkswSVk2RkJkY1NBSUNKcnFDRjB3REFCak5LQUNtdUlLSmV0U2pYRkNHUmtlNjBTZEs5S01vUmNBd1NNclNJQUVocFRCRmdBVnJ3ZEthaG9nTE1ZM3BDblJSMDU2V1ZENGR6V2xNZWVwVG00TG5wRUtOcVVWdlVkU2lGdWVsU1JVcUVIRFIxS1pxWmdKUi80M3FWSmxhVmF1dUphaFpGU3BSdStwVW43Z2hyRmtkSzFsOXFwSXpvRFdyTzgzRldydXFqd21BOWExQ2RZRmE1MXJXZHlBVnIySVZCbC9KcWc2b0FqYXBJUlhwWUwycWpSY2NWcXVKb01JZmZ2Q0RMNVNpQTM4SVFoRElvSWpGVmpVYmQzMXNTcE9nQ0JRazRMU29SWUVvV2tDQTFycTJCWjMxYkYrRjhWZlJvblFGTXhYRUYxRExXOVJhdGhOa2NLMXdYY3ZaUk1pV3JjRXdyRzFUZWdaRm5LRzMwRTFBSjlBdzNPb1NZQkhIUmE0dGNMcGNtTHFCRWRHTkxpZXNhMTFHWkxlbnRRaHRkeEVRMTBYOElMelEvUzBtZ2t2ZTRRYWhFZWR0YVN4cXUxNlpPZ0srMEZWdElqQlFnQUlYQUFPS1lHMTloK3VJL09xWEZXN3Q3LzlIdDlvSURBQVl1b2lBZzRFM1hBQTRJR0xCMVczQ0l4eE0wbFZJK0tPa2ZVUUhMb3hoUTdDQXd4eG13U0ZBWEYwblFJTEVJejBGZDAvYzNrZVlsc1c4TllTR1ljeGhEeGVDeHNPRmJTUndqTkZUbkhpaWlZVkVINERNV3dRWGdzaEVOa1FUa0N6Y1BVaUN5VDhWQlg5dFMrRklVSm0zelNVRWdiSE1ZU3NUZ3N2Q3BRU1RTU0hoRkU5aURXYytyWUFKd2VZc0YwTEJjSDVESlVnOENxeDJ0OGVUeVBOcEQ5Rm5HQnZDQ1hCMjdTVWNQSXJ1THJVU1B6NnptL25jNkEwZllzdVJWdktnczF0b01tTml4WXBHUktjOVBlTklFOERHa3o1dXBROXI1MHNvT2dFL1VQV3FDNHlJSUxqNnVwbndMSjBCbTF0SnZEZlZ1dDcxQlQ3LzdPcjdCbnV3cEJoelR0T3NpVnRUMnhDNzVqVWlxT3RxVHZDMUZHSDlMaWNzbk9jOU16cmJDWGExaUwxTjExTHNXS2VmdVBVaXNsMkFSZno2RTU5MWNreWp6SWxNVTNuVDU5NzFJa0FOWjFHejI2aXBlQUZTS3dxSzV5SmJFZlJldGlKK2pRWlFQRmdmdDg3MXZORzlDRjkzbTRySHpuTWo2TjJJWHp0YmlyZkdMQ05JemdoSWZ6eUs1RDZ6dVNIT2NVWUFtc3ZyZmlLcVJlNklpRHZpMTdBdW9yK0J2SVpIc0x3UmIzQzF3WE8wMjRlUHZPWWxmM21RYnQwSFNCeTlFWHU0ZDVCQ1R1V1pyeHpxamJnNWtrK09JbmxId3VlUTBEcUtZdjV2U1Z6ZEVRVEhPWXAyZnVaSnZQM25yZzU2Z1RKdWQ3QTd3dU9SdnRDVW5XNTEvNy9qUGRKZTNydWk1WHYyYkVzOEV2UU4vSDd3WE81SzNQMFJZcWV4b09WamRrcGMvaEZxdjg3UVdRend4Z3U4RW5GSDh0SmY0M0NlVzk3d2FYZDF4WjNEZDB1Z25SS0FoN056bXU3NjE1L2VFcjh1N210R2YrRnJleDcya09CMndZdWphSy8zL2ZlV3lEeUltZDk3MnlNL0VsTFhUSjVMZjN4bFp5TDEwOWNOMnkrOGljOVBBczQ1SnczdkwxeDFUWmhmRWxsSHN2QmZRMlZPdkY4U1hBWVBpenR4Zi95SC96cXRGMTNHaHdtM2x3bktaMTJ6ZHg3amx3RGNSNERYaDNvaE5uZC9vSEtmMEgrV1lHTjY5MUJmQjMwYUNBc1cySUdtVUlBZzJBb2ZPSUtqVUlJbUdBcHIxbWtObUlLb3dJRXV1QXBEMW1kR0ZvT3U4R0pzSmhsak5nZ0xNMWhrT3pnTEszaGdQemlFUkZpRVJuaUVuQkFJQUNINUJBVUhBSDhBTEFBQUFBRElBTWdBQUFmL2dIK0NnNFNGaG9lSWlZcUxqSTJPajVDUmtwT1VsWmFYbUptYW01eWRucCtnb2FLanBLV21wNmlwcXF1c3JhNnZzTEd5czdTMXRyZTR1YTQ5QTcwRFBickJ3bzladnNZRFdjUEt5NE1weDhjcHpOSzZ4Yy9IeWRQWnROYlcydDZ3dk56SHdOL2xxdUxkNXVxbTZNL3I3NlB0eC9EMG4vTEc5Zm1iOTc3NjJWRi9BSWJpMXl1VWhUOEgvVzBxb3FDaHd5TDJDSDVTY3FDaVJTVUtMZTF3eU5IaGprNEVCM1RLWWJHa3hSd1pKM1ZjcVFDa1JFNG1ZeDVJR1lrbFMwNGhZY3FNU2RPUkdKc3JzV1hLcVFuSnpwaGdlakppQ0xUanZwZVpqc2JFcUZSUjA1VVFoMEs5UkZHcXlhcFdyenJWeWsrVFY1NWdFWW50ZUlMc3ZVd2wvODUrVFh2b3hGcU9IeThSdFVSU3JzVVNkQS85dk9zUTA5NUtma3NtRFd5SXNNTUplcmRPOHBIWUl1TkRHeDIzdEhSNFV1V0tseEhaZFp5VlV1ZElYUk1ERG4xSXN3S0JrMDVEK253QUF1dERiRFMzTlMwWlV0ekthbTZyMVN5R2Q5bEpZR2dMUjVURnRmRzNuajhqV1Q3Y01XUkpzaGxSL2t3OWtYUHN2UnNwNzQ2SUtlSFNqN0lyU3UyWEtubERFYjVEVW8vSXd2ajNoeWJvamtULzBPL0VQdURubldaQ05kSmZJVVp4SnlBaWd6azJYM2lKMExiWWduVnB4a1o2RUI2aXhtZXJVVmdkWVJnZUo1NkNIcGEzbjRFWkZ2SmZleVdHNVJoc2loeUkwSDB0NWlkZmpDa09RbHVBTlE1b0hTTUhibGRaUmxvUVljQ1JKR2dCU3Y5bURpNXlJRzBvZlJLR0NRdFVPVUlZcXh5cDVaWXVmRExhZVU3bXlKNWNIWExpUVpWb3BvbUtDMXUyaWVRbk54N1NINDJiVUpubW5RdDRZSXFiZkJyUVJpZm0zYlViSXZTdEtKZDdtZ3lCNTZJTGxHSmtuM3hldUlscmVjbVpZVjlEYmlJQW80eU9RQXFrb0Q2aGlYNmFKYUxlanBwc3dPbXFvendCS3FoRWFPTGFkWVprSjJSaW1veXc2cW9ialBMcXF6eGdFa1djZzJSSFcwS1dDTEhycnEzKytxdVNsbng1RjNyRmhqZm1XV1ZPRXNheXkvWXFpck8va2lCcUphN0JLTWhwOXBGSWlaM2NzdW9ydUwvR1NrbHVqZzFhcllpREdIcFdjSlRvMnU2eXBEd0tMN0NVRUJ1T1BPUVFRdWNqeXY2N3JLZWZEdXhzbDVFMFIxci9yZEFSY3ExWDAwVnlwc1BjbXNLbXhPRktJdTFhaGxTRFRvR0NjQ2dKdXlDdnF1Y3BKRHNyN3lPbEd1S01PTkVZb200ai9zYk1yQ3BzMVB4cnNJNEVLaFp6M0xDc1kyS0lMdEt3MEtzSzRJckFSdmM1TGlPRTJXdkl3Yjhvb3U5UmpxaEs5YW9RdzBKQzFwQ1MwQWlwWWhXWFNYSnk4YmdJekdmZmFVSXRJN1BONTUrTDNLWFRXWXdvbWplak05dkNnOTk5U29vSWswQlZtZ21tUjBXSnlLYUhMeXFFTUZnei9tWWlEZDcwaVZRVEdySUIzcGt2a1BZd2EzdSs1YzBWc2pVRUtITG9tMjBoUWFkZTVkN1RhT0Y2bTBnek9BRmtFWlFDaGc4QjJvYkkxTHBYaWFVM2kvK3VKY1hDZk54OGxadXIwN25uME9xeTdmV3ExOVA2LysvQ2dHK0N0L1VVL2J2YnVhQ2V0OVVadFVGK0xzM1BydFQ0YkhkZnkvZUg4dzZXcTM0TFhpMllSelgwMFNWNlJoTWdMUWdJc3V5eFpudmcwZ1hWVmljYy9JSHJDdlFEbWYvSTB6ZG5zUThYN3VOVTRnU0V3RmNGdzJ6TGNtQ0pJTGdsL2VHQ2Y1M3FFU0VzcUNWbU1HcURNaFNFQ3dTV3BHbE1DVTBqR0dFT2gwakVJaHJ4aUVoTW9oSUxBUVFFT1BHSlVJeWlGS2RJeFNvK0VRajEySUFBdHNqRkxucnhpMkFNb3hpNWFFQkl1TUdLYUV5akdxWG9oblZrWUl4d2pLTWN2NWlCU0t4Z2pYak1ZeFZYWUE0THpQR1BnQlFqc2hoeFJqMGE4cEFJYUtNMzNoaklSanBTQUhWc0JDSW5xY2R2UFBLU2dXeEVFeW5KeVRSaU1mOGJXc1NrS09OWXhrTjA4cFJvMU1Zb1Z3bEhScUR5bFZOVUpTdG4rVVZYd3ZLV1RwUWxMWGNKUDBYZ0VwZTY1T1VzR2JISlg1N3lrOU1JcFRCWFdVcFRHdk9VbGx6bUtoMVJ5R2RPVXBIYVlLUTBMeG5KUnR6Um1vZmtZem44dUUxSERySVIxUVRuR3JGWkRtMldjNDdkakVReDFWbEZaTDVEbWU4VVl6T1h5TTkrK3ZPZkFBMm9RR2x4Qmd3azRLQW8rTUkwR3FDQ0FEaTBBbVU0SWdvT1NsR0tua0VaWlhDb1JqV3FBaUlhdEtJZ1RjQXdHckRSa2o2MFJ6OElxVW9UMElGZ21QU2xBZUNBaDg2dzBwV2lRQmNOaGVsTEk0cWZpZFowcGJyUXFVNDcycDJQL25TbENyMEZTWVdxMHdvSUo2VkgvZWtQY01FQnBqSlZwb3ovNlVCVW96clZXMVRWcWt5bEFGMTh1dFdmQmhXc1RDVnFUOVpRMXEyZUZhMU0xVUJLK3REV3JkNDBGem1GSzFOQm9JOE9rTFd1UHhXQkxoeWdWN0NxOVIxR0JheFpoYkhVd2pMVnFlcUFxbUtQZWxGbE9CYXNXTlhHRnliTDFVUUlGZ01ZR0VNcEFQQUhBSmhXRVYrOXJGQWJrSTIvY2pha0dGQUVDd3BBMjlxeVFCU216VzF1RlZFQjFRcjFzTUpJN0d0QmlvS1dJbUlNdFUxdWJVWGJDZDA2ZDdlSnlLdHZUUXBaWFVoMnVDSHRneUxNb056dUZxQzV6MzN1SWtBd1haMW10aFkweGE1SzE4QUk3M3FYRStFTkx5TTBVRjZZOG5RV3JsVnZBdTY2Q0F5NHQ3dk14VVI4NDlzSTZkYlhvY0J0aFhEMXkxSkgvTGU3dDAxRS94QUlRR0VDQkVFUkE1WnZJeWh3WU9xNmdxNE1ybWhYRzNHRUIzY1hFVytvc0lvSjhBWkVaRmpEalVodGh4M0tWMVdFdUtLeGZVUUlUSHhpUTdSZ3hTdHV3U0ZlRE9ORzlIYkdHa1ZGZW0vTTMwZk1sc2ZKTlVTS2diemlGaGVDeU9LTmhJRVBmTjlSM1BpZ2xZV0VINkNjM0NNWWdzcFVOZ1NXc3d5SmpDSTVBS1ZZOEhCSEhBa3lKOWNNaFpnd21sZDg0U3V2R2JxU2tIRjlxeHVLRU9kNEVuQ3dNMjBqVElnOXA5blBmejR0Slk1ODRGRm9WYjFObm9TaWFYc0lSd05aelpHV2RDVzJmRm14aWtLOVNhM0VrKzFzNWpON1dzVkREalZwTGRGWTMxcDZ6cGpZOGFZUjhXcFl4enJVbUJCMFlVMWQ2TWtlK2hLYkxzQ3hHLy9kYXdxN1dOYWFvSFJoU1RGWjQyTEN2N3ZtZGJNSmtBaFp6eG9USEhZc0tlUmNVKzF1SXRsNDFuYXp1dzN0VFpBWHJvUXVkbFRaeTRrU0s1clJuZDQyaHR1OUNmcUMxUlJMdHVrbmtyMkliWE43MzVIK0JLazMybVZxcnpUTW5GZzFtVnVkQ0lNdnd0dWZjUE5MVi9FRm95WVVGTnpOdGlJc2ZuRitkNEtoR3EwQWF4V1M3R1huZTkwbEJ6WVNzYTNvUnBBODVnay9ZckpEWUhOOU13TGpSclMzbmZFOWNwLy8zT1F5MUhYTkhYSHpvOHM4aHhLSE1od2UwWFNjLzNtSXlCVjV6Mkh1Q0tTM0tObCtnRVRWcmI1bUdkS2N6RVJueE5qSmp1VWVFVHdTYTJmN2kyc2s5SWxMSXU0SXp6bUZsRzduU2VBOTcxZW5VTXY5Ym5UL1NBQmRRR1BXdXRnTGIzaXZVeWZaQVlZNzR4OXhlUElrK3Q2VitMdmM1LzZldDFOQzg1c2Y4SHVpem1PS0U1N3JrNmo4YlVLKzlNeFBQaEtxRDgzZ0xRSDYwSXRlT0ZsdnZldFJUNG5ZQjRiMEprNDM3VjhQZThmVFpkTnBQMzJ2TTJIOHRDaCs5OHRudnQ1bHoycE4xTDRSVHc5TjNVMjhpZXRqUC9Dc3liMkp3MjU5NHFjZS9Ld2hNeWU4LzMwaWQ0ZkhuV0IvKzI5UEhkWjdWL2psNTcyQU9VK2U3UmZBOU4xbmZwWkFZQjdDY3p3SEN2SUhlNlUxVUl1bmZ3em9DZ240Z0tFUWdSTDRDUlJZZ2ZFbmdCaG9DbnIyYW4yMmdSQVlmU0RvQ2xQbWFGWTJncTd3WTNzbVpDZ0lDeVZZWlMwNEN4MW9ZVEZZZ3paNGd6aVlCSU9jRUFnQUlma0VDUWNBZndBc0NBQUlBTHdBdkFBQUIvK0FmNEtEaElXR2g0aUppb3VNalJNS2tBb1RqWlNWbHBlWW1acWJuSVZza2FBS2JKMmtwYWFucUtRbm9hRW5xYSt3c2JLYW42eWhvN081dXJ1d3RyYTh3TUhDbFkrK29aUER5Y3JEeHIvTHo5Q3l6YXpSMWRhbDA2SFgyOXlXMmFEZDRlS0gzNUhqNTVwUGYrclM1UXF5VUgveDZMdEVCdmY0UkwzdXNFc0Qvd0NYMEl2bEFwOUJmQzVTdVh1SENnbkFod0NSREV4MXNLSUJoZnhRUWR3NFlPSXBpeFpSTGRUSWNhTkhVbHBBVnNTRkxXTXBQaVUzYmpuSnlaN0tnNmRHbW9xNVVTQk5UVGNyNm10WnpwUS9uaEIvQWcyS2sraTNuVWlUS3NYRTlDQUpwOWxLcFlncWRhb2xFbFVOSnV5a2s1TkRyZ0JUZUwyVU1pdytVbVgvTjZGOU9IT3RKYmY0ZUpCMXFhbkhYSUIyTHhYRWU1RlQzRXgvL3dYR0JCYnZVRTJITHgyZHEzYnhKY0lHMkdXS2JDbnhBQ3VXTDdVaGZCVXkzMHRiLzJZSlRaV3dGdE5GTTIzeHpCb1RHOHl3bnlKT3pLZDJhN3g2TVhGbTVEZXg3MHk0aForbVJQczRKcHR1SDFjYXJtZ3lXcC9PTFYxSjdtMzVJaWpOczEvaVFmb1NkVVNwNS9ZUWo1d3d5MGJuRGNFMHpoNVRXN3pkWXpOUFhMZitwY1p1dFRHZGQ0aGtrVmhsL3YzbTFvRDZNUkplZ3BkQUYxWnBqTVEzU0hyWFFiZ1VYcG9wWXFFOEQycG9DWG1Fd1VkZ0laNnRKMko3d0ZWNDRpREYvV1hYQzBrZ1lPTUtMeERFWFNJV2VpWVJMR0NVY01DUVNvQUJpNDFJSnNrRi95d0FoaVVkT1MvK1lSMVhDS0tTdzVCWVpva0tGMGwyZVNNc08wTFo0Q0VobWlKa2xtZ2VrSU1wWHJhSmdCdXBTRmdWaFdMcWhsNWkySm1pUnBwOEhsQktqVzYyZVFZcW1JMVZaMWFJbkNYaktVajAyYWNTcEFRcUtUS2trSWdmSXRTbGFJb0ZqbmJheVFTU1NwcUVLWmdGWjhod01jNWxpaEtkZG1wQko2R0dDZ1FwVDRRNXlIQ2V6Y09KRDYyMittbXNzZWJJU1pOVlBTa0laMU5HVldVbVlQVGE2NnVjQUJ2ckNwU3k2RmFIeHk0SEhuMmJuT21zcDdCS0crdW9tb3lHRjUzWmp2a0hobHl0cGdtcjMvWktDcURpeXJyaGdvVVVrMDIxZ3BSSkNhL3g5Z3BwcFBVQ3UrUWx0emwycXAyREpJdFViNWRjR2JDenBuQlo4UCswakpYb1NUYnY5ZnZYc28xNE8zR25hNTV5TWJEa1ZxSnhJYXNZNDRvaDNGSUM3OGkrdm5MR3liSE9Tb21jUVNGU0N5c2REL0pYbm9zQVRIT25QOFpDTDg1dThwdUlXK2ptQzRyVGhMRExFeVdjSHQzcHdMcXN3SFNnS3pSaWFWQ3ZsVEliVnlvdUlyTFdhSllnak1WZnR3bm5JbUdSRkJVamU3TGRaOG5EQUJHM200TW1NdGhOaHBhaWFFeEpIOUtvM256NkVNM1NmMytaeUgwaHdjSlRmNFpZc0RiakIzQmRqZGVSSjVueUljUWFRRUljc1FoZ05jaUV6TXo1a0c1MzgwTG9YZXFNaUJZODZIWEZMbHYwc0I1b2lCajkrcEJHanVNMzdVZ2VUSS9Fd3cvcCtFQ1FSeTdzT2MwMjMvbFBvTk5Pai9VbFFQdlR6YlNIUGM3LzVtd25QcFViMm84enZCcXNaZi8xOU54VXIzZnN0WUVhdCszY0NIKzA5OGNkanpQKzI5RGZ4SjVYbitoSjZ4eEg4MXlDM0NjdExLaHZZdlJiRWR5QUpUNXhrTTlSZkZ2UklQd1hLblJrclZjRTFLQWhESmdrK0lsRGZvOFNJU01ZaUtTVDlDbUNLbFFFRitpRm81OEVDVXRLeUdBTWQ4akRIdnJ3aDBBTW9oQ0hxSWdmSk9DSVNFeWlFcGZJeENZNkVZay84STBRRmtERktscnhpbGpNb2hhM1dFVWhJR0lOVHd5akdNZTR4RFZZWmdoY1RLTWExNGpGSVJRQ0JXU01veHlkaUlMQW1JQ05lTXpqRmswd0NERE84WStBVElBWnZZSkdQUnJ5a0F0dzR4OEN5Y2c1cmdXUmtOVGpINHpZeUVxS01ZcEttV0lrTjZsR0lWankvNU5obkFvblI1bEdVSnFTaWFJa3BTcXhlTXBXSWpHVnE0emxBbHpwU2xqS1VwV1VwT1VuTWZrVFRkNXlsRjdVSlNnZitjdFJDc0tQd21Ua0lLZFN5R0pDVXBGL2dHTXlBVmxIdTl6Um1ZZmtJeUdRT1UweUx0TXV6Y1FtRzZGWmlGeDIwNG04REkwdnhibEZMeEx4bmZDTXB6em5TYzk2MnRNVVpqaENBZmJKZ2pIOHhBc1dFSUJBbWRDRmVMSmdud2hGcUJrbTBnV0JPdFNoL0FPaVBoTkswUUlNeEFzUHplaEFnWWlCaW5xMEFDRkFoMFpIS29BTjhOQU1ILzBvQzg0UlVKS090S0FpUEdoS1Azb09sN28wb3Y2WjZFdy82czl3WU5TbUxtVkNnanE2MDVsaVFCd2JBQ3BRVFpxZEVCUzFxRWNOUjFLVkN0UUtIRWVtVC8rZGFVMnBDbFNjcmdVT1dYM3FWcmtLMUF3RXhnOWhmZXBLeDlGU3NnTFZDRk1KQVZiVE9sTVRjb01EYnFXcVY5R2hVN3BxbFI0L3pTdFFoVG9Rb3ZwMXB3dWRpR0NweWxSeGpPR3dVRTFFQi80UWhDQ1FZUmRWK0FNSE9OQUFSVXgxc1RiMVFqam1DdG1LSGtFUkxTQ0FhbGZiZ2xtb0lBQ3dqYTBLRk1FRTBOcDByOHJvYTJrcHlvS1FJb0lNcXczdWFpK2JpZ2JFOXJpeDdXd2kybXBialJMMkdZYmRiVVg5b0FnMENQZTZCRWhGR1pETDNRQXN3Z2pOZFdsamhZRlM2WG9VRG96QUxuWlIwZDN1TWlJRDRTVXBUSUZCV3ZNV1lLMkxDSUo2cjB0Y1VoaTN2Y2psUUNPWUcxK0I0allWdXJVdlNDbXgzK3UyTmhFQWlMRC9oQlh4V2dBamx4SVZLTEJ6WjRGV0JTYzBxbzFvUW9Pdml3Z0ptM2pDaDdBd2Q2MUtpYzlxV0tCd2ZZV0hFM3JhU2poaHhDUTJ4SWwzRElBVXF4aTVGTEJFYlYvc1VGU1VkOGI0clVScWNSeGNIZk40eDRiNE1YSm5ld2tDRjNpK25aanhQaE5yaVQwd09iaE5jUEtUVFd5SUNrajV1Q0RBUkVPSkxJQlNKSGkzSUw3RWw0T0xoa0tNbWNkUlBuTnNOZUhpK0Q1M0V4NnVjU2JlTUdmVlBwZ1FkNFp5SVNxc1p3MXNZc2dGN29SVHpadmtUQlJhdFlkSTlJa05RUUU5NzVrVFZsNHNpd0V0M1o1dVlzbHpEck9ZTmQzak1uczZBRlRlUkdCdEsyazRrK0xHbHk0eHF5T01pRmNISU1pZDZITmVSNjBKeUFxNkU1Y21RQkIwLzcxclJIREExNmFBZEY1SmNWamZra0svdVdZMnF4UGhhd0dYSXNPQ0pjV2JVMHJkVXlTN3p0cldkQ0syKzJwVWdKZXNmeVoxVWRHTENoRVgrdENaM25XckVjSG9NeE83RlBDbEtqNTNXbWxUSkhzUit0NTNyOXY5aWxBL0ZNdlUvaWlYVVlIcUw2c2F3dnBlaEprOUhXdFVySG1rc0JpRFR2c1pDK3RtV3hFSlo0U3Z5eEFMZ0RxVUNhSmRTN0tYamZDTUwrTFpESThudGd2ZGlKU3IvTlhlaG1leW5kQnpteStpMHprbm9yM25qRytVRzMwUi9aYnl2NEdJYTU1VHd1ZU44RFd3aFZoeEpyK2hFbGhuaEFaZTNmRWZBdmZrUlc5MkphQXR4R1R2d1JKaFp3UUkyUDdEblgrNTZZeUlPeU9pL3VPZzkvRGdsOUQ3enozOXcvK2xXeHdUZ3RmNHE2ZXV3YXJQT1JPSlg0VFdlVGh6eUQrOUVqZ25mQXk5akhhNFgzN3RyMDZ6Q3BQZDM4Qi9uaEwvMWJ3R0NYM3ZUVVIrNzY5MnRBWUJyNG5YRDE3UEd1dzZqaTl1ZWJWcll1TjZMbnQ5VEc1MTE1L2VFaXZYVU9VNVlYdEdaQjczQ1RwNzhZM3YrMDM0V3JuMTBmMkkwYzM4NDF1QzNjRlAwS1h4M3Z0dGs0THZLaGIvOUx0ZmZVNGtYVHlGNWozN3pVOEs0RXM1UVlZZjhTbWFEM3FwUi8vTGIyY0svRWNKY3lkbDJGY2ZYNFlLQTBnSlp5WWlPSllLQzhpQTZTY2l4SWRkM0NlQTNxY0o0TmRkTEtkQitVY0E4b2VCN1djSzlnZGJqTGNpUkVkMHNSQ0JtQkJrVzNkUDVhZHVNRGdPTERpRHdWQ0ROc2dsQ3ppWWc3cXdnenc0Q3o3NGc3SXdna0lZRFVSWWhOQWdnMGpJRFhlMmhEUzRhU3NTQ0FBaCtRUUpCd0IvQUN3QUFBQUF5QURJQUFBSC80Qi9nb09FaFlhSGlJbUtpNHlOam8rUWtaS1RsSldXbDVpWm1wdWNuWjZmb0tHaW82U2xwcWVvcWFxcnJLMnVyN0N4c3JPMHRiYTN1TG11UEFhOUJqeTZ3Y0tQYmI3R0JtM0R5c3VESk1mSEpNelN1c1hQeDhuVDJiVFcxdHJlc0x6Y3g4RGY1YXJpM2VicXB1alA2KytqN2NmdzlKL3l4dlg1bS9lKyt0a1Rmd0NHNHRjckE2Z29meEQ2MjVRRWdjT0hTZXdSL0ZSRWdjV0xSUlphNHZLdzQwTXVuUWdhNkxUam9zbUxPelJPOHNnU1FjaUpuRTdLVktBeVVzdVduRVRHbkNtenBxTVhOMW1lMlVmUVlLWXNQR1dLOGNtb1lWQ1BSUGx0U2lvekkxTkZUMWxHektRelUwV3FKNjlpelFxVksweE1ZSHVLUlVUVzR3cXpVdjh4blVnYmR1MmhGVzA3Z3J3azBtaWxrblF2bnJCN0NHamVoNWk2V2dwc2NpbGhRNGNmQXVGN2x0SUV4aGNmSCtJWTJhVWx4WlF3VzlTTUNHL2tyWlJBUy9yS2VERHBRNTBSQ0p6VXQ1Sm9CUkZlSDNMVCtXM3F5cEhtWW1ham0yM25GNy9qU2hKenV6aWlNN0dUM3dzdE9vdHo0NUVuUzFMdDZMTG82NG1pYnk4cXFUbDRSRTRQbzM3RW5SSHJ3RmJQRzhJaUhsSjdSVkhNeXo4RXBIZWsrNGtJeDlocyswSFcyVkRzQWJjSVV0OFZpSWhoa2RsSG5pTzNPZWJnWFoyNWthQnlqTEFobW1zWFluZllodE5SMkdDSTZQblhDSUNGQ0FnZmltTkZSbUFpTEE2UzM0a3c4bGVmSXJVdGN0dU1PUllTbTNZOEttaUlkNWhwOUFYL0JnazBpY0lYb0hBVzRTSTEvbkZiU3A5c2tjSUFYQzZ4eFNwTmhpa21ncDJZcGg2VlJoTHlIbDBnY29JRWwzREdpY29aWXRicDVDYzdIbEtqZnB4c0dlZWZBeUJoaXAyRUpyQkdKK25sNVJzaVBSN2lJbDN4YVpJRm9KUU9VQXFUaFJMYUJ5ZXg3YVZubW44QWx1UW1mRlJhNlJLa1pLcHFCNXIwMXhtTm9QNm9DUlNtMWpwS0I2cXFpb0VtUXpLYUpwS01hYkpFcmJWQ01VcXV1ZjZBeVFSNURuTGZiUXBaMGdPeHhONktMTEpRV21KbVh1czVPNkdhSDE2eUJiWFVHaXZLdGNpaXdHb2xzUUhKM1kyalZ1SW51YlllaXk2eXUxTENXMlNMZXN1aElJK21SUndsdzlKTExTbVkzcHNzSmMyR0l3ODVoUEFKeWJRR1U0dHEvNm9LWDB2bUk5Q2Rac2kvZjZ5WmxuV1J2Rmt4dWFiUW1YRzZrbXpibGlIVm9JTk54SmkxNmNpOEo5Y3E2Q2tyWDV2dkk2OGE0b3c0MFJpQ1l5TUY1MXl0S24zMGpLeXlqaVJLRmlJeFg0TUlacEV1UXJIU3RmTGhTc0pPRjdvdUk0ZjFhNGpEdnlnU2NGS08wTXAxclJmRGdrTFltYUxRaUt0a0laY0pjM1FCZVFqT2IvK1pRaTBxMDAzb29Zdmt0Vk5hakV3YWVLVTcyL0tENFlWdW1vaVVRWG1haWFoSllZbElxWTlUMm9Nd1lGTitaeUlRNHZRSlZSWWFBZ1hnb1E4UTl6QnpteTdtenhpNjVRSW9Rd1JzY3lGSng4N2w0Tk44WVh1ZFVEOEl4R1JZbENMR0JBRGxoc2pXd25QNXBUZVRIeC9teHJxWVhEMlhvNnRUdXYvcDJlb3k3dmV5MTFQNzhjS2duNEs1OVRSOXZOMjV3QjY0MXhxdHdYNHUxWlBzMC9wMEsxOHR6dmM0NG9rRlY0WkxYaTJveHpYNDJTVjdUbE1nTFJoNHN2QzlabnpvMGdYWFpsY2NBS0tMQ3Z3N21RSFBVN2hyMFE4WDlqTlY1QW9Fd1Z3RncyM1VzaUNLTUNnbUFlS0NnS2NLRWlFOEdDWm1WR3FFT2hURUdSTDJwR2xvQ1U1TFdHRVFsOGpFSmpyeGlWQ01vaFFMZ1lFQ1dQR0tXTXlpRnJmSXhTNWVFWGZyOE1FQnhrakdNcHJ4akdoTW94cko2QU5Ld01HTGNJeWpITFVJaDNXb1lZMTR6S01lejZpR1NMQmdqb0FNWkJkWllJNFM3UEdRaUZSakNSN3hSa0U2OHBFRnFLTTM3cGpJU2xyeUFIMXNCQ1EzS2NodlhQTC9rNGxzUkJVNVNjbzRnbkVaWWdTbEt2UFl4a1dVOHBWdzFNWXFaNGxIUnNEeWxsdVVKUzEzZVVaYjR2S1hWdFFsTDRkNUFGOENFNWZDSk9ZdUdUSEtZNzd5bE1wSXBUSm4yVXBYT3ZPVm5wem1MQjNSeUd0dVVwTGFvS1EyUDVuSlJ2elJtNDhrWkRrTU9VNUxMaElTM1VUbkhNRlpEbkcyYzQvbGpFUXo1ZGxGYUpaRG12ZFVZelduU05DQ0d2U2dDRTJvUW5HQmhpWVE0S0V0SU1NMHdtQ0NCVmgwQkI1d29oTmE4TkNPZGhRTnl2Q0FSVWM2VWhNc2NRSU85YWhLQ1RDTU1KRDBwUmNOVWhCV1NsTUNPQ0VZTU0zcEFvUVFJalRVdEtZdDBFVkZkWnJUak1vbkJCejlhVTExUVZTaW1tQU80RW1wVW1zcTBWdTR0S2xFL3gxQmNXWTZWYVVHQVJkQ3dDcFdlZm9ZSjNTMXExKzlSVmpGaXRVTnJLVURTVDJyVXBuS1ZxeWFRQXBNZVlOY3owclh1bUoxQ0NyWncxN1BHdFJjRE5XdldCV0FQalk2MkxPR1FCZHpRQ3hiVGVCV2VFaTFzWE1WeGxVbGk5VVI0TlVjWE1Yc1ZFR3FETTZ5bGF6YUlJTm8wWm9JQVB3QkFMQXR4UlQrc0lFTmVFRVJhelZ0VThNd0RjYXU5cWROVUFSc2h6dGNVVmhBQU1oTnJnVVVNUUxkTnBXeXk3anNiMVhhZ3BzaWdyallMVzRudkpEYzdpYjN0b2s0ckhOaHF0VmdoSGE2SzkyRGNMT2IzVTUwd2J2d1Zhd2lCREJlb3FLMkZqNUZMMDNmd0FqMnNwY1Q4WTB2STRaUVg1MGFkUlp4MVc5SEM3c0kvL3BYRTl3TnNQOTNLN3NJOFJiWW9pYU5oWFFWYkZOSE9QaS9pZUJBQUVZY0FBNG80cmdTOXE0ak5uQmg4cnBDc0J6MmFGb2I4V0VRRzBJREpNNXhBRFNBaUJURGx3bVB5RzJMTFNyZlZNVFlvOEY5UkkxdFRBZ1Y2RmpIS2ppRWorRmJBVWcwZDhnamhhb3A4bnRrQml0NXlkaTk4Wk9mek9OQ1RObTd5NDJFaFM5OGlpTS9sTFNRQUhON0N6SG1NUnVDQ1dmdXJoRWtJVklzTDZBVUc1N3VqQ01oNXpBVFFzUjExckdKelp6bjVGSkN5QVV1cnloaW5PUkpGSnE0aGtpMG5RdUI0a2I3UlJKWFpyTW96S3BmTDF2NjBxN050S1oxYklnS05OclJsbGl6YVNrTUN2MVd0UktvanEycVYwM2lRK0Q1MVdtdXhHYWRPd3BTcjNiUWxNaDFxbmYvemVzQTlQalZBcWp5SlNBdFdWcC9ZcldWdm9TeUVkSHNYaDlpQTlBdThpVkNMVmxTaU5hNm1OZzJ0N3NkQUFZOCs5WFdyZ1NMT1V1S1FQOVV2WnRROXlIWTdXeEV2QmZhQUVhc3BDZDlWdjV5UXQvN1p2ZUpvUTFrVGhDWXJWdWVxcWsxa2V0RjhIc1I0ZjZFckVsNjRGTDhGTTRIcjdnaUxxNklYemM2Mkp6b2MwNVhRUWFwUmhRVUNGOTN0OTA5WDJoM0FSUVVIZWtJZUx1UW1DZTgyNHdBTjhDaDZQT2ZON3NSNFk1M0VJdk9iRjQzd3RWRGJ5TFRtNzVxUjNRNnp3MWY0dFNwcm1tYU15TGMwbDY2eUJ0QjhrWmtBTm9vejlIV3VaNW9TR1JjN0tpR1JOa2JZWVMzcTMzc2pwaDdJNjUrWnFVWENPOTVaN2ZYSFdIMy94Q3QzZWhPajRUSnNZNml3eU8rNnBJQXUrRUJIM2lnUzBMb3I3NlE0eCt2YVVxRWU4OS9wM3psbXozNFIwUTQ4L3ZaUE9mYlRnbStUL25UMXhIOUkvUWVpY0k3Ui9XcnI3TWxGbi9tdEw4Rzk3bmZkQ1hDZmZQYnkzNzJncmNFNWh0dC9MaGZndmFSaHpaNGYzOTg1RnZlRXY4K2VYR3FiLzJqWThMMVB0NytwVFVCL1VsRW5UVE94d1MvUzA4SjNvZGZOK01udjhJMTBlaXNvNy9RbXlqL0pPcCs1dWxUZjhtY29IL21kMmJnQVlBQk9IK2JNR1huWVlENWwzeWJrSDN4Vlh3THlHUU5lSDJjNEg3MjkzZXZGUW9DaUFsVkZuWUxSWFlJR0lLeDBJRWtpQXJyZDRJbE9JSXEyQW9tMklLa2dHaTh0bWd3NkFvV1dJT3NnQ1JqcTFabU9PZ0tUcFpvVWRhRHNLQ0RaQ2FFc3lDREpXYUVTcmlFVE5pRVRzZ0pnUUFBSWZrRUNRY0Fmd0FzQUFBQUFNZ0F5QUFBQi8rQWY0S0RoSVdHaDRpSmlvdU1qWTZQa0pHU2s1U1ZscGVZbVpxYm5KMmVuNkNob3FPa3BhYW5xS21xcTZ5dHJxK3dzYkt6dExXMnQ3aTVya0FJdlFoQXVzSENqMjYreGdodXc4ckxneXZIeHl2TTByckZ6OGZKMDltMDF0YmEzckM4M01mQTMrV3E0dDNtNnFib3ordnZvKzNIOFBTZjhzYjErWnYzdnZyWkhYOEFodUxYSzlTVFB3ZjliY0tRb0tGRERQWUlmaUppb0tKRklnb3RuWEhJMGVHWlRnUVJkSEpoc2FSRkZ4a25kVnlaQUtSRVRpWmpHa2daaVNWTFRpRmh5b3hKMDlFWG15djc3SHVaaWMzT21GcDZNbUlJdE9OUWZwdU94c1NvVkZIVGxSQXo1Y3hFVWFySnFsYXZPdFZLOUpKWG5tQVJpZTJJZ2l4VVRDVC96bjVOZXdqRldvNGZMMjIxUkZLdVJSSjBELzI4NnhEVDNrcCtTeVlOYklpd3d4OTZ5MDdpa2RnaTQwTWJIYmUwZEhoUzVZcVhFZGwxbkpWUzUwaGRFd01PZlVoekFvR1RUa1A2Yk9BSzYwTnJOTGMxTFJsUzNNcHRicXZWL0lYM1cwbGFhQXRIMU1lMThYdVVhTE5aUHR3eFpFbXlHVkgrVEQyUmMreTlHeW52am9ncDRkS1BzaXRLN1pjcWVVTlV2a05TaitqSitQZUhmdWlPUlAvUTc4UTg0T2VkWmtLbEYxNGlSbkVuSUNLRE9UYmZnWWpRdHRpQ2RXbTJob0hITWRMR1o2dFJXQjFoR0VMbnlIMGVIbUxlWGJzeDB0OGcvN1ZYWWxpT3dhYklpZ2lSK0tJaCttbldDSTIwQlhqamdOYXBDT0VnMjFXVzBSaEhGS0FrL3d0amdKS1pnNHVzU0J0S240aHhnZ0pZRmlIR0trcDI2YVVabjR4MlhwUkQvc0dlWEIxeXNnT1diTGFKaWhsZXhybmtKL0loMHArTm1selo1cDRLN0dDS25JQVdBRWNuSjY2VjRpSDB0U2lYZTVxd3dlZWpDcFNTWktDQStzR0phM2toQ21GZlJtNlNCYVNRRmtFS3BhU0dvRW1PVUdxYVlTRTlhaElGcUxDT0VnS3BwQjZoaVd2WEdaSmRrWWxwVWdTc3NFWXhDcTIwb2tkSkIzVVNraDF0Q1ZreUFiREF5a29zc1UxYUl1WmR4Z29pMjVsbnBUbUpHTkJDSzZ3bzB4TExncW1WdUNhanRyM1pwMkFsZW9ZYjY3RGxFbXNySmJrNWRpaTdxLzZoNkZuQlVmS3J2TkNTTW1tOXhWS1M3Qi9oeUVNT0lYZzY4aXpCMElvNkt2L0MwNElaU1hPazZTb2lJZHg2TlYwa2ExSWNyaWx3WW15dUpOZXVaVWcxNkdBRGNXWGVOaEt2eWJENmVZckswOTc3aUk2R09DTk9OSWE4NjhqQU9FZXJpaDg4RTV0dElvVmVoUWpNMTBTWUdLT0xUSncwckZtNGNuRFRnYUxMQ0dIN0Z0THdMNHI4ZTVRanIyNE5xOFd3c0FBMnBTdzBndXBWeFdXU25GdytMbkt6MjN1ZVVFdktjd002NkNKMzZYUVdJNDRDRHFuT3RtQlFlS0NXSnZJa1VKbG13dWxSVkNMeXFlT1BUaURNMTVQUG1VaUROMzBpMVlTR1JQRTM2QXJBUFl6Y3BYdnBjNFZzaVFCS0hQL1dUQWpTc0dNcCtEUmoxQjduMDROODhRTmtWSlNpQlE4QjJvYUkxc0ZqdWFVM2todmZwY2JDbEZ3OWxxS3JRM3IvNmRYcUF1NzNzZGREdS9IQ29IL0N1UFV3Ylh6ZHVid09lTmNad2NGK0x0V1AzTlA2Y3l0ZkxjN251T0dCWlZhRlF4NHNxTGMxK05FbGUwMVQ0Q3NZYUxMd3NXWjg1ZExGMW1RbkhBQ1dTM2U0d0prQnlVTzRhZEVQRi9ZREZlUUVCRUZhQmFOdDBMSmdpVERvSlFIaWdvQ2graEVoUE5nbFprQnFoRG9VaEJrT3hxUnBXSWxOUlZoaEVKZkl4Q1k2OFlsUWpLSVVDeEVFQWxqeGlsak1vaGEzeU1VdVhqRUk5ZWpCQU1aSXhqS2E4WXhvVEtNYXlkZ0RTcnpCaTNDTW94eTErSVoxWkdHTmVNeWpIcytJdjBlMFlJNkFER1FYVzJDT0ZPenhrSWhVWXdvZThVWkJPdktSQktpak4rNll5RXBhY2dCOVhBUWtOeW5JYjF6eS81T0piRVFWT1VuS09JSXhHMklFcFNyejJFWk5sdktWWHRUR0ttZUpSMGJBOHBaYmxDVXRkM2xHVytMeWwxYlVKUytIT1FCZkFoT1h3aVRtTGhreHltTys4cFRUU0tVeVo5bEtWenF6bEo2YzVpd2QwY2hyYmxLUzJxQ2tOaitaeVVYODBadVBKR1E1RERsT1N5NFNFdDFFNXh6QldRNXh0bk9QNVh4RU0rWFpSV2krUTVyM1ZHTTFwMGpRZ2hyMG9BaE5xRUp4QVlDR09oUUEwd0JEQ1E1QVVTWGs0SWtQelNoRWg1RURpbnJVb3lXd3dCSTFxdEZoZ09HaktLM29qMGpLMG8zbUlxVXdQWUFQR2tDaGxyWlVGeE9OS1V3WFpOT2J2bFNuTVMyQkhMclQwNTdpNHFSQTFha1NoRlBVb3VMQ0IwbE5xZzh1MDlTbVBqV3FVZjhWYVZxcTZ0U2ZZaFdvSllDQVVyaHFWYTkrRmFocVNBbFpxNHJUczJJVkNmcFlLMWQxSVFlM1lqV2s5SkJyV1lPQlZMc21WUWxpTllkZTJhb012MkoxcXQ0WTdGNE5VWVUvY0lBRE5DV0ZGUDRnQkNHRVFSRlFOV3hTd1pBTnhSbzFFU29JZ0doSHF3SlJtR0FCcUUydENSU2hCTTJDVmF2RDhPeG5EOUdBMGRwMnRKSGxSQmhTeTl2VVhqWVJPWFV0VEpjYURObmFWQkZsdUsxeUE5QUpEL1QydVF0WUJCS0VxMVBFMnNLNFBsWEVjcGZMQ2VoQ2x4RnFvRzVNTDBvTDdKSzBFUnpZcm5KemU0bmRlcmUzUW1oRWNNVUxVbG1ZOTd5TlVLOXlTNXVJRFFqZ3Z3TFlnQ0pPKzk3ZU9zSUM5RTBwY1ZseDM1STZvZ0w2VlM3L0lqSUE0QW9MSUFPSUtQQnpSL0NJekNiWW8zQlZSWU1mQ2drS1JGakNockNBaFMwTVcwSm8rTGtDZmtSclAreFJWSXpZb1pJSTdZbHRhd2dLcjlqQ0dDN0VpM3U3MmtqTU44SGtKY1dOWGZvSUVPell0aFV3eEk5L2JJZ1JESm0zQXBCRVIybDhnRkxjbUJKUHRtMFpDdUhmS1ZzNHhpNitjbW9wNFdINkxqZ1VEYTZFQnNJc1d2NFN3c3hVTGdTQjFUeUVTc3lZdnFPNDd5WG9MTnBENEhuRmh0aUFtdGRzaVNOcnRzV2Z3TzRsZEJ6bUtFdjUwQlUraEpVWFhlUks5TlcxZ1pZdEpreE1hRVJnT3RPSFdEUnEwVnlKTnZzVjBwNVFyQ1lJSFFBT21QclUvMFdFRUZRZDNVejgyYTVLMXFzbTBsdnFXK002RWJ5T2J5WVEvK3pYWUpPVkU3UWVzN0ZQblFqbnFwb1QwejNybStGTTJFMUFtTTUyTmpTdXM1eUlQVitadzV3SUwxWk5zZGhOMEhvUjR5WTNzcS90Q1Vlak5NbGV6aTRuS1Axa1N5Y2kzb3ZZdEpvN3pZa3Q3MVRFRHZaRWNvdXRDSUF2Z3RjZUFJVkVQYW9FemlxRTFyYUc5N2dac1d0NlA1SFlkRzZFd3grdWFtVTdrZFlVRVBuR0dhRm9qelB4MjJFT2Q4Tlh6Z2h6RHhuZFN5UjF5QjB4Y2tid210VS80dmVPTmZDSW5pOWlDS29tK0kxcXkzQ1ZIL3NSdkY0aXJVRUFDYVBETytvL0F2bVRaYzRJcXkvQzVpODJlWW5lSFFtdmszelJONEo1dnlWaGRrVUkvTndsMG5tWUo5RjJSZnpjUXhpbk84MGgwWEcwTDhqSlRhLzYzaUhCYS85NXY0Zlc3Qlg4MHlYaFhyKy9aODdncmtUZHY2N3FQaDgrOEdVZmZDU3czaDJobjlqZmVsLzhKTjQrWktXelp1RTdsN3ptTjYvcWlDOG43NWFZUE1jNXp4cW1wMTcxb3FjRXIzL0xHczlIV05xeFgzMGtyRDF3NFJDYTY2R25OaWJBcm1IajN6NzR1YStFeXk5RFo5QkRYL21ZSUgzemI2UDJDRzlDOWxDSCsyMXNIMkdxYXdMOFBMOHk3MW56WkU2ZzN4Rlg3czZKTy9GKytHK2ZPcWhmTHZEUEwveEtFQis2cmtjZTNSY0Exc2QvMFpjSjJvZHpDNUp5S1FjSzlTY0pBZ1owQzZWeEJ6aUJyZkNBRmlnS0dKaUJEdGgvSElnS0cvaUJuVkJtbUNhQklxZ0tGWGlDcU9CamVCWmtLdWdLS21abXNQYUNxOENDUUVhRHMwQVBnZ0dHZ3p6WWd6NzRnMERJQ1lFQUFDSDVCQWtIQUg4QUxBQUFBQURJQU1nQUFBZi9nSCtDZzRTRmhvZUlpWXFMakkyT2o1Q1JrcE9VbFphWG1KbWFtNXlkbnArZ29hS2pwS1dtcDZpcHFxdXNyYTZ2c0xHeXM3UzF0cmU0dWE0L0NiMEpQN3JCd285cnZzWUphOFBLeTRNb3g4Y296Tks2eGMvSHlkUFp0TmJXMnQ2d3ZOekh3Ti9scXVMZDV1cW02TS9yNzZQdHgvRDBuL0xHOWZtYjk3NzYyU0YvQUliaTF5dlVoRDhIL1cwNlVxQ2h3eVAyQ0g1S2dxQ2l4U1FLTFpseHlOR2htVTRFRTNUaVlyR2tSUzRaSjNWY1dRQ2tSRTRtWXlKSUdZa2xTMDRoWWNxTVNkUFJHSnNyL2V4N21lbk16cGd2ZWpKaUNMVGpVSDZianNiRXFGUlIwNVVRTStYTVJGR3F5YXBXcnpyVlN2U1NWNTVnRVludHlJSXNWRXdyLzg1K1RYdUl4VnFPSHk5dHRVUlNyc1VWZEEvOXZPc1EwOTVLZmtzbURXeUlzRU1NZXN0T0FwTFlJdU5ER3gyM3RIUjRVdVdLbHhIWmRaeVZVdWRJWFJNRERuMUljd0dCazA1RCtvd0FDK3REY0RTM05TMFpVdHpLYm02cjFUeUc5MXRKTDJnTFIrVEh0ZkY3bEdpZldUN2NNV1JKc2hsUi9rdzlrWFBzdlJzcDc0NklLZUhTajdJclN1MlhLbmxESXI1RFVvOW93dmozaHpEb2prVC8wTy9FUU9Ebm5XWkNwUmRlSWtaeEp5QWlnemsyMzRHSTBMYllnblZwQm9lQnh6SGl4bWVyVVZnZFlSaEM1OGg5SGg1aTNsMjdNZExmSVArMVYySllqc0dteUlvSWtmaWlJZnBwMWdpTnRBVjQ0NERXcVFqaElOdFZsaEVaVFJDZ1pQOExaSUNTbVlPTHJFZ2JTcDlvUVlJQldCS2h4U3BLZHVrbEdwK01kbDZVUS83Qm5sd2RjdUlDbG15MmlRb2FYc2E1NUNmeUlkS2ZqWnBjMmVhZUJyaGdpcHlBRXZCR0p5ZXVsZUloOUxVb2wzdWF0TUhub3dhVWttU2dnTzdCaVd0NUlRcGhYMFp1d2dha2tCSkJDcVdrT3FGSmpsQnFtbUVoUFdyeUJLaXdqdUlFcWFRMm9ZbHIxeG1TWFpHSmFVSUVyTEErTVFxdHRBYUJTUWgxRXBJZGJRbFp3Z093d01wS0xMRk5XaUxtWGVnTkl0dVpaNlU1aVJiUVFpdXNLTk1TMjRLcGxiZ21veUNuMmFkZ0pYcUdHK3V3NVJKckt5VzVPWFlvdTcwcGVsWndsUHdxTDdTa1RGcHZzWlFrKzBjNDhwQkRDSjZPUERzd3RLS09ldkQvdEdCRzBoeHB1b3BJQ0xkZVRSZkptaE9IYXdxY0Y1c3J5YlZyR1ZJTk90ZzhYSm0zamNSYk1xeCtucEx5dFBjK29xTWh6b2dUalNIdk9pTHd6ZEdxc3NmT3hCcnJTS0ZYSWZMeU5SRW14dWdpRWlNTkt4dXVHTXgwb09neVF0aStoVEQ4aXlMK0h1WElxMXJEV2pFc0xYeE5hUXVOb0hwVmNaa2tKNWVQaTlqYzlwNGsxSUt5M0lBT3VzaGRPcDNGaUtOL1E1cXpMVUVRSHFpbGlUd0pWS2FaY0hvVWxZaDgydmlqUEFqanRlUnpKdExnVFo5SU5hRWhUL2o5dVFGdkR4TTM2VjcyWENGYnE2dnBMODJFSFAwNmxvRlBRd2J0Y1RyTklBYVFpVkRLQzBBRWFCc2lXZitPNVpiZVJFNThseGtMUTdMMFdJYXV6dWlrVjZzTC83amN3MTdQN01RTFV6NEo0OWF6TlBGMDUrTDYzMXhuOUViNnVVamZSbFhveXkxK0xlUnJYUERBTWl2Q0dhOFcwZE5hKytoaVBhWWRrQllKTEpuM1dBTytjdWxDYTdFVFR2L0sxWUg4bFd5QTVCbmN0T0tIaS9tQjZuRUNhaUN0Z3NFMmFFMndSQlgwMHY5d0VjQlEvWWdRRyt3U015QUZ3aHNLQWcwR1k5STByTVFtSXFEUWgwaE1vaEtYeU1RbU92R0poUUNBRktkSXhTcGE4WXBZekdJVjZ6RUJCWGp4aTJBTW94akhTTVl5ZnJGWmtkQ2lHdGZJUml5dWd3MW1qS01jNXlqRytqMmlqWGpNb3hyTmNRSTYrdkdQWlR6QkhmVkl5RUpPOFJ0d0JLUWlGNmtBT3k3Q2tKRFU0emNZU1VsQU5pS1NtTVNqTnJwWXlVN0tFZitOaU1pa0tQZVlEVSthTW82TUdLVXFyNmlOVTdweWpLbGNwU3lsMk1wWDJ0S0xzWnpsS210NXkxZm1VcGVqM0dRdlhRbktVQUpUbEpNY3Bpa2RjVXhrZWlPUnlxU2tJeC9aVEVqeU1acU1GQ1FrcWxuSU4ySVRrTk1jSkRmWHlNVnZmaEtLNkV5bk90Zkp6bmE2TXhobHFFQUE1cW1DQmt4akN5a1lnRDZYZ0FRbXFtQ2VBQVZvR1pTQkJIMGExS0FwU0tJOEE4clFBQXhqQ3dlTjZENS94SUdHV2pRQUZBaUdSRGM2Z0I1NHFBd1h2YWdLZEpGUGptNjBuL2o1WjBndnFndVRtalNoM1Zub1NpOXF6MXRBMUtVbVhZSndLanJUbFhJQUZ6M0FLVTQ5eWhnSzlMU25QNzFGVUlXS1V5alFSYVZIWFdsTG1ZcFRtUFpFQTFIL1BlcFVxWXJUTEtRRUJGazk2a2h6VVZLdTRwUVArcUFBVk1PNlVnZm9RZ0JtWmFwVjN5RlR0a3BWR0RlTkswNTFxZzZlMm5XbUExV0dYcGxLVkcwMDRLOUlUY1FVL3JDQkRYaWhGQkQ0Z3c5OEFBWkZMSFd3THQxQ050YUsySVpXUUJFV0VJQm9SMnNCVVpUZ0FLaE5iUWtVc1FUTXVuU3V3cWhyWnhtcWdvd2l3Z3VqemUxb0g5c0pNS1QydDZtdGJDTEs2bHFKOGxVWGZwMXRRMEdnaUM3bzlya0M2RVFPZ0V2ZEF5eUNEOFUxYVdGckFWTGxXbFFEaklBdWREbFIzZW95SWd2WjVTaEtaOEZaN3daZ3JJdllnSGlmeTF0TStMYTh3UFZCSTRpYlhuM0N0aFd5ZFM5R0hUSGY1NVkyRVVKWWdJSVhJQVJGbkJhL3dIVUUveFQ2YTF4WGdGWEFBVTFxSTVoUTRPY2lZZ2dMRHZFQ2hvQUlDRk5YQ1krNExJWDFpVlpWWURpZ24zMUVCVHJzWVVPWVFNUWlOc0VoVEV6ZEF6dWl0U3MyS0NxNisyTDRQaUswTk02dElVQ01ZeEdUdUJBOEJ1NXFJOEhmL3E1M0ZDK2VaMkFoWVlRazU1WUpobWh5a3cyaGhDai85c3FPS0dpUUIxQ0tBTTlXdzVId2NtNjdVSWdFaTFuRURZYXltVk5MQ1JXbjk3aWh3SENNSjVFQk9Zdld4NE80ODVnTDhlQTlxNkVTUU83dktJenFYU05Qd3RDaVBZU2ljV3dJQyt5Wno1YW84bUNkS2dydjFyUVNTSll6bU1PODZSQWZvc3lmbm5JbDh1cmFTYjhaRXpQR05DSmE3ZW9kZi9vQWlPNXpjVWtkNkw4TytoS1lGc0FHZHYvTmF3VWp3Z2UvdG00bUloMVhVdnpWdHBpUXI2NlozZXhFUkZ1L21aaXdYa25oNXBBeWR4UEpwak8zZVoySTZmNmFFOWpsS3FDTDNWUHdjb0xEaGc1MklacnQ3RVEwMnN3bzVnUjZtV29LSW92MEU4bGVCTDhYc0lob2YwTFVCMFV6bGkrNlpVNmsyc3VyVHNUQ0Z3SHJQY3VhRTJyZTZDb2FJTk42Z3NLNTIxYkV4aHYrNnh5QUFwOEdYWUptRlpMc1pTdWMzNHlBOXJ1YnFHMUROMkxsTFA4MHVKZVk3R05ySE9lTThQVE9sWWh2T2V0NzNhMTJ4TCtqSEhBazV0cm5qZ0E2STZMOTlCSmRQTWtaZUlUV0Y2R0dYMy84UnJoTitjK1I3Z2lIK3pEWlJvREUyQmVCQkxmZnFPZGU3dnJSdXcySnFmTjQ2Q1ZLZUNUbXZ2WC9wWHVvNlJpWEJPRTUvdXVxTCtqcWNwN0U0b08rWjcwdnArYVNaenNrZFA1cENuVlo3WExYUENTaUxYSHFKTHUrZ3hmOUkrN2JlZndVT3QrVm1Ed2ovRzdpUjc5SDhKU1FmZUZiMzUydjB6amptZWM3SlRwdTVyT3pCdVZZajczcUl4RnRsMThlMHpaWHZ2QXB3Zms5THlmdHlaYyt1eThSYmVHeXh2Y2RWcmNsZE44SWQzdGNPSmkydk5pWEx3bmFReGo5MlI4Lyt5VmgrTXNZR3ZqeW43NGxpTTlqNFNDK3c1dEFmbyt3WjQ1M0dkalhZWEduQ1FLWVptYm1mYXpoWlp5d2dHMFhaZDFCWTUwZ2dSUDRmdDJCZk5BbGZnbzRmNVJnZnRYbGZPVHhmd0tBZngrb2Y1ckFmd2RRZ1BqeFdVWVhnU0NJQ2FXbGZ1KzBiek40UllPcGdJRTZPQW84MklPaDhJTkErQWxDT0lTZFlHZXRsbWRHNkFvcXVJU3F3R1NLOW1STzZBbzNkbWM2Tm9Xd0FJVk9ob1d6Z0lRTXhvVmdHSVppT0laa3lBbUJBQUFoK1FRSkJ3Qi9BQ3dBQUFBQXlBRElBQUFILzRCL2dvT0VoWWFIaUltS2k0eU5qbytRa1pLVGxKV1dsNWlabXB1Y25aNmZvS0dpbzZTbHBxZW9xYXFycksydXI3Q3hzck8wdGJhM3VMbXVHQVc5QlJpNndjS1BjTDdHQlhERHlzdURMTWZITE16U3VzWFB4OG5UMmJUVzF0cmVzTHpjeDhEZjVhcmkzZWJxcHVqUDYrK2o3Y2Z3OUoveXh2WDVtL2UrK3RsT2Z3Q0c0dGZyQXFnT2Z4RDYyOVNFZ01PSFRld1IvSVFoZ2NXTDVCWlNRdk93NDBNMG5RZ1c2SFRtb3NtTFp6Uk84c2lTUU1pSm5FN0tUS0F5VXN1V25FVEduQ216cGlNeU4xbnUyVWZRWUtZK1BHVis4Y21vWVZDUFJQbHRTaW96STFORVQxbEd6S1F6VTBXcUo2OHF5c3BTVTFkTVlIdUt4VXEyWXd1dU1QOHZvVWdiZHUyaEZtMDdncndrMG1pbGtuUXZvckI3Q0dqZWg1ak9WZ3BzY2lsaFE0Y2ZCdUVibDlJUHhoY2ZzNDFNV2FvbHpCWTFJOEliZVNzbHhaSytNaDRzK2xCa2h3SW45VjBNbWtyclEyOWV2ejFkT2RKY3pHdHViejVNaHJkblNWOUEweFIrYU05cmw3SjdQMUxlaC9ud3ZKTWxvWFowR2JSMVJFNmVSK2ZuZDdyMzc0aWNIamI5YURzajFZR3RvaThrUHBKN1JSMlV6MDhVUkxkOTZZdjh4dGdQK3lYeTNGRHRBWmdJVXVjVldGaDlqc3ptaUhLT09YalhhMjhrZUJ3amE0REdtb1hYdGFYaFBlWmhCcUlpNnVXMUd5UDNHU0pnZkNlTzlWcHNpclJJU0g0TnhuaElmNjgxSXFFaXloR29vNEd2WlZlamdvUjBaK0wvUWdBMDZTUUFvSERVNHlJMkNxSmNTcCs4c0FJQ1hDYnh3aXBQaGdtbEo2U3RSeVdTZ3NCSDE0ZWNjTUhsbTNDaUl1YWNuMENJU0pYNmViSWxuSHdpd0lVcGN3YmFTWXB0clhqSWp5NkNKaDhtYnZUcEtBS2xCQ3JwbUpvOHQ5ZWhTQUsycENablBQcG9FcVJNT3FrbVBISjJKNUpCYWpLQnA2eU9JcXFvbFJaNTZvWko1b2xKRXF5eU9vR3JyNDU2U1hoVEduS2ZjZ3BaQWtTdXVmTGFLNnlXbEprWGU0TWdtcWFIbDd5QUxMSzdpckpzcjVZOFI2TWcyK0c0S1NWN1h0dXFzdHY2T2tsdWtSa0tyblF2MGhVY0piaWFpMnlvNlhLN1VyQ0RoQ1BQb3JaR2NxeTl5SUtLYjc2dlN1SmNhY0tTV0lpYWFWVVhpWnNFWHdzby84TDZRdUtzaUlWVWd3NDJoRkFiU2JrVnMvcm5LUmhuN0FpL3phQVRqU0U1TmxKdnljbXFrckxLaXhDYUZTSWVYNE1JWm9zbU1qRE5yR0xKeXMwSk4zS1l1dzhiRS9RZzhWTGx5S3BFczJvd0xFaXJxMGlwV1JXWFNYSjBDYmtJeVZYenVVSXRXV3NkNGswN3BjVklvMlUvZXJJdGFVdXFpSlJQWFpxSnBra1pmVWluY1RzS2hEQjEwNW1JWVd4L1FsV0Zoa3hBZHVBSVhEMU00V0lxc2pFQkxZUUFpZ2hSczJuSXpKQnplZlkwbEZkK2VCQ1RGU3ZLRno4UWFCc2lRNGZPNVpmZWxCNm1NaFRMenVYZzZ0anVwRERXNmg1NVBiNExJL3dLMlJKdnV5NlBsKzIzUHFYcklyc2JWMUdPUy9CeGp5NVc0YmpFVG5UeWRxWGRmZi9adkxkMnMvUTBTeTVjeXJtVXJEMTZDRE5QOE53RmJoc00xY2lXZnlMT3QyRC82WkNFc05zeUh2VStBQXJDY016UTBwdVNRRDhET3ZDQkVJeWdCQ2RJd1FvV2dnTUJ5S0FHTjhqQkRucndneURVSUFmcXdRTURtUENFS0V5aENsZkl3aGFla0FlVTBFQUlaMGpER25aUUErdG9nd3QzeU1NZXFyQU5rVkNCRFlkSVJCQ3F3QndrOEtFU2w5aENFanhDaGtXTW9oUURnRU52NkpDSldNeWlBWURZaUNsNnNZamYwS0lZbWRnSURIN3hqRFFjWVRaS09NWTI4aENHaTBDakhHZW9EVGZhY1llTW1LTWVQVmpITy9wUmhYbmNveUF6Mk1jL0d0SUFnUnprSGd0NVNEOHl3b3lLbEtNYXA4SEdSdG9Sam5HTXBCekRhRWs3T2dML2lwcjBZaFcxY2NWT2lwR0xqUkJpS0tWNHhISWswWlJaZENJa1FMbEtHNDZ5SEtXRXBROVJHUWxJMWhLRWszeEhKWFhaUWt4YThKaklUS1l5bDhuTVp1S2lDMHdRZ0RRdDRJVnBpT0VFQ3NobUVYWVF3UXBZUUpyZ0JHY1hsTEdEYkpyVG5DZHdJQVdpR2M1MkNtQVlZamluUExVNXBBMjQ4NTRDcUVBdzVzbFBCWUJ2UDEzQUp6NHRvQXRzOXBPZjNKd1BCNzRwVUh6cTRxQUhQY0VRdnNQT2h1S3ptcmVJSjBRUFdnVGgyTk9pRGQwQUxpYXcwWTMrVXl3VkFDbElSWG9Ma3BaMG8xRll5eFFZcXRLR1B2U2xHejFCQkppU2dacXE5S1k0M1NnYlZHSUVuNnFVb0xrd2FGQTNtZ1Y5ZU5Pb0tnMm1MWWF3MUplZUlLYncvNmdvVkcwcURJMVdkYU5GMktrNVBycFZpNDVUR1Y5OTZVbVo0WVd5cmpRUlV2aURFSVFRaGxKWTRRODk2TUVXRk9IU3RFSlVETk40cWxzRnlnUkZtR0FCaUUyc0NVU1JnZ0U0OXJFcFVFUVIvQXJScXk1RHE0TnRwd1gwaVlnd0pQYXppYTFySjdidzJOSStkcStKVUNwbDU5blJZSkExcys0MGdpSThBTnJhTHFBVFNEQ3RiZ2V3aUN5czlxQnJqVVZBWVh2UEREREN0cmJseEc1M3l3ZzIvTGFmQ1owRlRZa0xUcVF1UWdqSXJhMW9NVUhhNVpxMkI0MVE3WE96bWM1WVlKYTYrWFJFZG11NzJFVDQ0QUR3UFlBUEZORlk3NXJXRVZFWUwydGRVVlQwaHBPbGpSakJlbXVMQ0RYRTk4QUhVQU1pN0t2YkpUeWlyL3JOWnY5VFZlSGZjQmIyRVJzWU1JRU5VUUlFSTdnRWgyQ3dicUVBaWNsRzJKd1ROY1Z3SzJ6ZFJ4eFd3NTgxaElFOWpHQUZGMExFcG8xc0pNUTczbE5VV0pwbmhZUUFZUHpaRVJpQ3hqUTJ4Qkp3WEZvK1NLS2NKMVpBS2M2YldRQkhnc2lmOVVBaDNvdGtCTS8zeGt4K0xDVWcvTnpXaXNLL0Y1N0VFTENNMlBZU29zdEpMa1I5d3p6aFNaaTR4NkpJS1hGYlBBazJJL1lRY1Bhd0lhQVFaakZiZ3NkcHhXb29pSXZSU3J3WXkwWStjcUFQZklnbEYxckhsZkFxWlVlaFo3ZGFtUklaOWpNaUprM3BFQmQ2QUNTK0JKbXJxbWhRdURYTmwvRHpBb1F3YWxMREZ4RTlPRFZ2TTNIbnFwS2lySnpGQkhaRlhXdGJKMExYNE0xRWZyLy9TZ29xQzFTMm01QzFsb3RONmtUazl0U2M4RzFRelh4bWxScVhFd0ptczVzQmJlc0QwUGZVRHVhRWMxK3FZb3Z5V1JPeVhrUzV6YTBJWFg4QzBlZU1iaWtFR21ST1BKcklrVTdFdkJkaDZUQmptaE5RNXVjcXZGQlJhb0tDdHNSV3hNQVhvV3NrZ09LYTVpd0NZQmNpYTFyTHU5eU15RFcySnpoc05qZGk0aFEvZGJJaktPdFBVM3ZTalNEMHlDRVliaXlQVytJZ2I4U2NtWnh1QjRiYTVJNUFPU04wbldvRC9odkdLVDU1emh1UmhWTWZYRWVlamJqU2pmMElleHRRMXU5OGhOQVp3UWVyNjZqa1JMNDVJN2JPaUozamVPVW5pbmNreUQ3MG1ZT281Z0NYQk5zSmp1NFQvUnpMazVoN3lndGQ5QUoxUE85TGg0VElDMjJoL3lGTEhSSjYzM3VZbmV4M1AyOTM3WUdIUkhjSnY1ODFpN3NTaVYrRTJVVmM1KytvblJLWlZ6eVQ1M04wRFFjYzhGU25STUdaL1BUV1FCem9tSSs4SkNwdW5iOWJJdlNMR0h5WW1STjEyTWMrOVpYUU5XcGJVL29CVC92MnNwZkV0UTB1SEQrTEhmWFZ4c1RtR2R4ODN5TWYrSlp3dTJiWWZQcnJSeDhUcXhleGNPQSs0RTNnM2hGaDdybG9lai9nckdmaS9JM29PbzZIM3hvaWN3TCtqUmg5N2N0Ly8rUm5uL3JmOFhxMmRYeWFnSCtOc0h5N1pYSHpRWDRMMEgwRjZIK1hFSDREb0g0RklsSXVaMzRRbUFrazFuZk9OSFlaMklHcVlJQWdLQW9pT0lLZ1VJSW02QWtvbUlLY3dHV1Q5bVVzNkFyWUY0T3JNR053Wm1NMDZCNEtIZFpsSUphRHNHQ0ROZWFEcytDQzhpV0VSbmlFU0ppRVNzZ0pnUUFBSWZrRUJRY0Fmd0FzQUFBQUFNZ0F5QUFBQi8rQWY0S0RoSVdHaDRpSmlvdU1qWTZQa0pHU2s1U1ZscGVZbVpxYm5KMmVuNkNob3FPa3BhYW5xS21xcTZ5dHJxK3dzYkt6dExXMnQ3aTVya0VFdlFSQnVzSENqMisreGdSdnc4ckxneTNIeHkzTTByckZ6OGZKMDltMDF0YmEzckM4M01mQTMrV3E0dDNtNnFib3ordnZvKzNIOFBTZjhzYjErWnYzdnZyWkFIOEFodUxYSzFTSVB3ZjliUUxBc0NGRGV3US9IU2xBc2VJUmhaWWNhbXpZaVNDQlRtWXFpcXhvQnVPa2pSczdSdVEwc21VQms1RlFvdVRra2FYTGxqQWR5WlM1YjJVbVB6ZGJqc25KYU9kTVRUVTFCVzE1a2FnaW8wY3hKY1UwY2VsSXAwK2hha1RxODVKVm5GZ1JhVTBwdFdzbEZsK3ZoajAwbHF5bHFaWC9RcWF0eUdJdDI3WU95L0xETkZma1VMdUc4T1o5YTFZU2hyNFZBZDhWTExBUzNFbUlLU29XeTdqeHBNZVJxdmF0TzNteFlNZUZJVVV1SUtLelo3eWc5MUpDaXhpT2FjcU1LV0YyTkdiMGE5aWZMNGR1Tk5yUGJkeW9KYzFtZERqeTcwU1ZkYXVPWlBzNDhMYkNkeXZTUExlcDg4REpJdzFQRktMNTlkUFFJVzFIeExvdmh1L0lzenNhYndpb2NmVFB4NHFYZm1qMFgvamc1YStuWHdoT1pNNzR4UWZWSSt3UjRsMkErV20xMzNLTGxGY2RnbG5GeGtpQkNCMElJWFlTTGtMaGFPZGRtRjZHaVJSWUhHSVlOVkJCQUNpcTBBQW9sVm1HU0lHamxmVEpGeWdrWUNNR1g2eUM0bzQ4bHZGSml4cnlSMTFhQUhKeWhvMUlKb2xLL3hrOE5wbmlqeUFld3A2Rm10U1k1SlVKbkdHS2sxd0dvRUVuUUlaSW40TnBXYWZKR2xpbW1VQXBKM2JKSlFpY2hDbWxkSEtSdUVrZmFxclpvU2h1OWttQkpuSWFzaDJIbW5TUTU2R2pVTkJubnhVQXFsNGh3NDNZbHlZWUhIcG9CNk1zdWlnSG1BUkt5SENqSldUSkQ1WmFtcWltbXE2WTBhT0R6RGJrVjBWTzhrV3BwV0xLSjZxTHF2Qm5KWjcrZ1ZsMzcxVmlKYTJJWm9xcnBvMVMwaXRtWkg3bEdpV1ZFbHNxS1cwZXU2bXlVZjRSamp6a0dCaHNKS1JLVytxZXQxcXJxWTh4c2VyclBZYThhcFZ2a1J3cExxMm1NR211cGlwSW9tNDE2R0RqN1dhU0REdnZvVnFlY2krcXlUNlM3Ui9PaUJPTklkODJFdTNBcHFvQ3d2L0JtbktxVTI2RzhIc05Jb2ladVVpNEZCL2FoeXZWWXR6bHJrVUZoOGkydnlqU2JGQ09HRnJ5b2VTNm9vTEtidWJiY25pWTFKWld6b2dJZlBPVktOUmlMODljZnJrSTBKbk14UWlhUjZ0WnNDMGNNTjBsbkI4T3VFbWRRY21JQ0o1VnAvbURNQ2xyL1dUWFVYV3kxSDJHZEdCMDJRa1FyY3ZPYXZPWWNJSXVidkpDczdFV01qSGROaVk5VFFONU42a3hiQUdWTWdZRzU1V0dDTW1FMjVpak4xa252aU82d3NoYnVZMW5xNU8yMnFycU11dm5kZGVEZCtMQ29JNkNyZlZjbkxqUHVNeDk5TWtZYWNCNkxwV3Y0ZFRxUEpkZXkrbFZHNDZWb2t3dlhndmxKY08rVnVZWUswOEw4L09HM3Rub3VPcFNzdDJUQVk5ckZielBhN3ovYzB1alN2c3R0dWQ1TlhyUUx4cU16YVZhanlEMlBBcVBDL0Y2ZWtpSTl6c3lvK2I0K2hORUdhcWxvbW5RQ0VrWVdGOEFGOGpBQmpyd2dSQ01vQVFMc1FFQldQQ0NHTXlnQmpmSXdRNWVjQVAxQUFJQ1JrakNFcHJ3aENoTW9RcEpDQVJLWk1DRE1JeWhERFdZZ1hXNFlZVTR6S0VPVCtpR1NGaGdoa0FNWWdjdFlJNFY3UENJU0ZUaENoN3hRaUU2OFlrQ3FLRTNicGpFS2xvUkFUMXNCQlMzS01SdlhQR0xTV3hFQmJsSXhoaUNNQnNpQktNYWM5akNSWlR4alREVXhocm5pRU5Hd1BHT0c1UWpIZmQ0UWp2aThZOFcxQ01mQjRrQVB3SVNqNElrNUI0Wk1jWkR2dkdNMDBpakl1ZllSamM2OG8xZW5PUWNIZEhFUzI1Ui80cmFvS0ltdjVqRlJ2elFrMDhrWWptTU9Fb3JMaEVTblVUbERFRlpEbEcyY29lbGpFUWpaZGxCU0w1RGtyZFVZU1VuU014aUd2T1l5RXltTW5IaGdSRXM0SmttQ01NMHRFQUNBMWlUQ0M1NG9BbWV5VTF1ZWtBWkxyQ21PTVZKZ2ljczBKbmRUT2NDaHFHRmNicnptaDRTZ2pybnVRQmYzdUtkK0RRQUR3S0FIdy9RazU0bTBFVTE4NGxQK0d6em4vVFVCVUVKU29JNEhBZWRDS1duTkcvUnpvVVNsQWl2a1dkRUVTb0VYUERBb2hibGdXSTJzTkdOZHZRV0h3V3BSYzBabG9PV0ZLRUtWYWxGU1hBRm9nemhwU1dOcVV3dDJnYVRDQUNuSlExb0xnYTZVNHV5UVI4YmNDbFFFVG9IWGNTaHFDb3RKejBndWxTWUNxT2lVUCsxS0JGcWFnNk5WaldpMzFSR1ZsVXFVbStFNGFzbVRRUUUvdUFESDRDaEZCSDR3d1FtSUFaRnBIU3NDOVZDTnBTS1ZuV09RQkVsT0lCZ0Ixc0NVWnhBQVloTjdBa1VRUVM4TGxTcXlxQnFYOU5wQW5zU0FneUR6ZXhnMzlvSk1TVDJzNG10YXlLSTZ0aDNZalFZWHAyc09nV2dpQnhvOXJVSDZNUU9RRXRiQlN5Q0RhVWxhRmx0NFUvVnpuTUlqSUF0YkRsUjI5b3lvZzI1eldjMmFjRlgzeTVBcUl2d2dYQmZ5MWxNZUxhNG9KMUFJMGliWEd1U1FCYVNkVzQ5SFRIZDF4WTJFVDBZZ0hvSDBBTkZIQmE3b0hYRUU3cHJXbGY4Vkx6ZFBHa2psRkRlMXlJaUMrc044QUN5Z0FqNDByWUlqN2dyZmExNVZGWGd0NXQvZllUL0JmcnJYME9rUU1BQ1RzRWhERXpiS0VDaXNRc1dKeXA2KzJEb1BpS3dGTTZzSVFDTVlRRVR1QkFjQnUxaUk4SGQ3aTZYRkE5K1psZ2hnWVFVWjFZSmhtaHhpdzFSaEJoLzlzV1FDR2VJRFZDSzhFNVd2NUh3Y1daelVJajBDbG5BN1lXeGtSTkxDUVVuOTdTaXdHK0VKNkVHS1F2MnZJUzQ4cEFMOGQ0dE4zZ1NJTzd1S0VqcVd4TlB3c3lDUFlTYU1XeUlLR3laeTVhbzhWaFpHZ3JmVHJRU0tKWXlrSU84NXdBZm9zaC9ubkVsc09yWU9UOFpFeFBHTXlJYTdlZ04vMWtCSHI2RWw2RkthRkNnZGN5WHdQTUJmTEJwVHFzWEVSUDR0RzB6RVdlbzRyaXFscVdFZERWOWlBQzQrdFVGL3JSMk16SGZySkxDeWY5azdTWlUvMDNsVnJzNkViUDlOQ2R3dTFNd2g3bWt3T1VFZjgyTVpqMy8ycjJmUmpBbmtLdFNVNUFZb0o5UTlTSitQWUJGeVBvVGdoN25qVXZ4engxekl0RStYalFpZlAxdFJVQjZ5NUxtaEpJTHFvb3dRRFNhb0hBdHJ4WEJia2JJZWdlZ29LWTRpYUJYaGFpYTFldnV0eUppTFcwSTd0ck1qV2k0dzRVTlFWV3JNdVBQWm9TZk85N0FiVXU1MjRuZ2Q4b1owV1lqaTN1Qm1RYTVJMFRlQ0ZtSE9vRDRUckVhSHNGelJyRGgwd0cvRUdZWEhuS045NXpsSGxJMUVpQlJkRVprNGQwZStyaVBZYjRJbVhNNkVqV1A4YkFocE81SVZQM3BmNzZReS9NdGliTXo0dDgyUjFET3BUd0p0NC84eno5SHo4WHI3dlJIY0R6dDhPa3gweC9oOWY5R1UwTFdTTDZPcXF0cjlyNC80cnFBdjA2WnVWMEp1emNpN0J4KzgzSEtUZ25MbzMzTDF3azZoZlhOOTVsUEF1NHhUbnBuRks1elNoUit6NWQ0K0cvMmJnblBOK0x2b0gvTjBsdGZlY2RMUXRhaTdZem8rOXZzMnZzK0V0RUcrR3Z3elBYU2Z4MFRtRGZ3OG5sZmlkZXJXUk5RVjR5WlNXOTgwMXNDOWRJM3pkcjd1d25iUTJMTE41L003dnM3ZFUyWS94RlhqM0h3TytOalRyei9FVWJlUFBrM1lmMHJkNExEenNGNnNGVjg3bmQ4bFpCOHRRVngxekYrQjhCOUJlaDltZ0IrNlljZVJIUnlubkIvbE9CaGViZE1qSUNCSEVnSy9TZGtIemdMSGppQ29sQ0NKZ2dLS0ppQ25tQmxqWlpsTE9nS0VCaURxc0JpYXBaNE5NZ2VDaGQyWlJxV2c3QmdneTdtZzdQZ2d1d2xoRVo0aEVpWWhFcklDWUVBQURzPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbWcvaWNvbnMvbG9hZGVyLmdpZlxuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWRYUm1MVGdpUHo0TkNqd2hMUzBnUjJWdVpYSmhkRzl5T2lCQlpHOWlaU0JKYkd4MWMzUnlZWFJ2Y2lBeE5pNHdMakFzSUZOV1J5QkZlSEJ2Y25RZ1VHeDFaeTFKYmlBdUlGTldSeUJXWlhKemFXOXVPaUEyTGpBd0lFSjFhV3hrSURBcElDQXRMVDROQ2p3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krRFFvOGMzWm5JSFpsY25OcGIyNDlJakV1TVNJZ2FXUTlJa3hoZVdWeVh6RWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaUlIZzlJakJ3ZUNJZ2VUMGlNSEI0SWcwS0NTQjNhV1IwYUQwaU1qUndlQ0lnYUdWcFoyaDBQU0l4T0M0ME9UZHdlQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREU0TGpRNU55SWdaVzVoWW14bExXSmhZMnRuY205MWJtUTlJbTVsZHlBd0lEQWdNalFnTVRndU5EazNJaUI0Yld3NmMzQmhZMlU5SW5CeVpYTmxjblpsSWo0TkNqeHdZWFJvSUdacGJHdzlJaU00TmtNMU5FUWlJR1E5SWswNExqSXdOU3d4T0M0eE1UZHNNQzR4TkRNc01DNHhORE5NTWpRc01pNDJNRGhNTWpFdU16a3hMREJNTnk0NU5qZ3NNVE11TkRJemJDMDFMak0xT1MwMUxqTTJUREFzTVRBdU5qY3hiRGN1T0RJMUxEY3VPREkyVERndU1qQTFMREU0TGpFeE53MEtDVXc0TGpJd05Td3hPQzR4TVRkNklpOCtEUW84TDNOMlp6NE5DZz09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2ltZy9pY29ucy9jaGVjay1ncmVlbi5zdmdcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBEOTRiV3dnZG1WeWMybHZiajBpTVM0d0lpQmxibU52WkdsdVp6MGlkWFJtTFRnaVB6NE5DandoTFMwZ1IyVnVaWEpoZEc5eU9pQkJaRzlpWlNCSmJHeDFjM1J5WVhSdmNpQXhOaTR3TGpBc0lGTldSeUJGZUhCdmNuUWdVR3gxWnkxSmJpQXVJRk5XUnlCV1pYSnphVzl1T2lBMkxqQXdJRUoxYVd4a0lEQXBJQ0F0TFQ0TkNqd2hSRTlEVkZsUVJTQnpkbWNnVUZWQ1RFbERJQ0l0THk5WE0wTXZMMFJVUkNCVFZrY2dNUzR4THk5RlRpSWdJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5MMGR5WVhCb2FXTnpMMU5XUnk4eExqRXZSRlJFTDNOMlp6RXhMbVIwWkNJK0RRbzhjM1puSUhabGNuTnBiMjQ5SWpFdU1TSWdhV1E5SWt4aGVXVnlYekVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUlnZUcxc2JuTTZlR3hwYm1zOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6RTVPVGt2ZUd4cGJtc2lJSGc5SWpCd2VDSWdlVDBpTUhCNElnMEtDU0IzYVdSMGFEMGlNVGh3ZUNJZ2FHVnBaMmgwUFNJeE15NDROekp3ZUNJZ2RtbGxkMEp2ZUQwaU1DQXdJREU0SURFekxqZzNNaUlnWlc1aFlteGxMV0poWTJ0bmNtOTFibVE5SW01bGR5QXdJREFnTVRnZ01UTXVPRGN5SWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElqNE5Danh3YjJ4NVoyOXVJR1pwYkd3OUlpTkdSa1pHUmtZaUlIQnZhVzUwY3owaU5pNHhOVFFzTVRNdU5UZzRJRFl1TWpZeExERXpMalk1TlNBeE9Dd3hMamsxTmlBeE5pNHdORFFzTUNBMUxqazNOeXd4TUM0d05qZ2dNUzQ1TlRZc05pNHdORGdnTUN3NExqQXdNaUExTGpnM0xERXpMamczTWlBTkNnazJMakUxTkN3eE15NDFPRGNnSWk4K0RRbzhMM04yWno0TkNnPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW1nL2ljb25zL2NoZWNrLXdoaXRlLnN2Z1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEQ5NGJXd2dkbVZ5YzJsdmJqMGlNUzR3SWlCbGJtTnZaR2x1WnowaWRYUm1MVGdpUHo0TkNqd2hMUzBnUjJWdVpYSmhkRzl5T2lCQlpHOWlaU0JKYkd4MWMzUnlZWFJ2Y2lBeE5pNHdMakFzSUZOV1J5QkZlSEJ2Y25RZ1VHeDFaeTFKYmlBdUlGTldSeUJXWlhKemFXOXVPaUEyTGpBd0lFSjFhV3hrSURBcElDQXRMVDROQ2p3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krRFFvOGMzWm5JSFpsY25OcGIyNDlJakV1TVNJZ2FXUTlJa3hoZVdWeVh6RWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaUlIZzlJakJ3ZUNJZ2VUMGlNSEI0SWcwS0NTQjNhV1IwYUQwaU0zQjRJaUJvWldsbmFIUTlJakUwY0hnaUlIWnBaWGRDYjNnOUlqQWdNQ0F6SURFMElpQmxibUZpYkdVdFltRmphMmR5YjNWdVpEMGlibVYzSURBZ01DQXpJREUwSWlCNGJXdzZjM0JoWTJVOUluQnlaWE5sY25abElqNE5Danh3WVhSb0lHWnBiR3c5SWlOR1JrWkdSa1lpSUdROUlrMHlMamszTVN3d2RqVXVORGd5WXpBc01DNDFPRGd0TUM0d016a3NNUzR4TnpFdE1DNHhNVE1zTVM0M05VTXlMamMzT1N3M0xqZ3lOU3d5TGpZNExEZ3VOREUxTERJdU5UWXhMRGxJTUM0ME1RMEtDVU13TGpJNE55dzRMalFzTUM0eE9EZ3NOeTQ0TVN3d0xqRXhNeXczTGpJek1rTXdMakF6Tnl3MkxqWTFNaXd3TERZdU1EWTNMREFzTlM0ME9ESldNRWd5TGprM01Yb2lMejROQ2p4d1lYUm9JR1pwYkd3OUlpTkdSa1pHUmtZaUlHUTlJazB3TERFeUxqVmpMVEF1TURBMExUQXVNemszTERBdU1UVXhMVEF1TnpjNExEQXVORE10TVM0d05qRmpNQzQwTXpZdE1DNDBNemNzTVM0d09USXRNQzQxTmpNc01TNDJOVGd0TUM0ek1nMEtDV013TGpFNE1pd3dMakEzT0N3d0xqTTBNaXd3TGpFNE5Td3dMalEzTnl3d0xqTXlZekF1TVRNNExEQXVNVE0wTERBdU1qUTBMREF1TWpreUxEQXVNeklzTUM0ME56TkRNaTQ1TmpJc01USXVNRGswTERNc01USXVNamc1TERNc01USXVOUTBLQ1dNd0xEQXVNakV0TUM0d016Z3NNQzQwTURndE1DNHhNVFVzTUM0MU9USmpMVEF1TVRRMkxEQXVNell5TFRBdU5ETTFMREF1TmpRNExUQXVOemszTERBdU56azBRekV1T1RBeExERXpMamsyTXl3eExqY3dNU3d4TkM0d01ERXNNUzQxTERFMERRb0pZeTB3TGpJeE5pd3dMVEF1TkRFMUxUQXVNRE00TFRBdU5UazRMVEF1TVRFMFl5MHdMak0xTnkwd0xqRTBPQzB3TGpZME15MHdMalF6TlMwd0xqYzROeTB3TGpjNU5FTXdMakF6Tnl3eE1pNDVNRFF0TUM0d01ESXNNVEl1TnpBekxEQXNNVEl1TlhvaUx6NE5Dand2YzNablBnMEtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW1nL2ljb25zL2V4Y2xhbWF0aW9uLnN2Z1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50byArIFwiIFwiICsgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgSGVhZGVyIGZyb20gJy4uL2NvbXBvbmVudHMvSGVhZGVyJztcclxuaW1wb3J0IEZvb3RlciBmcm9tICcuLi9jb21wb25lbnRzL0Zvb3Rlcic7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGF5b3V0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHRyZW5kZXIoKSB7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHQ8ZGl2PlxyXG5cdFx0XHRcdDxIZWFkZXIvPlxyXG5cdFx0XHRcdDxtYWluPlxyXG5cdFx0XHRcdFx0e3RoaXMucHJvcHMuY2hpbGRyZW59XHJcblx0XHRcdFx0PC9tYWluPlxyXG5cdFx0XHRcdDxGb290ZXIgLz5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQpO1xyXG5cdH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL3BhZ2VzL0xheW91dC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IE5hdkxpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuXHJcbmltcG9ydCBOYXYgZnJvbSAnLi9OYXYnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHRtZW51Q29udHJvbGxlcigpIHtcclxuXHRcdGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWRlcicpO1xyXG5cdFx0aGVhZGVyLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xyXG5cdH1cclxuXHRjbG9zZU1lbnUoKSB7XHJcblx0XHRjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKTtcclxuXHRcdGhlYWRlci5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcclxuXHR9XHJcblx0cmVuZGVyKCkge1xyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0PGhlYWRlciByZWY9XCJoZWFkZXJcIj5cclxuXHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cImhhbWJ1cmdlclwiIG9uQ2xpY2s9e3RoaXMubWVudUNvbnRyb2xsZXIuYmluZCh0aGlzKX0+XHJcblx0XHRcdFx0XHQ8c3Bhbj48L3NwYW4+XHJcblx0XHRcdFx0XHQ8c3Bhbj48L3NwYW4+XHJcblx0XHRcdFx0XHQ8c3Bhbj48L3NwYW4+XHJcblx0XHRcdFx0XHQ8c3Bhbj48L3NwYW4+XHJcblx0XHRcdFx0PC9idXR0b24+XHJcblx0XHRcdFx0PE5hdkxpbmsgb25DbGljaz17dGhpcy5jbG9zZU1lbnUuYmluZCh0aGlzKX0gdG89XCIvXCIgY2xhc3NOYW1lPVwidGFtdGFtLWljb25cIj5cclxuXHRcdFx0XHRcdDxzdmcgd2lkdGg9XCIzMnB4XCIgaGVpZ2h0PVwiMzJweFwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiBlbmFibGVCYWNrZ3JvdW5kPVwibmV3IDAgMCAzMiAzMlwiIHhtbFNwYWNlPVwicHJlc2VydmVcIj5cclxuXHRcdFx0XHRcdFx0PHBvbHlsaW5lIGZpbGw9XCIjRkZGRkZGXCIgcG9pbnRzPVwiNi40LDMyIDAsMjUuNjAxIDI1LjYsMCAzMiw2LjQwMiA2LjQsMzIgXCIvPlxyXG5cdFx0XHRcdFx0PC9zdmc+XHJcblx0XHRcdFx0PC9OYXZMaW5rPlxyXG5cdFx0XHRcdDxOYXYgbWVudUNvbnRyb2xsZXI9e3RoaXMubWVudUNvbnRyb2xsZXJ9IC8+XHJcblx0XHRcdDwvaGVhZGVyPlxyXG5cdFx0KTtcclxuXHR9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy9jb21wb25lbnRzL0hlYWRlci5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IE5hdkxpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcblxyXG5cdHJlbmRlcigpIHtcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdDxuYXYgcmVmPVwibmF2XCI+XHJcblx0XHRcdFx0PHVsPlxyXG5cdFx0XHRcdFx0PGxpPlxyXG5cdFx0XHRcdFx0XHQ8TmF2TGluayBvbkNsaWNrPXt0aGlzLnByb3BzLm1lbnVDb250cm9sbGVyfSBleGFjdCB0bz1cIi9cIj4gSG9tZSA8L05hdkxpbms+XHJcblx0XHRcdFx0XHQ8L2xpPlxyXG5cdFx0XHRcdFx0PGxpPlxyXG5cdFx0XHRcdFx0XHQ8TmF2TGluayBvbkNsaWNrPXt0aGlzLnByb3BzLm1lbnVDb250cm9sbGVyfSB0bz1cIi9wZW9wbGVcIj4gUGVvcGxlIDwvTmF2TGluaz5cclxuXHRcdFx0XHRcdDwvbGk+XHJcblx0XHRcdFx0XHQ8bGk+XHJcblx0XHRcdFx0XHRcdDxOYXZMaW5rIG9uQ2xpY2s9e3RoaXMucHJvcHMubWVudUNvbnRyb2xsZXJ9IHRvPVwiL2NvbnRhY3RcIj4gQ29udGFjdCA8L05hdkxpbms+XHRcclxuXHRcdFx0XHRcdDwvbGk+XHJcblx0XHRcdFx0PC91bD5cdFx0XHRcdFx0XHRcclxuXHRcdFx0PC9uYXY+XHJcblx0XHQpO1xyXG5cdH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL2NvbXBvbmVudHMvTmF2LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvb3RlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcblx0cmVuZGVyKCkge1xyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0PGZvb3Rlcj5cclxuXHRcdFx0XHQ8YXJ0aWNsZSBjbGFzc05hbWU9XCJmb290ZXItY29udGVudFwiPlxyXG5cdFx0XHRcdFx0PGEgdGFyZ2V0PVwiX2JsYW5rXCIgY2xhc3NOYW1lPVwic29jaWFsXCIgaHJlZj1cImh0dHBzOi8vd3d3LmZhY2Vib29rLmNvbS90YW10YW1ubC9cIj5cclxuXHRcdFx0XHRcdFx0PHN2ZyB3aWR0aD1cIjEwLjgxM3B4XCIgaGVpZ2h0PVwiMjBweFwiIHZpZXdCb3g9XCIwIDAgMTAuODEzIDIwXCIgZW5hYmxlQmFja2dyb3VuZD1cIm5ldyAwIDAgMTAuODEzIDIwXCIgeG1sU3BhY2U9XCJwcmVzZXJ2ZVwiPlxyXG5cdFx0XHRcdFx0XHRcdDxwYXRoIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk0xMC40MDYsMC4wMDRMNy44MTMsMEM0Ljg5OCwwLDMuMDE2LDEuOTMyLDMuMDE2LDQuOTIydjIuMjdIMC40MDhDMC4xODQsNy4xOTIsMCw3LjM3NCwwLDcuNTk5djMuMjg5XHJcblx0XHRcdFx0XHRcdFx0XHRjMCwwLjIyNSwwLjE4NCwwLjQwNywwLjQwOCwwLjQwN2gyLjYwN3Y4LjI5N0MzLjAxNiwxOS44MTgsMy4xOTgsMjAsMy40MjMsMjBoMy40MDNjMC4yMjUsMCwwLjQwNi0wLjE4NCwwLjQwNi0wLjQwOHYtOC4yOTdoMy4wNTFcclxuXHRcdFx0XHRcdFx0XHRcdGMwLjIyNSwwLDAuNDA2LTAuMTgyLDAuNDA2LTAuNDA3bDAuMDAyLTMuMjg5YzAtMC4yMjYtMC4xODItMC40MDgtMC40MDctMC40MDhjLTAuMDAxLDAtMC4wMDEsMC0wLjAwMSwwSDcuMjMyVjUuMjY4XHJcblx0XHRcdFx0XHRcdFx0XHRjMC0wLjkyNSwwLjIyMS0xLjM5NCwxLjQyNi0xLjM5NGwxLjc0Ni0wLjAwMWMwLjIyNywwLDAuNDA4LTAuMTgzLDAuNDA4LTAuNDA4VjAuNDEyQzEwLjgxMywwLjE4NywxMC42MzEsMC4wMDQsMTAuNDA2LDAuMDA0XHJcblx0XHRcdFx0XHRcdFx0XHRMMTAuNDA2LDAuMDA0elwiLz5cclxuXHRcdFx0XHRcdFx0PC9zdmc+XHJcblx0XHRcdFx0XHQ8L2E+XHJcblxyXG5cdFx0XHRcdFx0PGEgdGFyZ2V0PVwiX2JsYW5rXCIgY2xhc3NOYW1lPVwic29jaWFsXCIgaHJlZj1cImh0dHBzOi8vdHdpdHRlci5jb20vdGFtdGFtbmxcIj5cclxuXHRcdFx0XHRcdFx0PHN2ZyB3aWR0aD1cIjI0LjY1OXB4XCIgaGVpZ2h0PVwiMjBweFwiIHZpZXdCb3g9XCIwIDAgMjQuNjU5IDIwXCIgZW5hYmxlQmFja2dyb3VuZD1cIm5ldyAwIDAgMjQuNjU5IDIwXCIgeG1sU3BhY2U9XCJwcmVzZXJ2ZVwiPlxyXG5cdFx0XHRcdFx0XHRcdDxwYXRoIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk0yNC42NTksMi4zNjZjLTAuOTA4LDAuNDAyLTEuODgyLDAuNjc0LTIuOTA1LDAuNzk2YzEuMDU1LTAuNjMxLDEuODQ2LTEuNjI0LDIuMjI1LTIuNzkzXHJcblx0XHRcdFx0XHRcdFx0XHRjLTAuOTgsMC41NzktMi4wNjMsMC45OTktMy4yMTUsMS4yMjdDMTkuODA4LDAuNTc2LDE4LjQ3MS0wLjAwMiwxNy4wNzIsMGMtMi43OTItMC4wMDItNS4wNTcsMi4yNTktNS4wNiw1LjA1MVxyXG5cdFx0XHRcdFx0XHRcdFx0Yy0wLjAwMSwwLjM4NywwLjA0NCwwLjc3MiwwLjEzMiwxLjE0OUM4LjA3OCw1Ljk5OCw0LjI4OSw0LjA4LDEuNzE4LDAuOTIzQzEuMjY4LDEuNjkzLDEuMDMxLDIuNTcsMS4wMzQsMy40NjJcclxuXHRcdFx0XHRcdFx0XHRcdGMwLDEuNzUyLDAuODk0LDMuMjk5LDIuMjUsNC4yMDNDMi40OCw3LjYzOSwxLjY5NSw3LjQyMSwwLjk5Miw3LjAzMXYwLjA2M0MwLjk5NCw5LjUsMi42OTEsMTEuNTcsNS4wNDksMTIuMDQ3XHJcblx0XHRcdFx0XHRcdFx0XHRjLTAuNDIzLDAuMTE0LTAuODY5LDAuMTc4LTEuMzMyLDAuMTc4Yy0wLjMyNiwwLTAuNjQzLTAuMDMzLTAuOTUzLTAuMDk1YzAuNjY0LDIuMDYsMi41NjMsMy40Nyw0LjcyNiwzLjUwOVxyXG5cdFx0XHRcdFx0XHRcdFx0Yy0xLjc5MywxLjQwMi00LjAwNSwyLjE2My02LjI4MiwyLjE1OGMtMC40MDksMC0wLjgxMS0wLjAyNS0xLjIwNy0wLjA3QzIuMzEzLDE5LjIxMyw1LjAwNSwyMC4wMDIsNy43NTQsMjBcclxuXHRcdFx0XHRcdFx0XHRcdGM5LjMwNSwwLDE0LjM5My03LjY5NSwxNC4zOTMtMTQuMzdsLTAuMDE4LTAuNjU0QzIzLjEyMyw0LjI2NiwyMy45OCwzLjM4MiwyNC42NTksMi4zNjZ6XCIvPlxyXG5cdFx0XHRcdFx0XHQ8L3N2Zz5cclxuXHRcdFx0XHRcdDwvYT5cclxuXHJcblx0XHRcdFx0XHQ8YSB0YXJnZXQ9XCJfYmxhbmtcIiBjbGFzc05hbWU9XCJzb2NpYWxcIiBocmVmPVwiaHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS90YW10YW1ubC9cIj5cclxuXHRcdFx0XHRcdFx0PHN2ZyB3aWR0aD1cIjIwcHhcIiBoZWlnaHQ9XCIyMHB4XCIgdmlld0JveD1cIjAgMCAyMCAyMFwiIGVuYWJsZUJhY2tncm91bmQ9XCJuZXcgMCAwIDIwIDIwXCIgeG1sU3BhY2U9XCJwcmVzZXJ2ZVwiPlxyXG5cdFx0XHRcdFx0XHRcdDxwYXRoIGZpbGw9XCIjRkZGRkZGXCIgZD1cIk0yLjU2NiwwaDE0Ljg2N0MxOC44NDYsMCwyMCwxLjA0NSwyMCwyLjU2N3YxNC44NjdDMjAsMTguOTU1LDE4Ljg0NiwyMCwxNy40MzQsMjBIMi41NjZcclxuXHRcdFx0XHRcdFx0XHRcdEMxLjE1NCwyMCwwLDE4Ljk1NSwwLDE3LjQzNFYyLjU2N0MwLDEuMDQ1LDEuMTU0LDAsMi41NjYsMHogTTE0LjU2OCwyLjIyMmMtMC41LDAuMDA1LTAuOTAyLDAuNDE1LTAuODk5LDAuOTE2djIuMTkzXHJcblx0XHRcdFx0XHRcdFx0XHRjLTAuMDAzLDAuNTAxLDAuMzk5LDAuOTExLDAuODk5LDAuOTE2aDIuMjYxYzAuNDk2LDAsMC45MDEtMC40MTIsMC45MDEtMC45MTZWMy4xMzhjMC4wMDMtMC41MDEtMC4zOTktMC45MTEtMC45LTAuOTE2aC0yLjI2XHJcblx0XHRcdFx0XHRcdFx0XHRIMTQuNTY4eiBNMTcuNzM4LDguNDU4aC0xLjc2YzAuMTcxLDAuNTU2LDAuMjU4LDEuMTM0LDAuMjU4LDEuNzE2YzAsMy4zMjYtMi43ODQsNi4wMjMtNi4yMTcsNi4wMjNcclxuXHRcdFx0XHRcdFx0XHRcdGMtMy40MzQsMC02LjIxNy0yLjY5Ny02LjIxNy02LjAyM2MwLTAuNTk3LDAuMDktMS4xNzMsMC4yNTYtMS43MTZIMi4yMjN2OC40NDhjMCwwLjQzOCwwLjM1NywwLjc5NSwwLjc5NSwwLjc5NWgxMy45MjhcclxuXHRcdFx0XHRcdFx0XHRcdGMwLjQzOC0wLjAwMiwwLjc5My0wLjM1NiwwLjc5NS0wLjc5NVY4LjQ1OEgxNy43Mzh6IE0xMC4wMiw2LjA2NWMtMi4yMTksMC00LjAxOCwxLjc0Mi00LjAxOCwzLjg5MmMwLDIuMTUsMS43OTksMy44OTMsNC4wMTgsMy44OTNcclxuXHRcdFx0XHRcdFx0XHRcdGMyLjIxNywwLDQuMDE3LTEuNzQ0LDQuMDE3LTMuODkzQzE0LjAzNiw3LjgwNywxMi4yMzYsNi4wNjUsMTAuMDIsNi4wNjV6XCIvPlxyXG5cdFx0XHRcdFx0XHQ8L3N2Zz5cclxuXHRcdFx0XHRcdDwvYT5cclxuXHRcdFx0XHQ8L2FydGljbGU+XHJcblx0XHRcdDwvZm9vdGVyPlxyXG5cdFx0KTtcclxuXHR9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy9jb21wb25lbnRzL0Zvb3Rlci5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcblxyXG5pbXBvcnQgU2xpZGVyIGZyb20gJy4uL2NvbXBvbmVudHMvU2xpZGVyJztcclxuaW1wb3J0IEludHJvIGZyb20gJy4uL2NvbXBvbmVudHMvSW50cm8nO1xyXG5pbXBvcnQgRmVlZCBmcm9tICcuLi9jb21wb25lbnRzL0ZlZWQnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSG9tZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XHJcblx0cmVuZGVyKCkge1xyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0PGRpdj5cclxuXHRcdFx0XHQ8U2xpZGVyIC8+XHJcblx0XHRcdFx0PEludHJvIC8+XHJcblx0XHRcdFx0PEZlZWQgLz5cclxuXHRcdFx0PC9kaXY+XHJcblx0XHQpO1xyXG5cdH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL3BhZ2VzL0hvbWUuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBDYXJvdXNlbCB9IGZyb20gJ3JlYWN0LXJlc3BvbnNpdmUtY2Fyb3VzZWwnO1xyXG5pbXBvcnQgYW5pbWF0ZVNjcm9sbFRvIGZyb20gJ2FuaW1hdGVkLXNjcm9sbC10byc7XHJcblxyXG5pbXBvcnQgU2xpZGUgZnJvbSAnLi9TbGlkZSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTbGlkZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cdHNjcm9sbFRvKCkge1xyXG5cdFx0YW5pbWF0ZVNjcm9sbFRvKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbnRybycpKTtcclxuXHR9XHJcblx0cmVuZGVyKCkge1xyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0PHNlY3Rpb24gY2xhc3NOYW1lPVwic2xpZGVyXCI+XHJcblx0XHRcdFx0PENhcm91c2VsIHNob3dTdGF0dXM9e2ZhbHNlfSBpbmZpbml0ZUxvb3Agc2hvd0luZGljYXRvcnM9e2ZhbHNlfT5cclxuXHRcdFx0XHRcdDxTbGlkZSB0aXRsZT1cIldhbGliaVwiIGltYWdlPVwiLi4vLi4vaW1nL3NsaWRlci93YWxpYmkuanBnXCIgbGluaz0naHR0cHM6Ly93d3cudGFtdGFtLm5sL3dlcmsvd2FsaWJpLWhvbGxhbmQvJyAvPlxyXG5cdFx0XHRcdFx0PFNsaWRlIHRpdGxlPVwiT3h4aW9cIiBpbWFnZT1cIi4uLy4uL2ltZy9zbGlkZXIvb3h4aW8uanBnXCIgbGluaz0naHR0cHM6Ly93d3cudGFtdGFtLm5sL3dlcmsvb3h4aW8vJyAvPlxyXG5cdFx0XHRcdFx0PFNsaWRlIHRpdGxlPVwiRmxvcmVuc2lzXCIgaW1hZ2U9XCIuLi8uLi9pbWcvc2xpZGVyL2Zsb3JlbnNpcy5qcGdcIiBsaW5rPSdodHRwczovL3d3dy50YW10YW0ubmwvd2Vyay9mbG9yZW5zaXMvJyAvPlxyXG5cdFx0XHRcdDwvQ2Fyb3VzZWw+XHJcblx0XHRcdFx0PGJ1dHRvbiBvbkNsaWNrPXt0aGlzLnNjcm9sbFRvLmJpbmQodGhpcyl9IGNsYXNzTmFtZT1cInNjcm9sbC1kb3duXCI+XHJcblx0XHRcdFx0XHQ8c3ZnIGNsYXNzTmFtZT1cIm1vdXNlXCIgd2lkdGg9XCIyMnB4XCIgaGVpZ2h0PVwiMzRweFwiIHZpZXdCb3g9XCIwIDAgMjIgMzRcIiBlbmFibGVCYWNrZ3JvdW5kPVwibmV3IDAgMCAyMiAzNFwiIHhtbFNwYWNlPVwicHJlc2VydmVcIj5cclxuXHRcdFx0XHRcdFx0PHBhdGggZmlsbD1cIiMwMTAxMDFcIiBkPVwiTTAsMTAuNDk3QzAsNC43MDIsNC45MzIsMCwxMSwwYzYuMDc2LDAsMTEsNC42OTYsMTEsMTAuNDk3djEzLjAwNkMyMiwyOS4yOTgsMTcuMDY4LDM0LDExLDM0XHJcblx0XHRcdFx0XHRcdFx0QzQuOTI0LDM0LDAsMjkuMzA1LDAsMjMuNTAzVjEwLjQ5N3ogTTIsMTAuNDk3djEzLjAwNkMyLDI4LjIsNi4wMjksMzIsMTEsMzJjNC45NiwwLDktMy44MDUsOS04LjQ5N1YxMC40OTdDMjAsNS44LDE1Ljk3MSwyLDExLDJcclxuXHRcdFx0XHRcdFx0XHRDNi4wNCwyLDIsNS44MDQsMiwxMC40OTd6IE05LDEwLjk5OEM5LDkuODk1LDkuODg5LDksMTEsOWMxLjEwNSwwLDIsMC44ODcsMiwxLjk5OHY0LjAwNGMwLjAwMiwxLjEwMS0wLjg4OSwxLjk5Ni0xLjk5LDEuOTk4XHJcblx0XHRcdFx0XHRcdFx0Yy0wLjAwMywwLTAuMDA2LDAtMC4wMSwwYy0xLjEwNSwwLTItMC44ODctMi0xLjk5OFYxMC45OTh6XCIvPlxyXG5cdFx0XHRcdFx0PC9zdmc+XHJcblxyXG5cdFx0XHRcdFx0PHN2ZyBjbGFzc05hbWU9XCJhcnJvd3MtZG93blwiIHdpZHRoPVwiMTIuMDYxcHhcIiBoZWlnaHQ9XCIxN3B4XCIgdmlld0JveD1cIjAgMCAxMi4wNjEgMTdcIiBlbmFibGVCYWNrZ3JvdW5kPVwibmV3IDAgMCAxMi4wNjEgMTdcIiB4bWxTcGFjZT1cInByZXNlcnZlXCI+XHJcblx0XHRcdFx0XHRcdDxwYXRoIGZpbGw9XCIjMDEwMTAxXCIgZD1cIk03LjAxOCw3LjMyMmMwLDAtMC41MjYsMC42NzgtMC45ODYsMC42NzhjLTAuNDQsMC0wLjk4OC0wLjY3OC0wLjk4OC0wLjY3OGwtMC4wMS0wLjAxbC00Ljc3Mi01LjM4XHJcblx0XHRcdFx0XHRcdFx0Yy0wLjM0OC0wLjQ0MS0wLjM0OC0xLjE2MiwwLTEuNjAyYzAuMzQ5LTAuNDQsMC45MTgtMC40NCwxLjI2NywwTDYuMDMsNC44MzVsNC41MDMtNC41MDVjMC4zNS0wLjQ0LDAuOTE4LTAuNDQsMS4yNjcsMFxyXG5cdFx0XHRcdFx0XHRcdGMwLjM0OCwwLjQ0LDAuMzQ4LDEuMTYsMCwxLjYwMUw3LjAyNyw3LjMxMkw3LjAxOCw3LjMyMkw3LjAxOCw3LjMyMnogTTcuMDE4LDE2LjMyMmMwLDAtMC41MjYsMC42NzgtMC45ODYsMC42NzhcclxuXHRcdFx0XHRcdFx0XHRjLTAuNDQsMC0wLjk4OC0wLjY3OC0wLjk4OC0wLjY3OGwtMC4wMS0wLjAxbC00Ljc3Mi01LjM4MWMtMC4zNDgtMC40NDEtMC4zNDgtMS4xNjIsMC0xLjYwMmMwLjM0OS0wLjQ0LDAuOTE4LTAuNDQsMS4yNjcsMFxyXG5cdFx0XHRcdFx0XHRcdGw0LjUwMyw0LjUwNWw0LjUwMy00LjUwNWMwLjM1LTAuNDQsMC45MTgtMC40NCwxLjI2NywwYzAuMzQ4LDAuNDM5LDAuMzQ4LDEuMTYsMCwxLjYwMmwtNC43NzIsNS4zODFMNy4wMTgsMTYuMzIyTDcuMDE4LDE2LjMyMnpcIi8+XHJcblx0XHRcdFx0XHQ8L3N2Zz5cclxuXHRcdFx0XHQ8L2J1dHRvbj5cclxuXHJcblx0XHRcdFx0PHN2ZyBjbGFzc05hbWU9XCJjaGV2cm9uLWRvd25cIiB3aWR0aD1cIjEyLjA2MnB4XCIgaGVpZ2h0PVwiOHB4XCIgdmlld0JveD1cIjAgMCAxMi4wNjIgOFwiIGVuYWJsZUJhY2tncm91bmQ9XCJuZXcgMCAwIDEyLjA2MiA4XCIgeG1sU3BhY2U9XCJwcmVzZXJ2ZVwiPlxyXG5cdFx0XHRcdFx0PHBhdGggZmlsbD1cIiNGRkZGRkZcIiBkPVwiTTUuMDQzLDcuMzIyQzUuMDQzLDcuMzIyLDUuNTcsOCw2LjAyOSw4YzAuNDQxLDAsMC45ODgtMC42NzgsMC45ODgtMC42NzhsMC4wMS0wLjAxbDQuNzcyLTUuMzhcclxuXHRcdFx0XHRcdFx0YzAuMzQ5LTAuNDQxLDAuMzQ5LTEuMTYyLDAtMS42MDJjLTAuMzQ4LTAuNDQtMC45MTktMC40NC0xLjI2NiwwTDYuMDI5LDQuODM1TDEuNTI3LDAuMzNjLTAuMzUtMC40NC0wLjkxOC0wLjQ0LTEuMjY2LDBcclxuXHRcdFx0XHRcdFx0Yy0wLjM0OSwwLjQ0LTAuMzQ5LDEuMTYsMCwxLjYwMWw0Ljc3MSw1LjM4MUw1LjA0Myw3LjMyMlwiLz5cclxuXHRcdFx0XHQ8L3N2Zz5cclxuXHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0KTtcdFxyXG5cdH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL2NvbXBvbmVudHMvU2xpZGVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5UaHVtYnMgPSBleHBvcnRzLkNhcm91c2VsID0gdW5kZWZpbmVkO1xuXG52YXIgX0Nhcm91c2VsID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL0Nhcm91c2VsJyk7XG5cbnZhciBfQ2Fyb3VzZWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ2Fyb3VzZWwpO1xuXG52YXIgX1RodW1icyA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9UaHVtYnMnKTtcblxudmFyIF9UaHVtYnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfVGh1bWJzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5DYXJvdXNlbCA9IF9DYXJvdXNlbDIuZGVmYXVsdDtcbmV4cG9ydHMuVGh1bWJzID0gX1RodW1iczIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JlYWN0RG9tID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5cbnZhciBfcmVhY3REb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3REb20pO1xuXG52YXIgX3Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKTtcblxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcblxudmFyIF9jc3NDbGFzc2VzID0gcmVxdWlyZSgnLi4vY3NzQ2xhc3NlcycpO1xuXG52YXIgX2Nzc0NsYXNzZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3NzQ2xhc3Nlcyk7XG5cbnZhciBfQ1NTVHJhbnNsYXRlID0gcmVxdWlyZSgnLi4vQ1NTVHJhbnNsYXRlJyk7XG5cbnZhciBfQ1NTVHJhbnNsYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NTU1RyYW5zbGF0ZSk7XG5cbnZhciBfcmVhY3RFYXN5U3dpcGUgPSByZXF1aXJlKCdyZWFjdC1lYXN5LXN3aXBlJyk7XG5cbnZhciBfcmVhY3RFYXN5U3dpcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3RFYXN5U3dpcGUpO1xuXG52YXIgX1RodW1icyA9IHJlcXVpcmUoJy4vVGh1bWJzJyk7XG5cbnZhciBfVGh1bWJzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1RodW1icyk7XG5cbnZhciBfY3VzdG9tUHJvcFR5cGVzID0gcmVxdWlyZSgnLi4vY3VzdG9tUHJvcFR5cGVzJyk7XG5cbnZhciBjdXN0b21Qcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY3VzdG9tUHJvcFR5cGVzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcblxudmFyIGRlZmF1bHRTdGF0dXNGb3JtYXR0ZXIgPSBmdW5jdGlvbiBkZWZhdWx0U3RhdHVzRm9ybWF0dGVyKGN1cnJlbnQsIHRvdGFsKSB7XG4gICAgcmV0dXJuIGN1cnJlbnQgKyAnIG9mICcgKyB0b3RhbDtcbn07XG5cbnZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gICAgX2luaGVyaXRzKENhcm91c2VsLCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIENhcm91c2VsKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXJvdXNlbCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENhcm91c2VsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2Fyb3VzZWwpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuYXV0b1BsYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLmF1dG9QbGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZXIpO1xuICAgICAgICAgICAgX3RoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmNyZW1lbnQoKTtcbiAgICAgICAgICAgIH0sIF90aGlzLnByb3BzLmludGVydmFsKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5jbGVhckF1dG9QbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5hdXRvUGxheSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVyKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5yZXNldEF1dG9QbGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJBdXRvUGxheSgpO1xuICAgICAgICAgICAgX3RoaXMuYXV0b1BsYXkoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5zdG9wT25Ib3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXNNb3VzZUVudGVyZWQ6IHRydWUgfSk7XG4gICAgICAgICAgICBfdGhpcy5jbGVhckF1dG9QbGF5KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuc3RhcnRPbkxlYXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc01vdXNlRW50ZXJlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICBfdGhpcy5hdXRvUGxheSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLm5hdmlnYXRlV2l0aEtleWJvYXJkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBheGlzID0gX3RoaXMucHJvcHMuYXhpcztcblxuICAgICAgICAgICAgdmFyIGlzSG9yaXpvbnRhbCA9IGF4aXMgPT09ICdob3Jpem9udGFsJztcbiAgICAgICAgICAgIHZhciBrZXlOYW1lcyA9IHtcbiAgICAgICAgICAgICAgICBBcnJvd1VwOiAzOCxcbiAgICAgICAgICAgICAgICBBcnJvd1JpZ2h0OiAzOSxcbiAgICAgICAgICAgICAgICBBcnJvd0Rvd246IDQwLFxuICAgICAgICAgICAgICAgIEFycm93TGVmdDogMzdcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBuZXh0S2V5ID0gaXNIb3Jpem9udGFsID8ga2V5TmFtZXMuQXJyb3dSaWdodCA6IGtleU5hbWVzLkFycm93RG93bjtcbiAgICAgICAgICAgIHZhciBwcmV2S2V5ID0gaXNIb3Jpem9udGFsID8ga2V5TmFtZXMuQXJyb3dMZWZ0IDoga2V5TmFtZXMuQXJyb3dVcDtcblxuICAgICAgICAgICAgaWYgKG5leHRLZXkgPT09IGUua2V5Q29kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmluY3JlbWVudCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2S2V5ID09PSBlLmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kZWNyZW1lbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy51cGRhdGVTaXplcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc0hvcml6b250YWwgPSBfdGhpcy5wcm9wcy5heGlzID09PSAnaG9yaXpvbnRhbCc7XG4gICAgICAgICAgICB2YXIgZmlyc3RJdGVtID0gX3RoaXMucmVmcy5pdGVtMDtcbiAgICAgICAgICAgIHZhciBpdGVtU2l6ZSA9IGlzSG9yaXpvbnRhbCA/IGZpcnN0SXRlbS5jbGllbnRXaWR0aCA6IGZpcnN0SXRlbS5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpdGVtU2l6ZTogaXRlbVNpemUsXG4gICAgICAgICAgICAgICAgd3JhcHBlclNpemU6IGlzSG9yaXpvbnRhbCA/IGl0ZW1TaXplICogX3RoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoIDogaXRlbVNpemVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLnNldE1vdW50U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGhhc01vdW50OiB0cnVlIH0pO1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5oYW5kbGVDbGlja0l0ZW0gPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5jYW5jZWxDbGljaykge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQ2xpY2s6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2xpY2tJdGVtKGluZGV4LCBpdGVtKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBfdGhpcy5zdGF0ZS5zZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbTogaW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5oYW5kbGVPbkNoYW5nZSA9IGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UoaW5kZXgsIGl0ZW0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrVGh1bWIgPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2xpY2tUaHVtYihpbmRleCwgaXRlbSk7XG5cbiAgICAgICAgICAgIF90aGlzLnNlbGVjdEl0ZW0oe1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbTogaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLm9uU3dpcGVTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBzd2lwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyQXV0b1BsYXkoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5vblN3aXBlRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMucmVzZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHN3aXBpbmc6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLmF1dG9QbGF5KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMub25Td2lwZU1vdmUgPSBmdW5jdGlvbiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBpc0hvcml6b250YWwgPSBfdGhpcy5wcm9wcy5heGlzID09PSAnaG9yaXpvbnRhbCc7XG5cbiAgICAgICAgICAgIHZhciBpbml0aWFsQm91bmRyeSA9IDA7XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50UG9zaXRpb24gPSBfdGhpcy5nZXRQb3NpdGlvbihfdGhpcy5zdGF0ZS5zZWxlY3RlZEl0ZW0pO1xuICAgICAgICAgICAgdmFyIGZpbmFsQm91bmRyeSA9IF90aGlzLmdldFBvc2l0aW9uKF90aGlzLnByb3BzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgICAgICB2YXIgYXhpc0RlbHRhID0gaXNIb3Jpem9udGFsID8gZGVsdGEueCA6IGRlbHRhLnk7XG4gICAgICAgICAgICB2YXIgaGFuZGxlZERlbHRhID0gYXhpc0RlbHRhO1xuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHVzZXIgZnJvbSBzd2lwaW5nIGxlZnQgb3V0IG9mIGJvdW5kYXJpZXNcbiAgICAgICAgICAgIGlmIChjdXJyZW50UG9zaXRpb24gPT09IGluaXRpYWxCb3VuZHJ5ICYmIGF4aXNEZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVkRGVsdGEgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHVzZXIgZnJvbSBzd2lwaW5nIHJpZ2h0IG91dCBvZiBib3VuZGFyaWVzXG4gICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID09PSBmaW5hbEJvdW5kcnkgJiYgYXhpc0RlbHRhIDwgMCkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWREZWx0YSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbiArIDEwMCAvIChfdGhpcy5zdGF0ZS5pdGVtU2l6ZSAvIGhhbmRsZWREZWx0YSkgKyAnJSc7XG5cbiAgICAgICAgICAgIF90aGlzLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcblxuICAgICAgICAgICAgLy8gYWxsb3dzIHNjcm9sbCBpZiB0aGUgc3dpcGUgd2FzIHdpdGhpbiB0aGUgdG9sZXJhbmNlXG4gICAgICAgICAgICB2YXIgaGFzTW92ZWQgPSBNYXRoLmFicyhheGlzRGVsdGEpID4gX3RoaXMucHJvcHMuc3dpcGVTY3JvbGxUb2xlcmFuY2U7XG5cbiAgICAgICAgICAgIGlmIChoYXNNb3ZlZCAmJiAhX3RoaXMuc3RhdGUuY2FuY2VsQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbENsaWNrOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYXNNb3ZlZDtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5yZXNldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IF90aGlzLmdldFBvc2l0aW9uKF90aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSkgKyAnJSc7XG4gICAgICAgICAgICBfdGhpcy5zZXRQb3NpdGlvbihjdXJyZW50UG9zaXRpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbGlzdCA9IF9yZWFjdERvbTIuZGVmYXVsdC5maW5kRE9NTm9kZShfdGhpcy5yZWZzLml0ZW1MaXN0KTtcbiAgICAgICAgICAgIFsnV2Via2l0VHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdNc1RyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ3RyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBsaXN0LnN0eWxlW3Byb3BdID0gKDAsIF9DU1NUcmFuc2xhdGUyLmRlZmF1bHQpKHBvc2l0aW9uLCBfdGhpcy5wcm9wcy5heGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmRlY3JlbWVudCA9IGZ1bmN0aW9uIChwb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIF90aGlzLm1vdmVUbyhfdGhpcy5zdGF0ZS5zZWxlY3RlZEl0ZW0gLSAodHlwZW9mIHBvc2l0aW9ucyA9PT0gJ051bWJlcicgPyBwb3NpdGlvbnMgOiAxKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuaW5jcmVtZW50ID0gZnVuY3Rpb24gKHBvc2l0aW9ucykge1xuICAgICAgICAgICAgX3RoaXMubW92ZVRvKF90aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSArICh0eXBlb2YgcG9zaXRpb25zID09PSAnTnVtYmVyJyA/IHBvc2l0aW9ucyA6IDEpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5tb3ZlVG8gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBsYXN0UG9zaXRpb24gPSBfdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBfdGhpcy5wcm9wcy5pbmZpbml0ZUxvb3AgPyBsYXN0UG9zaXRpb24gOiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPiBsYXN0UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IF90aGlzLnByb3BzLmluZmluaXRlTG9vcCA/IDAgOiBsYXN0UG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzLnNlbGVjdEl0ZW0oe1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0J3Mgbm90IGEgc2xpZGVyLCB3ZSBkb24ndCBuZWVkIHRvIHNldCBwb3NpdGlvbiBoZXJlXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtOiBwb3NpdGlvblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGRvbid0IHJlc2V0IGF1dG8gcGxheSB3aGVuIHN0b3Agb24gaG92ZXIgaXMgZW5hYmxlZCwgZG9pbmcgc28gd2lsbCB0cmlnZ2VyIGEgY2FsbCB0byBhdXRvIHBsYXkgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICAgIC8vIGFuZCB3aWxsIHJlc3VsdCBpbiB0aGUgaW50ZXJ2YWwgZnVuY3Rpb24gbm90IGJlaW5nIGNsZWFyZWQgY29ycmVjdGx5LlxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmF1dG9QbGF5ICYmIF90aGlzLnN0YXRlLmlzTW91c2VFbnRlcmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0QXV0b1BsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5jaGFuZ2VJdGVtID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdJbmRleCA9IGUudGFyZ2V0LnZhbHVlO1xuXG4gICAgICAgICAgICBfdGhpcy5zZWxlY3RJdGVtKHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW06IG5ld0luZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5zZWxlY3RJdGVtID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVPbkNoYW5nZShzdGF0ZS5zZWxlY3RlZEl0ZW0sIF90aGlzLnByb3BzLmNoaWxkcmVuW3N0YXRlLnNlbGVjdGVkSXRlbV0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzLmdldEluaXRpYWxJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEl0ZW0gPSBfdGhpcy5wcm9wcy5zZWxlY3RlZEl0ZW07XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzLnJlZnNbJ2l0ZW0nICsgc2VsZWN0ZWRJdGVtXTtcbiAgICAgICAgICAgIHZhciBpbWFnZXMgPSBpdGVtICYmIGl0ZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpO1xuICAgICAgICAgICAgcmV0dXJuIGltYWdlcyAmJiBpbWFnZXNbc2VsZWN0ZWRJdGVtXTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5nZXRWYXJpYWJsZUltYWdlSGVpZ2h0ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzLnJlZnNbJ2l0ZW0nICsgcG9zaXRpb25dO1xuICAgICAgICAgICAgdmFyIGltYWdlcyA9IGl0ZW0gJiYgaXRlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJyk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuaGFzTW91bnQgJiYgaW1hZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2UgPSBpbWFnZXNbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpbWFnZSBpcyBzdGlsbCBsb2FkaW5nLCB0aGUgc2l6ZSB3b24ndCBiZSBhdmFpbGFibGUgc28gd2UgdHJpZ2dlciBhIG5ldyByZW5kZXIgYWZ0ZXIgaXQncyBkb25lXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkltYWdlTG9hZCA9IGZ1bmN0aW9uIG9uSW1hZ2VMb2FkKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkltYWdlTG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uSW1hZ2VMb2FkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWlnaHQgPiAwID8gaGVpZ2h0IDogbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgICBzZWxlY3RlZEl0ZW06IHByb3BzLnNlbGVjdGVkSXRlbSxcbiAgICAgICAgICAgIGhhc01vdW50OiBmYWxzZSxcbiAgICAgICAgICAgIGlzTW91c2VFbnRlcmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENhcm91c2VsLCBbe1xuICAgICAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXR1cENhcm91c2VsKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcHMuc2VsZWN0ZWRJdGVtICE9PSB0aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUbyhuZXh0UHJvcHMuc2VsZWN0ZWRJdGVtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5leHRQcm9wcy5hdXRvUGxheSAhPT0gdGhpcy5wcm9wcy5hdXRvUGxheSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXh0UHJvcHMuYXV0b1BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cEF1dG9QbGF5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QXV0b1BsYXkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudERpZFVwZGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIXByZXZQcm9wcy5jaGlsZHJlbiAmJiB0aGlzLnByb3BzLmNoaWxkcmVuICYmICF0aGlzLnN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cENhcm91c2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95Q2Fyb3VzZWwoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0dXBDYXJvdXNlbCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cENhcm91c2VsKCkge1xuICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmF1dG9QbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cEF1dG9QbGF5KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGluaXRpYWxJbWFnZSA9IHRoaXMuZ2V0SW5pdGlhbEltYWdlKCk7XG4gICAgICAgICAgICBpZiAoaW5pdGlhbEltYWdlKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhIGNhcm91c2VsIG9mIGltYWdlcywgd2Ugc2V0IHRoZSBtb3VudCBzdGF0ZSBhZnRlciB0aGUgZmlyc3QgaW1hZ2UgaXMgbG9hZGVkXG4gICAgICAgICAgICAgICAgaW5pdGlhbEltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLnNldE1vdW50U3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1vdW50U3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveUNhcm91c2VsJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lDYXJvdXNlbCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lBdXRvUGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXR1cEF1dG9QbGF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwQXV0b1BsYXkoKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9QbGF5KCk7XG4gICAgICAgICAgICB2YXIgY2Fyb3VzZWxXcmFwcGVyID0gdGhpcy5yZWZzWydjYXJvdXNlbFdyYXBwZXInXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuc3RvcE9uSG92ZXIgJiYgY2Fyb3VzZWxXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgY2Fyb3VzZWxXcmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLnN0b3BPbkhvdmVyKTtcbiAgICAgICAgICAgICAgICBjYXJvdXNlbFdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuc3RhcnRPbkxlYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveUF1dG9QbGF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lBdXRvUGxheSgpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBdXRvUGxheSgpO1xuICAgICAgICAgICAgdmFyIGNhcm91c2VsV3JhcHBlciA9IHRoaXMucmVmc1snY2Fyb3VzZWxXcmFwcGVyJ107XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnN0b3BPbkhvdmVyICYmIGNhcm91c2VsV3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGNhcm91c2VsV3JhcHBlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5zdG9wT25Ib3Zlcik7XG4gICAgICAgICAgICAgICAgY2Fyb3VzZWxXcmFwcGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLnN0YXJ0T25MZWF2ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2JpbmRFdmVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50cygpIHtcbiAgICAgICAgICAgIC8vIGFzIHRoZSB3aWR0aHMgYXJlIGNhbGN1bGF0ZWQsIHdlIG5lZWQgdG8gcmVzaXplXG4gICAgICAgICAgICAvLyB0aGUgY2Fyb3VzZWwgd2hlbiB0aGUgd2luZG93IGlzIHJlc2l6ZWRcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMudXBkYXRlU2l6ZXMpO1xuICAgICAgICAgICAgLy8gaXNzdWUgIzIgLSBpbWFnZSBsb2FkaW5nIHNtYWxsZXJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCB0aGlzLnVwZGF0ZVNpemVzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMudXNlS2V5Ym9hcmRBcnJvd3MpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm5hdmlnYXRlV2l0aEtleWJvYXJkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5iaW5kRXZlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZEV2ZW50cygpIHtcbiAgICAgICAgICAgIC8vIHJlbW92aW5nIGxpc3RlbmVyc1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy51cGRhdGVTaXplcyk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgdGhpcy51cGRhdGVTaXplcyk7XG5cbiAgICAgICAgICAgIHZhciBpbml0aWFsSW1hZ2UgPSB0aGlzLmdldEluaXRpYWxJbWFnZSgpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxJbWFnZSkge1xuICAgICAgICAgICAgICAgIGluaXRpYWxJbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLnNldE1vdW50U3RhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy51c2VLZXlib2FyZEFycm93cykge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMubmF2aWdhdGVXaXRoS2V5Ym9hcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRQb3NpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbihpbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuY2VudGVyTW9kZSAmJiB0aGlzLnByb3BzLmF4aXMgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50UG9zaXRpb24gPSAtaW5kZXggKiB0aGlzLnByb3BzLmNlbnRlclNsaWRlUGVyY2VudGFnZTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFBvc2l0aW9uID0gdGhpcy5wcm9wcy5jaGlsZHJlbi5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICYmIGluZGV4ICE9PSBsYXN0UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uICs9ICgxMDAgLSB0aGlzLnByb3BzLmNlbnRlclNsaWRlUGVyY2VudGFnZSkgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGxhc3RQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gKz0gMTAwIC0gdGhpcy5wcm9wcy5jZW50ZXJTbGlkZVBlcmNlbnRhZ2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIC1pbmRleCAqIDEwMDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVuZGVySXRlbXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVySXRlbXMoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1DbGFzcyA9IF9jc3NDbGFzc2VzMi5kZWZhdWx0LklURU0odHJ1ZSwgaW5kZXggPT09IF90aGlzMi5zdGF0ZS5zZWxlY3RlZEl0ZW0pO1xuICAgICAgICAgICAgICAgIHZhciBzbGlkZVByb3BzID0ge1xuICAgICAgICAgICAgICAgICAgICByZWY6ICdpdGVtJyArIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdpdGVtS2V5JyArIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IF9jc3NDbGFzc2VzMi5kZWZhdWx0LklURU0odHJ1ZSwgaW5kZXggPT09IF90aGlzMi5zdGF0ZS5zZWxlY3RlZEl0ZW0pLFxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiBfdGhpczIuaGFuZGxlQ2xpY2tJdGVtLmJpbmQoX3RoaXMyLCBpbmRleCwgaXRlbSlcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzMi5wcm9wcy5jZW50ZXJNb2RlICYmIF90aGlzMi5wcm9wcy5heGlzID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVQcm9wcy5zdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBfdGhpczIucHJvcHMuY2VudGVyU2xpZGVQZXJjZW50YWdlICsgJyUnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnbGknLFxuICAgICAgICAgICAgICAgICAgICBzbGlkZVByb3BzLFxuICAgICAgICAgICAgICAgICAgICBpdGVtXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXJDb250cm9scycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDb250cm9scygpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvcHMuc2hvd0luZGljYXRvcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICd1bCcsXG4gICAgICAgICAgICAgICAgeyBjbGFzc05hbWU6ICdjb250cm9sLWRvdHMnIH0sXG4gICAgICAgICAgICAgICAgX3JlYWN0Mi5kZWZhdWx0LkNoaWxkcmVuLm1hcCh0aGlzLnByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdsaScsIHsgY2xhc3NOYW1lOiBfY3NzQ2xhc3NlczIuZGVmYXVsdC5ET1QoaW5kZXggPT09IF90aGlzMy5zdGF0ZS5zZWxlY3RlZEl0ZW0pLCBvbkNsaWNrOiBfdGhpczMuY2hhbmdlSXRlbSwgdmFsdWU6IGluZGV4LCBrZXk6IGluZGV4IH0pO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXJTdGF0dXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyU3RhdHVzKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BzLnNob3dTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICdwJyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogJ2Nhcm91c2VsLXN0YXR1cycgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnN0YXR1c0Zvcm1hdHRlcih0aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSArIDEsIHRoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVuZGVyVGh1bWJzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRodW1icygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcy5zaG93VGh1bWJzIHx8IHRoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICBfVGh1bWJzMi5kZWZhdWx0LFxuICAgICAgICAgICAgICAgIHsgb25TZWxlY3RJdGVtOiB0aGlzLmhhbmRsZUNsaWNrVGh1bWIsIHNlbGVjdGVkSXRlbTogdGhpcy5zdGF0ZS5zZWxlY3RlZEl0ZW0sIHRyYW5zaXRpb25UaW1lOiB0aGlzLnByb3BzLnRyYW5zaXRpb25UaW1lLCB0aHVtYldpZHRoOiB0aGlzLnByb3BzLnRodW1iV2lkdGggfSxcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BzLmNoaWxkcmVuIHx8IHRoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpdGVtc0xlbmd0aCA9IHRoaXMucHJvcHMuY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgaXNIb3Jpem9udGFsID0gdGhpcy5wcm9wcy5heGlzID09PSAnaG9yaXpvbnRhbCc7XG5cbiAgICAgICAgICAgIHZhciBjYW5TaG93QXJyb3dzID0gdGhpcy5wcm9wcy5zaG93QXJyb3dzICYmIGl0ZW1zTGVuZ3RoID4gMTtcblxuICAgICAgICAgICAgLy8gc2hvdyBsZWZ0IGFycm93P1xuICAgICAgICAgICAgdmFyIGhhc1ByZXYgPSBjYW5TaG93QXJyb3dzICYmICh0aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSA+IDAgfHwgdGhpcy5wcm9wcy5pbmZpbml0ZUxvb3ApO1xuICAgICAgICAgICAgLy8gc2hvdyByaWdodCBhcnJvd1xuICAgICAgICAgICAgdmFyIGhhc05leHQgPSBjYW5TaG93QXJyb3dzICYmICh0aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSA8IGl0ZW1zTGVuZ3RoIC0gMSB8fCB0aGlzLnByb3BzLmluZmluaXRlTG9vcCk7XG4gICAgICAgICAgICAvLyBvYmogdG8gaG9sZCB0aGUgdHJhbnNmb3JtYXRpb25zIGFuZCBzdHlsZXNcbiAgICAgICAgICAgIHZhciBpdGVtTGlzdFN0eWxlcyA9IHt9O1xuXG4gICAgICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLnN0YXRlLnNlbGVjdGVkSXRlbSk7XG5cbiAgICAgICAgICAgIC8vIGlmIDNkIGlzIGF2YWlsYWJsZSwgbGV0J3MgdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIHBlcmZvcm1hbmNlIG9mIHRyYW5zZm9ybVxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVByb3AgPSAoMCwgX0NTU1RyYW5zbGF0ZTIuZGVmYXVsdCkoY3VycmVudFBvc2l0aW9uICsgJyUnLCB0aGlzLnByb3BzLmF4aXMpO1xuXG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvblRpbWUgPSB0aGlzLnByb3BzLnRyYW5zaXRpb25UaW1lICsgJ21zJztcblxuICAgICAgICAgICAgaXRlbUxpc3RTdHlsZXMgPSB7XG4gICAgICAgICAgICAgICAgJ1dlYmtpdFRyYW5zZm9ybSc6IHRyYW5zZm9ybVByb3AsXG4gICAgICAgICAgICAgICAgJ01velRyYW5zZm9ybSc6IHRyYW5zZm9ybVByb3AsXG4gICAgICAgICAgICAgICAgJ01zVHJhbnNmb3JtJzogdHJhbnNmb3JtUHJvcCxcbiAgICAgICAgICAgICAgICAnT1RyYW5zZm9ybSc6IHRyYW5zZm9ybVByb3AsXG4gICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IHRyYW5zZm9ybVByb3AsXG4gICAgICAgICAgICAgICAgJ21zVHJhbnNmb3JtJzogdHJhbnNmb3JtUHJvcFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnN3aXBpbmcpIHtcbiAgICAgICAgICAgICAgICBpdGVtTGlzdFN0eWxlcyA9IF9leHRlbmRzKHt9LCBpdGVtTGlzdFN0eWxlcywge1xuICAgICAgICAgICAgICAgICAgICAnV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uJzogdHJhbnNpdGlvblRpbWUsXG4gICAgICAgICAgICAgICAgICAgICdNb3pUcmFuc2l0aW9uRHVyYXRpb24nOiB0cmFuc2l0aW9uVGltZSxcbiAgICAgICAgICAgICAgICAgICAgJ01zVHJhbnNpdGlvbkR1cmF0aW9uJzogdHJhbnNpdGlvblRpbWUsXG4gICAgICAgICAgICAgICAgICAgICdPVHJhbnNpdGlvbkR1cmF0aW9uJzogdHJhbnNpdGlvblRpbWUsXG4gICAgICAgICAgICAgICAgICAgICd0cmFuc2l0aW9uRHVyYXRpb24nOiB0cmFuc2l0aW9uVGltZSxcbiAgICAgICAgICAgICAgICAgICAgJ21zVHJhbnNpdGlvbkR1cmF0aW9uJzogdHJhbnNpdGlvblRpbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN3aXBlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbTogdGhpcy5zdGF0ZS5zZWxlY3RlZEl0ZW0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBfY3NzQ2xhc3NlczIuZGVmYXVsdC5TTElERVIodHJ1ZSwgdGhpcy5zdGF0ZS5zd2lwaW5nKSxcbiAgICAgICAgICAgICAgICBvblN3aXBlTW92ZTogdGhpcy5vblN3aXBlTW92ZSxcbiAgICAgICAgICAgICAgICBvblN3aXBlU3RhcnQ6IHRoaXMub25Td2lwZVN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uU3dpcGVFbmQ6IHRoaXMub25Td2lwZUVuZCxcbiAgICAgICAgICAgICAgICBzdHlsZTogaXRlbUxpc3RTdHlsZXMsXG4gICAgICAgICAgICAgICAgdG9sZXJhbmNlOiB0aGlzLnByb3BzLnN3aXBlU2Nyb2xsVG9sZXJhbmNlLFxuICAgICAgICAgICAgICAgIHJlZjogJ2l0ZW1MaXN0J1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclN0eWxlcyA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgc3dpcGVyUHJvcHMub25Td2lwZUxlZnQgPSB0aGlzLmluY3JlbWVudDtcbiAgICAgICAgICAgICAgICBzd2lwZXJQcm9wcy5vblN3aXBlUmlnaHQgPSB0aGlzLmRlY3JlbWVudDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmR5bmFtaWNIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1IZWlnaHQgPSB0aGlzLmdldFZhcmlhYmxlSW1hZ2VIZWlnaHQodGhpcy5zdGF0ZS5zZWxlY3RlZEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBzd2lwZXJQcm9wcy5zdHlsZS5oZWlnaHQgPSBpdGVtSGVpZ2h0IHx8ICdhdXRvJztcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGVzLmhlaWdodCA9IGl0ZW1IZWlnaHQgfHwgJ2F1dG8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpcGVyUHJvcHMub25Td2lwZVVwID0gdGhpcy5wcm9wcy52ZXJ0aWNhbFN3aXBlID09PSAnbmF0dXJhbCcgPyB0aGlzLmluY3JlbWVudCA6IHRoaXMuZGVjcmVtZW50O1xuICAgICAgICAgICAgICAgIHN3aXBlclByb3BzLm9uU3dpcGVEb3duID0gdGhpcy5wcm9wcy52ZXJ0aWNhbFN3aXBlID09PSAnbmF0dXJhbCcgPyB0aGlzLmRlY3JlbWVudCA6IHRoaXMuaW5jcmVtZW50O1xuICAgICAgICAgICAgICAgIHN3aXBlclByb3BzLnN0eWxlLmhlaWdodCA9IHRoaXMuc3RhdGUuaXRlbVNpemU7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGVzLmhlaWdodCA9IHRoaXMuc3RhdGUuaXRlbVNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWUsIHJlZjogJ2Nhcm91c2VsV3JhcHBlcicgfSxcbiAgICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgIHsgY2xhc3NOYW1lOiBfY3NzQ2xhc3NlczIuZGVmYXVsdC5DQVJPVVNFTCh0cnVlKSwgc3R5bGU6IHsgd2lkdGg6IHRoaXMucHJvcHMud2lkdGggfSB9LFxuICAgICAgICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJywgeyB0eXBlOiAnYnV0dG9uJywgY2xhc3NOYW1lOiBfY3NzQ2xhc3NlczIuZGVmYXVsdC5BUlJPV19QUkVWKCFoYXNQcmV2KSwgb25DbGljazogdGhpcy5kZWNyZW1lbnQgfSksXG4gICAgICAgICAgICAgICAgICAgIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGNsYXNzTmFtZTogX2Nzc0NsYXNzZXMyLmRlZmF1bHQuV1JBUFBFUih0cnVlLCB0aGlzLnByb3BzLmF4aXMpLCBzdHlsZTogY29udGFpbmVyU3R5bGVzLCByZWY6ICdpdGVtc1dyYXBwZXInIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVhY3RFYXN5U3dpcGUyLmRlZmF1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4dGVuZHMoeyB0YWdOYW1lOiAndWwnIH0sIHN3aXBlclByb3BzLCB7IGFsbG93TW91c2VFdmVudHM6IHRoaXMucHJvcHMuZW11bGF0ZVRvdWNoIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVySXRlbXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJywgeyB0eXBlOiAnYnV0dG9uJywgY2xhc3NOYW1lOiBfY3NzQ2xhc3NlczIuZGVmYXVsdC5BUlJPV19ORVhUKCFoYXNOZXh0KSwgb25DbGljazogdGhpcy5pbmNyZW1lbnQgfSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ29udHJvbHMoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTdGF0dXMoKVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUaHVtYnMoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDYXJvdXNlbDtcbn0oX3JlYWN0LkNvbXBvbmVudCk7XG5cbkNhcm91c2VsLmRpc3BsYXlOYW1lID0gJ0Nhcm91c2VsJztcbkNhcm91c2VsLnByb3BUeXBlcyA9IHtcbiAgICBjbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICAgIGNoaWxkcmVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm5vZGUsXG4gICAgc2hvd0Fycm93czogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICAgIHNob3dTdGF0dXM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgICBzaG93SW5kaWNhdG9yczogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICAgIGluZmluaXRlTG9vcDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICAgIHNob3dUaHVtYnM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgICB0aHVtYldpZHRoOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgICBzZWxlY3RlZEl0ZW06IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICAgIG9uQ2xpY2tJdGVtOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBvbkNsaWNrVGh1bWI6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYy5pc1JlcXVpcmVkLFxuICAgIG9uQ2hhbmdlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMuaXNSZXF1aXJlZCxcbiAgICBheGlzOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddKSxcbiAgICB2ZXJ0aWNhbFN3aXBlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mKFsnbmF0dXJhbCcsICdzdGFuZGFyZCddKSxcbiAgICB3aWR0aDogY3VzdG9tUHJvcFR5cGVzLnVuaXQsXG4gICAgdXNlS2V5Ym9hcmRBcnJvd3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgICBhdXRvUGxheTogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICAgIHN0b3BPbkhvdmVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXG4gICAgaW50ZXJ2YWw6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxuICAgIHRyYW5zaXRpb25UaW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcbiAgICBzd2lwZVNjcm9sbFRvbGVyYW5jZTogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXG4gICAgZHluYW1pY0hlaWdodDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICAgIGVtdWxhdGVUb3VjaDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICAgIHN0YXR1c0Zvcm1hdHRlcjogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLmlzUmVxdWlyZWQsXG4gICAgY2VudGVyTW9kZTogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxuICAgIGNlbnRlclNsaWRlUGVyY2VudGFnZTogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXJcbn07XG5DYXJvdXNlbC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgc2hvd0luZGljYXRvcnM6IHRydWUsXG4gICAgc2hvd0Fycm93czogdHJ1ZSxcbiAgICBzaG93U3RhdHVzOiB0cnVlLFxuICAgIHNob3dUaHVtYnM6IHRydWUsXG4gICAgaW5maW5pdGVMb29wOiBmYWxzZSxcbiAgICBzZWxlY3RlZEl0ZW06IDAsXG4gICAgYXhpczogJ2hvcml6b250YWwnLFxuICAgIHZlcnRpY2FsU3dpcGU6ICdzdGFuZGFyZCcsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICB1c2VLZXlib2FyZEFycm93czogZmFsc2UsXG4gICAgYXV0b1BsYXk6IGZhbHNlLFxuICAgIHN0b3BPbkhvdmVyOiB0cnVlLFxuICAgIGludGVydmFsOiAzMDAwLFxuICAgIHRyYW5zaXRpb25UaW1lOiAzNTAsXG4gICAgc3dpcGVTY3JvbGxUb2xlcmFuY2U6IDUsXG4gICAgZHluYW1pY0hlaWdodDogZmFsc2UsXG4gICAgZW11bGF0ZVRvdWNoOiBmYWxzZSxcbiAgICBvbkNsaWNrSXRlbTogbm9vcCxcbiAgICBvbkNsaWNrVGh1bWI6IG5vb3AsXG4gICAgb25DaGFuZ2U6IG5vb3AsXG4gICAgc3RhdHVzRm9ybWF0dGVyOiBkZWZhdWx0U3RhdHVzRm9ybWF0dGVyLFxuICAgIGNlbnRlck1vZGU6IGZhbHNlLFxuICAgIGNlbnRlclNsaWRlUGVyY2VudGFnZTogODBcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBDYXJvdXNlbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS1jYXJvdXNlbC9saWIvY29tcG9uZW50cy9DYXJvdXNlbC5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydleHBvcnRzJywgJ3JlYWN0JywgJ3Byb3AtdHlwZXMnXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ3JlYWN0JyksIHJlcXVpcmUoJ3Byb3AtdHlwZXMnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG1vZCA9IHtcbiAgICAgIGV4cG9ydHM6IHt9XG4gICAgfTtcbiAgICBmYWN0b3J5KG1vZC5leHBvcnRzLCBnbG9iYWwucmVhY3QsIGdsb2JhbC5wcm9wVHlwZXMpO1xuICAgIGdsb2JhbC5yZWFjdFN3aXBlID0gbW9kLmV4cG9ydHM7XG4gIH1cbn0pKHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLCBfcmVhY3QsIF9wcm9wVHlwZXMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICBleHBvcnRzLnNldEhhc1N1cHBvcnRUb0NhcHR1cmVPcHRpb24gPSBzZXRIYXNTdXBwb3J0VG9DYXB0dXJlT3B0aW9uO1xuXG4gIHZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG4gIHZhciBfcHJvcFR5cGVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Byb3BUeXBlcyk7XG5cbiAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgZGVmYXVsdDogb2JqXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgICBpZiAoIXNlbGYpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICAgIH1cblxuICAgIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgfVxuXG4gIHZhciBzdXBwb3J0c0NhcHR1cmVPcHRpb24gPSBmYWxzZTtcbiAgZnVuY3Rpb24gc2V0SGFzU3VwcG9ydFRvQ2FwdHVyZU9wdGlvbihoYXNTdXBwb3J0KSB7XG4gICAgc3VwcG9ydHNDYXB0dXJlT3B0aW9uID0gaGFzU3VwcG9ydDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnY2FwdHVyZScsIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHNldEhhc1N1cHBvcnRUb0NhcHR1cmVPcHRpb24odHJ1ZSk7XG4gICAgICB9IH0pKTtcbiAgfSBjYXRjaCAoZSkge31cblxuICBmdW5jdGlvbiBnZXRTYWZlRXZlbnRIYW5kbGVyT3B0cygpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogeyBjYXB0dXJlOiB0cnVlIH07XG5cbiAgICByZXR1cm4gc3VwcG9ydHNDYXB0dXJlT3B0aW9uID8gb3B0aW9ucyA6IG9wdGlvbnMuY2FwdHVyZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbZ2V0UG9zaXRpb24gcmV0dXJucyBhIHBvc2l0aW9uIGVsZW1lbnQgdGhhdCB3b3JrcyBmb3IgbW91c2Ugb3IgdG91Y2ggZXZlbnRzXVxuICAgKiBAcGFyYW0gIHtbRXZlbnRdfSBldmVudCBbdGhlIHJlY2VpdmVkIGV2ZW50XVxuICAgKiBAcmV0dXJuIHtbT2JqZWN0XX0gICAgICBbeCBhbmQgeSBjb29yZHNdXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQb3NpdGlvbihldmVudCkge1xuICAgIGlmICgndG91Y2hlcycgaW4gZXZlbnQpIHtcbiAgICAgIHZhciBfZXZlbnQkdG91Y2hlcyQgPSBldmVudC50b3VjaGVzWzBdLFxuICAgICAgICAgIHBhZ2VYID0gX2V2ZW50JHRvdWNoZXMkLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZID0gX2V2ZW50JHRvdWNoZXMkLnBhZ2VZO1xuXG4gICAgICByZXR1cm4geyB4OiBwYWdlWCwgeTogcGFnZVkgfTtcbiAgICB9XG5cbiAgICB2YXIgc2NyZWVuWCA9IGV2ZW50LnNjcmVlblgsXG4gICAgICAgIHNjcmVlblkgPSBldmVudC5zY3JlZW5ZO1xuXG4gICAgcmV0dXJuIHsgeDogc2NyZWVuWCwgeTogc2NyZWVuWSB9O1xuICB9XG5cbiAgdmFyIFJlYWN0U3dpcGUgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0cyhSZWFjdFN3aXBlLCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFJlYWN0U3dpcGUoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlYWN0U3dpcGUpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoX3JlZiA9IFJlYWN0U3dpcGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihSZWFjdFN3aXBlKSkuY2FsbC5hcHBseShfcmVmLCBbdGhpc10uY29uY2F0KGFyZ3MpKSk7XG5cbiAgICAgIF90aGlzLl9oYW5kbGVTd2lwZVN0YXJ0ID0gX3RoaXMuX2hhbmRsZVN3aXBlU3RhcnQuYmluZChfdGhpcyk7XG4gICAgICBfdGhpcy5faGFuZGxlU3dpcGVNb3ZlID0gX3RoaXMuX2hhbmRsZVN3aXBlTW92ZS5iaW5kKF90aGlzKTtcbiAgICAgIF90aGlzLl9oYW5kbGVTd2lwZUVuZCA9IF90aGlzLl9oYW5kbGVTd2lwZUVuZC5iaW5kKF90aGlzKTtcblxuICAgICAgX3RoaXMuX29uTW91c2VEb3duID0gX3RoaXMuX29uTW91c2VEb3duLmJpbmQoX3RoaXMpO1xuICAgICAgX3RoaXMuX29uTW91c2VNb3ZlID0gX3RoaXMuX29uTW91c2VNb3ZlLmJpbmQoX3RoaXMpO1xuICAgICAgX3RoaXMuX29uTW91c2VVcCA9IF90aGlzLl9vbk1vdXNlVXAuYmluZChfdGhpcyk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFJlYWN0U3dpcGUsIFt7XG4gICAgICBrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN3aXBlcikge1xuICAgICAgICAgIHRoaXMuc3dpcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVN3aXBlTW92ZSwgZ2V0U2FmZUV2ZW50SGFuZGxlck9wdHMoe1xuICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnY29tcG9uZW50V2lsbFVubW91bnQnLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBpZiAodGhpcy5zd2lwZXIpIHtcbiAgICAgICAgICB0aGlzLnN3aXBlci5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVTd2lwZU1vdmUsIGdldFNhZmVFdmVudEhhbmRsZXJPcHRzKHtcbiAgICAgICAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19vbk1vdXNlRG93bicsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9wcy5hbGxvd01vdXNlRXZlbnRzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlU3dpcGVTdGFydChldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX29uTW91c2VNb3ZlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlRG93bikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hhbmRsZVN3aXBlTW92ZShldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX29uTW91c2VVcCcsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTW91c2VVcChldmVudCkge1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlU3dpcGVFbmQoZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogJ19oYW5kbGVTd2lwZVN0YXJ0JyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU3dpcGVTdGFydChldmVudCkge1xuICAgICAgICB2YXIgX2dldFBvc2l0aW9uID0gZ2V0UG9zaXRpb24oZXZlbnQpLFxuICAgICAgICAgICAgeCA9IF9nZXRQb3NpdGlvbi54LFxuICAgICAgICAgICAgeSA9IF9nZXRQb3NpdGlvbi55O1xuXG4gICAgICAgIHRoaXMubW92ZVN0YXJ0ID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAgIHRoaXMucHJvcHMub25Td2lwZVN0YXJ0KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6ICdfaGFuZGxlU3dpcGVNb3ZlJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU3dpcGVNb3ZlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfZ2V0UG9zaXRpb24yID0gZ2V0UG9zaXRpb24oZXZlbnQpLFxuICAgICAgICAgICAgeCA9IF9nZXRQb3NpdGlvbjIueCxcbiAgICAgICAgICAgIHkgPSBfZ2V0UG9zaXRpb24yLnk7XG5cbiAgICAgICAgdmFyIGRlbHRhWCA9IHggLSB0aGlzLm1vdmVTdGFydC54O1xuICAgICAgICB2YXIgZGVsdGFZID0geSAtIHRoaXMubW92ZVN0YXJ0Lnk7XG4gICAgICAgIHRoaXMubW92aW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBoYW5kbGluZyB0aGUgcmVzcG9uc2FiaWxpdHkgb2YgY2FuY2VsbGluZyB0aGUgc2Nyb2xsIHRvXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgaGFuZGxpbmcgdGhlIGV2ZW50XG4gICAgICAgIHZhciBzaG91bGRQcmV2ZW50RGVmYXVsdCA9IHRoaXMucHJvcHMub25Td2lwZU1vdmUoe1xuICAgICAgICAgIHg6IGRlbHRhWCxcbiAgICAgICAgICB5OiBkZWx0YVlcbiAgICAgICAgfSwgZXZlbnQpO1xuXG4gICAgICAgIGlmIChzaG91bGRQcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdmVQb3NpdGlvbiA9IHsgZGVsdGFYOiBkZWx0YVgsIGRlbHRhWTogZGVsdGFZIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAnX2hhbmRsZVN3aXBlRW5kJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU3dpcGVFbmQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vblN3aXBlRW5kKGV2ZW50KTtcblxuICAgICAgICB2YXIgdG9sZXJhbmNlID0gdGhpcy5wcm9wcy50b2xlcmFuY2U7XG5cblxuICAgICAgICBpZiAodGhpcy5tb3ZpbmcpIHtcbiAgICAgICAgICBpZiAodGhpcy5tb3ZlUG9zaXRpb24uZGVsdGFYIDwgLXRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblN3aXBlTGVmdCgxLCBldmVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm1vdmVQb3NpdGlvbi5kZWx0YVggPiB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Td2lwZVJpZ2h0KDEsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMubW92ZVBvc2l0aW9uLmRlbHRhWSA8IC10b2xlcmFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Td2lwZVVwKDEsIGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW92ZVBvc2l0aW9uLmRlbHRhWSA+IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblN3aXBlRG93bigxLCBldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3ZlU3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdmVQb3NpdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICB0aGlzLnByb3BzLnRhZ05hbWUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVmOiBmdW5jdGlvbiByZWYobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLnN3aXBlciA9IG5vZGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Nb3VzZURvd246IHRoaXMuX29uTW91c2VEb3duLFxuICAgICAgICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLl9oYW5kbGVTd2lwZVN0YXJ0LFxuICAgICAgICAgICAgb25Ub3VjaEVuZDogdGhpcy5faGFuZGxlU3dpcGVFbmQsXG4gICAgICAgICAgICBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICAgICAgc3R5bGU6IHRoaXMucHJvcHMuc3R5bGVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUmVhY3RTd2lwZTtcbiAgfShfcmVhY3QuQ29tcG9uZW50KTtcblxuICBSZWFjdFN3aXBlLmRpc3BsYXlOYW1lID0gJ1JlYWN0U3dpcGUnO1xuICBSZWFjdFN3aXBlLnByb3BUeXBlcyA9IHtcbiAgICB0YWdOYW1lOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcbiAgICBjbGFzc05hbWU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxuICAgIHN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcbiAgICBjaGlsZHJlbjogX3Byb3BUeXBlczIuZGVmYXVsdC5ub2RlLFxuICAgIGFsbG93TW91c2VFdmVudHM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcbiAgICBvblN3aXBlVXA6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgICBvblN3aXBlRG93bjogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxuICAgIG9uU3dpcGVMZWZ0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gICAgb25Td2lwZVJpZ2h0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gICAgb25Td2lwZVN0YXJ0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gICAgb25Td2lwZU1vdmU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcbiAgICBvblN3aXBlRW5kOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXG4gICAgdG9sZXJhbmNlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlci5pc1JlcXVpcmVkXG4gIH07XG4gIFJlYWN0U3dpcGUuZGVmYXVsdFByb3BzID0ge1xuICAgIHRhZ05hbWU6ICdkaXYnLFxuICAgIGFsbG93TW91c2VFdmVudHM6IGZhbHNlLFxuICAgIG9uU3dpcGVVcDogZnVuY3Rpb24gb25Td2lwZVVwKCkge30sXG4gICAgb25Td2lwZURvd246IGZ1bmN0aW9uIG9uU3dpcGVEb3duKCkge30sXG4gICAgb25Td2lwZUxlZnQ6IGZ1bmN0aW9uIG9uU3dpcGVMZWZ0KCkge30sXG4gICAgb25Td2lwZVJpZ2h0OiBmdW5jdGlvbiBvblN3aXBlUmlnaHQoKSB7fSxcbiAgICBvblN3aXBlU3RhcnQ6IGZ1bmN0aW9uIG9uU3dpcGVTdGFydCgpIHt9LFxuICAgIG9uU3dpcGVNb3ZlOiBmdW5jdGlvbiBvblN3aXBlTW92ZSgpIHt9LFxuICAgIG9uU3dpcGVFbmQ6IGZ1bmN0aW9uIG9uU3dpcGVFbmQoKSB7fSxcblxuICAgIHRvbGVyYW5jZTogMFxuICB9O1xuICBleHBvcnRzLmRlZmF1bHQgPSBSZWFjdFN3aXBlO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWVhc3ktc3dpcGUvbGliL3JlYWN0LXN3aXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG52YXIgb3V0ZXJXaWR0aCA9IGV4cG9ydHMub3V0ZXJXaWR0aCA9IGZ1bmN0aW9uIG91dGVyV2lkdGgoZWwpIHtcblx0dmFyIHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG5cdHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xuXG5cdHdpZHRoICs9IHBhcnNlSW50KHN0eWxlLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQoc3R5bGUubWFyZ2luUmlnaHQpO1xuXHRyZXR1cm4gd2lkdGg7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9kaW1lbnNpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgdW5pdCA9IGV4cG9ydHMudW5pdCA9IGZ1bmN0aW9uIHVuaXQocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCEvKHB0fHB4fGVtfHJlbXx2d3x2aHwlKSQvLnRlc3QocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIHByb3AgYCcgKyBwcm9wTmFtZSArICdgIHN1cHBsaWVkIHRvJyArICcgYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFZhbGlkYXRpb24gZmFpbGVkLiBJdCBuZWVkcyB0byBiZSBhIHNpemUgdW5pdCBsaWtlIHB0LCBweCwgZW0sIHJlbSwgdncsICUnKTtcbiAgICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNwb25zaXZlLWNhcm91c2VsL2xpYi9jdXN0b21Qcm9wVHlwZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBkZXNpcmVkT2Zmc2V0IC0gcGFnZSBvZmZzZXQgdG8gc2Nyb2xsIHRvXG4gIC8vIHNwZWVkIC0gZHVyYXRpb24gb2YgdGhlIHNjcm9sbCBwZXIgMTAwMHB4XG4gIGZ1bmN0aW9uIF9fQU5JTUFURV9TQ1JPTExfVE8oZGVzaXJlZE9mZnNldCkge1xuICAgIHZhciB1c2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzFdO1xuXG4gICAgaWYgKGRlc2lyZWRPZmZzZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgaWYgKHVzZXJPcHRpb25zLmVsZW1lbnQgJiYgdXNlck9wdGlvbnMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGRlc2lyZWRPZmZzZXQgPSAoZGVzaXJlZE9mZnNldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB1c2VyT3B0aW9ucy5lbGVtZW50LnNjcm9sbFRvcClcbiAgICAgICAgICAtIHVzZXJPcHRpb25zLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNjcm9sbFRvcCA9IHdpbmRvdy5zY3JvbGxZIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIGRlc2lyZWRPZmZzZXQgPSBzY3JvbGxUb3AgKyBkZXNpcmVkT2Zmc2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHNwZWVkOiA1MDAsXG4gICAgICBtaW5EdXJhdGlvbjogMjUwLFxuICAgICAgbWF4RHVyYXRpb246IDE1MDAsXG4gICAgICBjYW5jZWxPblVzZXJBY3Rpb246IHRydWUsXG4gICAgICBlbGVtZW50OiB3aW5kb3csXG4gICAgICBvbkNvbXBsZXRlOiB1bmRlZmluZWQsXG4gICAgfTtcblxuICAgIHZhciBvcHRpb25zS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuXG4gICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBvcHRpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IG9wdGlvbnNLZXlzW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIHVzZXJPcHRpb25zW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHVzZXJPcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucy5pc1dpbmRvdyA9IG9wdGlvbnMuZWxlbWVudCA9PT0gd2luZG93O1xuXG4gICAgdmFyIGluaXRpYWxTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gICAgdmFyIG1heFNjcm9sbCA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5pc1dpbmRvdykge1xuICAgICAgLy8gZ2V0IGNyb3NzIGJyb3dzZXIgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICBpbml0aWFsU2Nyb2xsUG9zaXRpb24gPSB3aW5kb3cuc2Nyb2xsWSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgLy8gY3Jvc3MgYnJvd3NlciBkb2N1bWVudCBoZWlnaHQgbWludXMgd2luZG93IGhlaWdodFxuICAgICAgbWF4U2Nyb2xsID0gTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICkgLSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERPTSBlbGVtZW50XG4gICAgICBpbml0aWFsU2Nyb2xsUG9zaXRpb24gPSBvcHRpb25zLmVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgbWF4U2Nyb2xsID0gb3B0aW9ucy5lbGVtZW50LnNjcm9sbEhlaWdodCAtIG9wdGlvbnMuZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBncmVhdGVyIHRoYW4gbWF4aW11bSBhdmFpbGFibGUgc2Nyb2xsXG4gICAgaWYgKGRlc2lyZWRPZmZzZXQgPiBtYXhTY3JvbGwpIHtcbiAgICAgIGRlc2lyZWRPZmZzZXQgPSBtYXhTY3JvbGw7XG4gICAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlIGRpZmYgdG8gc2Nyb2xsXG4gICAgdmFyIGRpZmYgPSBkZXNpcmVkT2Zmc2V0IC0gaW5pdGlhbFNjcm9sbFBvc2l0aW9uO1xuXG4gICAgLy8gRG8gbm90aGluZyBpZiB0aGUgcGFnZSBpcyBhbHJlYWR5IHRoZXJlXG4gICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgIC8vIEV4ZWN1dGUgY2FsbGJhY2sgaWYgdGhlcmUgaXMgYW55XG4gICAgICBpZiAob3B0aW9ucy5vbkNvbXBsZXRlICYmIHR5cGVvZiBvcHRpb25zLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBkdXJhdGlvbiBvZiB0aGUgc2Nyb2xsXG4gICAgdmFyIGR1cmF0aW9uID0gTWF0aC5hYnMoTWF0aC5yb3VuZCgoZGlmZiAvIDEwMDApICogb3B0aW9ucy5zcGVlZCkpO1xuXG4gICAgLy8gU2V0IG1pbmltdW0gYW5kIG1heGltdW0gZHVyYXRpb25cbiAgICBpZiAoZHVyYXRpb24gPCBvcHRpb25zLm1pbkR1cmF0aW9uKSB7XG4gICAgICBkdXJhdGlvbiA9IG9wdGlvbnMubWluRHVyYXRpb247XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbiA+IG9wdGlvbnMubWF4RHVyYXRpb24pIHtcbiAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5tYXhEdXJhdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRpbmdUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIFJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lIElEXG4gICAgdmFyIHJlcXVlc3RJRCA9IG51bGw7XG5cbiAgICAvLyBNZXRob2QgaGFuZGxlclxuICAgIHZhciBoYW5kbGVVc2VyRXZlbnQgPSBudWxsO1xuXG4gICAgaWYgKG9wdGlvbnMuY2FuY2VsT25Vc2VyQWN0aW9uKSB7XG4gICAgICAvLyBTZXQgaGFuZGxlciB0byBjYW5jZWwgc2Nyb2xsIG9uIHVzZXIgYWN0aW9uXG4gICAgICBoYW5kbGVVc2VyRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJRCk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVVc2VyRXZlbnQpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZVVzZXJFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNldCBoYW5kbGVyIHRvIHByZXZlbnQgdXNlciBhY3Rpb25zIHdoaWxlIHNjcm9sbCBpcyBhY3RpdmVcbiAgICAgIGhhbmRsZVVzZXJFdmVudCA9IGZ1bmN0aW9uKGUpIHsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZVVzZXJFdmVudCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgaGFuZGxlVXNlckV2ZW50KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVVzZXJFdmVudCk7XG5cbiAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgaGFuZGxlVXNlckV2ZW50KTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVXNlckV2ZW50KTtcblxuICAgICAgaWYgKG9wdGlvbnMuY2FuY2VsT25Vc2VyQWN0aW9uKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlVXNlckV2ZW50KTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGhhbmRsZVVzZXJFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlVXNlckV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGltZURpZmYgPSBEYXRlLm5vdygpIC0gc3RhcnRpbmdUaW1lO1xuICAgICAgdmFyIHQgPSAodGltZURpZmYgLyBkdXJhdGlvbikgLSAxO1xuICAgICAgdmFyIGVhc2luZyA9IHQgKiB0ICogdCArIDE7XG4gICAgICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBNYXRoLnJvdW5kKGluaXRpYWxTY3JvbGxQb3NpdGlvbiArIChkaWZmICogZWFzaW5nKSk7XG5cbiAgICAgIGlmICh0aW1lRGlmZiA8IGR1cmF0aW9uICYmIHNjcm9sbFBvc2l0aW9uICE9PSBkZXNpcmVkT2Zmc2V0KSB7XG4gICAgICAgIC8vIElmIHNjcm9sbCBkaWRuJ3QgcmVhY2ggZGVzaXJlZCBvZmZzZXQgb3IgdGltZSBpcyBub3QgZWxhcHNlZFxuICAgICAgICAvLyBTY3JvbGwgdG8gYSBuZXcgcG9zaXRpb25cbiAgICAgICAgLy8gQW5kIHJlcXVlc3QgYSBuZXcgc3RlcFxuXG4gICAgICAgIGlmIChvcHRpb25zLmlzV2luZG93KSB7XG4gICAgICAgICAgb3B0aW9ucy5lbGVtZW50LnNjcm9sbFRvKDAsIHNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLmVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0SUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgdGltZSBlbGFwc2VkIG9yIHdlIHJlYWNoZWQgdGhlIGRlc2lyZWQgb2Zmc2V0XG4gICAgICAgIC8vIFNldCBzY3JvbGwgdG8gdGhlIGRlc2lyZWQgb2Zmc2V0ICh3aGVuIHJvdW5kaW5nIG1hZGUgaXQgdG8gYmUgb2ZmIGEgcGl4ZWwgb3IgdHdvKVxuICAgICAgICAvLyBDbGVhciBhbmltYXRpb24gZnJhbWUgdG8gYmUgc3VyZVxuICAgICAgICBpZiAob3B0aW9ucy5pc1dpbmRvdykge1xuICAgICAgICAgIG9wdGlvbnMuZWxlbWVudC5zY3JvbGxUbygwLCBkZXNpcmVkT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLmVsZW1lbnQuc2Nyb2xsVG9wID0gZGVzaXJlZE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZXF1ZXN0SUQpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnNcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG5cbiAgICAgICAgLy8gQW5pbWF0aW9uIGlzIGNvbXBsZXRlLCBleGVjdXRlIGNhbGxiYWNrIGlmIHRoZXJlIGlzIGFueVxuICAgICAgICBpZiAob3B0aW9ucy5vbkNvbXBsZXRlICYmIHR5cGVvZiBvcHRpb25zLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFN0YXJ0IGFuaW1hdGluZyBzY3JvbGxcbiAgICByZXF1ZXN0SUQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IF9fQU5JTUFURV9TQ1JPTExfVE87XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHM7XG4gICAgfVxuICAgIGV4cG9ydHMuZGVmYXVsdCA9IF9fQU5JTUFURV9TQ1JPTExfVE87XG4gIH0gZWxzZSBpZiAod2luZG93KSB7XG4gICAgd2luZG93LmFuaW1hdGVTY3JvbGxUbyA9IF9fQU5JTUFURV9TQ1JPTExfVE87XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvYW5pbWF0ZWQtc2Nyb2xsLXRvL2FuaW1hdGVkLXNjcm9sbC10by5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCB7IE5hdkxpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNsaWRlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHR0cmlnZ2VyUHJldigpIHtcclxuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLXByZXYnKS5jbGljaygpO1xyXG5cdH1cclxuXHR0cmlnZ2VyTmV4dCgpIHtcclxuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLW5leHQnKS5jbGljaygpO1xyXG5cdH1cclxuXHRyZW5kZXIoKSB7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHQ8YXJ0aWNsZSBjbGFzc05hbWU9XCJzbGlkZVwiIHN0eWxlPXt7YmFja2dyb3VuZEltYWdlOiBcInVybChcIiArIHRoaXMucHJvcHMuaW1hZ2UgKyBcIilcIn19PlxyXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwib3ZlcmxheVwiPlxyXG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJzbGlkZS1jb250YWluZXJcIj5cclxuXHRcdFx0XHRcdFx0PGgxPiB7dGhpcy5wcm9wcy50aXRsZX0gPC9oMT5cclxuXHRcdFx0XHRcdFx0PG5hdj5cclxuXHRcdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cImFycm93XCIgb25DbGljaz17dGhpcy50cmlnZ2VyUHJldi5iaW5kKHRoaXMpfT5cclxuXHRcdFx0XHRcdFx0XHRcdDxzdmcgd2lkdGg9XCI4cHhcIiBoZWlnaHQ9XCIxMi4wNjFweFwiIHZpZXdCb3g9XCIwIDAgOCAxMi4wNjFcIiBlbmFibGVCYWNrZ3JvdW5kPVwibmV3IDAgMCA4IDEyLjA2MVwiIHhtbFNwYWNlPVwicHJlc2VydmVcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PHBhdGggZmlsbD1cIiNGRkZGRkZcIiBkPVwiTTAuNjc4LDcuMDE4YzAsMC0wLjY3OC0wLjUyNy0wLjY3OC0wLjk4N2MwLTAuNDQsMC42NzgtMC45ODgsMC42NzgtMC45ODhsMC4wMS0wLjAxbDUuMzgxLTQuNzcyXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YzAuNDQtMC4zNDgsMS4xNjItMC4zNDgsMS42MDIsMGMwLjQzOSwwLjM0OCwwLjQzOSwwLjkxOCwwLDEuMjY2TDMuMTY1LDYuMDNsNC41MDUsNC41MDNjMC40MzksMC4zNSwwLjQzOSwwLjkxOCwwLDEuMjY3XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Yy0wLjQzOSwwLjM0OC0xLjE2LDAuMzQ4LTEuNjAyLDBMMC42ODgsNy4wMjdMMC42NzgsNy4wMThcIi8+XHJcblx0XHRcdFx0XHRcdFx0XHQ8L3N2Zz5cclxuXHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cclxuXHJcblx0XHRcdFx0XHRcdFx0PGEgaHJlZj17dGhpcy5wcm9wcy5saW5rfSB0YXJnZXQ9XCJfYmxhbmtcIiBjbGFzc05hbWU9XCJyYWRpdXMtYnV0dG9uXCI+VmlldyBjYXNlPC9hPlxyXG5cclxuXHRcdFx0XHRcdFx0XHQ8YnV0dG9uIGNsYXNzTmFtZT1cImFycm93XCIgb25DbGljaz17dGhpcy50cmlnZ2VyTmV4dC5iaW5kKHRoaXMpfT5cclxuXHRcdFx0XHRcdFx0XHRcdDxzdmcgd2lkdGg9XCI4cHhcIiBoZWlnaHQ9XCIxMi4wNjFweFwiIHZpZXdCb3g9XCIwIDAgOCAxMi4wNjFcIiBlbmFibGVCYWNrZ3JvdW5kPVwibmV3IDAgMCA4IDEyLjA2MVwiIHhtbFNwYWNlPVwicHJlc2VydmVcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PHBhdGggZmlsbD1cIiNGRkZGRkZcIiBkPVwiTTcuMzIyLDcuMDE4YzAsMCwwLjY3OC0wLjUyNywwLjY3OC0wLjk4N2MwLTAuNDQtMC42NzgtMC45ODgtMC42NzgtMC45ODhsLTAuMDEtMC4wMUwxLjkzMiwwLjI2MVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGMtMC40NC0wLjM0OC0xLjE2Mi0wLjM0OC0xLjYwMiwwYy0wLjQzOSwwLjM0OC0wLjQzOSwwLjkxOCwwLDEuMjY2TDQuODM1LDYuMDNMMC4zMywxMC41MzNjLTAuNDM5LDAuMzUtMC40MzksMC45MTgsMCwxLjI2N1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGMwLjQzOSwwLjM0OCwxLjE2LDAuMzQ4LDEuNjAyLDBsNS4zODEtNC43NzNMNy4zMjIsNy4wMThcIi8+XHJcblx0XHRcdFx0XHRcdFx0XHQ8L3N2Zz5cclxuXHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cclxuXHRcdFx0XHRcdFx0PC9uYXY+XHJcblx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0PC9hcnRpY2xlPlxyXG5cdFx0KTtcdFxyXG5cdH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL2NvbXBvbmVudHMvU2xpZGUuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50cm8gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cdHJlbmRlcigpIHtcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdDxzZWN0aW9uIGNsYXNzTmFtZT1cImludHJvIHBhZGRpbmdcIj5cclxuXHRcdFx0XHQ8YXJ0aWNsZSBjbGFzc05hbWU9XCJpbnRyby1jb250ZW50IHdyYXBwZXJcIj5cclxuXHRcdFx0XHRcdDxoMj4gV2UgYXJlIFRhbSBUYW0gPC9oMj5cclxuXHRcdFx0XHRcdDxwPiBUYW0gVGFtIGlzIGEgZnVsbCBzZXJ2aWNlIGRpZ2l0YWwgYWdlbmN5IGZvY3VzaW5nIG9uIER1dGNoIERpZ2l0YWwgU2VydmljZSBEZXNpZ24uIFdlIGNvbWJpbmUgc3RyYXRlZ3ksIGRlc2lnbiwgdGVjaG5vbG9neSBhbmQgaW50ZXJhY3Rpb24gdG8gbWFrZSB0aGUgZGlnaXRhbCBpbnRlcmFjdGlvbnMgYmV0d2VlbiBjb21wYW55IGFuZCBjdXN0b21lciB2YWx1YWJsZSBhbmQgbWVtb3JhYmxlLiBXZSB3b3JrIGZvciBhd2Vzb21lIGJyYW5kcyB3aXRoIGEgdGVhbSBvZiAxMjAgZGlnaXRhbHMgZnJvbSBvdXIgb2ZmaWNlIGluIEFtc3RlcmRhbS4gTWFraW5nIGdyZWF0IHdvcmsgYW5kIGhhdmluZyBhIGJsYXN0IGRvaW5nIGl0LiBUaGF04oCZcyB3aGF0IHdlIGJlbGlldmUgaW4uPC9wPlxyXG5cdFx0XHRcdDwvYXJ0aWNsZT5cclxuXHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0KTtcdFxyXG5cdH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL2NvbXBvbmVudHMvSW50cm8uanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5cclxuaW1wb3J0IFBvc3QgZnJvbSAnLi9Qb3N0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZlZWQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMuc3RhdGUgPSB7XHJcblx0XHRcdGZlZWQ6IFtcclxuXHRcdFx0XHR7XHJcblx0XHRcdFx0XHRpbWFnZXM6IHtcclxuXHRcdFx0XHRcdFx0c3RhbmRhcmRfcmVzb2x1dGlvbjoge1xyXG5cdFx0XHRcdFx0XHRcdHVybDogbnVsbFxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0Y2FwdGlvbjoge1xyXG5cdFx0XHRcdFx0XHR0ZXh0OiBudWxsXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRdLFxyXG5cdFx0XHRsaW1pdFJlYWNoZWQ6IGZhbHNlLFxyXG5cdFx0XHRnZXREYXRhOiB7XHJcblx0XHRcdFx0YWNjZXNzVG9rZW46ICczMDA5NzI4NDguNzhkMDU2NS5kZWRlZDY2YzgxODc0YzViOTViNzBiZjEwMDY3ZDEyZScsXHJcblx0XHRcdFx0Y291bnQ6IDYsXHJcblx0XHRcdFx0dXNlcklkOiAnNTYyMDk5MzI1J1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRwb3B1cDoge1xyXG5cdFx0XHRcdGltYWdlczoge1xyXG5cdFx0XHRcdFx0c3RhbmRhcmRfcmVzb2x1dGlvbjogbnVsbFxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0dXNlcjoge1xyXG5cdFx0XHRcdFx0dXNlcm5hbWU6IG51bGwsXHJcblx0XHRcdFx0XHRwcm9maWxlX3BpY3R1cmU6IG51bGxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGNhcHRpb246IHtcclxuXHRcdFx0XHRcdHRleHQ6IG51bGxcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGxpa2VzOiB7XHJcblx0XHRcdFx0XHRjb3VudDogbnVsbFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0c2hvd1BvcHVwOiBmYWxzZVxyXG5cdFx0fVxyXG5cdH1cclxuXHRjb21wb25lbnRXaWxsTW91bnQoKSB7XHJcblx0XHRjb25zdCBhY2Nlc3NUb2tlbiA9IHRoaXMuc3RhdGUuZ2V0RGF0YS5hY2Nlc3NUb2tlbjtcclxuXHRcdGNvbnN0IGNvdW50ID0gdGhpcy5zdGF0ZS5nZXREYXRhLmNvdW50O1xyXG5cdFx0Y29uc3QgdXNlcklkID0gdGhpcy5zdGF0ZS5nZXREYXRhLnVzZXJJZDtcclxuXHJcblx0XHRheGlvcy5nZXQoJ2h0dHBzOi8vYXBpLmluc3RhZ3JhbS5jb20vdjEvdXNlcnMvJyt1c2VySWQrJy9tZWRpYS9yZWNlbnQvP2NvdW50PScrY291bnQrJyZhY2Nlc3NfdG9rZW49JythY2Nlc3NUb2tlbilcclxuXHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcblx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7ZmVlZDogcmVzcG9uc2UuZGF0YS5kYXRhfSk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYXRjaCgoZXJyKSA9PiB7XHJcblx0XHRcdFx0YWxlcnQoZXJyKTtcclxuXHRcdFx0fSlcclxuXHR9XHJcblx0bG9hZFBvc3RzKGUpIHtcclxuXHRcdGNvbnN0IGJ1dHRvbiA9IGUudGFyZ2V0O1xyXG5cdFx0YnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2xvYWRpbmcnKTtcclxuXHJcblx0XHRjb25zdCBtYXhfaWQgPSB0aGlzLnN0YXRlLmZlZWRbdGhpcy5zdGF0ZS5mZWVkLmxlbmd0aCAtIDFdLmlkO1xyXG5cdFx0Y29uc3QgYWNjZXNzVG9rZW4gPSB0aGlzLnN0YXRlLmdldERhdGEuYWNjZXNzVG9rZW47XHJcblx0XHRjb25zdCBjb3VudCA9IHRoaXMuc3RhdGUuZ2V0RGF0YS5jb3VudDtcclxuXHRcdGNvbnN0IHVzZXJJZCA9IHRoaXMuc3RhdGUuZ2V0RGF0YS51c2VySWQ7XHJcblxyXG5cdFx0YXhpb3MuZ2V0KCdodHRwczovL2FwaS5pbnN0YWdyYW0uY29tL3YxL3VzZXJzLycrdXNlcklkKycvbWVkaWEvcmVjZW50Lz9jb3VudD0nK2NvdW50KycmbWF4X2lkPScrbWF4X2lkKycmYWNjZXNzX3Rva2VuPScrYWNjZXNzVG9rZW4pXHJcblx0XHRcdC50aGVuKChyZXNwb25zZSkgPT4ge1xyXG5cdFx0XHRcdGxldCBuZXdEYXRhID0gcmVzcG9uc2UuZGF0YS5kYXRhO1xyXG5cdFx0XHRcdGxldCBkYXRhID0gWyAuLi50aGlzLnN0YXRlLmZlZWQsIC4uLm5ld0RhdGEgXTtcclxuXHJcblx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7ZmVlZDogZGF0YX0pO1xyXG5cdFx0XHRcdGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdsb2FkaW5nJyk7XHJcblxyXG5cdFx0XHRcdGlmKHRoaXMuc3RhdGUuZmVlZC5sZW5ndGggPT0gMTgpIHtcclxuXHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoe2xpbWl0UmVhY2hlZDogdHJ1ZX0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhdGNoKChlcnIpID0+IHtcclxuXHRcdFx0XHRhbGVydChlcnIpO1xyXG5cdFx0XHRcdGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdsb2FkaW5nJyk7XHJcblx0XHRcdH0pXHJcblx0XHRcclxuXHR9XHJcblx0aGlkZVBvcHVwKCkge1xyXG5cdFx0dGhpcy5zZXRTdGF0ZSh7c2hvd1BvcHVwOiBmYWxzZX0pO1xyXG5cdH1cclxuXHRmZWVkUG9wdXAoaWQpIHtcclxuXHRcdGxldCBmZWVkID0gdGhpcy5zdGF0ZS5mZWVkO1xyXG5cdFx0bGV0IHBvc3QgPSBmZWVkLmZpbHRlcihmdW5jdGlvbihvYmopIHtcclxuXHRcdFx0cmV0dXJuIG9iai5pZCA9PSBpZDtcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5zZXRTdGF0ZSh7cG9wdXA6IHBvc3RbMF0sIHNob3dQb3B1cDogdHJ1ZX0sICgpID0+IHtcclxuXHRcdFx0Y29uc29sZS5sb2codGhpcy5zdGF0ZS5wb3B1cClcclxuXHRcdH0pO1xyXG5cdFx0XHJcblx0fVxyXG5cdHJlbmRlcigpIHtcclxuXHRcdGxldCBmZWVkID0gdGhpcy5zdGF0ZS5mZWVkLm1hcCgocG9zdCwgaSkgPT5cclxuXHRcdFx0PFBvc3QgY2xpY2s9e3RoaXMuZmVlZFBvcHVwLmJpbmQodGhpcyl9IGtleT17aX0gaWQ9e3Bvc3QuaWR9IGltYWdlPXtwb3N0LmltYWdlcy5zdGFuZGFyZF9yZXNvbHV0aW9uLnVybH0gdGV4dD17cG9zdC5jYXB0aW9ufSAvPlxyXG5cdFx0KVxyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0PHNlY3Rpb24gY2xhc3NOYW1lPVwiZmVlZFwiPlxyXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwicGFkZGluZ1wiPlxyXG5cdFx0XHRcdFx0PGFydGljbGUgY2xhc3NOYW1lPVwid3JhcHBlclwiPlxyXG5cdFx0XHRcdFx0XHQ8aDI+IEZvbGxvdyB1cyBvbiBJbnN0YWdyYW0gPC9oMj5cclxuXHRcdFx0XHRcdFx0PGgzPiBAdGFtdGFtbmwgPC9oMz5cclxuXHRcdFx0XHRcdFx0PHNlY3Rpb24gY2xhc3NOYW1lPVwiZmVlZC1jb250ZW50XCI+XHJcblx0XHRcdFx0XHRcdFx0e2ZlZWR9XHJcblx0XHRcdFx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdFx0XHRcdFx0eyF0aGlzLnN0YXRlLmxpbWl0UmVhY2hlZCA/IFxyXG5cdFx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3NOYW1lPVwiZmVlZC1idXR0b25cIiBvbkNsaWNrPXt0aGlzLmxvYWRQb3N0cy5iaW5kKHRoaXMpfT4gTG9hZCBtb3JlIDwvYnV0dG9uPlxyXG5cdFx0XHRcdFx0XHQ6IG51bGwgfVxyXG5cdFx0XHRcdFx0PC9hcnRpY2xlPlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdHt0aGlzLnN0YXRlLnNob3dQb3B1cCA/IFxyXG5cdFx0XHRcdFx0PGFydGljbGUgY2xhc3NOYW1lPVwiZmVlZC1wb3B1cFwiPlxyXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cIm92ZXJsYXlcIiBvbkNsaWNrPXt0aGlzLmhpZGVQb3B1cC5iaW5kKHRoaXMpfT48L2Rpdj5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJjb250YWluZXJcIj5cclxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj5cclxuXHRcdFx0XHRcdFx0XHRcdDxzZWN0aW9uIGNsYXNzTmFtZT1cImltYWdlXCIgc3R5bGU9e3tiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKFwiICsgdGhpcy5zdGF0ZS5wb3B1cC5pbWFnZXMuc3RhbmRhcmRfcmVzb2x1dGlvbi51cmwgKyBcIilcIn19Pjwvc2VjdGlvbj5cclxuXHRcdFx0XHRcdFx0XHRcdDxzZWN0aW9uIGNsYXNzTmFtZT1cImluZm9ib3hcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PGJ1dHRvbiBjbGFzc05hbWU9XCJjcm9zc1wiIG9uQ2xpY2s9e3RoaXMuaGlkZVBvcHVwLmJpbmQodGhpcyl9PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxzdmcgdmlld0JveD1cIjAgMCAyMy4zMzUgMjMuMzM1XCIgZW5hYmxlLWJhY2tncm91bmQ9XCJuZXcgMCAwIDIzLjMzNSAyMy4zMzVcIiB4bWxTcGFjZT1cInByZXNlcnZlXCI+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQ8cGF0aCBkPVwiTTEzLjc4OSwxMS42NjdsOS41NDYsOS41NDZsLTIuMTIyLDIuMTIybC05LjU0Ni05LjU0NmwtOS41NDYsOS41NDZMMCwyMS4yMTNsOS41NDYtOS41NDZMMCwyLjEyMUwyLjEyMSwwbDkuNTQ2LDkuNTQ2XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdEwyMS4yMTMsMGwyLjEyMiwyLjEyMUwxMy43ODksMTEuNjY3elwiLz5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8L3N2Zz5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PC9idXR0b24+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDxhcnRpY2xlIGNsYXNzTmFtZT1cInVzZXJcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8aW1nIHNyYz17dGhpcy5zdGF0ZS5wb3B1cC51c2VyLnByb2ZpbGVfcGljdHVyZX0gLz5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJ1c2VybmFtZVwiPiB7dGhpcy5zdGF0ZS5wb3B1cC51c2VyLnVzZXJuYW1lfSA8L3NwYW4+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDwvYXJ0aWNsZT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PGFydGljbGUgY2xhc3NOYW1lPVwidGV4dFwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuPnt0aGlzLnN0YXRlLnBvcHVwLmNhcHRpb24udGV4dH08L3NwYW4+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDwvYXJ0aWNsZT5cclxuXHRcdFx0XHRcdFx0XHRcdFx0PGFydGljbGUgY2xhc3NOYW1lPVwibGlrZXNcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3Bhbj57dGhpcy5zdGF0ZS5wb3B1cC5saWtlcy5jb3VudH0gbGlrZXM8L3NwYW4+XHJcblx0XHRcdFx0XHRcdFx0XHRcdDwvYXJ0aWNsZT5cclxuXHRcdFx0XHRcdFx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHQ8L2FydGljbGU+XHJcblx0XHRcdFx0OiBudWxsIH1cclxuXHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0KTtcdFxyXG5cdH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL2NvbXBvbmVudHMvRmVlZC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcbiAgICAgIHVybDogYXJndW1lbnRzWzBdXG4gICAgfSwgYXJndW1lbnRzWzFdKTtcbiAgfVxuXG4gIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCB0aGlzLmRlZmF1bHRzLCB7IG1ldGhvZDogJ2dldCcgfSwgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH1cblxuICAgICAgaWYgKCF1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idG9hLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZlZWQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cdHJlbmRlcigpIHtcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdDxhcnRpY2xlIGNsYXNzTmFtZT1cInBvc3RcIiBvbkNsaWNrPXt0aGlzLnByb3BzLmNsaWNrLmJpbmQodGhpcywgdGhpcy5wcm9wcy5pZCl9PlxyXG5cdFx0XHRcdDxpbWcgc3JjPXt0aGlzLnByb3BzLmltYWdlfSBhbHQ9XCJcIiAvPlxyXG5cdFx0XHRcdDxzZWN0aW9uIGNsYXNzTmFtZT1cImNvbnRlbnRcIj5cclxuXHRcdFx0XHRcdDxwPiBcclxuXHRcdFx0XHRcdFx0e3RoaXMucHJvcHMudGV4dCA/IFxyXG5cdFx0XHRcdFx0XHRcdHRoaXMucHJvcHMudGV4dC50ZXh0XHJcblx0XHRcdFx0XHRcdDogbnVsbCB9XHJcblx0XHRcdFx0XHQ8L3A+XHJcblx0XHRcdFx0PC9zZWN0aW9uPlxyXG5cdFx0XHQ8L2FydGljbGU+XHJcblx0XHQpO1x0XHJcblx0fVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvY29tcG9uZW50cy9Qb3N0LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmltcG9ydCBDb250YWN0Rm9ybSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRhY3RGb3JtJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRhY3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xyXG5cdHJlbmRlcigpIHtcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdDxDb250YWN0Rm9ybSAvPlxyXG5cdFx0KTtcclxuXHR9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy9wYWdlcy9Db250YWN0LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRhY3RGb3JtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHN1cGVyKCk7XHJcblx0XHR0aGlzLnN0YXRlID0ge1xyXG5cdFx0XHR2YWxpZGF0aW9uOiB7XHJcblx0XHRcdFx0ZW1haWw6IGZhbHNlLFxyXG5cdFx0XHRcdGZpcnN0bmFtZTogZmFsc2UsXHJcblx0XHRcdFx0bGFzdG5hbWU6IGZhbHNlLFxyXG5cdFx0XHRcdG1lc3NhZ2U6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdG1lc3NhZ2U6IHtcclxuXHRcdFx0XHRzaG93OiBmYWxzZSxcclxuXHRcdFx0XHR0ZXh0OiAnJyxcclxuXHRcdFx0XHR0eXBlOiAnZXJyb3InXHJcblx0XHRcdH0sXHJcblx0XHRcdGVycm9yOiB7XHJcblx0XHRcdFx0ZW1haWw6IGZhbHNlLFxyXG5cdFx0XHRcdGZpcnN0bmFtZTogZmFsc2UsXHJcblx0XHRcdFx0bGFzdG5hbWU6IGZhbHNlLFxyXG5cdFx0XHRcdG1lc3NhZ2U6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdGRhdGE6IHtcclxuXHRcdFx0XHRlbWFpbDogJycsXHJcblx0XHRcdFx0Zmlyc3RuYW1lOiAnJyxcclxuXHRcdFx0XHRsYXN0bmFtZTogJycsXHJcblx0XHRcdFx0bWVzc2FnZTogJydcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRjaGVja0ZpZWxkKGUpIHtcclxuXHRcdGNvbnN0IGlucHV0ID0gZS50YXJnZXQudmFsdWU7XHJcblx0XHRjb25zdCBuYW1lID0gZS50YXJnZXQubmFtZTtcclxuXHJcblx0XHRpZihuYW1lID09ICdlbWFpbCcpIHtcclxuXHRcdFx0Ly8gU291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NjE1NS9ob3ctY2FuLXlvdS12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzLWluLWphdmFzY3JpcHRcclxuXHRcdFx0Y29uc3QgcmUgPSAvXigoW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXF0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvO1xyXG5cdFx0XHRcclxuXHRcdFx0aWYocmUudGVzdChpbnB1dCkpIHtcclxuXHRcdFx0XHR0aGlzLnZhbGlkYXRpb24odHJ1ZSwgZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy52YWxpZGF0aW9uKGZhbHNlLCBlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYoaW5wdXQpIHtcclxuXHRcdFx0XHR0aGlzLnZhbGlkYXRpb24odHJ1ZSwgZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy52YWxpZGF0aW9uKGZhbHNlLCBlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHR2YWxpZGF0aW9uKHZhbGlkLCBlKSB7XHJcblx0XHRjb25zdCBwYXJlbnQgPSBlLnRhcmdldC5wYXJlbnRFbGVtZW50O1xyXG5cdFx0Y29uc3QgbmFtZSA9IGUudGFyZ2V0Lm5hbWU7XHJcblx0XHRsZXQgdmFsaWRhdGlvbiA9IHRoaXMuc3RhdGUudmFsaWRhdGlvbjtcclxuXHJcblx0XHRpZih2YWxpZCkge1xyXG5cdFx0XHRwYXJlbnQuY2xhc3NMaXN0LmFkZCgndmFsaWQnKTtcclxuXHRcdFx0dmFsaWRhdGlvbltuYW1lXSA9IHRydWU7XHJcblx0XHRcdHRoaXMuc2V0U3RhdGUoe3ZhbGlkYXRpb246IHZhbGlkYXRpb259KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKCd2YWxpZCcpO1xyXG5cdFx0XHR2YWxpZGF0aW9uW25hbWVdID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuc2V0U3RhdGUoe3ZhbGlkYXRpb246IHZhbGlkYXRpb259KTtcclxuXHRcdH1cclxuXHR9XHJcblx0c3VibWl0KGUpIHtcclxuXHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdGNvbnN0IHZhbGlkYXRpb24gPSB0aGlzLnN0YXRlLnZhbGlkYXRpb247XHJcblx0XHRpZih0aGlzLmNoZWNrSWZWYWxpZCh2YWxpZGF0aW9uKSkge1xyXG5cdFx0XHQvLyBTdWNjZXNzXHJcblx0XHRcdHRoaXMuc2V0U3RhdGUoe21lc3NhZ2U6IHtcclxuXHRcdFx0XHR0ZXh0OiAnVGhhbmsgeW91LCB3ZSBoYXZlIHJlY2VpdmVkIHlvdXIgbWVzc2FnZS4nLFxyXG5cdFx0XHRcdHR5cGU6ICdzdWNjZXNzJyxcclxuXHRcdFx0XHRzaG93OiB0cnVlXHJcblx0XHRcdH19KTtcclxuXHJcblx0XHRcdHRoaXMucmVmcy5mb3JtLmNsYXNzTGlzdC5hZGQoJ2hpZGUnKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEVycm9yKHMpXHJcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xyXG5cdFx0XHRcdG1lc3NhZ2U6IHtcclxuXHRcdFx0XHRcdHRleHQ6ICdQbGVhc2UgY29tcGxldGUgdGhlIGZvcm0gYW5kIHRyeSBhZ2Fpbi4nLFxyXG5cdFx0XHRcdFx0dHlwZTogJ2Vycm9yJyxcclxuXHRcdFx0XHRcdHNob3c6IHRydWVcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGRhdGE6IHtcclxuXHRcdFx0XHRcdGVtYWlsOiB0aGlzLnJlZnMuZW1haWwudmFsdWUsXHJcblx0XHRcdFx0XHRmaXJzdG5hbWU6IHRoaXMucmVmcy5maXJzdG5hbWUudmFsdWUsXHJcblx0XHRcdFx0XHRsYXN0bmFtZTogdGhpcy5yZWZzLmxhc3RuYW1lLnZhbHVlLFxyXG5cdFx0XHRcdFx0bWVzc2FnZTogdGhpcy5yZWZzLm1lc3NhZ2UudmFsdWVcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRTdGF0ZSh7ZXJyb3I6IHtcclxuXHRcdFx0XHRlbWFpbDogIXRoaXMuc3RhdGUudmFsaWRhdGlvbi5lbWFpbCxcclxuXHRcdFx0XHRmaXJzdG5hbWU6ICF0aGlzLnN0YXRlLnZhbGlkYXRpb24uZmlyc3RuYW1lLFxyXG5cdFx0XHRcdGxhc3RuYW1lOiAhdGhpcy5zdGF0ZS52YWxpZGF0aW9uLmxhc3RuYW1lLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICF0aGlzLnN0YXRlLnZhbGlkYXRpb24ubWVzc2FnZSxcclxuXHRcdFx0fX0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRjaGVja0lmVmFsaWQodmFsaWRhdGlvbikge1xyXG5cdFx0Zm9yKGNvbnN0IG8gaW4gdmFsaWRhdGlvbilcclxuICAgICAgICAgIGlmKCF2YWxpZGF0aW9uW29dKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cdHJlbmRlcigpIHtcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdDxzZWN0aW9uIGNsYXNzTmFtZT1cImNvbnRhY3QtZm9ybVwiPlxyXG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwicGFkZGluZyB3cmFwcGVyLXNtYWxsXCI+XHJcblx0XHRcdFx0XHQ8aDE+IFdlIHdvdWxkIGxvdmUgdG8gaGVhciBmcm9tIHlvdSA8L2gxPlxyXG5cdFx0XHRcdFx0e3RoaXMuc3RhdGUubWVzc2FnZS5zaG93ID8gXHJcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwibWVzc2FnZVwiPlxyXG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwibWVzc2FnZS1pY29uXCI+XHJcblx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT17J2ljb24gJyt0aGlzLnN0YXRlLm1lc3NhZ2UudHlwZX0+PC9kaXY+XHJcblx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJtZXNzYWdlLXRleHRcIj4ge3RoaXMuc3RhdGUubWVzc2FnZS50ZXh0fSA8L3NwYW4+XHJcblx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0OiBudWxsIH1cclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdFx0PGZvcm0gb25TdWJtaXQ9e3RoaXMuc3VibWl0LmJpbmQodGhpcyl9IHJlZj1cImZvcm1cIj5cclxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmb3JtLWNvbnRhaW5lclwiPlxyXG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZmllbGQgaGFsZlwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0PGlucHV0IG9uQ2hhbmdlPXt0aGlzLmNoZWNrRmllbGQuYmluZCh0aGlzKX0gbmFtZT1cImZpcnN0bmFtZVwiIHJlZj1cImZpcnN0bmFtZVwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJGaXJzdCBuYW1lXCIgLz5cclxuXHRcdFx0XHRcdFx0XHRcdHt0aGlzLnN0YXRlLmVycm9yLmZpcnN0bmFtZSA/IFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImVycm9yLXBvcHVwXCI+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJ0cmlhbmdsZVwiPjwvZGl2PlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxzcGFuPiBXZSBuZWVkIHlvdXIgZmlyc3QgbmFtZS4gPC9zcGFuPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHRcdDogbnVsbCB9XHJcblx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmaWVsZCBoYWxmXCI+XHJcblx0XHRcdFx0XHRcdFx0XHQ8aW5wdXQgb25DaGFuZ2U9e3RoaXMuY2hlY2tGaWVsZC5iaW5kKHRoaXMpfSBuYW1lPVwibGFzdG5hbWVcIiByZWY9XCJsYXN0bmFtZVwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJMYXN0IG5hbWVcIiAvPlxyXG5cdFx0XHRcdFx0XHRcdFx0e3RoaXMuc3RhdGUuZXJyb3IubGFzdG5hbWUgPyBcclxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJlcnJvci1wb3B1cFwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwidHJpYW5nbGVcIj48L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3Bhbj4gV2UgbmVlZCB5b3VyIGxhc3QgbmFtZS4gPC9zcGFuPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHRcdDogbnVsbCB9XHJcblx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmaWVsZCBoYWxmXCI+XHJcblx0XHRcdFx0XHRcdFx0XHQ8aW5wdXQgb25DaGFuZ2U9e3RoaXMuY2hlY2tGaWVsZC5iaW5kKHRoaXMpfSBuYW1lPVwiZW1haWxcIiByZWY9XCJlbWFpbFwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJZb3VyIGUtbWFpbCBhZGRyZXNzXCIgLz5cclxuXHRcdFx0XHRcdFx0XHRcdHt0aGlzLnN0YXRlLmVycm9yLmVtYWlsID8gXHJcblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiZXJyb3ItcG9wdXBcIj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cInRyaWFuZ2xlXCI+PC9kaXY+XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0PHNwYW4+IFBsZWFzZSB1c2UgYSB2YWxpZCBlLW1haWwgYWRkcmVzcy4gPC9zcGFuPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHRcdDogbnVsbCB9XHJcblx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJmaWVsZCBoYWxmXCI+XHJcblx0XHRcdFx0XHRcdFx0XHQ8aW5wdXQgb25DaGFuZ2U9e3RoaXMuY2hlY2tGaWVsZC5iaW5kKHRoaXMpfSBuYW1lPVwicGhvbmVudW1iZXJcIiByZWY9XCJwaG9uZW51bWJlclwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJZb3VyIHBob25lIG51bWJlciAob3B0aW9uYWwpXCIgLz5cclxuXHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImZpZWxkIGZ1bGxcIj5cclxuXHRcdFx0XHRcdFx0XHRcdDx0ZXh0YXJlYSBvbkNoYW5nZT17dGhpcy5jaGVja0ZpZWxkLmJpbmQodGhpcyl9IG5hbWU9XCJtZXNzYWdlXCIgcmVmPVwibWVzc2FnZVwiIHBsYWNlaG9sZGVyPVwiWW91ciBtZXNzYWdlLi4uXCI+PC90ZXh0YXJlYT5cclxuXHRcdFx0XHRcdFx0XHRcdHt0aGlzLnN0YXRlLmVycm9yLm1lc3NhZ2UgPyBcclxuXHRcdFx0XHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJlcnJvci1wb3B1cFwiPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwidHJpYW5nbGVcIj48L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQ8c3Bhbj4gU29ycnksIHlvdXIgbWVzc2FnZSBjYW4ndCBiZSBlbXB0eS4gPC9zcGFuPlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQ8L2Rpdj5cclxuXHRcdFx0XHRcdFx0XHRcdDogbnVsbCB9XHJcblx0XHRcdFx0XHRcdFx0PC9kaXY+XHJcblx0XHRcdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHRcdFx0XHQ8aW5wdXQgY2xhc3NOYW1lPVwic3VibWl0LWJ1dHRvblwiIHR5cGU9XCJzdWJtaXRcIiB2YWx1ZT1cIlNlbmRcIiAvPlxyXG5cdFx0XHRcdFx0PC9mb3JtPlxyXG5cdFx0XHRcdDwvZGl2PlxyXG5cdFx0XHQ8L3NlY3Rpb24+XHJcblx0XHQpO1xyXG5cdH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL2NvbXBvbmVudHMvQ29udGFjdEZvcm0uanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVvcGxlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcclxuXHRyZW5kZXIoKSB7XHJcblx0XHRyZXR1cm4gKFxyXG5cdFx0XHQ8c2VjdGlvbiBjbGFzc05hbWU9XCJwZW9wbGVcIj5cclxuXHRcdFx0XHQ8aW1nIGNsYXNzTmFtZT1cImNhdFwiIHNyYz1cImh0dHA6Ly9naWZpbWFnZS5uZXQvd3AtY29udGVudC91cGxvYWRzLzIwMTcvMTAvY2F0LXR5cGluZy1mYXN0LWdpZi0yLmdpZlwiIGFsdD1cIkNhdFwiIC8+XHJcblx0XHRcdDwvc2VjdGlvbj5cclxuXHRcdCk7XHJcblx0fVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvcGFnZXMvUGVvcGxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==